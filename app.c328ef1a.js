// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"node_modules/postcss/lib/css-syntax-error.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _supportsColor = _interopRequireDefault(require("supports-color"));

var _chalk = _interopRequireDefault(require("chalk"));

var _terminalHighlight = _interopRequireDefault(require("./terminal-highlight"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
/**
 * The CSS parser throws this error for broken CSS.
 *
 * Custom parsers can throw this error for broken custom syntax using
 * the {@link Node#error} method.
 *
 * PostCSS will use the input source map to detect the original error location.
 * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
 * PostCSS will show the original position in the Sass file.
 *
 * If you need the position in the PostCSS input
 * (e.g., to debug the previous compiler), use `error.input.file`.
 *
 * @example
 * // Catching and checking syntax error
 * try {
 *   postcss.parse('a{')
 * } catch (error) {
 *   if (error.name === 'CssSyntaxError') {
 *     error //=> CssSyntaxError
 *   }
 * }
 *
 * @example
 * // Raising error from plugin
 * throw node.error('Unknown variable', { plugin: 'postcss-vars' })
 */


var CssSyntaxError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(CssSyntaxError, _Error);
  /**
   * @param {string} message  Error message.
   * @param {number} [line]   Source line of the error.
   * @param {number} [column] Source column of the error.
   * @param {string} [source] Source code of the broken file.
   * @param {string} [file]   Absolute path to the broken file.
   * @param {string} [plugin] PostCSS plugin name, if error came from plugin.
   */


  function CssSyntaxError(message, line, column, source, file, plugin) {
    var _this;

    _this = _Error.call(this, message) || this;
    /**
     * Always equal to `'CssSyntaxError'`. You should always check error type
     * by `error.name === 'CssSyntaxError'`
     * instead of `error instanceof CssSyntaxError`,
     * because npm could have several PostCSS versions.
     *
     * @type {string}
     *
     * @example
     * if (error.name === 'CssSyntaxError') {
     *   error //=> CssSyntaxError
     * }
     */

    _this.name = 'CssSyntaxError';
    /**
     * Error message.
     *
     * @type {string}
     *
     * @example
     * error.message //=> 'Unclosed block'
     */

    _this.reason = message;

    if (file) {
      /**
       * Absolute path to the broken file.
       *
       * @type {string}
       *
       * @example
       * error.file       //=> 'a.sass'
       * error.input.file //=> 'a.css'
       */
      _this.file = file;
    }

    if (source) {
      /**
       * Source code of the broken file.
       *
       * @type {string}
       *
       * @example
       * error.source       //=> 'a { b {} }'
       * error.input.column //=> 'a b { }'
       */
      _this.source = source;
    }

    if (plugin) {
      /**
       * Plugin name, if error came from plugin.
       *
       * @type {string}
       *
       * @example
       * error.plugin //=> 'postcss-vars'
       */
      _this.plugin = plugin;
    }

    if (typeof line !== 'undefined' && typeof column !== 'undefined') {
      /**
       * Source line of the error.
       *
       * @type {number}
       *
       * @example
       * error.line       //=> 2
       * error.input.line //=> 4
       */
      _this.line = line;
      /**
       * Source column of the error.
       *
       * @type {number}
       *
       * @example
       * error.column       //=> 1
       * error.input.column //=> 4
       */

      _this.column = column;
    }

    _this.setMessage();

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), CssSyntaxError);
    }

    return _this;
  }

  var _proto = CssSyntaxError.prototype;

  _proto.setMessage = function setMessage() {
    /**
     * Full error text in the GNU error format
     * with plugin, file, line and column.
     *
     * @type {string}
     *
     * @example
     * error.message //=> 'a.css:1:1: Unclosed block'
     */
    this.message = this.plugin ? this.plugin + ': ' : '';
    this.message += this.file ? this.file : '<css input>';

    if (typeof this.line !== 'undefined') {
      this.message += ':' + this.line + ':' + this.column;
    }

    this.message += ': ' + this.reason;
  }
  /**
   * Returns a few lines of CSS source that caused the error.
   *
   * If the CSS has an input source map without `sourceContent`,
   * this method will return an empty string.
   *
   * @param {boolean} [color] Whether arrow will be colored red by terminal
   *                          color codes. By default, PostCSS will detect
   *                          color support by `process.stdout.isTTY`
   *                          and `process.env.NODE_DISABLE_COLORS`.
   *
   * @example
   * error.showSourceCode() //=> "  4 | }
   *                        //      5 | a {
   *                        //    > 6 |   bad
   *                        //        |   ^
   *                        //      7 | }
   *                        //      8 | b {"
   *
   * @return {string} Few lines of CSS source that caused the error.
   */
  ;

  _proto.showSourceCode = function showSourceCode(color) {
    var _this2 = this;

    if (!this.source) return '';
    var css = this.source;

    if (_terminalHighlight.default) {
      if (typeof color === 'undefined') color = _supportsColor.default.stdout;
      if (color) css = (0, _terminalHighlight.default)(css);
    }

    var lines = css.split(/\r?\n/);
    var start = Math.max(this.line - 3, 0);
    var end = Math.min(this.line + 2, lines.length);
    var maxWidth = String(end).length;

    function mark(text) {
      if (color && _chalk.default.red) {
        return _chalk.default.red.bold(text);
      }

      return text;
    }

    function aside(text) {
      if (color && _chalk.default.gray) {
        return _chalk.default.gray(text);
      }

      return text;
    }

    return lines.slice(start, end).map(function (line, index) {
      var number = start + 1 + index;
      var gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';

      if (number === _this2.line) {
        var spacing = aside(gutter.replace(/\d/g, ' ')) + line.slice(0, _this2.column - 1).replace(/[^\t]/g, ' ');
        return mark('>') + aside(gutter) + line + '\n ' + spacing + mark('^');
      }

      return ' ' + aside(gutter) + line;
    }).join('\n');
  }
  /**
   * Returns error position, message and source code of the broken part.
   *
   * @example
   * error.toString() //=> "CssSyntaxError: app.css:1:1: Unclosed block
   *                  //    > 1 | a {
   *                  //        | ^"
   *
   * @return {string} Error position, message and source code.
   */
  ;

  _proto.toString = function toString() {
    var code = this.showSourceCode();

    if (code) {
      code = '\n\n' + code + '\n';
    }

    return this.name + ': ' + this.message + code;
  }
  /**
   * @memberof CssSyntaxError#
   * @member {Input} input Input object with PostCSS internal information
   *                       about input file. If input has source map
   *                       from previous tool, PostCSS will use origin
   *                       (for example, Sass) source. You can use this
   *                       object to get PostCSS input source.
   *
   * @example
   * error.input.file //=> 'a.css'
   * error.file       //=> 'a.sass'
   */
  ;

  return CssSyntaxError;
}(_wrapNativeSuper(Error));

var _default = CssSyntaxError;
exports.default = _default;
module.exports = exports.default;
},{"supports-color":"node_modules/parcel-bundler/src/builtins/_empty.js","chalk":"node_modules/parcel-bundler/src/builtins/_empty.js","./terminal-highlight":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/postcss/lib/stringifier.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;
var DEFAULT_RAW = {
  colon: ': ',
  indent: '    ',
  beforeDecl: '\n',
  beforeRule: '\n',
  beforeOpen: ' ',
  beforeClose: '\n',
  beforeComment: '\n',
  after: '\n',
  emptyBody: '',
  commentLeft: ' ',
  commentRight: ' ',
  semicolon: false
};

function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}

var Stringifier = /*#__PURE__*/function () {
  function Stringifier(builder) {
    this.builder = builder;
  }

  var _proto = Stringifier.prototype;

  _proto.stringify = function stringify(node, semicolon) {
    this[node.type](node, semicolon);
  };

  _proto.root = function root(node) {
    this.body(node);
    if (node.raws.after) this.builder(node.raws.after);
  };

  _proto.comment = function comment(node) {
    var left = this.raw(node, 'left', 'commentLeft');
    var right = this.raw(node, 'right', 'commentRight');
    this.builder('/*' + left + node.text + right + '*/', node);
  };

  _proto.decl = function decl(node, semicolon) {
    var between = this.raw(node, 'between', 'colon');
    var string = node.prop + between + this.rawValue(node, 'value');

    if (node.important) {
      string += node.raws.important || ' !important';
    }

    if (semicolon) string += ';';
    this.builder(string, node);
  };

  _proto.rule = function rule(node) {
    this.block(node, this.rawValue(node, 'selector'));

    if (node.raws.ownSemicolon) {
      this.builder(node.raws.ownSemicolon, node, 'end');
    }
  };

  _proto.atrule = function atrule(node, semicolon) {
    var name = '@' + node.name;
    var params = node.params ? this.rawValue(node, 'params') : '';

    if (typeof node.raws.afterName !== 'undefined') {
      name += node.raws.afterName;
    } else if (params) {
      name += ' ';
    }

    if (node.nodes) {
      this.block(node, name + params);
    } else {
      var end = (node.raws.between || '') + (semicolon ? ';' : '');
      this.builder(name + params + end, node);
    }
  };

  _proto.body = function body(node) {
    var last = node.nodes.length - 1;

    while (last > 0) {
      if (node.nodes[last].type !== 'comment') break;
      last -= 1;
    }

    var semicolon = this.raw(node, 'semicolon');

    for (var i = 0; i < node.nodes.length; i++) {
      var child = node.nodes[i];
      var before = this.raw(child, 'before');
      if (before) this.builder(before);
      this.stringify(child, last !== i || semicolon);
    }
  };

  _proto.block = function block(node, start) {
    var between = this.raw(node, 'between', 'beforeOpen');
    this.builder(start + between + '{', node, 'start');
    var after;

    if (node.nodes && node.nodes.length) {
      this.body(node);
      after = this.raw(node, 'after');
    } else {
      after = this.raw(node, 'after', 'emptyBody');
    }

    if (after) this.builder(after);
    this.builder('}', node, 'end');
  };

  _proto.raw = function raw(node, own, detect) {
    var value;
    if (!detect) detect = own; // Already had

    if (own) {
      value = node.raws[own];
      if (typeof value !== 'undefined') return value;
    }

    var parent = node.parent; // Hack for first rule in CSS

    if (detect === 'before') {
      if (!parent || parent.type === 'root' && parent.first === node) {
        return '';
      }
    } // Floating child without parent


    if (!parent) return DEFAULT_RAW[detect]; // Detect style by other nodes

    var root = node.root();
    if (!root.rawCache) root.rawCache = {};

    if (typeof root.rawCache[detect] !== 'undefined') {
      return root.rawCache[detect];
    }

    if (detect === 'before' || detect === 'after') {
      return this.beforeAfter(node, detect);
    } else {
      var method = 'raw' + capitalize(detect);

      if (this[method]) {
        value = this[method](root, node);
      } else {
        root.walk(function (i) {
          value = i.raws[own];
          if (typeof value !== 'undefined') return false;
        });
      }
    }

    if (typeof value === 'undefined') value = DEFAULT_RAW[detect];
    root.rawCache[detect] = value;
    return value;
  };

  _proto.rawSemicolon = function rawSemicolon(root) {
    var value;
    root.walk(function (i) {
      if (i.nodes && i.nodes.length && i.last.type === 'decl') {
        value = i.raws.semicolon;
        if (typeof value !== 'undefined') return false;
      }
    });
    return value;
  };

  _proto.rawEmptyBody = function rawEmptyBody(root) {
    var value;
    root.walk(function (i) {
      if (i.nodes && i.nodes.length === 0) {
        value = i.raws.after;
        if (typeof value !== 'undefined') return false;
      }
    });
    return value;
  };

  _proto.rawIndent = function rawIndent(root) {
    if (root.raws.indent) return root.raws.indent;
    var value;
    root.walk(function (i) {
      var p = i.parent;

      if (p && p !== root && p.parent && p.parent === root) {
        if (typeof i.raws.before !== 'undefined') {
          var parts = i.raws.before.split('\n');
          value = parts[parts.length - 1];
          value = value.replace(/[^\s]/g, '');
          return false;
        }
      }
    });
    return value;
  };

  _proto.rawBeforeComment = function rawBeforeComment(root, node) {
    var value;
    root.walkComments(function (i) {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before;

        if (value.indexOf('\n') !== -1) {
          value = value.replace(/[^\n]+$/, '');
        }

        return false;
      }
    });

    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeDecl');
    } else if (value) {
      value = value.replace(/[^\s]/g, '');
    }

    return value;
  };

  _proto.rawBeforeDecl = function rawBeforeDecl(root, node) {
    var value;
    root.walkDecls(function (i) {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before;

        if (value.indexOf('\n') !== -1) {
          value = value.replace(/[^\n]+$/, '');
        }

        return false;
      }
    });

    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeRule');
    } else if (value) {
      value = value.replace(/[^\s]/g, '');
    }

    return value;
  };

  _proto.rawBeforeRule = function rawBeforeRule(root) {
    var value;
    root.walk(function (i) {
      if (i.nodes && (i.parent !== root || root.first !== i)) {
        if (typeof i.raws.before !== 'undefined') {
          value = i.raws.before;

          if (value.indexOf('\n') !== -1) {
            value = value.replace(/[^\n]+$/, '');
          }

          return false;
        }
      }
    });
    if (value) value = value.replace(/[^\s]/g, '');
    return value;
  };

  _proto.rawBeforeClose = function rawBeforeClose(root) {
    var value;
    root.walk(function (i) {
      if (i.nodes && i.nodes.length > 0) {
        if (typeof i.raws.after !== 'undefined') {
          value = i.raws.after;

          if (value.indexOf('\n') !== -1) {
            value = value.replace(/[^\n]+$/, '');
          }

          return false;
        }
      }
    });
    if (value) value = value.replace(/[^\s]/g, '');
    return value;
  };

  _proto.rawBeforeOpen = function rawBeforeOpen(root) {
    var value;
    root.walk(function (i) {
      if (i.type !== 'decl') {
        value = i.raws.between;
        if (typeof value !== 'undefined') return false;
      }
    });
    return value;
  };

  _proto.rawColon = function rawColon(root) {
    var value;
    root.walkDecls(function (i) {
      if (typeof i.raws.between !== 'undefined') {
        value = i.raws.between.replace(/[^\s:]/g, '');
        return false;
      }
    });
    return value;
  };

  _proto.beforeAfter = function beforeAfter(node, detect) {
    var value;

    if (node.type === 'decl') {
      value = this.raw(node, null, 'beforeDecl');
    } else if (node.type === 'comment') {
      value = this.raw(node, null, 'beforeComment');
    } else if (detect === 'before') {
      value = this.raw(node, null, 'beforeRule');
    } else {
      value = this.raw(node, null, 'beforeClose');
    }

    var buf = node.parent;
    var depth = 0;

    while (buf && buf.type !== 'root') {
      depth += 1;
      buf = buf.parent;
    }

    if (value.indexOf('\n') !== -1) {
      var indent = this.raw(node, null, 'indent');

      if (indent.length) {
        for (var step = 0; step < depth; step++) {
          value += indent;
        }
      }
    }

    return value;
  };

  _proto.rawValue = function rawValue(node, prop) {
    var value = node[prop];
    var raw = node.raws[prop];

    if (raw && raw.value === value) {
      return raw.raw;
    }

    return value;
  };

  return Stringifier;
}();

var _default = Stringifier;
exports.default = _default;
module.exports = exports.default;
},{}],"node_modules/postcss/lib/stringify.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _stringifier = _interopRequireDefault(require("./stringifier"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function stringify(node, builder) {
  var str = new _stringifier.default(builder);
  str.stringify(node);
}

var _default = stringify;
exports.default = _default;
module.exports = exports.default;
},{"./stringifier":"node_modules/postcss/lib/stringifier.js"}],"node_modules/postcss/lib/node.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.default = void 0;

var _cssSyntaxError = _interopRequireDefault(require("./css-syntax-error"));

var _stringifier = _interopRequireDefault(require("./stringifier"));

var _stringify = _interopRequireDefault(require("./stringify"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function cloneNode(obj, parent) {
  var cloned = new obj.constructor();

  for (var i in obj) {
    if (!obj.hasOwnProperty(i)) continue;
    var value = obj[i];

    var type = _typeof(value);

    if (i === 'parent' && type === 'object') {
      if (parent) cloned[i] = parent;
    } else if (i === 'source') {
      cloned[i] = value;
    } else if (value instanceof Array) {
      cloned[i] = value.map(function (j) {
        return cloneNode(j, cloned);
      });
    } else {
      if (type === 'object' && value !== null) value = cloneNode(value);
      cloned[i] = value;
    }
  }

  return cloned;
}
/**
 * All node classes inherit the following common methods.
 *
 * @abstract
 */


var Node = /*#__PURE__*/function () {
  /**
   * @param {object} [defaults] Value for node properties.
   */
  function Node(defaults) {
    if (defaults === void 0) {
      defaults = {};
    }

    this.raws = {};

    if ("development" !== 'production') {
      if (_typeof(defaults) !== 'object' && typeof defaults !== 'undefined') {
        throw new Error('PostCSS nodes constructor accepts object, not ' + JSON.stringify(defaults));
      }
    }

    for (var name in defaults) {
      this[name] = defaults[name];
    }
  }
  /**
   * Returns a `CssSyntaxError` instance containing the original position
   * of the node in the source, showing line and column numbers and also
   * a small excerpt to facilitate debugging.
   *
   * If present, an input source map will be used to get the original position
   * of the source, even from a previous compilation step
   * (e.g., from Sass compilation).
   *
   * This method produces very useful error messages.
   *
   * @param {string} message     Error description.
   * @param {object} [opts]      Options.
   * @param {string} opts.plugin Plugin name that created this error.
   *                             PostCSS will set it automatically.
   * @param {string} opts.word   A word inside a node’s string that should
   *                             be highlighted as the source of the error.
   * @param {number} opts.index  An index inside a node’s string that should
   *                             be highlighted as the source of the error.
   *
   * @return {CssSyntaxError} Error object to throw it.
   *
   * @example
   * if (!variables[name]) {
   *   throw decl.error('Unknown variable ' + name, { word: name })
   *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
   *   //   color: $black
   *   // a
   *   //          ^
   *   //   background: white
   * }
   */


  var _proto = Node.prototype;

  _proto.error = function error(message, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (this.source) {
      var pos = this.positionBy(opts);
      return this.source.input.error(message, pos.line, pos.column, opts);
    }

    return new _cssSyntaxError.default(message);
  }
  /**
   * This method is provided as a convenience wrapper for {@link Result#warn}.
   *
   * @param {Result} result      The {@link Result} instance
   *                             that will receive the warning.
   * @param {string} text        Warning message.
   * @param {object} [opts]      Options
   * @param {string} opts.plugin Plugin name that created this warning.
   *                             PostCSS will set it automatically.
   * @param {string} opts.word   A word inside a node’s string that should
   *                             be highlighted as the source of the warning.
   * @param {number} opts.index  An index inside a node’s string that should
   *                             be highlighted as the source of the warning.
   *
   * @return {Warning} Created warning object.
   *
   * @example
   * const plugin = postcss.plugin('postcss-deprecated', () => {
   *   return (root, result) => {
   *     root.walkDecls('bad', decl => {
   *       decl.warn(result, 'Deprecated property bad')
   *     })
   *   }
   * })
   */
  ;

  _proto.warn = function warn(result, text, opts) {
    var data = {
      node: this
    };

    for (var i in opts) {
      data[i] = opts[i];
    }

    return result.warn(text, data);
  }
  /**
   * Removes the node from its parent and cleans the parent properties
   * from the node and its children.
   *
   * @example
   * if (decl.prop.match(/^-webkit-/)) {
   *   decl.remove()
   * }
   *
   * @return {Node} Node to make calls chain.
   */
  ;

  _proto.remove = function remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }

    this.parent = undefined;
    return this;
  }
  /**
   * Returns a CSS string representing the node.
   *
   * @param {stringifier|syntax} [stringifier] A syntax to use
   *                                           in string generation.
   *
   * @return {string} CSS string of this node.
   *
   * @example
   * postcss.rule({ selector: 'a' }).toString() //=> "a {}"
   */
  ;

  _proto.toString = function toString(stringifier) {
    if (stringifier === void 0) {
      stringifier = _stringify.default;
    }

    if (stringifier.stringify) stringifier = stringifier.stringify;
    var result = '';
    stringifier(this, function (i) {
      result += i;
    });
    return result;
  }
  /**
   * Returns an exact clone of the node.
   *
   * The resulting cloned node and its (cloned) children will retain
   * code style properties.
   *
   * @param {object} [overrides] New properties to override in the clone.
   *
   * @example
   * decl.raws.before    //=> "\n  "
   * const cloned = decl.clone({ prop: '-moz-' + decl.prop })
   * cloned.raws.before  //=> "\n  "
   * cloned.toString()   //=> -moz-transform: scale(0)
   *
   * @return {Node} Clone of the node.
   */
  ;

  _proto.clone = function clone(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    var cloned = cloneNode(this);

    for (var name in overrides) {
      cloned[name] = overrides[name];
    }

    return cloned;
  }
  /**
   * Shortcut to clone the node and insert the resulting cloned node
   * before the current node.
   *
   * @param {object} [overrides] Mew properties to override in the clone.
   *
   * @example
   * decl.cloneBefore({ prop: '-moz-' + decl.prop })
   *
   * @return {Node} New node
   */
  ;

  _proto.cloneBefore = function cloneBefore(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    var cloned = this.clone(overrides);
    this.parent.insertBefore(this, cloned);
    return cloned;
  }
  /**
   * Shortcut to clone the node and insert the resulting cloned node
   * after the current node.
   *
   * @param {object} [overrides] New properties to override in the clone.
   *
   * @return {Node} New node.
   */
  ;

  _proto.cloneAfter = function cloneAfter(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    var cloned = this.clone(overrides);
    this.parent.insertAfter(this, cloned);
    return cloned;
  }
  /**
   * Inserts node(s) before the current node and removes the current node.
   *
   * @param {...Node} nodes Mode(s) to replace current one.
   *
   * @example
   * if (atrule.name === 'mixin') {
   *   atrule.replaceWith(mixinRules[atrule.params])
   * }
   *
   * @return {Node} Current node to methods chain.
   */
  ;

  _proto.replaceWith = function replaceWith() {
    if (this.parent) {
      for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
        nodes[_key] = arguments[_key];
      }

      for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {
        var node = _nodes[_i];
        this.parent.insertBefore(this, node);
      }

      this.remove();
    }

    return this;
  }
  /**
   * Returns the next child of the node’s parent.
   * Returns `undefined` if the current node is the last child.
   *
   * @return {Node|undefined} Next node.
   *
   * @example
   * if (comment.text === 'delete next') {
   *   const next = comment.next()
   *   if (next) {
   *     next.remove()
   *   }
   * }
   */
  ;

  _proto.next = function next() {
    if (!this.parent) return undefined;
    var index = this.parent.index(this);
    return this.parent.nodes[index + 1];
  }
  /**
   * Returns the previous child of the node’s parent.
   * Returns `undefined` if the current node is the first child.
   *
   * @return {Node|undefined} Previous node.
   *
   * @example
   * const annotation = decl.prev()
   * if (annotation.type === 'comment') {
   *   readAnnotation(annotation.text)
   * }
   */
  ;

  _proto.prev = function prev() {
    if (!this.parent) return undefined;
    var index = this.parent.index(this);
    return this.parent.nodes[index - 1];
  }
  /**
   * Insert new node before current node to current node’s parent.
   *
   * Just alias for `node.parent.insertBefore(node, add)`.
   *
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * decl.before('content: ""')
   */
  ;

  _proto.before = function before(add) {
    this.parent.insertBefore(this, add);
    return this;
  }
  /**
   * Insert new node after current node to current node’s parent.
   *
   * Just alias for `node.parent.insertAfter(node, add)`.
   *
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * decl.after('color: black')
   */
  ;

  _proto.after = function after(add) {
    this.parent.insertAfter(this, add);
    return this;
  };

  _proto.toJSON = function toJSON() {
    var fixed = {};

    for (var name in this) {
      if (!this.hasOwnProperty(name)) continue;
      if (name === 'parent') continue;
      var value = this[name];

      if (value instanceof Array) {
        fixed[name] = value.map(function (i) {
          if (_typeof(i) === 'object' && i.toJSON) {
            return i.toJSON();
          } else {
            return i;
          }
        });
      } else if (_typeof(value) === 'object' && value.toJSON) {
        fixed[name] = value.toJSON();
      } else {
        fixed[name] = value;
      }
    }

    return fixed;
  }
  /**
   * Returns a {@link Node#raws} value. If the node is missing
   * the code style property (because the node was manually built or cloned),
   * PostCSS will try to autodetect the code style property by looking
   * at other nodes in the tree.
   *
   * @param {string} prop          Name of code style property.
   * @param {string} [defaultType] Name of default value, it can be missed
   *                               if the value is the same as prop.
   *
   * @example
   * const root = postcss.parse('a { background: white }')
   * root.nodes[0].append({ prop: 'color', value: 'black' })
   * root.nodes[0].nodes[1].raws.before   //=> undefined
   * root.nodes[0].nodes[1].raw('before') //=> ' '
   *
   * @return {string} Code style value.
   */
  ;

  _proto.raw = function raw(prop, defaultType) {
    var str = new _stringifier.default();
    return str.raw(this, prop, defaultType);
  }
  /**
   * Finds the Root instance of the node’s tree.
   *
   * @example
   * root.nodes[0].nodes[0].root() === root
   *
   * @return {Root} Root parent.
   */
  ;

  _proto.root = function root() {
    var result = this;

    while (result.parent) {
      result = result.parent;
    }

    return result;
  }
  /**
   * Clear the code style properties for the node and its children.
   *
   * @param {boolean} [keepBetween] Keep the raws.between symbols.
   *
   * @return {undefined}
   *
   * @example
   * node.raws.before  //=> ' '
   * node.cleanRaws()
   * node.raws.before  //=> undefined
   */
  ;

  _proto.cleanRaws = function cleanRaws(keepBetween) {
    delete this.raws.before;
    delete this.raws.after;
    if (!keepBetween) delete this.raws.between;
  };

  _proto.positionInside = function positionInside(index) {
    var string = this.toString();
    var column = this.source.start.column;
    var line = this.source.start.line;

    for (var i = 0; i < index; i++) {
      if (string[i] === '\n') {
        column = 1;
        line += 1;
      } else {
        column += 1;
      }
    }

    return {
      line: line,
      column: column
    };
  };

  _proto.positionBy = function positionBy(opts) {
    var pos = this.source.start;

    if (opts.index) {
      pos = this.positionInside(opts.index);
    } else if (opts.word) {
      var index = this.toString().indexOf(opts.word);
      if (index !== -1) pos = this.positionInside(index);
    }

    return pos;
  }
  /**
   * @memberof Node#
   * @member {string} type String representing the node’s type.
   *                       Possible values are `root`, `atrule`, `rule`,
   *                       `decl`, or `comment`.
   *
   * @example
   * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'
   */

  /**
   * @memberof Node#
   * @member {Container} parent The node’s parent node.
   *
   * @example
   * root.nodes[0].parent === root
   */

  /**
   * @memberof Node#
   * @member {source} source The input source of the node.
   *
   * The property is used in source map generation.
   *
   * If you create a node manually (e.g., with `postcss.decl()`),
   * that node will not have a `source` property and will be absent
   * from the source map. For this reason, the plugin developer should
   * consider cloning nodes to create new ones (in which case the new node’s
   * source will reference the original, cloned node) or setting
   * the `source` property manually.
   *
   * ```js
   * // Bad
   * const prefixed = postcss.decl({
   *   prop: '-moz-' + decl.prop,
   *   value: decl.value
   * })
   *
   * // Good
   * const prefixed = decl.clone({ prop: '-moz-' + decl.prop })
   * ```
   *
   * ```js
   * if (atrule.name === 'add-link') {
   *   const rule = postcss.rule({ selector: 'a', source: atrule.source })
   *   atrule.parent.insertBefore(atrule, rule)
   * }
   * ```
   *
   * @example
   * decl.source.input.from //=> '/home/ai/a.sass'
   * decl.source.start      //=> { line: 10, column: 2 }
   * decl.source.end        //=> { line: 10, column: 12 }
   */

  /**
   * @memberof Node#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `after`: the space symbols after the last child of the node
   *   to the end of the node.
   * * `between`: the symbols between the property and value
   *   for declarations, selector and `{` for rules, or last parameter
   *   and `{` for at-rules.
   * * `semicolon`: contains true if the last child has
   *   an (optional) semicolon.
   * * `afterName`: the space between the at-rule name and its parameters.
   * * `left`: the space symbols between `/*` and the comment’s text.
   * * `right`: the space symbols between the comment’s text
   *   and <code>*&#47;</code>.
   * * `important`: the content of the important statement,
   *   if it is not just `!important`.
   *
   * PostCSS cleans selectors, declaration values and at-rule parameters
   * from comments and extra spaces, but it stores origin content in raws
   * properties. As such, if you don’t change a declaration’s value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('a {\n  color:black\n}')
   * root.first.first.raws //=> { before: '\n  ', between: ':' }
   */
  ;

  return Node;
}();

var _default = Node;
/**
 * @typedef {object} position
 * @property {number} line   Source line in file.
 * @property {number} column Source column in file.
 */

/**
 * @typedef {object} source
 * @property {Input} input    {@link Input} with input file
 * @property {position} start The starting position of the node’s source.
 * @property {position} end   The ending position of the node’s source.
 */

exports.default = _default;
module.exports = exports.default;
},{"./css-syntax-error":"node_modules/postcss/lib/css-syntax-error.js","./stringifier":"node_modules/postcss/lib/stringifier.js","./stringify":"node_modules/postcss/lib/stringify.js"}],"node_modules/postcss/lib/declaration.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(require("./node"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/**
 * Represents a CSS declaration.
 *
 * @extends Node
 *
 * @example
 * const root = postcss.parse('a { color: black }')
 * const decl = root.first.first
 * decl.type       //=> 'decl'
 * decl.toString() //=> ' color: black'
 */


var Declaration = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Declaration, _Node);

  function Declaration(defaults) {
    var _this;

    _this = _Node.call(this, defaults) || this;
    _this.type = 'decl';
    return _this;
  }
  /**
   * @memberof Declaration#
   * @member {string} prop The declaration’s property name.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * const decl = root.first.first
   * decl.prop //=> 'color'
   */

  /**
   * @memberof Declaration#
   * @member {string} value The declaration’s value.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * const decl = root.first.first
   * decl.value //=> 'black'
   */

  /**
   * @memberof Declaration#
   * @member {boolean} important `true` if the declaration
   *                             has an !important annotation.
   *
   * @example
   * const root = postcss.parse('a { color: black !important; color: red }')
   * root.first.first.important //=> true
   * root.first.last.important  //=> undefined
   */

  /**
   * @memberof Declaration#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `between`: the symbols between the property and value
   *   for declarations.
   * * `important`: the content of the important statement,
   *   if it is not just `!important`.
   *
   * PostCSS cleans declaration from comments and extra spaces,
   * but it stores origin content in raws properties.
   * As such, if you don’t change a declaration’s value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('a {\n  color:black\n}')
   * root.first.first.raws //=> { before: '\n  ', between: ':' }
   */


  return Declaration;
}(_node.default);

var _default = Declaration;
exports.default = _default;
module.exports = exports.default;
},{"./node":"node_modules/postcss/lib/node.js"}],"node_modules/source-map/lib/base64.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */

exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }

  throw new TypeError("Must be between 0 and 63: " + number);
};
/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */


exports.decode = function (charCode) {
  var bigA = 65; // 'A'

  var bigZ = 90; // 'Z'

  var littleA = 97; // 'a'

  var littleZ = 122; // 'z'

  var zero = 48; // '0'

  var nine = 57; // '9'

  var plus = 43; // '+'

  var slash = 47; // '/'

  var littleOffset = 26;
  var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ

  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  } // 26 - 51: abcdefghijklmnopqrstuvwxyz


  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  } // 52 - 61: 0123456789


  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  } // 62: +


  if (charCode == plus) {
    return 62;
  } // 63: /


  if (charCode == slash) {
    return 63;
  } // Invalid base64 digit.


  return -1;
};
},{}],"node_modules/source-map/lib/base64-vlq.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var base64 = require('./base64'); // A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011


var VLQ_BASE_SHIFT = 5; // binary: 100000

var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111

var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000

var VLQ_CONTINUATION_BIT = VLQ_BASE;
/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */

function toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}
/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */


function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}
/**
 * Returns the base 64 VLQ encoded value.
 */


exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;
  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;

    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }

    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};
/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */


exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));

    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};
},{"./base64":"node_modules/source-map/lib/base64.js"}],"node_modules/source-map/lib/util.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}

exports.getArg = getArg;
var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);

  if (!match) {
    return null;
  }

  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}

exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';

  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }

  url += '//';

  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }

  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }

  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }

  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }

  return url;
}

exports.urlGenerate = urlGenerate;
/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */

function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);

  if (url) {
    if (!url.path) {
      return aPath;
    }

    path = url.path;
  }

  var isAbsolute = exports.isAbsolute(path);
  var parts = path.split(/\/+/);

  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];

    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }

  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }

  return path;
}

exports.normalize = normalize;
/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */

function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  if (aPath === "") {
    aPath = ".";
  }

  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);

  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  } // `join(foo, '//www.example.org')`


  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }

    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  } // `join('http://', 'www.example.com')`


  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }

  return joined;
}

exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};
/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */


function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, ''); // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.

  var level = 0;

  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");

    if (index < 0) {
      return aPath;
    } // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.


    aRoot = aRoot.slice(0, index);

    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  } // Make sure we add a "../" for each component we removed from the root.


  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}

exports.relative = relative;

var supportsNullProto = function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}();

function identity(s) {
  return s;
}
/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */


function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}

exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}

exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9
  /* "__proto__".length */
  ) {
      return false;
    }

  if (s.charCodeAt(length - 1) !== 95
  /* '_' */
  || s.charCodeAt(length - 2) !== 95
  /* '_' */
  || s.charCodeAt(length - 3) !== 111
  /* 'o' */
  || s.charCodeAt(length - 4) !== 116
  /* 't' */
  || s.charCodeAt(length - 5) !== 111
  /* 'o' */
  || s.charCodeAt(length - 6) !== 114
  /* 'r' */
  || s.charCodeAt(length - 7) !== 112
  /* 'p' */
  || s.charCodeAt(length - 8) !== 95
  /* '_' */
  || s.charCodeAt(length - 9) !== 95
  /* '_' */
  ) {
      return false;
    }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36
    /* '$' */
    ) {
        return false;
      }
  }

  return true;
}
/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */


function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}

exports.compareByOriginalPositions = compareByOriginalPositions;
/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */

function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}

exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}
/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */


function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}

exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */

function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}

exports.parseSourceMapInput = parseSourceMapInput;
/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */

function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    } // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.


    sourceURL = sourceRoot + sourceURL;
  } // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).


  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);

    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }

    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');

      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }

    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}

exports.computeSourceURL = computeSourceURL;
},{}],"node_modules/source-map/lib/array-set.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = require('./util');

var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";
/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */

function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}
/**
 * Static method for creating ArraySet instances from an existing array.
 */


ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();

  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }

  return set;
};
/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */


ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
/**
 * Add the given string to this set.
 *
 * @param String aStr
 */


ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;

  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }

  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};
/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */


ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};
/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */


ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);

    if (idx >= 0) {
      return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);

    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};
/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */


ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }

  throw new Error('No element indexed by ' + aIdx);
};
/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */


ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;
},{"./util":"node_modules/source-map/lib/util.js"}],"node_modules/source-map/lib/mapping-list.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = require('./util');
/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */


function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */


function MappingList() {
  this._array = [];
  this._sorted = true; // Serves as infimum

  this._last = {
    generatedLine: -1,
    generatedColumn: 0
  };
}
/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */


MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};
/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */


MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;

    this._array.push(aMapping);
  } else {
    this._sorted = false;

    this._array.push(aMapping);
  }
};
/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */


MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);

    this._sorted = true;
  }

  return this._array;
};

exports.MappingList = MappingList;
},{"./util":"node_modules/source-map/lib/util.js"}],"node_modules/source-map/lib/source-map-generator.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var base64VLQ = require('./base64-vlq');

var util = require('./util');

var ArraySet = require('./array-set').ArraySet;

var MappingList = require('./mapping-list').MappingList;
/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */


function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }

  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;
/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */

SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator({
    file: aSourceMapConsumer.file,
    sourceRoot: sourceRoot
  });
  aSourceMapConsumer.eachMapping(function (mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };

    if (mapping.source != null) {
      newMapping.source = mapping.source;

      if (sourceRoot != null) {
        newMapping.source = util.relative(sourceRoot, newMapping.source);
      }

      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };

      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }

    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var sourceRelative = sourceFile;

    if (sourceRoot !== null) {
      sourceRelative = util.relative(sourceRoot, sourceFile);
    }

    if (!generator._sources.has(sourceRelative)) {
      generator._sources.add(sourceRelative);
    }

    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};
/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */


SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = util.getArg(aArgs, 'generated');
  var original = util.getArg(aArgs, 'original', null);
  var source = util.getArg(aArgs, 'source', null);
  var name = util.getArg(aArgs, 'name', null);

  if (!this._skipValidation) {
    this._validateMapping(generated, original, source, name);
  }

  if (source != null) {
    source = String(source);

    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }

  if (name != null) {
    name = String(name);

    if (!this._names.has(name)) {
      this._names.add(name);
    }
  }

  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source: source,
    name: name
  });
};
/**
 * Set the source content for a source file.
 */


SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;

  if (this._sourceRoot != null) {
    source = util.relative(this._sourceRoot, source);
  }

  if (aSourceContent != null) {
    // Add the source content to the _sourcesContents map.
    // Create a new _sourcesContents map if the property is null.
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }

    this._sourcesContents[util.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    // Remove the source file from the _sourcesContents map.
    // If the _sourcesContents map is empty, set the property to null.
    delete this._sourcesContents[util.toSetString(source)];

    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};
/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */


SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap

  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
    }

    sourceFile = aSourceMapConsumer.file;
  }

  var sourceRoot = this._sourceRoot; // Make "sourceFile" relative if an absolute Url is passed.

  if (sourceRoot != null) {
    sourceFile = util.relative(sourceRoot, sourceFile);
  } // Applying the SourceMap can add and remove items from the sources and
  // the names array.


  var newSources = new ArraySet();
  var newNames = new ArraySet(); // Find mappings for the "sourceFile"

  this._mappings.unsortedForEach(function (mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      // Check if it can be mapped by the source map, then update the mapping.
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });

      if (original.source != null) {
        // Copy mapping
        mapping.source = original.source;

        if (aSourceMapPath != null) {
          mapping.source = util.join(aSourceMapPath, mapping.source);
        }

        if (sourceRoot != null) {
          mapping.source = util.relative(sourceRoot, mapping.source);
        }

        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;

        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }

    var source = mapping.source;

    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }

    var name = mapping.name;

    if (name != null && !newNames.has(name)) {
      newNames.add(name);
    }
  }, this);

  this._sources = newSources;
  this._names = newNames; // Copy sourcesContents of applied map.

  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile = util.join(aSourceMapPath, sourceFile);
      }

      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }

      this.setSourceContent(sourceFile, content);
    }
  }, this);
};
/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */


SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  // When aOriginal is truthy but has empty values for .line and .column,
  // it is most likely a programmer error. In this case we throw a very
  // specific error message to try to guide them the right way.
  // For example: https://github.com/Polymer/polymer-bundler/pull/519
  if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
    throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
  }

  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    // Case 1.
    return;
  } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    // Cases 2 and 3.
    return;
  } else {
    throw new Error('Invalid mapping: ' + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    }));
  }
};
/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */


SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = '';
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;

  var mappings = this._mappings.toArray();

  for (var i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    next = '';

    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;

      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ';';
        previousGeneratedLine++;
      }
    } else {
      if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }

        next += ',';
      }
    }

    next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;

    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += base64VLQ.encode(sourceIdx - previousSource);
      previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3

      next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;
      next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;

      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += base64VLQ.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }

    result += next;
  }

  return result;
};

SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function (source) {
    if (!this._sourcesContents) {
      return null;
    }

    if (aSourceRoot != null) {
      source = util.relative(aSourceRoot, source);
    }

    var key = util.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};
/**
 * Externalize the source map.
 */


SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };

  if (this._file != null) {
    map.file = this._file;
  }

  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }

  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }

  return map;
};
/**
 * Render the source map being generated to a string.
 */


SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};

exports.SourceMapGenerator = SourceMapGenerator;
},{"./base64-vlq":"node_modules/source-map/lib/base64-vlq.js","./util":"node_modules/source-map/lib/util.js","./array-set":"node_modules/source-map/lib/array-set.js","./mapping-list":"node_modules/source-map/lib/mapping-list.js"}],"node_modules/source-map/lib/binary-search.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;
/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */

function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);

  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  } else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    } // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.


    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  } else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    } // we are in termination case (3) or (2) and return the appropriate thing.


    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}
/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */


exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);

  if (index < 0) {
    return -1;
  } // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.


  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }

    --index;
  }

  return index;
};
},{}],"node_modules/source-map/lib/quick-sort.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}
/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */


function randomIntInRange(low, high) {
  return Math.round(low + Math.random() * (high - low));
}
/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */


function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.
  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.
    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;
    swap(ary, pivotIndex, r);
    var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.

    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1; // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}
/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */


exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};
},{}],"node_modules/source-map/lib/source-map-consumer.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = require('./util');

var binarySearch = require('./binary-search');

var ArraySet = require('./array-set').ArraySet;

var base64VLQ = require('./base64-vlq');

var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};
/**
 * The version of the source mapping spec that we are consuming.
 */


SourceMapConsumer.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});
SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c = aStr.charAt(index);
  return c === ";" || c === ",";
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;
SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;
/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */

SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
  var mappings;

  switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;

    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;

    default:
      throw new Error("Unknown order of iteration.");
  }

  var sourceRoot = this.sourceRoot;
  mappings.map(function (mapping) {
    var source = mapping.source === null ? null : this._sources.at(mapping.source);
    source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
    return {
      source: source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : this._names.at(mapping.name)
    };
  }, this).forEach(aCallback, context);
};
/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */


SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = util.getArg(aArgs, 'line'); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.

  var needle = {
    source: util.getArg(aArgs, 'source'),
    originalLine: line,
    originalColumn: util.getArg(aArgs, 'column', 0)
  };
  needle.source = this._findSourceIndex(needle.source);

  if (needle.source < 0) {
    return [];
  }

  var mappings = [];

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we found. Since
      // mappings are sorted, this is guaranteed to find all mappings for
      // the line we found.

      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we were searching for.
      // Since mappings are sorted, this is guaranteed to find all mappings for
      // the line we are searching for.

      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    }
  }

  return mappings;
};

exports.SourceMapConsumer = SourceMapConsumer;
/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */

function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.

  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources.map(String) // Some source maps produce relative source paths like "./foo.js" instead of
  // "foo.js".  Normalize these first so that future comparisons will succeed.
  // See bugzil.la/1090768.
  .map(util.normalize) // Always ensure that absolute sources are internally stored relative to
  // the source root, if the source root is absolute. Not doing this would
  // be particularly problematic when the source root is a prefix of the
  // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  .map(function (source) {
    return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
  }); // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.

  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);
  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });
  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */

BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
  var relativeSource = aSource;

  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  } // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.


  var i;

  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};
/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */


BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
  var smc = Object.create(BasicSourceMapConsumer.prototype);
  var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file;
  smc._sourceMapURL = aSourceMapURL;
  smc._absoluteSources = smc._sources.toArray().map(function (s) {
    return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
  }); // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.

  var generatedMappings = aSourceMap._mappings.toArray().slice();

  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];

  for (var i = 0, length = generatedMappings.length; i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new Mapping();
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;

    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;

      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }

      destOriginalMappings.push(destMapping);
    }

    destGeneratedMappings.push(destMapping);
  }

  quickSort(smc.__originalMappings, util.compareByOriginalPositions);
  return smc;
};
/**
 * The version of the source mapping spec that we are consuming.
 */


BasicSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */

Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});
/**
 * Provide the JIT with a nice shape / hidden class.
 */

function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str, segment, end, value;

  while (index < length) {
    if (aStr.charAt(index) === ';') {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
    } else if (aStr.charAt(index) === ',') {
      index++;
    } else {
      mapping = new Mapping();
      mapping.generatedLine = generatedLine; // Because each offset is encoded relative to the previous one,
      // many segments often have the same encoding. We can exploit this
      // fact by caching the parsed variable length fields of each segment,
      // allowing us to avoid a second parse if we encounter the same
      // segment again.

      for (end = index; end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }

      str = aStr.slice(index, end);
      segment = cachedSegments[str];

      if (segment) {
        index += str.length;
      } else {
        segment = [];

        while (index < end) {
          base64VLQ.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }

        if (segment.length === 2) {
          throw new Error('Found a source, but no line and column');
        }

        if (segment.length === 3) {
          throw new Error('Found a source and line, but no column');
        }

        cachedSegments[str] = segment;
      } // Generated column.


      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;

      if (segment.length > 1) {
        // Original source.
        mapping.source = previousSource + segment[1];
        previousSource += segment[1]; // Original line.

        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine; // Lines are stored 0-based

        mapping.originalLine += 1; // Original column.

        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;

        if (segment.length > 4) {
          // Original name.
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }

      generatedMappings.push(mapping);

      if (typeof mapping.originalLine === 'number') {
        originalMappings.push(mapping);
      }
    }
  }

  quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
  this.__generatedMappings = generatedMappings;
  quickSort(originalMappings, util.compareByOriginalPositions);
  this.__originalMappings = originalMappings;
};
/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */


BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.
  if (aNeedle[aLineName] <= 0) {
    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
  }

  if (aNeedle[aColumnName] < 0) {
    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
  }

  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};
/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */


BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0; index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We
    // can come up with an optimistic estimate, however, by assuming that
    // mappings are contiguous (i.e. given two consecutive mappings, the
    // first mapping ends where the second one starts).

    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];

      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    } // The last mapping for each line spans the entire line.


    mapping.lastGeneratedColumn = Infinity;
  }
};
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */


BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._generatedMappings[index];

    if (mapping.generatedLine === needle.generatedLine) {
      var source = util.getArg(mapping, 'source', null);

      if (source !== null) {
        source = this._sources.at(source);
        source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
      }

      var name = util.getArg(mapping, 'name', null);

      if (name !== null) {
        name = this._names.at(name);
      }

      return {
        source: source,
        line: util.getArg(mapping, 'originalLine', null),
        column: util.getArg(mapping, 'originalColumn', null),
        name: name
      };
    }
  }

  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */


BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }

  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
    return sc == null;
  });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */


BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }

  var index = this._findSourceIndex(aSource);

  if (index >= 0) {
    return this.sourcesContent[index];
  }

  var relativeSource = aSource;

  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  var url;

  if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
    // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    // many users. We can help them out when they expect file:// URIs to
    // behave like it would if they were running a local HTTP server. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");

    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }

    if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
  } // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.


  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */


BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = util.getArg(aArgs, 'source');
  source = this._findSourceIndex(source);

  if (source < 0) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }

  var needle = {
    source: source,
    originalLine: util.getArg(aArgs, 'line'),
    originalColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (mapping.source === needle.source) {
      return {
        line: util.getArg(mapping, 'generatedLine', null),
        column: util.getArg(mapping, 'generatedColumn', null),
        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
      };
    }
  }

  return {
    line: null,
    column: null,
    lastColumn: null
  };
};

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */

function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();
  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }

    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }

    lastOffset = offset;
    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    };
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
/**
 * The version of the source mapping spec that we are consuming.
 */

IndexedSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */

Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];

    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }

    return sources;
  }
});
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */

IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  }; // Find the section containing the generated position we're trying to map
  // to an original position.

  var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

    if (cmp) {
      return cmp;
    }

    return needle.generatedColumn - section.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];

  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }

  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */


IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function (s) {
    return s.consumer.hasContentsOfAllSources();
  });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */


IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var content = section.consumer.sourceContentFor(aSource, true);

    if (content) {
      return content;
    }
  }

  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */


IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i]; // Only consider this section if the requested source is in the list of
    // sources of the consumer.

    if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
      continue;
    }

    var generatedPosition = section.consumer.generatedPositionFor(aArgs);

    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }

  return {
    line: null,
    column: null
  };
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];

  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;

    for (var j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];

      var source = section.consumer._sources.at(mapping.source);

      source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);

      this._sources.add(source);

      source = this._sources.indexOf(source);
      var name = null;

      if (mapping.name) {
        name = section.consumer._names.at(mapping.name);

        this._names.add(name);

        name = this._names.indexOf(name);
      } // The mappings coming from the consumer for the section have
      // generated positions relative to the start of the section, so we
      // need to offset them to be relative to the start of the concatenated
      // generated file.


      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };

      this.__generatedMappings.push(adjustedMapping);

      if (typeof adjustedMapping.originalLine === 'number') {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }

  quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
  quickSort(this.__originalMappings, util.compareByOriginalPositions);
};

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
},{"./util":"node_modules/source-map/lib/util.js","./binary-search":"node_modules/source-map/lib/binary-search.js","./array-set":"node_modules/source-map/lib/array-set.js","./base64-vlq":"node_modules/source-map/lib/base64-vlq.js","./quick-sort":"node_modules/source-map/lib/quick-sort.js"}],"node_modules/source-map/lib/source-node.js":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;

var util = require('./util'); // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).


var REGEX_NEWLINE = /(\r?\n)/; // Newline character code for charCodeAt() comparisons

var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!

var isSourceNode = "$$$isSourceNode$$$";
/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */

function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}
/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */


SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  // The SourceNode we want to fill with the generated code
  // and the SourceMap
  var node = new SourceNode(); // All even indices of this array are one line of the generated code,
  // while all odd indices are the newlines between two adjacent lines
  // (since `REGEX_NEWLINE` captures its match).
  // Processed fragments are accessed by calling `shiftNextLine`.

  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
  var remainingLinesIndex = 0;

  var shiftNextLine = function () {
    var lineContents = getNextLine(); // The last line of a file might not have a newline.

    var newLine = getNextLine() || "";
    return lineContents + newLine;

    function getNextLine() {
      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
    }
  }; // We need to remember the position of "remainingLines"


  var lastGeneratedLine = 1,
      lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.
  // To extract it current and last mapping is used.
  // Here we store the last mapping.

  var lastMapping = null;
  aSourceMapConsumer.eachMapping(function (mapping) {
    if (lastMapping !== null) {
      // We add the code from "lastMapping" to "mapping":
      // First check if there is a new line in between.
      if (lastGeneratedLine < mapping.generatedLine) {
        // Associate first line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
        lastGeneratedLine++;
        lastGeneratedColumn = 0; // The remaining code is added without mapping
      } else {
        // There is no new line in between.
        // Associate the code between "lastGeneratedColumn" and
        // "mapping.generatedColumn" with "lastMapping"
        var nextLine = remainingLines[remainingLinesIndex] || '';
        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
        addMappingWithCode(lastMapping, code); // No more remaining code, continue

        lastMapping = mapping;
        return;
      }
    } // We add the generated code until the first mapping
    // to the SourceNode without any mapping.
    // Each line is added as separate string.


    while (lastGeneratedLine < mapping.generatedLine) {
      node.add(shiftNextLine());
      lastGeneratedLine++;
    }

    if (lastGeneratedColumn < mapping.generatedColumn) {
      var nextLine = remainingLines[remainingLinesIndex] || '';
      node.add(nextLine.substr(0, mapping.generatedColumn));
      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
    }

    lastMapping = mapping;
  }, this); // We have processed all mappings.

  if (remainingLinesIndex < remainingLines.length) {
    if (lastMapping) {
      // Associate the remaining code in the current line with "lastMapping"
      addMappingWithCode(lastMapping, shiftNextLine());
    } // and add the remaining lines without any mapping


    node.add(remainingLines.splice(remainingLinesIndex).join(""));
  } // Copy sourcesContent into SourceNode


  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      if (aRelativePath != null) {
        sourceFile = util.join(aRelativePath, sourceFile);
      }

      node.setSourceContent(sourceFile, content);
    }
  });
  return node;

  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
      node.add(code);
    } else {
      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
      node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
    }
  }
};
/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */


SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }

  return this;
};
/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */


SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length - 1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }

  return this;
};
/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */


SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;

  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];

    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    } else {
      if (chunk !== '') {
        aFn(chunk, {
          source: this.source,
          line: this.line,
          column: this.column,
          name: this.name
        });
      }
    }
  }
};
/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */


SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;

  if (len > 0) {
    newChildren = [];

    for (i = 0; i < len - 1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }

    newChildren.push(this.children[i]);
    this.children = newChildren;
  }

  return this;
};
/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */


SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];

  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  } else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  } else {
    this.children.push(''.replace(aPattern, aReplacement));
  }

  return this;
};
/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */


SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};
/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */


SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
  for (var i = 0, len = this.children.length; i < len; i++) {
    if (this.children[i][isSourceNode]) {
      this.children[i].walkSourceContents(aFn);
    }
  }

  var sources = Object.keys(this.sourceContents);

  for (var i = 0, len = sources.length; i < len; i++) {
    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
};
/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */


SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};
/**
 * Returns the string representation of this source node along with a source
 * map.
 */


SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;

    if (original.source !== null && original.line !== null && original.column !== null) {
      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }

      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }

    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0; // Mappings end at eol

        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });
  return {
    code: generated.code,
    map: map
  };
};

exports.SourceNode = SourceNode;
},{"./source-map-generator":"node_modules/source-map/lib/source-map-generator.js","./util":"node_modules/source-map/lib/util.js"}],"node_modules/source-map/source-map.js":[function(require,module,exports) {
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;
},{"./lib/source-map-generator":"node_modules/source-map/lib/source-map-generator.js","./lib/source-map-consumer":"node_modules/source-map/lib/source-map-consumer.js","./lib/source-node":"node_modules/source-map/lib/source-node.js"}],"node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"node_modules/path-browserify/index.js":[function(require,module,exports) {
var process = require("process");
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

},{"process":"node_modules/process/browser.js"}],"node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"node_modules/ieee754/index.js":[function(require,module,exports) {
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"node_modules/base64-js/index.js","ieee754":"node_modules/ieee754/index.js","isarray":"node_modules/isarray/index.js","buffer":"node_modules/buffer/index.js"}],"node_modules/postcss/lib/map-generator.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _sourceMap = _interopRequireDefault(require("source-map"));

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var MapGenerator = /*#__PURE__*/function () {
  function MapGenerator(stringify, root, opts) {
    this.stringify = stringify;
    this.mapOpts = opts.map || {};
    this.root = root;
    this.opts = opts;
  }

  var _proto = MapGenerator.prototype;

  _proto.isMap = function isMap() {
    if (typeof this.opts.map !== 'undefined') {
      return !!this.opts.map;
    }

    return this.previous().length > 0;
  };

  _proto.previous = function previous() {
    var _this = this;

    if (!this.previousMaps) {
      this.previousMaps = [];
      this.root.walk(function (node) {
        if (node.source && node.source.input.map) {
          var map = node.source.input.map;

          if (_this.previousMaps.indexOf(map) === -1) {
            _this.previousMaps.push(map);
          }
        }
      });
    }

    return this.previousMaps;
  };

  _proto.isInline = function isInline() {
    if (typeof this.mapOpts.inline !== 'undefined') {
      return this.mapOpts.inline;
    }

    var annotation = this.mapOpts.annotation;

    if (typeof annotation !== 'undefined' && annotation !== true) {
      return false;
    }

    if (this.previous().length) {
      return this.previous().some(function (i) {
        return i.inline;
      });
    }

    return true;
  };

  _proto.isSourcesContent = function isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== 'undefined') {
      return this.mapOpts.sourcesContent;
    }

    if (this.previous().length) {
      return this.previous().some(function (i) {
        return i.withContent();
      });
    }

    return true;
  };

  _proto.clearAnnotation = function clearAnnotation() {
    if (this.mapOpts.annotation === false) return;
    var node;

    for (var i = this.root.nodes.length - 1; i >= 0; i--) {
      node = this.root.nodes[i];
      if (node.type !== 'comment') continue;

      if (node.text.indexOf('# sourceMappingURL=') === 0) {
        this.root.removeChild(i);
      }
    }
  };

  _proto.setSourcesContent = function setSourcesContent() {
    var _this2 = this;

    var already = {};
    this.root.walk(function (node) {
      if (node.source) {
        var from = node.source.input.from;

        if (from && !already[from]) {
          already[from] = true;

          var relative = _this2.relative(from);

          _this2.map.setSourceContent(relative, node.source.input.css);
        }
      }
    });
  };

  _proto.applyPrevMaps = function applyPrevMaps() {
    for (var _iterator = this.previous(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var prev = _ref;
      var from = this.relative(prev.file);

      var root = prev.root || _path.default.dirname(prev.file);

      var map = void 0;

      if (this.mapOpts.sourcesContent === false) {
        map = new _sourceMap.default.SourceMapConsumer(prev.text);

        if (map.sourcesContent) {
          map.sourcesContent = map.sourcesContent.map(function () {
            return null;
          });
        }
      } else {
        map = prev.consumer();
      }

      this.map.applySourceMap(map, from, this.relative(root));
    }
  };

  _proto.isAnnotation = function isAnnotation() {
    if (this.isInline()) {
      return true;
    }

    if (typeof this.mapOpts.annotation !== 'undefined') {
      return this.mapOpts.annotation;
    }

    if (this.previous().length) {
      return this.previous().some(function (i) {
        return i.annotation;
      });
    }

    return true;
  };

  _proto.toBase64 = function toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString('base64');
    }

    return window.btoa(unescape(encodeURIComponent(str)));
  };

  _proto.addAnnotation = function addAnnotation() {
    var content;

    if (this.isInline()) {
      content = 'data:application/json;base64,' + this.toBase64(this.map.toString());
    } else if (typeof this.mapOpts.annotation === 'string') {
      content = this.mapOpts.annotation;
    } else {
      content = this.outputFile() + '.map';
    }

    var eol = '\n';
    if (this.css.indexOf('\r\n') !== -1) eol = '\r\n';
    this.css += eol + '/*# sourceMappingURL=' + content + ' */';
  };

  _proto.outputFile = function outputFile() {
    if (this.opts.to) {
      return this.relative(this.opts.to);
    }

    if (this.opts.from) {
      return this.relative(this.opts.from);
    }

    return 'to.css';
  };

  _proto.generateMap = function generateMap() {
    this.generateString();
    if (this.isSourcesContent()) this.setSourcesContent();
    if (this.previous().length > 0) this.applyPrevMaps();
    if (this.isAnnotation()) this.addAnnotation();

    if (this.isInline()) {
      return [this.css];
    }

    return [this.css, this.map];
  };

  _proto.relative = function relative(file) {
    if (file.indexOf('<') === 0) return file;
    if (/^\w+:\/\//.test(file)) return file;
    var from = this.opts.to ? _path.default.dirname(this.opts.to) : '.';

    if (typeof this.mapOpts.annotation === 'string') {
      from = _path.default.dirname(_path.default.resolve(from, this.mapOpts.annotation));
    }

    file = _path.default.relative(from, file);

    if (_path.default.sep === '\\') {
      return file.replace(/\\/g, '/');
    }

    return file;
  };

  _proto.sourcePath = function sourcePath(node) {
    if (this.mapOpts.from) {
      return this.mapOpts.from;
    }

    return this.relative(node.source.input.from);
  };

  _proto.generateString = function generateString() {
    var _this3 = this;

    this.css = '';
    this.map = new _sourceMap.default.SourceMapGenerator({
      file: this.outputFile()
    });
    var line = 1;
    var column = 1;
    var lines, last;
    this.stringify(this.root, function (str, node, type) {
      _this3.css += str;

      if (node && type !== 'end') {
        if (node.source && node.source.start) {
          _this3.map.addMapping({
            source: _this3.sourcePath(node),
            generated: {
              line: line,
              column: column - 1
            },
            original: {
              line: node.source.start.line,
              column: node.source.start.column - 1
            }
          });
        } else {
          _this3.map.addMapping({
            source: '<no source>',
            original: {
              line: 1,
              column: 0
            },
            generated: {
              line: line,
              column: column - 1
            }
          });
        }
      }

      lines = str.match(/\n/g);

      if (lines) {
        line += lines.length;
        last = str.lastIndexOf('\n');
        column = str.length - last;
      } else {
        column += str.length;
      }

      if (node && type !== 'start') {
        var p = node.parent || {
          raws: {}
        };

        if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {
          if (node.source && node.source.end) {
            _this3.map.addMapping({
              source: _this3.sourcePath(node),
              generated: {
                line: line,
                column: column - 2
              },
              original: {
                line: node.source.end.line,
                column: node.source.end.column - 1
              }
            });
          } else {
            _this3.map.addMapping({
              source: '<no source>',
              original: {
                line: 1,
                column: 0
              },
              generated: {
                line: line,
                column: column - 1
              }
            });
          }
        }
      }
    });
  };

  _proto.generate = function generate() {
    this.clearAnnotation();

    if (this.isMap()) {
      return this.generateMap();
    }

    var result = '';
    this.stringify(this.root, function (i) {
      result += i;
    });
    return [result];
  };

  return MapGenerator;
}();

var _default = MapGenerator;
exports.default = _default;
module.exports = exports.default;
},{"source-map":"node_modules/source-map/source-map.js","path":"node_modules/path-browserify/index.js","buffer":"node_modules/buffer/index.js"}],"node_modules/postcss/lib/warn-once.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = warnOnce;
var printed = {};

function warnOnce(message) {
  if (printed[message]) return;
  printed[message] = true;

  if (typeof console !== 'undefined' && console.warn) {
    console.warn(message);
  }
}

module.exports = exports.default;
},{}],"node_modules/postcss/lib/warning.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * Represents a plugin’s warning. It can be created using {@link Node#warn}.
 *
 * @example
 * if (decl.important) {
 *   decl.warn(result, 'Avoid !important', { word: '!important' })
 * }
 */

var Warning = /*#__PURE__*/function () {
  /**
   * @param {string} text        Warning message.
   * @param {Object} [opts]      Warning options.
   * @param {Node}   opts.node   CSS node that caused the warning.
   * @param {string} opts.word   Word in CSS source that caused the warning.
   * @param {number} opts.index  Index in CSS node string that caused
   *                             the warning.
   * @param {string} opts.plugin Name of the plugin that created
   *                             this warning. {@link Result#warn} fills
   *                             this property automatically.
   */
  function Warning(text, opts) {
    if (opts === void 0) {
      opts = {};
    }
    /**
     * Type to filter warnings from {@link Result#messages}.
     * Always equal to `"warning"`.
     *
     * @type {string}
     *
     * @example
     * const nonWarning = result.messages.filter(i => i.type !== 'warning')
     */


    this.type = 'warning';
    /**
     * The warning message.
     *
     * @type {string}
     *
     * @example
     * warning.text //=> 'Try to avoid !important'
     */

    this.text = text;

    if (opts.node && opts.node.source) {
      var pos = opts.node.positionBy(opts);
      /**
       * Line in the input file with this warning’s source.
       * @type {number}
       *
       * @example
       * warning.line //=> 5
       */

      this.line = pos.line;
      /**
       * Column in the input file with this warning’s source.
       *
       * @type {number}
       *
       * @example
       * warning.column //=> 6
       */

      this.column = pos.column;
    }

    for (var opt in opts) {
      this[opt] = opts[opt];
    }
  }
  /**
   * Returns a warning position and message.
   *
   * @example
   * warning.toString() //=> 'postcss-lint:a.css:10:14: Avoid !important'
   *
   * @return {string} Warning position and message.
   */


  var _proto = Warning.prototype;

  _proto.toString = function toString() {
    if (this.node) {
      return this.node.error(this.text, {
        plugin: this.plugin,
        index: this.index,
        word: this.word
      }).message;
    }

    if (this.plugin) {
      return this.plugin + ': ' + this.text;
    }

    return this.text;
  }
  /**
   * @memberof Warning#
   * @member {string} plugin The name of the plugin that created
   *                         it will fill this property automatically.
   *                         this warning. When you call {@link Node#warn}
   *
   * @example
   * warning.plugin //=> 'postcss-important'
   */

  /**
   * @memberof Warning#
   * @member {Node} node Contains the CSS node that caused the warning.
   *
   * @example
   * warning.node.toString() //=> 'color: white !important'
   */
  ;

  return Warning;
}();

var _default = Warning;
exports.default = _default;
module.exports = exports.default;
},{}],"node_modules/postcss/lib/result.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _warning = _interopRequireDefault(require("./warning"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/**
 * Provides the result of the PostCSS transformations.
 *
 * A Result instance is returned by {@link LazyResult#then}
 * or {@link Root#toResult} methods.
 *
 * @example
 * postcss([autoprefixer]).process(css).then(result => {
 *  console.log(result.css)
 * })
 *
 * @example
 * const result2 = postcss.parse(css).toResult()
 */


var Result = /*#__PURE__*/function () {
  /**
   * @param {Processor} processor Processor used for this transformation.
   * @param {Root}      root      Root node after all transformations.
   * @param {processOptions} opts Options from the {@link Processor#process}
   *                              or {@link Root#toResult}.
   */
  function Result(processor, root, opts) {
    /**
     * The Processor instance used for this transformation.
     *
     * @type {Processor}
     *
     * @example
     * for (const plugin of result.processor.plugins) {
     *   if (plugin.postcssPlugin === 'postcss-bad') {
     *     throw 'postcss-good is incompatible with postcss-bad'
     *   }
     * })
     */
    this.processor = processor;
    /**
     * Contains messages from plugins (e.g., warnings or custom messages).
     * Each message should have type and plugin properties.
     *
     * @type {Message[]}
     *
     * @example
     * postcss.plugin('postcss-min-browser', () => {
     *   return (root, result) => {
     *     const browsers = detectMinBrowsersByCanIUse(root)
     *     result.messages.push({
     *       type: 'min-browser',
     *       plugin: 'postcss-min-browser',
     *       browsers
     *     })
     *   }
     * })
     */

    this.messages = [];
    /**
     * Root node after all transformations.
     *
     * @type {Root}
     *
     * @example
     * root.toResult().root === root
     */

    this.root = root;
    /**
     * Options from the {@link Processor#process} or {@link Root#toResult} call
     * that produced this Result instance.
     *
     * @type {processOptions}
     *
     * @example
     * root.toResult(opts).opts === opts
     */

    this.opts = opts;
    /**
     * A CSS string representing of {@link Result#root}.
     *
     * @type {string}
     *
     * @example
     * postcss.parse('a{}').toResult().css //=> "a{}"
     */

    this.css = undefined;
    /**
     * An instance of `SourceMapGenerator` class from the `source-map` library,
     * representing changes to the {@link Result#root} instance.
     *
     * @type {SourceMapGenerator}
     *
     * @example
     * result.map.toJSON() //=> { version: 3, file: 'a.css', … }
     *
     * @example
     * if (result.map) {
     *   fs.writeFileSync(result.opts.to + '.map', result.map.toString())
     * }
     */

    this.map = undefined;
  }
  /**
   * Returns for @{link Result#css} content.
   *
   * @example
   * result + '' === result.css
   *
   * @return {string} String representing of {@link Result#root}.
   */


  var _proto = Result.prototype;

  _proto.toString = function toString() {
    return this.css;
  }
  /**
   * Creates an instance of {@link Warning} and adds it
   * to {@link Result#messages}.
   *
   * @param {string} text        Warning message.
   * @param {Object} [opts]      Warning options.
   * @param {Node}   opts.node   CSS node that caused the warning.
   * @param {string} opts.word   Word in CSS source that caused the warning.
   * @param {number} opts.index  Index in CSS node string that caused
   *                             the warning.
   * @param {string} opts.plugin Name of the plugin that created
   *                             this warning. {@link Result#warn} fills
   *                             this property automatically.
   *
   * @return {Warning} Created warning.
   */
  ;

  _proto.warn = function warn(text, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin;
      }
    }

    var warning = new _warning.default(text, opts);
    this.messages.push(warning);
    return warning;
  }
  /**
     * Returns warnings from plugins. Filters {@link Warning} instances
     * from {@link Result#messages}.
     *
     * @example
     * result.warnings().forEach(warn => {
     *   console.warn(warn.toString())
     * })
     *
     * @return {Warning[]} Warnings from plugins.
     */
  ;

  _proto.warnings = function warnings() {
    return this.messages.filter(function (i) {
      return i.type === 'warning';
    });
  }
  /**
   * An alias for the {@link Result#css} property.
   * Use it with syntaxes that generate non-CSS output.
   *
   * @type {string}
   *
   * @example
   * result.css === result.content
   */
  ;

  _createClass(Result, [{
    key: "content",
    get: function get() {
      return this.css;
    }
  }]);

  return Result;
}();

var _default = Result;
/**
 * @typedef  {object} Message
 * @property {string} type   Message type.
 * @property {string} plugin Source PostCSS plugin name.
 */

exports.default = _default;
module.exports = exports.default;
},{"./warning":"node_modules/postcss/lib/warning.js"}],"node_modules/postcss/lib/tokenize.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = tokenizer;
var SINGLE_QUOTE = '\''.charCodeAt(0);
var DOUBLE_QUOTE = '"'.charCodeAt(0);
var BACKSLASH = '\\'.charCodeAt(0);
var SLASH = '/'.charCodeAt(0);
var NEWLINE = '\n'.charCodeAt(0);
var SPACE = ' '.charCodeAt(0);
var FEED = '\f'.charCodeAt(0);
var TAB = '\t'.charCodeAt(0);
var CR = '\r'.charCodeAt(0);
var OPEN_SQUARE = '['.charCodeAt(0);
var CLOSE_SQUARE = ']'.charCodeAt(0);
var OPEN_PARENTHESES = '('.charCodeAt(0);
var CLOSE_PARENTHESES = ')'.charCodeAt(0);
var OPEN_CURLY = '{'.charCodeAt(0);
var CLOSE_CURLY = '}'.charCodeAt(0);
var SEMICOLON = ';'.charCodeAt(0);
var ASTERISK = '*'.charCodeAt(0);
var COLON = ':'.charCodeAt(0);
var AT = '@'.charCodeAt(0);
var RE_AT_END = /[ \n\t\r\f{}()'"\\;/[\]#]/g;
var RE_WORD_END = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g;
var RE_BAD_BRACKET = /.[\\/("'\n]/;
var RE_HEX_ESCAPE = /[a-f0-9]/i;

function tokenizer(input, options) {
  if (options === void 0) {
    options = {};
  }

  var css = input.css.valueOf();
  var ignore = options.ignoreErrors;
  var code, next, quote, lines, last, content, escape;
  var nextLine, nextOffset, escaped, escapePos, prev, n, currentToken;
  var length = css.length;
  var offset = -1;
  var line = 1;
  var pos = 0;
  var buffer = [];
  var returned = [];

  function position() {
    return pos;
  }

  function unclosed(what) {
    throw input.error('Unclosed ' + what, line, pos - offset);
  }

  function endOfFile() {
    return returned.length === 0 && pos >= length;
  }

  function nextToken(opts) {
    if (returned.length) return returned.pop();
    if (pos >= length) return;
    var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
    code = css.charCodeAt(pos);

    if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {
      offset = pos;
      line += 1;
    }

    switch (code) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED:
        next = pos;

        do {
          next += 1;
          code = css.charCodeAt(next);

          if (code === NEWLINE) {
            offset = next;
            line += 1;
          }
        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);

        currentToken = ['space', css.slice(pos, next)];
        pos = next - 1;
        break;

      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES:
        var controlChar = String.fromCharCode(code);
        currentToken = [controlChar, controlChar, line, pos - offset];
        break;

      case OPEN_PARENTHESES:
        prev = buffer.length ? buffer.pop()[1] : '';
        n = css.charCodeAt(pos + 1);

        if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
          next = pos;

          do {
            escaped = false;
            next = css.indexOf(')', next + 1);

            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos;
                break;
              } else {
                unclosed('bracket');
              }
            }

            escapePos = next;

            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);

          currentToken = ['brackets', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
          pos = next;
        } else {
          next = css.indexOf(')', pos + 1);
          content = css.slice(pos, next + 1);

          if (next === -1 || RE_BAD_BRACKET.test(content)) {
            currentToken = ['(', '(', line, pos - offset];
          } else {
            currentToken = ['brackets', content, line, pos - offset, line, next - offset];
            pos = next;
          }
        }

        break;

      case SINGLE_QUOTE:
      case DOUBLE_QUOTE:
        quote = code === SINGLE_QUOTE ? '\'' : '"';
        next = pos;

        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);

          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1;
              break;
            } else {
              unclosed('string');
            }
          }

          escapePos = next;

          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);

        content = css.slice(pos, next + 1);
        lines = content.split('\n');
        last = lines.length - 1;

        if (last > 0) {
          nextLine = line + last;
          nextOffset = next - lines[last].length;
        } else {
          nextLine = line;
          nextOffset = offset;
        }

        currentToken = ['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset];
        offset = nextOffset;
        line = nextLine;
        pos = next;
        break;

      case AT:
        RE_AT_END.lastIndex = pos + 1;
        RE_AT_END.test(css);

        if (RE_AT_END.lastIndex === 0) {
          next = css.length - 1;
        } else {
          next = RE_AT_END.lastIndex - 2;
        }

        currentToken = ['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
        pos = next;
        break;

      case BACKSLASH:
        next = pos;
        escape = true;

        while (css.charCodeAt(next + 1) === BACKSLASH) {
          next += 1;
          escape = !escape;
        }

        code = css.charCodeAt(next + 1);

        if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
          next += 1;

          if (RE_HEX_ESCAPE.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
              next += 1;
            }

            if (css.charCodeAt(next + 1) === SPACE) {
              next += 1;
            }
          }
        }

        currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
        pos = next;
        break;

      default:
        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
          next = css.indexOf('*/', pos + 2) + 1;

          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length;
            } else {
              unclosed('comment');
            }
          }

          content = css.slice(pos, next + 1);
          lines = content.split('\n');
          last = lines.length - 1;

          if (last > 0) {
            nextLine = line + last;
            nextOffset = next - lines[last].length;
          } else {
            nextLine = line;
            nextOffset = offset;
          }

          currentToken = ['comment', content, line, pos - offset, nextLine, next - nextOffset];
          offset = nextOffset;
          line = nextLine;
          pos = next;
        } else {
          RE_WORD_END.lastIndex = pos + 1;
          RE_WORD_END.test(css);

          if (RE_WORD_END.lastIndex === 0) {
            next = css.length - 1;
          } else {
            next = RE_WORD_END.lastIndex - 2;
          }

          currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
          buffer.push(currentToken);
          pos = next;
        }

        break;
    }

    pos++;
    return currentToken;
  }

  function back(token) {
    returned.push(token);
  }

  return {
    back: back,
    nextToken: nextToken,
    endOfFile: endOfFile,
    position: position
  };
}

module.exports = exports.default;
},{}],"node_modules/postcss/lib/comment.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(require("./node"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/**
 * Represents a comment between declarations or statements (rule and at-rules).
 *
 * Comments inside selectors, at-rule parameters, or declaration values
 * will be stored in the `raws` properties explained above.
 *
 * @extends Node
 */


var Comment = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Comment, _Node);

  function Comment(defaults) {
    var _this;

    _this = _Node.call(this, defaults) || this;
    _this.type = 'comment';
    return _this;
  }
  /**
   * @memberof Comment#
   * @member {string} text The comment’s text.
   */

  /**
   * @memberof Comment#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node.
   * * `left`: the space symbols between `/*` and the comment’s text.
   * * `right`: the space symbols between the comment’s text.
   */


  return Comment;
}(_node.default);

var _default = Comment;
exports.default = _default;
module.exports = exports.default;
},{"./node":"node_modules/postcss/lib/node.js"}],"node_modules/postcss/lib/list.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * Contains helpers for safely splitting lists of CSS values,
 * preserving parentheses and quotes.
 *
 * @example
 * const list = postcss.list
 *
 * @namespace list
 */

var list = {
  split: function split(string, separators, last) {
    var array = [];
    var current = '';
    var split = false;
    var func = 0;
    var quote = false;
    var escape = false;

    for (var i = 0; i < string.length; i++) {
      var letter = string[i];

      if (quote) {
        if (escape) {
          escape = false;
        } else if (letter === '\\') {
          escape = true;
        } else if (letter === quote) {
          quote = false;
        }
      } else if (letter === '"' || letter === '\'') {
        quote = letter;
      } else if (letter === '(') {
        func += 1;
      } else if (letter === ')') {
        if (func > 0) func -= 1;
      } else if (func === 0) {
        if (separators.indexOf(letter) !== -1) split = true;
      }

      if (split) {
        if (current !== '') array.push(current.trim());
        current = '';
        split = false;
      } else {
        current += letter;
      }
    }

    if (last || current !== '') array.push(current.trim());
    return array;
  },

  /**
   * Safely splits space-separated values (such as those for `background`,
   * `border-radius`, and other shorthand properties).
   *
   * @param {string} string Space-separated values.
   *
   * @return {string[]} Split values.
   *
   * @example
   * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']
   */
  space: function space(string) {
    var spaces = [' ', '\n', '\t'];
    return list.split(string, spaces);
  },

  /**
   * Safely splits comma-separated values (such as those for `transition-*`
   * and `background` properties).
   *
   * @param {string} string Comma-separated values.
   *
   * @return {string[]} Split values.
   *
   * @example
   * postcss.list.comma('black, linear-gradient(white, black)')
   * //=> ['black', 'linear-gradient(white, black)']
   */
  comma: function comma(string) {
    return list.split(string, [','], true);
  }
};
var _default = list;
exports.default = _default;
module.exports = exports.default;
},{}],"node_modules/postcss/lib/rule.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(require("./container"));

var _list = _interopRequireDefault(require("./list"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/**
 * Represents a CSS rule: a selector followed by a declaration block.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('a{}')
 * const rule = root.first
 * rule.type       //=> 'rule'
 * rule.toString() //=> 'a{}'
 */


var Rule = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Rule, _Container);

  function Rule(defaults) {
    var _this;

    _this = _Container.call(this, defaults) || this;
    _this.type = 'rule';
    if (!_this.nodes) _this.nodes = [];
    return _this;
  }
  /**
   * An array containing the rule’s individual selectors.
   * Groups of selectors are split at commas.
   *
   * @type {string[]}
   *
   * @example
   * const root = postcss.parse('a, b { }')
   * const rule = root.first
   *
   * rule.selector  //=> 'a, b'
   * rule.selectors //=> ['a', 'b']
   *
   * rule.selectors = ['a', 'strong']
   * rule.selector //=> 'a, strong'
   */


  _createClass(Rule, [{
    key: "selectors",
    get: function get() {
      return _list.default.comma(this.selector);
    },
    set: function set(values) {
      var match = this.selector ? this.selector.match(/,\s*/) : null;
      var sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');
      this.selector = values.join(sep);
    }
    /**
     * @memberof Rule#
     * @member {string} selector The rule’s full selector represented
     *                           as a string.
     *
     * @example
     * const root = postcss.parse('a, b { }')
     * const rule = root.first
     * rule.selector //=> 'a, b'
     */

    /**
     * @memberof Rule#
     * @member {object} raws Information to generate byte-to-byte equal
     *                       node string as it was in the origin input.
     *
     * Every parser saves its own properties,
     * but the default CSS parser uses:
     *
     * * `before`: the space symbols before the node. It also stores `*`
     *   and `_` symbols before the declaration (IE hack).
     * * `after`: the space symbols after the last child of the node
     *   to the end of the node.
     * * `between`: the symbols between the property and value
     *   for declarations, selector and `{` for rules, or last parameter
     *   and `{` for at-rules.
     * * `semicolon`: contains `true` if the last child has
     *   an (optional) semicolon.
     * * `ownSemicolon`: contains `true` if there is semicolon after rule.
     *
     * PostCSS cleans selectors from comments and extra spaces,
     * but it stores origin content in raws properties.
     * As such, if you don’t change a declaration’s value,
     * PostCSS will use the raw value with comments.
     *
     * @example
     * const root = postcss.parse('a {\n  color:black\n}')
     * root.first.first.raws //=> { before: '', between: ' ', after: '\n' }
     */

  }]);

  return Rule;
}(_container.default);

var _default = Rule;
exports.default = _default;
module.exports = exports.default;
},{"./container":"node_modules/postcss/lib/container.js","./list":"node_modules/postcss/lib/list.js"}],"node_modules/postcss/lib/container.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _declaration = _interopRequireDefault(require("./declaration"));

var _comment = _interopRequireDefault(require("./comment"));

var _node = _interopRequireDefault(require("./node"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function cleanSource(nodes) {
  return nodes.map(function (i) {
    if (i.nodes) i.nodes = cleanSource(i.nodes);
    delete i.source;
    return i;
  });
}
/**
 * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes
 * inherit some common methods to help work with their children.
 *
 * Note that all containers can store any content. If you write a rule inside
 * a rule, PostCSS will parse it.
 *
 * @extends Node
 * @abstract
 */


var Container = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Container, _Node);

  function Container() {
    return _Node.apply(this, arguments) || this;
  }

  var _proto = Container.prototype;

  _proto.push = function push(child) {
    child.parent = this;
    this.nodes.push(child);
    return this;
  }
  /**
   * Iterates through the container’s immediate children,
   * calling `callback` for each child.
   *
   * Returning `false` in the callback will break iteration.
   *
   * This method only iterates through the container’s immediate children.
   * If you need to recursively iterate through all the container’s descendant
   * nodes, use {@link Container#walk}.
   *
   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe
   * if you are mutating the array of child nodes during iteration.
   * PostCSS will adjust the current index to match the mutations.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * const root = postcss.parse('a { color: black; z-index: 1 }')
   * const rule = root.first
   *
   * for (const decl of rule.nodes) {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Cycle will be infinite, because cloneBefore moves the current node
   *   // to the next index
   * }
   *
   * rule.each(decl => {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Will be executed only for color and z-index
   * })
   */
  ;

  _proto.each = function each(callback) {
    if (!this.lastEach) this.lastEach = 0;
    if (!this.indexes) this.indexes = {};
    this.lastEach += 1;
    var id = this.lastEach;
    this.indexes[id] = 0;
    if (!this.nodes) return undefined;
    var index, result;

    while (this.indexes[id] < this.nodes.length) {
      index = this.indexes[id];
      result = callback(this.nodes[index], index);
      if (result === false) break;
      this.indexes[id] += 1;
    }

    delete this.indexes[id];
    return result;
  }
  /**
   * Traverses the container’s descendant nodes, calling callback
   * for each node.
   *
   * Like container.each(), this method is safe to use
   * if you are mutating arrays during iteration.
   *
   * If you only need to iterate through the container’s immediate children,
   * use {@link Container#each}.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walk(node => {
   *   // Traverses all descendant nodes.
   * })
   */
  ;

  _proto.walk = function walk(callback) {
    return this.each(function (child, i) {
      var result;

      try {
        result = callback(child, i);
      } catch (e) {
        e.postcssNode = child;

        if (e.stack && child.source && /\n\s{4}at /.test(e.stack)) {
          var s = child.source;
          e.stack = e.stack.replace(/\n\s{4}at /, "$&" + s.input.from + ":" + s.start.line + ":" + s.start.column + "$&");
        }

        throw e;
      }

      if (result !== false && child.walk) {
        result = child.walk(callback);
      }

      return result;
    });
  }
  /**
   * Traverses the container’s descendant nodes, calling callback
   * for each declaration node.
   *
   * If you pass a filter, iteration will only happen over declarations
   * with matching properties.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [prop]   String or regular expression
   *                                 to filter declarations by property name.
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkDecls(decl => {
   *   checkPropertySupport(decl.prop)
   * })
   *
   * root.walkDecls('border-radius', decl => {
   *   decl.remove()
   * })
   *
   * root.walkDecls(/^background/, decl => {
   *   decl.value = takeFirstColorFromGradient(decl.value)
   * })
   */
  ;

  _proto.walkDecls = function walkDecls(prop, callback) {
    if (!callback) {
      callback = prop;
      return this.walk(function (child, i) {
        if (child.type === 'decl') {
          return callback(child, i);
        }
      });
    }

    if (prop instanceof RegExp) {
      return this.walk(function (child, i) {
        if (child.type === 'decl' && prop.test(child.prop)) {
          return callback(child, i);
        }
      });
    }

    return this.walk(function (child, i) {
      if (child.type === 'decl' && child.prop === prop) {
        return callback(child, i);
      }
    });
  }
  /**
   * Traverses the container’s descendant nodes, calling callback
   * for each rule node.
   *
   * If you pass a filter, iteration will only happen over rules
   * with matching selectors.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [selector] String or regular expression
   *                                   to filter rules by selector.
   * @param {childIterator} callback   Iterator receives each node and index.
   *
   * @return {false|undefined} returns `false` if iteration was broke.
   *
   * @example
   * const selectors = []
   * root.walkRules(rule => {
   *   selectors.push(rule.selector)
   * })
   * console.log(`Your CSS uses ${ selectors.length } selectors`)
   */
  ;

  _proto.walkRules = function walkRules(selector, callback) {
    if (!callback) {
      callback = selector;
      return this.walk(function (child, i) {
        if (child.type === 'rule') {
          return callback(child, i);
        }
      });
    }

    if (selector instanceof RegExp) {
      return this.walk(function (child, i) {
        if (child.type === 'rule' && selector.test(child.selector)) {
          return callback(child, i);
        }
      });
    }

    return this.walk(function (child, i) {
      if (child.type === 'rule' && child.selector === selector) {
        return callback(child, i);
      }
    });
  }
  /**
   * Traverses the container’s descendant nodes, calling callback
   * for each at-rule node.
   *
   * If you pass a filter, iteration will only happen over at-rules
   * that have matching names.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [name]   String or regular expression
   *                                 to filter at-rules by name.
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkAtRules(rule => {
   *   if (isOld(rule.name)) rule.remove()
   * })
   *
   * let first = false
   * root.walkAtRules('charset', rule => {
   *   if (!first) {
   *     first = true
   *   } else {
   *     rule.remove()
   *   }
   * })
   */
  ;

  _proto.walkAtRules = function walkAtRules(name, callback) {
    if (!callback) {
      callback = name;
      return this.walk(function (child, i) {
        if (child.type === 'atrule') {
          return callback(child, i);
        }
      });
    }

    if (name instanceof RegExp) {
      return this.walk(function (child, i) {
        if (child.type === 'atrule' && name.test(child.name)) {
          return callback(child, i);
        }
      });
    }

    return this.walk(function (child, i) {
      if (child.type === 'atrule' && child.name === name) {
        return callback(child, i);
      }
    });
  }
  /**
   * Traverses the container’s descendant nodes, calling callback
   * for each comment node.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkComments(comment => {
   *   comment.remove()
   * })
   */
  ;

  _proto.walkComments = function walkComments(callback) {
    return this.walk(function (child, i) {
      if (child.type === 'comment') {
        return callback(child, i);
      }
    });
  }
  /**
   * Inserts new nodes to the end of the container.
   *
   * @param {...(Node|object|string|Node[])} children New nodes.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })
   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })
   * rule.append(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   */
  ;

  _proto.append = function append() {
    for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
      children[_key] = arguments[_key];
    }

    for (var _i = 0, _children = children; _i < _children.length; _i++) {
      var child = _children[_i];
      var nodes = this.normalize(child, this.last);

      for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i2 >= _iterator.length) break;
          _ref = _iterator[_i2++];
        } else {
          _i2 = _iterator.next();
          if (_i2.done) break;
          _ref = _i2.value;
        }

        var node = _ref;
        this.nodes.push(node);
      }
    }

    return this;
  }
  /**
   * Inserts new nodes to the start of the container.
   *
   * @param {...(Node|object|string|Node[])} children New nodes.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })
   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })
   * rule.prepend(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   */
  ;

  _proto.prepend = function prepend() {
    for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      children[_key2] = arguments[_key2];
    }

    children = children.reverse();

    for (var _iterator2 = children, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i3 >= _iterator2.length) break;
        _ref2 = _iterator2[_i3++];
      } else {
        _i3 = _iterator2.next();
        if (_i3.done) break;
        _ref2 = _i3.value;
      }

      var child = _ref2;
      var nodes = this.normalize(child, this.first, 'prepend').reverse();

      for (var _iterator3 = nodes, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i4 >= _iterator3.length) break;
          _ref3 = _iterator3[_i4++];
        } else {
          _i4 = _iterator3.next();
          if (_i4.done) break;
          _ref3 = _i4.value;
        }

        var node = _ref3;
        this.nodes.unshift(node);
      }

      for (var id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length;
      }
    }

    return this;
  };

  _proto.cleanRaws = function cleanRaws(keepBetween) {
    _Node.prototype.cleanRaws.call(this, keepBetween);

    if (this.nodes) {
      for (var _iterator4 = this.nodes, _isArray4 = Array.isArray(_iterator4), _i5 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
        var _ref4;

        if (_isArray4) {
          if (_i5 >= _iterator4.length) break;
          _ref4 = _iterator4[_i5++];
        } else {
          _i5 = _iterator4.next();
          if (_i5.done) break;
          _ref4 = _i5.value;
        }

        var node = _ref4;
        node.cleanRaws(keepBetween);
      }
    }
  }
  /**
   * Insert new node before old node within the container.
   *
   * @param {Node|number} exist             Child or child’s index.
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))
   */
  ;

  _proto.insertBefore = function insertBefore(exist, add) {
    exist = this.index(exist);
    var type = exist === 0 ? 'prepend' : false;
    var nodes = this.normalize(add, this.nodes[exist], type).reverse();

    for (var _iterator5 = nodes, _isArray5 = Array.isArray(_iterator5), _i6 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
      var _ref5;

      if (_isArray5) {
        if (_i6 >= _iterator5.length) break;
        _ref5 = _iterator5[_i6++];
      } else {
        _i6 = _iterator5.next();
        if (_i6.done) break;
        _ref5 = _i6.value;
      }

      var node = _ref5;
      this.nodes.splice(exist, 0, node);
    }

    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (exist <= index) {
        this.indexes[id] = index + nodes.length;
      }
    }

    return this;
  }
  /**
   * Insert new node after old node within the container.
   *
   * @param {Node|number} exist             Child or child’s index.
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   */
  ;

  _proto.insertAfter = function insertAfter(exist, add) {
    exist = this.index(exist);
    var nodes = this.normalize(add, this.nodes[exist]).reverse();

    for (var _iterator6 = nodes, _isArray6 = Array.isArray(_iterator6), _i7 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
      var _ref6;

      if (_isArray6) {
        if (_i7 >= _iterator6.length) break;
        _ref6 = _iterator6[_i7++];
      } else {
        _i7 = _iterator6.next();
        if (_i7.done) break;
        _ref6 = _i7.value;
      }

      var node = _ref6;
      this.nodes.splice(exist + 1, 0, node);
    }

    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (exist < index) {
        this.indexes[id] = index + nodes.length;
      }
    }

    return this;
  }
  /**
   * Removes node from the container and cleans the parent properties
   * from the node and its children.
   *
   * @param {Node|number} child Child or child’s index.
   *
   * @return {Node} This node for methods chain
   *
   * @example
   * rule.nodes.length  //=> 5
   * rule.removeChild(decl)
   * rule.nodes.length  //=> 4
   * decl.parent        //=> undefined
   */
  ;

  _proto.removeChild = function removeChild(child) {
    child = this.index(child);
    this.nodes[child].parent = undefined;
    this.nodes.splice(child, 1);
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index >= child) {
        this.indexes[id] = index - 1;
      }
    }

    return this;
  }
  /**
   * Removes all children from the container
   * and cleans their parent properties.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * rule.removeAll()
   * rule.nodes.length //=> 0
   */
  ;

  _proto.removeAll = function removeAll() {
    for (var _iterator7 = this.nodes, _isArray7 = Array.isArray(_iterator7), _i8 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
      var _ref7;

      if (_isArray7) {
        if (_i8 >= _iterator7.length) break;
        _ref7 = _iterator7[_i8++];
      } else {
        _i8 = _iterator7.next();
        if (_i8.done) break;
        _ref7 = _i8.value;
      }

      var node = _ref7;
      node.parent = undefined;
    }

    this.nodes = [];
    return this;
  }
  /**
   * Passes all declaration values within the container that match pattern
   * through callback, replacing those values with the returned result
   * of callback.
   *
   * This method is useful if you are using a custom unit or function
   * and need to iterate through all values.
   *
   * @param {string|RegExp} pattern      Replace pattern.
   * @param {object} opts                Options to speed up the search.
   * @param {string|string[]} opts.props An array of property names.
   * @param {string} opts.fast           String that’s used to narrow down
   *                                     values and speed up the regexp search.
   * @param {function|string} callback   String to replace pattern or callback
   *                                     that returns a new value. The callback
   *                                     will receive the same arguments
   *                                     as those passed to a function parameter
   *                                     of `String#replace`.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * root.replaceValues(/\d+rem/, { fast: 'rem' }, string => {
   *   return 15 * parseInt(string) + 'px'
   * })
   */
  ;

  _proto.replaceValues = function replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = {};
    }

    this.walkDecls(function (decl) {
      if (opts.props && opts.props.indexOf(decl.prop) === -1) return;
      if (opts.fast && decl.value.indexOf(opts.fast) === -1) return;
      decl.value = decl.value.replace(pattern, callback);
    });
    return this;
  }
  /**
   * Returns `true` if callback returns `true`
   * for all of the container’s children.
   *
   * @param {childCondition} condition Iterator returns true or false.
   *
   * @return {boolean} Is every child pass condition.
   *
   * @example
   * const noPrefixes = rule.every(i => i.prop[0] !== '-')
   */
  ;

  _proto.every = function every(condition) {
    return this.nodes.every(condition);
  }
  /**
   * Returns `true` if callback returns `true` for (at least) one
   * of the container’s children.
   *
   * @param {childCondition} condition Iterator returns true or false.
   *
   * @return {boolean} Is some child pass condition.
   *
   * @example
   * const hasPrefix = rule.some(i => i.prop[0] === '-')
   */
  ;

  _proto.some = function some(condition) {
    return this.nodes.some(condition);
  }
  /**
   * Returns a `child`’s index within the {@link Container#nodes} array.
   *
   * @param {Node} child Child of the current container.
   *
   * @return {number} Child index.
   *
   * @example
   * rule.index( rule.nodes[2] ) //=> 2
   */
  ;

  _proto.index = function index(child) {
    if (typeof child === 'number') {
      return child;
    }

    return this.nodes.indexOf(child);
  }
  /**
   * The container’s first child.
   *
   * @type {Node}
   *
   * @example
   * rule.first === rules.nodes[0]
   */
  ;

  _proto.normalize = function normalize(nodes, sample) {
    var _this = this;

    if (typeof nodes === 'string') {
      var parse = require('./parse');

      nodes = cleanSource(parse(nodes).nodes);
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0);

      for (var _iterator8 = nodes, _isArray8 = Array.isArray(_iterator8), _i9 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
        var _ref8;

        if (_isArray8) {
          if (_i9 >= _iterator8.length) break;
          _ref8 = _iterator8[_i9++];
        } else {
          _i9 = _iterator8.next();
          if (_i9.done) break;
          _ref8 = _i9.value;
        }

        var i = _ref8;
        if (i.parent) i.parent.removeChild(i, 'ignore');
      }
    } else if (nodes.type === 'root') {
      nodes = nodes.nodes.slice(0);

      for (var _iterator9 = nodes, _isArray9 = Array.isArray(_iterator9), _i10 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {
        var _ref9;

        if (_isArray9) {
          if (_i10 >= _iterator9.length) break;
          _ref9 = _iterator9[_i10++];
        } else {
          _i10 = _iterator9.next();
          if (_i10.done) break;
          _ref9 = _i10.value;
        }

        var _i11 = _ref9;
        if (_i11.parent) _i11.parent.removeChild(_i11, 'ignore');
      }
    } else if (nodes.type) {
      nodes = [nodes];
    } else if (nodes.prop) {
      if (typeof nodes.value === 'undefined') {
        throw new Error('Value field is missed in node creation');
      } else if (typeof nodes.value !== 'string') {
        nodes.value = String(nodes.value);
      }

      nodes = [new _declaration.default(nodes)];
    } else if (nodes.selector) {
      var Rule = require('./rule');

      nodes = [new Rule(nodes)];
    } else if (nodes.name) {
      var AtRule = require('./at-rule');

      nodes = [new AtRule(nodes)];
    } else if (nodes.text) {
      nodes = [new _comment.default(nodes)];
    } else {
      throw new Error('Unknown node type in node creation');
    }

    var processed = nodes.map(function (i) {
      if (i.parent) i.parent.removeChild(i);

      if (typeof i.raws.before === 'undefined') {
        if (sample && typeof sample.raws.before !== 'undefined') {
          i.raws.before = sample.raws.before.replace(/[^\s]/g, '');
        }
      }

      i.parent = _this;
      return i;
    });
    return processed;
  }
  /**
   * @memberof Container#
   * @member {Node[]} nodes An array containing the container’s children.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * root.nodes.length           //=> 1
   * root.nodes[0].selector      //=> 'a'
   * root.nodes[0].nodes[0].prop //=> 'color'
   */
  ;

  _createClass(Container, [{
    key: "first",
    get: function get() {
      if (!this.nodes) return undefined;
      return this.nodes[0];
    }
    /**
     * The container’s last child.
     *
     * @type {Node}
     *
     * @example
     * rule.last === rule.nodes[rule.nodes.length - 1]
     */

  }, {
    key: "last",
    get: function get() {
      if (!this.nodes) return undefined;
      return this.nodes[this.nodes.length - 1];
    }
  }]);

  return Container;
}(_node.default);

var _default = Container;
/**
 * @callback childCondition
 * @param {Node} node    Container child.
 * @param {number} index Child index.
 * @param {Node[]} nodes All container children.
 * @return {boolean}
 */

/**
 * @callback childIterator
 * @param {Node} node    Container child.
 * @param {number} index Child index.
 * @return {false|undefined} Returning `false` will break iteration.
 */

exports.default = _default;
module.exports = exports.default;
},{"./declaration":"node_modules/postcss/lib/declaration.js","./comment":"node_modules/postcss/lib/comment.js","./node":"node_modules/postcss/lib/node.js","./parse":"node_modules/postcss/lib/parse.js","./rule":"node_modules/postcss/lib/rule.js","./at-rule":"node_modules/postcss/lib/at-rule.js"}],"node_modules/postcss/lib/at-rule.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(require("./container"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/**
 * Represents an at-rule.
 *
 * If it’s followed in the CSS by a {} block, this node will have
 * a nodes property representing its children.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('@charset "UTF-8"; @media print {}')
 *
 * const charset = root.first
 * charset.type  //=> 'atrule'
 * charset.nodes //=> undefined
 *
 * const media = root.last
 * media.nodes   //=> []
 */


var AtRule = /*#__PURE__*/function (_Container) {
  _inheritsLoose(AtRule, _Container);

  function AtRule(defaults) {
    var _this;

    _this = _Container.call(this, defaults) || this;
    _this.type = 'atrule';
    return _this;
  }

  var _proto = AtRule.prototype;

  _proto.append = function append() {
    var _Container$prototype$;

    if (!this.nodes) this.nodes = [];

    for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
      children[_key] = arguments[_key];
    }

    return (_Container$prototype$ = _Container.prototype.append).call.apply(_Container$prototype$, [this].concat(children));
  };

  _proto.prepend = function prepend() {
    var _Container$prototype$2;

    if (!this.nodes) this.nodes = [];

    for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      children[_key2] = arguments[_key2];
    }

    return (_Container$prototype$2 = _Container.prototype.prepend).call.apply(_Container$prototype$2, [this].concat(children));
  }
  /**
   * @memberof AtRule#
   * @member {string} name The at-rule’s name immediately follows the `@`.
   *
   * @example
   * const root  = postcss.parse('@media print {}')
   * media.name //=> 'media'
   * const media = root.first
   */

  /**
   * @memberof AtRule#
   * @member {string} params The at-rule’s parameters, the values
   *                         that follow the at-rule’s name but precede
   *                         any {} block.
   *
   * @example
   * const root  = postcss.parse('@media print, screen {}')
   * const media = root.first
   * media.params //=> 'print, screen'
   */

  /**
   * @memberof AtRule#
   * @member {object} raws Information to generate byte-to-byte equal
   *                        node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `after`: the space symbols after the last child of the node
   *   to the end of the node.
   * * `between`: the symbols between the property and value
   *   for declarations, selector and `{` for rules, or last parameter
   *   and `{` for at-rules.
   * * `semicolon`: contains true if the last child has
   *   an (optional) semicolon.
   * * `afterName`: the space between the at-rule name and its parameters.
   *
   * PostCSS cleans at-rule parameters from comments and extra spaces,
   * but it stores origin content in raws properties.
   * As such, if you don’t change a declaration’s value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('  @media\nprint {\n}')
   * root.first.first.raws //=> { before: '  ',
   *                       //     between: ' ',
   *                       //     afterName: '\n',
   *                       //     after: '\n' }
   */
  ;

  return AtRule;
}(_container.default);

var _default = AtRule;
exports.default = _default;
module.exports = exports.default;
},{"./container":"node_modules/postcss/lib/container.js"}],"node_modules/postcss/lib/root.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(require("./container"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/**
 * Represents a CSS file and contains all its parsed nodes.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('a{color:black} b{z-index:2}')
 * root.type         //=> 'root'
 * root.nodes.length //=> 2
 */


var Root = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Root, _Container);

  function Root(defaults) {
    var _this;

    _this = _Container.call(this, defaults) || this;
    _this.type = 'root';
    if (!_this.nodes) _this.nodes = [];
    return _this;
  }

  var _proto = Root.prototype;

  _proto.removeChild = function removeChild(child, ignore) {
    var index = this.index(child);

    if (!ignore && index === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index].raws.before;
    }

    return _Container.prototype.removeChild.call(this, child);
  };

  _proto.normalize = function normalize(child, sample, type) {
    var nodes = _Container.prototype.normalize.call(this, child);

    if (sample) {
      if (type === 'prepend') {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before;
        } else {
          delete sample.raws.before;
        }
      } else if (this.first !== sample) {
        for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var node = _ref;
          node.raws.before = sample.raws.before;
        }
      }
    }

    return nodes;
  }
  /**
   * Returns a {@link Result} instance representing the root’s CSS.
   *
   * @param {processOptions} [opts] Options with only `to` and `map` keys.
   *
   * @return {Result} Result with current root’s CSS.
   *
   * @example
   * const root1 = postcss.parse(css1, { from: 'a.css' })
   * const root2 = postcss.parse(css2, { from: 'b.css' })
   * root1.append(root2)
   * const result = root1.toResult({ to: 'all.css', map: true })
   */
  ;

  _proto.toResult = function toResult(opts) {
    if (opts === void 0) {
      opts = {};
    }

    var LazyResult = require('./lazy-result');

    var Processor = require('./processor');

    var lazy = new LazyResult(new Processor(), this, opts);
    return lazy.stringify();
  }
  /**
   * @memberof Root#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `after`: the space symbols after the last child to the end of file.
   * * `semicolon`: is the last child has an (optional) semicolon.
   *
   * @example
   * postcss.parse('a {}\n').raws //=> { after: '\n' }
   * postcss.parse('a {}').raws   //=> { after: '' }
   */
  ;

  return Root;
}(_container.default);

var _default = Root;
exports.default = _default;
module.exports = exports.default;
},{"./container":"node_modules/postcss/lib/container.js","./lazy-result":"node_modules/postcss/lib/lazy-result.js","./processor":"node_modules/postcss/lib/processor.js"}],"node_modules/postcss/lib/parser.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _declaration = _interopRequireDefault(require("./declaration"));

var _tokenize = _interopRequireDefault(require("./tokenize"));

var _comment = _interopRequireDefault(require("./comment"));

var _atRule = _interopRequireDefault(require("./at-rule"));

var _root = _interopRequireDefault(require("./root"));

var _rule = _interopRequireDefault(require("./rule"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var Parser = /*#__PURE__*/function () {
  function Parser(input) {
    this.input = input;
    this.root = new _root.default();
    this.current = this.root;
    this.spaces = '';
    this.semicolon = false;
    this.createTokenizer();
    this.root.source = {
      input: input,
      start: {
        line: 1,
        column: 1
      }
    };
  }

  var _proto = Parser.prototype;

  _proto.createTokenizer = function createTokenizer() {
    this.tokenizer = (0, _tokenize.default)(this.input);
  };

  _proto.parse = function parse() {
    var token;

    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();

      switch (token[0]) {
        case 'space':
          this.spaces += token[1];
          break;

        case ';':
          this.freeSemicolon(token);
          break;

        case '}':
          this.end(token);
          break;

        case 'comment':
          this.comment(token);
          break;

        case 'at-word':
          this.atrule(token);
          break;

        case '{':
          this.emptyRule(token);
          break;

        default:
          this.other(token);
          break;
      }
    }

    this.endFile();
  };

  _proto.comment = function comment(token) {
    var node = new _comment.default();
    this.init(node, token[2], token[3]);
    node.source.end = {
      line: token[4],
      column: token[5]
    };
    var text = token[1].slice(2, -2);

    if (/^\s*$/.test(text)) {
      node.text = '';
      node.raws.left = text;
      node.raws.right = '';
    } else {
      var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
      node.text = match[2];
      node.raws.left = match[1];
      node.raws.right = match[3];
    }
  };

  _proto.emptyRule = function emptyRule(token) {
    var node = new _rule.default();
    this.init(node, token[2], token[3]);
    node.selector = '';
    node.raws.between = '';
    this.current = node;
  };

  _proto.other = function other(start) {
    var end = false;
    var type = null;
    var colon = false;
    var bracket = null;
    var brackets = [];
    var tokens = [];
    var token = start;

    while (token) {
      type = token[0];
      tokens.push(token);

      if (type === '(' || type === '[') {
        if (!bracket) bracket = token;
        brackets.push(type === '(' ? ')' : ']');
      } else if (brackets.length === 0) {
        if (type === ';') {
          if (colon) {
            this.decl(tokens);
            return;
          } else {
            break;
          }
        } else if (type === '{') {
          this.rule(tokens);
          return;
        } else if (type === '}') {
          this.tokenizer.back(tokens.pop());
          end = true;
          break;
        } else if (type === ':') {
          colon = true;
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
        if (brackets.length === 0) bracket = null;
      }

      token = this.tokenizer.nextToken();
    }

    if (this.tokenizer.endOfFile()) end = true;
    if (brackets.length > 0) this.unclosedBracket(bracket);

    if (end && colon) {
      while (tokens.length) {
        token = tokens[tokens.length - 1][0];
        if (token !== 'space' && token !== 'comment') break;
        this.tokenizer.back(tokens.pop());
      }

      this.decl(tokens);
    } else {
      this.unknownWord(tokens);
    }
  };

  _proto.rule = function rule(tokens) {
    tokens.pop();
    var node = new _rule.default();
    this.init(node, tokens[0][2], tokens[0][3]);
    node.raws.between = this.spacesAndCommentsFromEnd(tokens);
    this.raw(node, 'selector', tokens);
    this.current = node;
  };

  _proto.decl = function decl(tokens) {
    var node = new _declaration.default();
    this.init(node);
    var last = tokens[tokens.length - 1];

    if (last[0] === ';') {
      this.semicolon = true;
      tokens.pop();
    }

    if (last[4]) {
      node.source.end = {
        line: last[4],
        column: last[5]
      };
    } else {
      node.source.end = {
        line: last[2],
        column: last[3]
      };
    }

    while (tokens[0][0] !== 'word') {
      if (tokens.length === 1) this.unknownWord(tokens);
      node.raws.before += tokens.shift()[1];
    }

    node.source.start = {
      line: tokens[0][2],
      column: tokens[0][3]
    };
    node.prop = '';

    while (tokens.length) {
      var type = tokens[0][0];

      if (type === ':' || type === 'space' || type === 'comment') {
        break;
      }

      node.prop += tokens.shift()[1];
    }

    node.raws.between = '';
    var token;

    while (tokens.length) {
      token = tokens.shift();

      if (token[0] === ':') {
        node.raws.between += token[1];
        break;
      } else {
        if (token[0] === 'word' && /\w/.test(token[1])) {
          this.unknownWord([token]);
        }

        node.raws.between += token[1];
      }
    }

    if (node.prop[0] === '_' || node.prop[0] === '*') {
      node.raws.before += node.prop[0];
      node.prop = node.prop.slice(1);
    }

    node.raws.between += this.spacesAndCommentsFromStart(tokens);
    this.precheckMissedSemicolon(tokens);

    for (var i = tokens.length - 1; i > 0; i--) {
      token = tokens[i];

      if (token[1].toLowerCase() === '!important') {
        node.important = true;
        var string = this.stringFrom(tokens, i);
        string = this.spacesFromEnd(tokens) + string;
        if (string !== ' !important') node.raws.important = string;
        break;
      } else if (token[1].toLowerCase() === 'important') {
        var cache = tokens.slice(0);
        var str = '';

        for (var j = i; j > 0; j--) {
          var _type = cache[j][0];

          if (str.trim().indexOf('!') === 0 && _type !== 'space') {
            break;
          }

          str = cache.pop()[1] + str;
        }

        if (str.trim().indexOf('!') === 0) {
          node.important = true;
          node.raws.important = str;
          tokens = cache;
        }
      }

      if (token[0] !== 'space' && token[0] !== 'comment') {
        break;
      }
    }

    this.raw(node, 'value', tokens);
    if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);
  };

  _proto.atrule = function atrule(token) {
    var node = new _atRule.default();
    node.name = token[1].slice(1);

    if (node.name === '') {
      this.unnamedAtrule(node, token);
    }

    this.init(node, token[2], token[3]);
    var prev;
    var shift;
    var last = false;
    var open = false;
    var params = [];

    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();

      if (token[0] === ';') {
        node.source.end = {
          line: token[2],
          column: token[3]
        };
        this.semicolon = true;
        break;
      } else if (token[0] === '{') {
        open = true;
        break;
      } else if (token[0] === '}') {
        if (params.length > 0) {
          shift = params.length - 1;
          prev = params[shift];

          while (prev && prev[0] === 'space') {
            prev = params[--shift];
          }

          if (prev) {
            node.source.end = {
              line: prev[4],
              column: prev[5]
            };
          }
        }

        this.end(token);
        break;
      } else {
        params.push(token);
      }

      if (this.tokenizer.endOfFile()) {
        last = true;
        break;
      }
    }

    node.raws.between = this.spacesAndCommentsFromEnd(params);

    if (params.length) {
      node.raws.afterName = this.spacesAndCommentsFromStart(params);
      this.raw(node, 'params', params);

      if (last) {
        token = params[params.length - 1];
        node.source.end = {
          line: token[4],
          column: token[5]
        };
        this.spaces = node.raws.between;
        node.raws.between = '';
      }
    } else {
      node.raws.afterName = '';
      node.params = '';
    }

    if (open) {
      node.nodes = [];
      this.current = node;
    }
  };

  _proto.end = function end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }

    this.semicolon = false;
    this.current.raws.after = (this.current.raws.after || '') + this.spaces;
    this.spaces = '';

    if (this.current.parent) {
      this.current.source.end = {
        line: token[2],
        column: token[3]
      };
      this.current = this.current.parent;
    } else {
      this.unexpectedClose(token);
    }
  };

  _proto.endFile = function endFile() {
    if (this.current.parent) this.unclosedBlock();

    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }

    this.current.raws.after = (this.current.raws.after || '') + this.spaces;
  };

  _proto.freeSemicolon = function freeSemicolon(token) {
    this.spaces += token[1];

    if (this.current.nodes) {
      var prev = this.current.nodes[this.current.nodes.length - 1];

      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces;
        this.spaces = '';
      }
    }
  } // Helpers
  ;

  _proto.init = function init(node, line, column) {
    this.current.push(node);
    node.source = {
      start: {
        line: line,
        column: column
      },
      input: this.input
    };
    node.raws.before = this.spaces;
    this.spaces = '';
    if (node.type !== 'comment') this.semicolon = false;
  };

  _proto.raw = function raw(node, prop, tokens) {
    var token, type;
    var length = tokens.length;
    var value = '';
    var clean = true;
    var next, prev;
    var pattern = /^([.|#])?([\w])+/i;

    for (var i = 0; i < length; i += 1) {
      token = tokens[i];
      type = token[0];

      if (type === 'comment' && node.type === 'rule') {
        prev = tokens[i - 1];
        next = tokens[i + 1];

        if (prev[0] !== 'space' && next[0] !== 'space' && pattern.test(prev[1]) && pattern.test(next[1])) {
          value += token[1];
        } else {
          clean = false;
        }

        continue;
      }

      if (type === 'comment' || type === 'space' && i === length - 1) {
        clean = false;
      } else {
        value += token[1];
      }
    }

    if (!clean) {
      var raw = tokens.reduce(function (all, i) {
        return all + i[1];
      }, '');
      node.raws[prop] = {
        value: value,
        raw: raw
      };
    }

    node[prop] = value;
  };

  _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {
    var lastTokenType;
    var spaces = '';

    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
      spaces = tokens.pop()[1] + spaces;
    }

    return spaces;
  };

  _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {
    var next;
    var spaces = '';

    while (tokens.length) {
      next = tokens[0][0];
      if (next !== 'space' && next !== 'comment') break;
      spaces += tokens.shift()[1];
    }

    return spaces;
  };

  _proto.spacesFromEnd = function spacesFromEnd(tokens) {
    var lastTokenType;
    var spaces = '';

    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== 'space') break;
      spaces = tokens.pop()[1] + spaces;
    }

    return spaces;
  };

  _proto.stringFrom = function stringFrom(tokens, from) {
    var result = '';

    for (var i = from; i < tokens.length; i++) {
      result += tokens[i][1];
    }

    tokens.splice(from, tokens.length - from);
    return result;
  };

  _proto.colon = function colon(tokens) {
    var brackets = 0;
    var token, type, prev;

    for (var i = 0; i < tokens.length; i++) {
      token = tokens[i];
      type = token[0];

      if (type === '(') {
        brackets += 1;
      }

      if (type === ')') {
        brackets -= 1;
      }

      if (brackets === 0 && type === ':') {
        if (!prev) {
          this.doubleColon(token);
        } else if (prev[0] === 'word' && prev[1] === 'progid') {
          continue;
        } else {
          return i;
        }
      }

      prev = token;
    }

    return false;
  } // Errors
  ;

  _proto.unclosedBracket = function unclosedBracket(bracket) {
    throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);
  };

  _proto.unknownWord = function unknownWord(tokens) {
    throw this.input.error('Unknown word', tokens[0][2], tokens[0][3]);
  };

  _proto.unexpectedClose = function unexpectedClose(token) {
    throw this.input.error('Unexpected }', token[2], token[3]);
  };

  _proto.unclosedBlock = function unclosedBlock() {
    var pos = this.current.source.start;
    throw this.input.error('Unclosed block', pos.line, pos.column);
  };

  _proto.doubleColon = function doubleColon(token) {
    throw this.input.error('Double colon', token[2], token[3]);
  };

  _proto.unnamedAtrule = function unnamedAtrule(node, token) {
    throw this.input.error('At-rule without name', token[2], token[3]);
  };

  _proto.precheckMissedSemicolon = function precheckMissedSemicolon()
  /* tokens */
  {// Hook for Safe Parser
  };

  _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {
    var colon = this.colon(tokens);
    if (colon === false) return;
    var founded = 0;
    var token;

    for (var j = colon - 1; j >= 0; j--) {
      token = tokens[j];

      if (token[0] !== 'space') {
        founded += 1;
        if (founded === 2) break;
      }
    }

    throw this.input.error('Missed semicolon', token[2], token[3]);
  };

  return Parser;
}();

exports.default = Parser;
module.exports = exports.default;
},{"./declaration":"node_modules/postcss/lib/declaration.js","./tokenize":"node_modules/postcss/lib/tokenize.js","./comment":"node_modules/postcss/lib/comment.js","./at-rule":"node_modules/postcss/lib/at-rule.js","./root":"node_modules/postcss/lib/root.js","./rule":"node_modules/postcss/lib/rule.js"}],"node_modules/postcss/lib/previous-map.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.default = void 0;

var _sourceMap = _interopRequireDefault(require("source-map"));

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, 'base64').toString();
  } else {
    return window.atob(str);
  }
}
/**
 * Source map information from input CSS.
 * For example, source map after Sass compiler.
 *
 * This class will automatically find source map in input CSS or in file system
 * near input file (according `from` option).
 *
 * @example
 * const root = postcss.parse(css, { from: 'a.sass.css' })
 * root.input.map //=> PreviousMap
 */


var PreviousMap = /*#__PURE__*/function () {
  /**
   * @param {string}         css    Input CSS source.
   * @param {processOptions} [opts] {@link Processor#process} options.
   */
  function PreviousMap(css, opts) {
    this.loadAnnotation(css);
    /**
     * Was source map inlined by data-uri to input CSS.
     *
     * @type {boolean}
     */

    this.inline = this.startWith(this.annotation, 'data:');
    var prev = opts.map ? opts.map.prev : undefined;
    var text = this.loadMap(opts.from, prev);
    if (text) this.text = text;
  }
  /**
   * Create a instance of `SourceMapGenerator` class
   * from the `source-map` library to work with source map information.
   *
   * It is lazy method, so it will create object only on first call
   * and then it will use cache.
   *
   * @return {SourceMapGenerator} Object with source map information.
   */


  var _proto = PreviousMap.prototype;

  _proto.consumer = function consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new _sourceMap.default.SourceMapConsumer(this.text);
    }

    return this.consumerCache;
  }
  /**
   * Does source map contains `sourcesContent` with input source text.
   *
   * @return {boolean} Is `sourcesContent` present.
   */
  ;

  _proto.withContent = function withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  };

  _proto.startWith = function startWith(string, start) {
    if (!string) return false;
    return string.substr(0, start.length) === start;
  };

  _proto.getAnnotationURL = function getAnnotationURL(sourceMapString) {
    return sourceMapString.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//)[1].trim();
  };

  _proto.loadAnnotation = function loadAnnotation(css) {
    var annotations = css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//mg);

    if (annotations && annotations.length > 0) {
      // Locate the last sourceMappingURL to avoid picking up
      // sourceMappingURLs from comments, strings, etc.
      var lastAnnotation = annotations[annotations.length - 1];

      if (lastAnnotation) {
        this.annotation = this.getAnnotationURL(lastAnnotation);
      }
    }
  };

  _proto.decodeInline = function decodeInline(text) {
    var baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
    var baseUri = /^data:application\/json;base64,/;
    var uri = 'data:application/json,';

    if (this.startWith(text, uri)) {
      return decodeURIComponent(text.substr(uri.length));
    }

    if (baseCharsetUri.test(text) || baseUri.test(text)) {
      return fromBase64(text.substr(RegExp.lastMatch.length));
    }

    var encoding = text.match(/data:application\/json;([^,]+),/)[1];
    throw new Error('Unsupported source map encoding ' + encoding);
  };

  _proto.loadMap = function loadMap(file, prev) {
    if (prev === false) return false;

    if (prev) {
      if (typeof prev === 'string') {
        return prev;
      } else if (typeof prev === 'function') {
        var prevPath = prev(file);

        if (prevPath && _fs.default.existsSync && _fs.default.existsSync(prevPath)) {
          return _fs.default.readFileSync(prevPath, 'utf-8').toString().trim();
        } else {
          throw new Error('Unable to load previous source map: ' + prevPath.toString());
        }
      } else if (prev instanceof _sourceMap.default.SourceMapConsumer) {
        return _sourceMap.default.SourceMapGenerator.fromSourceMap(prev).toString();
      } else if (prev instanceof _sourceMap.default.SourceMapGenerator) {
        return prev.toString();
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev);
      } else {
        throw new Error('Unsupported previous source map format: ' + prev.toString());
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation);
    } else if (this.annotation) {
      var map = this.annotation;
      if (file) map = _path.default.join(_path.default.dirname(file), map);
      this.root = _path.default.dirname(map);

      if (_fs.default.existsSync && _fs.default.existsSync(map)) {
        return _fs.default.readFileSync(map, 'utf-8').toString().trim();
      } else {
        return false;
      }
    }
  };

  _proto.isMap = function isMap(map) {
    if (_typeof(map) !== 'object') return false;
    return typeof map.mappings === 'string' || typeof map._mappings === 'string';
  };

  return PreviousMap;
}();

var _default = PreviousMap;
exports.default = _default;
module.exports = exports.default;
},{"source-map":"node_modules/source-map/source-map.js","path":"node_modules/path-browserify/index.js","fs":"node_modules/parcel-bundler/src/builtins/_empty.js","buffer":"node_modules/buffer/index.js"}],"node_modules/postcss/lib/input.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _cssSyntaxError = _interopRequireDefault(require("./css-syntax-error"));

var _previousMap = _interopRequireDefault(require("./previous-map"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var sequence = 0;
/**
 * Represents the source CSS.
 *
 * @example
 * const root  = postcss.parse(css, { from: file })
 * const input = root.source.input
 */

var Input = /*#__PURE__*/function () {
  /**
   * @param {string} css    Input CSS source.
   * @param {object} [opts] {@link Processor#process} options.
   */
  function Input(css, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (css === null || _typeof(css) === 'object' && !css.toString) {
      throw new Error("PostCSS received " + css + " instead of CSS string");
    }
    /**
     * Input CSS source
     *
     * @type {string}
     *
     * @example
     * const input = postcss.parse('a{}', { from: file }).input
     * input.css //=> "a{}"
     */


    this.css = css.toString();

    if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
      this.hasBOM = true;
      this.css = this.css.slice(1);
    } else {
      this.hasBOM = false;
    }

    if (opts.from) {
      if (/^\w+:\/\//.test(opts.from) || _path.default.isAbsolute(opts.from)) {
        /**
         * The absolute path to the CSS source file defined
         * with the `from` option.
         *
         * @type {string}
         *
         * @example
         * const root = postcss.parse(css, { from: 'a.css' })
         * root.source.input.file //=> '/home/ai/a.css'
         */
        this.file = opts.from;
      } else {
        this.file = _path.default.resolve(opts.from);
      }
    }

    var map = new _previousMap.default(this.css, opts);

    if (map.text) {
      /**
       * The input source map passed from a compilation step before PostCSS
       * (for example, from Sass compiler).
       *
       * @type {PreviousMap}
       *
       * @example
       * root.source.input.map.consumer().sources //=> ['a.sass']
       */
      this.map = map;
      var file = map.consumer().file;
      if (!this.file && file) this.file = this.mapResolve(file);
    }

    if (!this.file) {
      sequence += 1;
      /**
       * The unique ID of the CSS source. It will be created if `from` option
       * is not provided (because PostCSS does not know the file path).
       *
       * @type {string}
       *
       * @example
       * const root = postcss.parse(css)
       * root.source.input.file //=> undefined
       * root.source.input.id   //=> "<input css 1>"
       */

      this.id = '<input css ' + sequence + '>';
    }

    if (this.map) this.map.file = this.from;
  }

  var _proto = Input.prototype;

  _proto.error = function error(message, line, column, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var result;
    var origin = this.origin(line, column);

    if (origin) {
      result = new _cssSyntaxError.default(message, origin.line, origin.column, origin.source, origin.file, opts.plugin);
    } else {
      result = new _cssSyntaxError.default(message, line, column, this.css, this.file, opts.plugin);
    }

    result.input = {
      line: line,
      column: column,
      source: this.css
    };
    if (this.file) result.input.file = this.file;
    return result;
  }
  /**
   * Reads the input source map and returns a symbol position
   * in the input source (e.g., in a Sass file that was compiled
   * to CSS before being passed to PostCSS).
   *
   * @param {number} line   Line in input CSS.
   * @param {number} column Column in input CSS.
   *
   * @return {filePosition} Position in input source.
   *
   * @example
   * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }
   */
  ;

  _proto.origin = function origin(line, column) {
    if (!this.map) return false;
    var consumer = this.map.consumer();
    var from = consumer.originalPositionFor({
      line: line,
      column: column
    });
    if (!from.source) return false;
    var result = {
      file: this.mapResolve(from.source),
      line: from.line,
      column: from.column
    };
    var source = consumer.sourceContentFor(from.source);
    if (source) result.source = source;
    return result;
  };

  _proto.mapResolve = function mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file;
    }

    return _path.default.resolve(this.map.consumer().sourceRoot || '.', file);
  }
  /**
   * The CSS source identifier. Contains {@link Input#file} if the user
   * set the `from` option, or {@link Input#id} if they did not.
   *
   * @type {string}
   *
   * @example
   * const root = postcss.parse(css, { from: 'a.css' })
   * root.source.input.from //=> "/home/ai/a.css"
   *
   * const root = postcss.parse(css)
   * root.source.input.from //=> "<input css 1>"
   */
  ;

  _createClass(Input, [{
    key: "from",
    get: function get() {
      return this.file || this.id;
    }
  }]);

  return Input;
}();

var _default = Input;
/**
 * @typedef  {object} filePosition
 * @property {string} file   Path to file.
 * @property {number} line   Source line in file.
 * @property {number} column Source column in file.
 */

exports.default = _default;
module.exports = exports.default;
},{"path":"node_modules/path-browserify/index.js","./css-syntax-error":"node_modules/postcss/lib/css-syntax-error.js","./previous-map":"node_modules/postcss/lib/previous-map.js"}],"node_modules/postcss/lib/parse.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _parser = _interopRequireDefault(require("./parser"));

var _input = _interopRequireDefault(require("./input"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function parse(css, opts) {
  var input = new _input.default(css, opts);
  var parser = new _parser.default(input);

  try {
    parser.parse();
  } catch (e) {
    if ("development" !== 'production') {
      if (e.name === 'CssSyntaxError' && opts && opts.from) {
        if (/\.scss$/i.test(opts.from)) {
          e.message += '\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser';
        } else if (/\.sass/i.test(opts.from)) {
          e.message += '\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser';
        } else if (/\.less$/i.test(opts.from)) {
          e.message += '\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser';
        }
      }
    }

    throw e;
  }

  return parser.root;
}

var _default = parse;
exports.default = _default;
module.exports = exports.default;
},{"./parser":"node_modules/postcss/lib/parser.js","./input":"node_modules/postcss/lib/input.js"}],"node_modules/postcss/lib/lazy-result.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.default = void 0;

var _mapGenerator = _interopRequireDefault(require("./map-generator"));

var _stringify2 = _interopRequireDefault(require("./stringify"));

var _warnOnce = _interopRequireDefault(require("./warn-once"));

var _result = _interopRequireDefault(require("./result"));

var _parse = _interopRequireDefault(require("./parse"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function isPromise(obj) {
  return _typeof(obj) === 'object' && typeof obj.then === 'function';
}
/**
 * A Promise proxy for the result of PostCSS transformations.
 *
 * A `LazyResult` instance is returned by {@link Processor#process}.
 *
 * @example
 * const lazy = postcss([autoprefixer]).process(css)
 */


var LazyResult = /*#__PURE__*/function () {
  function LazyResult(processor, css, opts) {
    this.stringified = false;
    this.processed = false;
    var root;

    if (_typeof(css) === 'object' && css !== null && css.type === 'root') {
      root = css;
    } else if (css instanceof LazyResult || css instanceof _result.default) {
      root = css.root;

      if (css.map) {
        if (typeof opts.map === 'undefined') opts.map = {};
        if (!opts.map.inline) opts.map.inline = false;
        opts.map.prev = css.map;
      }
    } else {
      var parser = _parse.default;
      if (opts.syntax) parser = opts.syntax.parse;
      if (opts.parser) parser = opts.parser;
      if (parser.parse) parser = parser.parse;

      try {
        root = parser(css, opts);
      } catch (error) {
        this.error = error;
      }
    }

    this.result = new _result.default(processor, root, opts);
  }
  /**
   * Returns a {@link Processor} instance, which will be used
   * for CSS transformations.
   *
   * @type {Processor}
   */


  var _proto = LazyResult.prototype;
  /**
   * Processes input CSS through synchronous plugins
   * and calls {@link Result#warnings()}.
   *
   * @return {Warning[]} Warnings from plugins.
   */

  _proto.warnings = function warnings() {
    return this.sync().warnings();
  }
  /**
   * Alias for the {@link LazyResult#css} property.
   *
   * @example
   * lazy + '' === lazy.css
   *
   * @return {string} Output CSS.
   */
  ;

  _proto.toString = function toString() {
    return this.css;
  }
  /**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls `onFulfilled` with a Result instance. If a plugin throws
   * an error, the `onRejected` callback will be executed.
   *
   * It implements standard Promise API.
   *
   * @param {onFulfilled} onFulfilled Callback will be executed
   *                                  when all plugins will finish work.
   * @param {onRejected}  onRejected  Callback will be executed on any error.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {
   *   console.log(result.css)
   * })
   */
  ;

  _proto.then = function then(onFulfilled, onRejected) {
    if ("development" !== 'production') {
      if (!('from' in this.opts)) {
        (0, _warnOnce.default)('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');
      }
    }

    return this.async().then(onFulfilled, onRejected);
  }
  /**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls onRejected for each error thrown in any plugin.
   *
   * It implements standard Promise API.
   *
   * @param {onRejected} onRejected Callback will be executed on any error.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css).then(result => {
   *   console.log(result.css)
   * }).catch(error => {
   *   console.error(error)
   * })
   */
  ;

  _proto.catch = function _catch(onRejected) {
    return this.async().catch(onRejected);
  }
  /**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls onFinally on any error or when all plugins will finish work.
   *
   * It implements standard Promise API.
   *
   * @param {onFinally} onFinally Callback will be executed on any error or
   *                              when all plugins will finish work.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css).finally(() => {
   *   console.log('processing ended')
   * })
   */
  ;

  _proto.finally = function _finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  };

  _proto.handleError = function handleError(error, plugin) {
    try {
      this.error = error;

      if (error.name === 'CssSyntaxError' && !error.plugin) {
        error.plugin = plugin.postcssPlugin;
        error.setMessage();
      } else if (plugin.postcssVersion) {
        if ("development" !== 'production') {
          var pluginName = plugin.postcssPlugin;
          var pluginVer = plugin.postcssVersion;
          var runtimeVer = this.result.processor.version;
          var a = pluginVer.split('.');
          var b = runtimeVer.split('.');

          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
            console.error('Unknown error from PostCSS plugin. Your current PostCSS ' + 'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' + pluginVer + '. Perhaps this is the source of the error below.');
          }
        }
      }
    } catch (err) {
      if (console && console.error) console.error(err);
    }
  };

  _proto.asyncTick = function asyncTick(resolve, reject) {
    var _this = this;

    if (this.plugin >= this.processor.plugins.length) {
      this.processed = true;
      return resolve();
    }

    try {
      var plugin = this.processor.plugins[this.plugin];
      var promise = this.run(plugin);
      this.plugin += 1;

      if (isPromise(promise)) {
        promise.then(function () {
          _this.asyncTick(resolve, reject);
        }).catch(function (error) {
          _this.handleError(error, plugin);

          _this.processed = true;
          reject(error);
        });
      } else {
        this.asyncTick(resolve, reject);
      }
    } catch (error) {
      this.processed = true;
      reject(error);
    }
  };

  _proto.async = function async() {
    var _this2 = this;

    if (this.processed) {
      return new Promise(function (resolve, reject) {
        if (_this2.error) {
          reject(_this2.error);
        } else {
          resolve(_this2.stringify());
        }
      });
    }

    if (this.processing) {
      return this.processing;
    }

    this.processing = new Promise(function (resolve, reject) {
      if (_this2.error) return reject(_this2.error);
      _this2.plugin = 0;

      _this2.asyncTick(resolve, reject);
    }).then(function () {
      _this2.processed = true;
      return _this2.stringify();
    });
    return this.processing;
  };

  _proto.sync = function sync() {
    if (this.processed) return this.result;
    this.processed = true;

    if (this.processing) {
      throw new Error('Use process(css).then(cb) to work with async plugins');
    }

    if (this.error) throw this.error;

    for (var _iterator = this.result.processor.plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var plugin = _ref;
      var promise = this.run(plugin);

      if (isPromise(promise)) {
        throw new Error('Use process(css).then(cb) to work with async plugins');
      }
    }

    return this.result;
  };

  _proto.run = function run(plugin) {
    this.result.lastPlugin = plugin;

    try {
      return plugin(this.result.root, this.result);
    } catch (error) {
      this.handleError(error, plugin);
      throw error;
    }
  };

  _proto.stringify = function stringify() {
    if (this.stringified) return this.result;
    this.stringified = true;
    this.sync();
    var opts = this.result.opts;
    var str = _stringify2.default;
    if (opts.syntax) str = opts.syntax.stringify;
    if (opts.stringifier) str = opts.stringifier;
    if (str.stringify) str = str.stringify;
    var map = new _mapGenerator.default(str, this.result.root, this.result.opts);
    var data = map.generate();
    this.result.css = data[0];
    this.result.map = data[1];
    return this.result;
  };

  _createClass(LazyResult, [{
    key: "processor",
    get: function get() {
      return this.result.processor;
    }
    /**
     * Options from the {@link Processor#process} call.
     *
     * @type {processOptions}
     */

  }, {
    key: "opts",
    get: function get() {
      return this.result.opts;
    }
    /**
     * Processes input CSS through synchronous plugins, converts `Root`
     * to a CSS string and returns {@link Result#css}.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {string}
     * @see Result#css
     */

  }, {
    key: "css",
    get: function get() {
      return this.stringify().css;
    }
    /**
     * An alias for the `css` property. Use it with syntaxes
     * that generate non-CSS output.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {string}
     * @see Result#content
     */

  }, {
    key: "content",
    get: function get() {
      return this.stringify().content;
    }
    /**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#map}.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {SourceMapGenerator}
     * @see Result#map
     */

  }, {
    key: "map",
    get: function get() {
      return this.stringify().map;
    }
    /**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#root}.
     *
     * This property will only work with synchronous plugins. If the processor
     * contains any asynchronous plugins it will throw an error.
     *
     * This is why this method is only for debug purpose,
     * you should always use {@link LazyResult#then}.
     *
     * @type {Root}
     * @see Result#root
     */

  }, {
    key: "root",
    get: function get() {
      return this.sync().root;
    }
    /**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#messages}.
     *
     * This property will only work with synchronous plugins. If the processor
     * contains any asynchronous plugins it will throw an error.
     *
     * This is why this method is only for debug purpose,
     * you should always use {@link LazyResult#then}.
     *
     * @type {Message[]}
     * @see Result#messages
     */

  }, {
    key: "messages",
    get: function get() {
      return this.sync().messages;
    }
  }]);

  return LazyResult;
}();

var _default = LazyResult;
/**
 * @callback onFulfilled
 * @param {Result} result
 */

/**
 * @callback onRejected
 * @param {Error} error
 */

exports.default = _default;
module.exports = exports.default;
},{"./map-generator":"node_modules/postcss/lib/map-generator.js","./stringify":"node_modules/postcss/lib/stringify.js","./warn-once":"node_modules/postcss/lib/warn-once.js","./result":"node_modules/postcss/lib/result.js","./parse":"node_modules/postcss/lib/parse.js"}],"node_modules/postcss/lib/processor.js":[function(require,module,exports) {
var process = require("process");
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.default = void 0;

var _lazyResult = _interopRequireDefault(require("./lazy-result"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Contains plugins to process CSS. Create one `Processor` instance,
 * initialize its plugins, and then use that instance on numerous CSS files.
 *
 * @example
 * const processor = postcss([autoprefixer, precss])
 * processor.process(css1).then(result => console.log(result.css))
 * processor.process(css2).then(result => console.log(result.css))
 */


var Processor = /*#__PURE__*/function () {
  /**
   * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.
   *        See {@link Processor#use} for plugin format.
   */
  function Processor(plugins) {
    if (plugins === void 0) {
      plugins = [];
    }
    /**
     * Current PostCSS version.
     *
     * @type {string}
     *
     * @example
     * if (result.processor.version.split('.')[0] !== '6') {
     *   throw new Error('This plugin works only with PostCSS 6')
     * }
     */


    this.version = '7.0.31';
    /**
     * Plugins added to this processor.
     *
     * @type {pluginFunction[]}
     *
     * @example
     * const processor = postcss([autoprefixer, precss])
     * processor.plugins.length //=> 2
     */

    this.plugins = this.normalize(plugins);
  }
  /**
   * Adds a plugin to be used as a CSS processor.
   *
   * PostCSS plugin can be in 4 formats:
   * * A plugin created by {@link postcss.plugin} method.
   * * A function. PostCSS will pass the function a @{link Root}
   *   as the first argument and current {@link Result} instance
   *   as the second.
   * * An object with a `postcss` method. PostCSS will use that method
   *   as described in #2.
   * * Another {@link Processor} instance. PostCSS will copy plugins
   *   from that instance into this one.
   *
   * Plugins can also be added by passing them as arguments when creating
   * a `postcss` instance (see [`postcss(plugins)`]).
   *
   * Asynchronous plugins should return a `Promise` instance.
   *
   * @param {Plugin|pluginFunction|Processor} plugin PostCSS plugin
   *                                                 or {@link Processor}
   *                                                 with plugins.
   *
   * @example
   * const processor = postcss()
   *   .use(autoprefixer)
   *   .use(precss)
   *
   * @return {Processes} Current processor to make methods chain.
   */


  var _proto = Processor.prototype;

  _proto.use = function use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]));
    return this;
  }
  /**
   * Parses source CSS and returns a {@link LazyResult} Promise proxy.
   * Because some plugins can be asynchronous it doesn’t make
   * any transformations. Transformations will be applied
   * in the {@link LazyResult} methods.
   *
   * @param {string|toString|Result} css String with input CSS or any object
   *                                     with a `toString()` method,
   *                                     like a Buffer. Optionally, send
   *                                     a {@link Result} instance
   *                                     and the processor will take
   *                                     the {@link Root} from it.
   * @param {processOptions} [opts]      Options.
   *
   * @return {LazyResult} Promise proxy.
   *
   * @example
   * processor.process(css, { from: 'a.css', to: 'a.out.css' })
   *   .then(result => {
   *      console.log(result.css)
   *   })
   */
  ;

  _proto.process = function (_process) {
    function process(_x) {
      return _process.apply(this, arguments);
    }

    process.toString = function () {
      return _process.toString();
    };

    return process;
  }(function (css, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (this.plugins.length === 0 && opts.parser === opts.stringifier) {
      if ("development" !== 'production') {
        if (typeof console !== 'undefined' && console.warn) {
          console.warn('You did not set any plugins, parser, or stringifier. ' + 'Right now, PostCSS does nothing. Pick plugins for your case ' + 'on https://www.postcss.parts/ and use them in postcss.config.js.');
        }
      }
    }

    return new _lazyResult.default(this, css, opts);
  });

  _proto.normalize = function normalize(plugins) {
    var normalized = [];

    for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var i = _ref;
      if (i.postcss) i = i.postcss;

      if (_typeof(i) === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins);
      } else if (typeof i === 'function') {
        normalized.push(i);
      } else if (_typeof(i) === 'object' && (i.parse || i.stringify)) {
        if ("development" !== 'production') {
          throw new Error('PostCSS syntaxes cannot be used as plugins. Instead, please use ' + 'one of the syntax/parser/stringifier options as outlined ' + 'in your PostCSS runner documentation.');
        }
      } else {
        throw new Error(i + ' is not a PostCSS plugin');
      }
    }

    return normalized;
  };

  return Processor;
}();

var _default = Processor;
/**
 * @callback builder
 * @param {string} part          Part of generated CSS connected to this node.
 * @param {Node}   node          AST node.
 * @param {"start"|"end"} [type] Node’s part type.
 */

/**
 * @callback parser
 *
 * @param {string|toString} css   String with input CSS or any object
 *                                with toString() method, like a Buffer.
 * @param {processOptions} [opts] Options with only `from` and `map` keys.
 *
 * @return {Root} PostCSS AST
 */

/**
 * @callback stringifier
 *
 * @param {Node} node       Start node for stringifing. Usually {@link Root}.
 * @param {builder} builder Function to concatenate CSS from node’s parts
 *                          or generate string and source map.
 *
 * @return {void}
 */

/**
 * @typedef {object} syntax
 * @property {parser} parse          Function to generate AST by string.
 * @property {stringifier} stringify Function to generate string by AST.
 */

/**
 * @typedef {object} toString
 * @property {function} toString
 */

/**
 * @callback pluginFunction
 * @param {Root} root     Parsed input CSS.
 * @param {Result} result Result to set warnings or check other plugins.
 */

/**
 * @typedef {object} Plugin
 * @property {function} postcss PostCSS plugin function.
 */

/**
 * @typedef {object} processOptions
 * @property {string} from             The path of the CSS source file.
 *                                     You should always set `from`,
 *                                     because it is used in source map
 *                                     generation and syntax error messages.
 * @property {string} to               The path where you’ll put the output
 *                                     CSS file. You should always set `to`
 *                                     to generate correct source maps.
 * @property {parser} parser           Function to generate AST by string.
 * @property {stringifier} stringifier Class to generate string by AST.
 * @property {syntax} syntax           Object with `parse` and `stringify`.
 * @property {object} map              Source map options.
 * @property {boolean} map.inline                    Does source map should
 *                                                   be embedded in the output
 *                                                   CSS as a base64-encoded
 *                                                   comment.
 * @property {string|object|false|function} map.prev Source map content
 *                                                   from a previous
 *                                                   processing step
 *                                                   (for example, Sass).
 *                                                   PostCSS will try to find
 *                                                   previous map automatically,
 *                                                   so you could disable it by
 *                                                   `false` value.
 * @property {boolean} map.sourcesContent            Does PostCSS should set
 *                                                   the origin content to map.
 * @property {string|false} map.annotation           Does PostCSS should set
 *                                                   annotation comment to map.
 * @property {string} map.from                       Override `from` in map’s
 *                                                   sources`.
 */

exports.default = _default;
module.exports = exports.default;
},{"./lazy-result":"node_modules/postcss/lib/lazy-result.js","process":"node_modules/process/browser.js"}],"node_modules/postcss/lib/vendor.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * Contains helpers for working with vendor prefixes.
 *
 * @example
 * const vendor = postcss.vendor
 *
 * @namespace vendor
 */

var vendor = {
  /**
   * Returns the vendor prefix extracted from an input string.
   *
   * @param {string} prop String with or without vendor prefix.
   *
   * @return {string} vendor prefix or empty string
   *
   * @example
   * postcss.vendor.prefix('-moz-tab-size') //=> '-moz-'
   * postcss.vendor.prefix('tab-size')      //=> ''
   */
  prefix: function prefix(prop) {
    var match = prop.match(/^(-\w+-)/);

    if (match) {
      return match[0];
    }

    return '';
  },

  /**
     * Returns the input string stripped of its vendor prefix.
     *
     * @param {string} prop String with or without vendor prefix.
     *
     * @return {string} String name without vendor prefixes.
     *
     * @example
     * postcss.vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
     */
  unprefixed: function unprefixed(prop) {
    return prop.replace(/^-\w+-/, '');
  }
};
var _default = vendor;
exports.default = _default;
module.exports = exports.default;
},{}],"node_modules/postcss/lib/postcss.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _declaration = _interopRequireDefault(require("./declaration"));

var _processor = _interopRequireDefault(require("./processor"));

var _stringify = _interopRequireDefault(require("./stringify"));

var _comment = _interopRequireDefault(require("./comment"));

var _atRule = _interopRequireDefault(require("./at-rule"));

var _vendor = _interopRequireDefault(require("./vendor"));

var _parse = _interopRequireDefault(require("./parse"));

var _list = _interopRequireDefault(require("./list"));

var _rule = _interopRequireDefault(require("./rule"));

var _root = _interopRequireDefault(require("./root"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Create a new {@link Processor} instance that will apply `plugins`
 * as CSS processors.
 *
 * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.
 *        See {@link Processor#use} for plugin format.
 *
 * @return {Processor} Processor to process multiple CSS.
 *
 * @example
 * import postcss from 'postcss'
 *
 * postcss(plugins).process(css, { from, to }).then(result => {
 *   console.log(result.css)
 * })
 *
 * @namespace postcss
 */


function postcss() {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }

  return new _processor.default(plugins);
}
/**
 * Creates a PostCSS plugin with a standard API.
 *
 * The newly-wrapped function will provide both the name and PostCSS
 * version of the plugin.
 *
 * ```js
 * const processor = postcss([replace])
 * processor.plugins[0].postcssPlugin  //=> 'postcss-replace'
 * processor.plugins[0].postcssVersion //=> '6.0.0'
 * ```
 *
 * The plugin function receives 2 arguments: {@link Root}
 * and {@link Result} instance. The function should mutate the provided
 * `Root` node. Alternatively, you can create a new `Root` node
 * and override the `result.root` property.
 *
 * ```js
 * const cleaner = postcss.plugin('postcss-cleaner', () => {
 *   return (root, result) => {
 *     result.root = postcss.root()
 *   }
 * })
 * ```
 *
 * As a convenience, plugins also expose a `process` method so that you can use
 * them as standalone tools.
 *
 * ```js
 * cleaner.process(css, processOpts, pluginOpts)
 * // This is equivalent to:
 * postcss([ cleaner(pluginOpts) ]).process(css, processOpts)
 * ```
 *
 * Asynchronous plugins should return a `Promise` instance.
 *
 * ```js
 * postcss.plugin('postcss-import', () => {
 *   return (root, result) => {
 *     return new Promise( (resolve, reject) => {
 *       fs.readFile('base.css', (base) => {
 *         root.prepend(base)
 *         resolve()
 *       })
 *     })
 *   }
 * })
 * ```
 *
 * Add warnings using the {@link Node#warn} method.
 * Send data to other plugins using the {@link Result#messages} array.
 *
 * ```js
 * postcss.plugin('postcss-caniuse-test', () => {
 *   return (root, result) => {
 *     root.walkDecls(decl => {
 *       if (!caniuse.support(decl.prop)) {
 *         decl.warn(result, 'Some browsers do not support ' + decl.prop)
 *       }
 *     })
 *   }
 * })
 * ```
 *
 * @param {string} name          PostCSS plugin name. Same as in `name`
 *                               property in `package.json`. It will be saved
 *                               in `plugin.postcssPlugin` property.
 * @param {function} initializer Will receive plugin options
 *                               and should return {@link pluginFunction}
 *
 * @return {Plugin} PostCSS plugin.
 */


postcss.plugin = function plugin(name, initializer) {
  function creator() {
    var transformer = initializer.apply(void 0, arguments);
    transformer.postcssPlugin = name;
    transformer.postcssVersion = new _processor.default().version;
    return transformer;
  }

  var cache;
  Object.defineProperty(creator, 'postcss', {
    get: function get() {
      if (!cache) cache = creator();
      return cache;
    }
  });

  creator.process = function (css, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css, processOpts);
  };

  return creator;
};
/**
 * Default function to convert a node tree into a CSS string.
 *
 * @param {Node} node       Start node for stringifing. Usually {@link Root}.
 * @param {builder} builder Function to concatenate CSS from node’s parts
 *                          or generate string and source map.
 *
 * @return {void}
 *
 * @function
 */


postcss.stringify = _stringify.default;
/**
 * Parses source css and returns a new {@link Root} node,
 * which contains the source CSS nodes.
 *
 * @param {string|toString} css   String with input CSS or any object
 *                                with toString() method, like a Buffer
 * @param {processOptions} [opts] Options with only `from` and `map` keys.
 *
 * @return {Root} PostCSS AST.
 *
 * @example
 * // Simple CSS concatenation with source map support
 * const root1 = postcss.parse(css1, { from: file1 })
 * const root2 = postcss.parse(css2, { from: file2 })
 * root1.append(root2).toResult().css
 *
 * @function
 */

postcss.parse = _parse.default;
/**
 * Contains the {@link vendor} module.
 *
 * @type {vendor}
 *
 * @example
 * postcss.vendor.unprefixed('-moz-tab') //=> ['tab']
 */

postcss.vendor = _vendor.default;
/**
 * Contains the {@link list} module.
 *
 * @member {list}
 *
 * @example
 * postcss.list.space('5px calc(10% + 5px)') //=> ['5px', 'calc(10% + 5px)']
 */

postcss.list = _list.default;
/**
 * Creates a new {@link Comment} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Comment} New comment node
 *
 * @example
 * postcss.comment({ text: 'test' })
 */

postcss.comment = function (defaults) {
  return new _comment.default(defaults);
};
/**
 * Creates a new {@link AtRule} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {AtRule} new at-rule node
 *
 * @example
 * postcss.atRule({ name: 'charset' }).toString() //=> "@charset"
 */


postcss.atRule = function (defaults) {
  return new _atRule.default(defaults);
};
/**
 * Creates a new {@link Declaration} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Declaration} new declaration node
 *
 * @example
 * postcss.decl({ prop: 'color', value: 'red' }).toString() //=> "color: red"
 */


postcss.decl = function (defaults) {
  return new _declaration.default(defaults);
};
/**
 * Creates a new {@link Rule} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Rule} new rule node
 *
 * @example
 * postcss.rule({ selector: 'a' }).toString() //=> "a {\n}"
 */


postcss.rule = function (defaults) {
  return new _rule.default(defaults);
};
/**
 * Creates a new {@link Root} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Root} new root node.
 *
 * @example
 * postcss.root({ after: '\n' }).toString() //=> "\n"
 */


postcss.root = function (defaults) {
  return new _root.default(defaults);
};

var _default = postcss;
exports.default = _default;
module.exports = exports.default;
},{"./declaration":"node_modules/postcss/lib/declaration.js","./processor":"node_modules/postcss/lib/processor.js","./stringify":"node_modules/postcss/lib/stringify.js","./comment":"node_modules/postcss/lib/comment.js","./at-rule":"node_modules/postcss/lib/at-rule.js","./vendor":"node_modules/postcss/lib/vendor.js","./parse":"node_modules/postcss/lib/parse.js","./list":"node_modules/postcss/lib/list.js","./rule":"node_modules/postcss/lib/rule.js","./root":"node_modules/postcss/lib/root.js"}],"node_modules/timsort/build/timsort.js":[function(require,module,exports) {
var define;
var global = arguments[3];
/****
 * The MIT License
 *
 * Copyright (c) 2015 Marco Ziccardi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 ****/
(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    define('timsort', ['exports'], factory);
  } else if (typeof exports !== 'undefined') {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.timsort = mod.exports;
  }
})(this, function (exports) {
  'use strict';

  exports.__esModule = true;
  exports.sort = sort;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }

  var DEFAULT_MIN_MERGE = 32;

  var DEFAULT_MIN_GALLOPING = 7;

  var DEFAULT_TMP_STORAGE_LENGTH = 256;

  var POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];

  function log10(x) {
    if (x < 1e5) {
      if (x < 1e2) {
        return x < 1e1 ? 0 : 1;
      }

      if (x < 1e4) {
        return x < 1e3 ? 2 : 3;
      }

      return 4;
    }

    if (x < 1e7) {
      return x < 1e6 ? 5 : 6;
    }

    if (x < 1e9) {
      return x < 1e8 ? 7 : 8;
    }

    return 9;
  }

  function alphabeticalCompare(a, b) {
    if (a === b) {
      return 0;
    }

    if (~ ~a === a && ~ ~b === b) {
      if (a === 0 || b === 0) {
        return a < b ? -1 : 1;
      }

      if (a < 0 || b < 0) {
        if (b >= 0) {
          return -1;
        }

        if (a >= 0) {
          return 1;
        }

        a = -a;
        b = -b;
      }

      var al = log10(a);
      var bl = log10(b);

      var t = 0;

      if (al < bl) {
        a *= POWERS_OF_TEN[bl - al - 1];
        b /= 10;
        t = -1;
      } else if (al > bl) {
        b *= POWERS_OF_TEN[al - bl - 1];
        a /= 10;
        t = 1;
      }

      if (a === b) {
        return t;
      }

      return a < b ? -1 : 1;
    }

    var aStr = String(a);
    var bStr = String(b);

    if (aStr === bStr) {
      return 0;
    }

    return aStr < bStr ? -1 : 1;
  }

  function minRunLength(n) {
    var r = 0;

    while (n >= DEFAULT_MIN_MERGE) {
      r |= n & 1;
      n >>= 1;
    }

    return n + r;
  }

  function makeAscendingRun(array, lo, hi, compare) {
    var runHi = lo + 1;

    if (runHi === hi) {
      return 1;
    }

    if (compare(array[runHi++], array[lo]) < 0) {
      while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
        runHi++;
      }

      reverseRun(array, lo, runHi);
    } else {
      while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
        runHi++;
      }
    }

    return runHi - lo;
  }

  function reverseRun(array, lo, hi) {
    hi--;

    while (lo < hi) {
      var t = array[lo];
      array[lo++] = array[hi];
      array[hi--] = t;
    }
  }

  function binaryInsertionSort(array, lo, hi, start, compare) {
    if (start === lo) {
      start++;
    }

    for (; start < hi; start++) {
      var pivot = array[start];

      var left = lo;
      var right = start;

      while (left < right) {
        var mid = left + right >>> 1;

        if (compare(pivot, array[mid]) < 0) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }

      var n = start - left;

      switch (n) {
        case 3:
          array[left + 3] = array[left + 2];

        case 2:
          array[left + 2] = array[left + 1];

        case 1:
          array[left + 1] = array[left];
          break;
        default:
          while (n > 0) {
            array[left + n] = array[left + n - 1];
            n--;
          }
      }

      array[left] = pivot;
    }
  }

  function gallopLeft(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;

    if (compare(value, array[start + hint]) > 0) {
      maxOffset = length - hint;

      while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      lastOffset += hint;
      offset += hint;
    } else {
      maxOffset = hint + 1;
      while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }

      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    }

    lastOffset++;
    while (lastOffset < offset) {
      var m = lastOffset + (offset - lastOffset >>> 1);

      if (compare(value, array[start + m]) > 0) {
        lastOffset = m + 1;
      } else {
        offset = m;
      }
    }
    return offset;
  }

  function gallopRight(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;

    if (compare(value, array[start + hint]) < 0) {
      maxOffset = hint + 1;

      while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    } else {
      maxOffset = length - hint;

      while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      lastOffset += hint;
      offset += hint;
    }

    lastOffset++;

    while (lastOffset < offset) {
      var m = lastOffset + (offset - lastOffset >>> 1);

      if (compare(value, array[start + m]) < 0) {
        offset = m;
      } else {
        lastOffset = m + 1;
      }
    }

    return offset;
  }

  var TimSort = (function () {
    function TimSort(array, compare) {
      _classCallCheck(this, TimSort);

      this.array = null;
      this.compare = null;
      this.minGallop = DEFAULT_MIN_GALLOPING;
      this.length = 0;
      this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
      this.stackLength = 0;
      this.runStart = null;
      this.runLength = null;
      this.stackSize = 0;

      this.array = array;
      this.compare = compare;

      this.length = array.length;

      if (this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
        this.tmpStorageLength = this.length >>> 1;
      }

      this.tmp = new Array(this.tmpStorageLength);

      this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;

      this.runStart = new Array(this.stackLength);
      this.runLength = new Array(this.stackLength);
    }

    TimSort.prototype.pushRun = function pushRun(runStart, runLength) {
      this.runStart[this.stackSize] = runStart;
      this.runLength[this.stackSize] = runLength;
      this.stackSize += 1;
    };

    TimSort.prototype.mergeRuns = function mergeRuns() {
      while (this.stackSize > 1) {
        var n = this.stackSize - 2;

        if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {

          if (this.runLength[n - 1] < this.runLength[n + 1]) {
            n--;
          }
        } else if (this.runLength[n] > this.runLength[n + 1]) {
          break;
        }
        this.mergeAt(n);
      }
    };

    TimSort.prototype.forceMergeRuns = function forceMergeRuns() {
      while (this.stackSize > 1) {
        var n = this.stackSize - 2;

        if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
          n--;
        }

        this.mergeAt(n);
      }
    };

    TimSort.prototype.mergeAt = function mergeAt(i) {
      var compare = this.compare;
      var array = this.array;

      var start1 = this.runStart[i];
      var length1 = this.runLength[i];
      var start2 = this.runStart[i + 1];
      var length2 = this.runLength[i + 1];

      this.runLength[i] = length1 + length2;

      if (i === this.stackSize - 3) {
        this.runStart[i + 1] = this.runStart[i + 2];
        this.runLength[i + 1] = this.runLength[i + 2];
      }

      this.stackSize--;

      var k = gallopRight(array[start2], array, start1, length1, 0, compare);
      start1 += k;
      length1 -= k;

      if (length1 === 0) {
        return;
      }

      length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

      if (length2 === 0) {
        return;
      }

      if (length1 <= length2) {
        this.mergeLow(start1, length1, start2, length2);
      } else {
        this.mergeHigh(start1, length1, start2, length2);
      }
    };

    TimSort.prototype.mergeLow = function mergeLow(start1, length1, start2, length2) {

      var compare = this.compare;
      var array = this.array;
      var tmp = this.tmp;
      var i = 0;

      for (i = 0; i < length1; i++) {
        tmp[i] = array[start1 + i];
      }

      var cursor1 = 0;
      var cursor2 = start2;
      var dest = start1;

      array[dest++] = array[cursor2++];

      if (--length2 === 0) {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
        return;
      }

      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
        }
        array[dest + length2] = tmp[cursor1];
        return;
      }

      var minGallop = this.minGallop;

      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;

        do {
          if (compare(array[cursor2], tmp[cursor1]) < 0) {
            array[dest++] = array[cursor2++];
            count2++;
            count1 = 0;

            if (--length2 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest++] = tmp[cursor1++];
            count1++;
            count2 = 0;
            if (--length1 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < minGallop);

        if (exit) {
          break;
        }

        do {
          count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

          if (count1 !== 0) {
            for (i = 0; i < count1; i++) {
              array[dest + i] = tmp[cursor1 + i];
            }

            dest += count1;
            cursor1 += count1;
            length1 -= count1;
            if (length1 <= 1) {
              exit = true;
              break;
            }
          }

          array[dest++] = array[cursor2++];

          if (--length2 === 0) {
            exit = true;
            break;
          }

          count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

          if (count2 !== 0) {
            for (i = 0; i < count2; i++) {
              array[dest + i] = array[cursor2 + i];
            }

            dest += count2;
            cursor2 += count2;
            length2 -= count2;

            if (length2 === 0) {
              exit = true;
              break;
            }
          }
          array[dest++] = tmp[cursor1++];

          if (--length1 === 1) {
            exit = true;
            break;
          }

          minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

        if (exit) {
          break;
        }

        if (minGallop < 0) {
          minGallop = 0;
        }

        minGallop += 2;
      }

      this.minGallop = minGallop;

      if (minGallop < 1) {
        this.minGallop = 1;
      }

      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
        }
        array[dest + length2] = tmp[cursor1];
      } else if (length1 === 0) {
        throw new Error('mergeLow preconditions were not respected');
      } else {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
      }
    };

    TimSort.prototype.mergeHigh = function mergeHigh(start1, length1, start2, length2) {
      var compare = this.compare;
      var array = this.array;
      var tmp = this.tmp;
      var i = 0;

      for (i = 0; i < length2; i++) {
        tmp[i] = array[start2 + i];
      }

      var cursor1 = start1 + length1 - 1;
      var cursor2 = length2 - 1;
      var dest = start2 + length2 - 1;
      var customCursor = 0;
      var customDest = 0;

      array[dest--] = array[cursor1--];

      if (--length1 === 0) {
        customCursor = dest - (length2 - 1);

        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i];
        }

        return;
      }

      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;

        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }

        array[dest] = tmp[cursor2];
        return;
      }

      var minGallop = this.minGallop;

      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;

        do {
          if (compare(tmp[cursor2], array[cursor1]) < 0) {
            array[dest--] = array[cursor1--];
            count1++;
            count2 = 0;
            if (--length1 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest--] = tmp[cursor2--];
            count2++;
            count1 = 0;
            if (--length2 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < minGallop);

        if (exit) {
          break;
        }

        do {
          count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

          if (count1 !== 0) {
            dest -= count1;
            cursor1 -= count1;
            length1 -= count1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;

            for (i = count1 - 1; i >= 0; i--) {
              array[customDest + i] = array[customCursor + i];
            }

            if (length1 === 0) {
              exit = true;
              break;
            }
          }

          array[dest--] = tmp[cursor2--];

          if (--length2 === 1) {
            exit = true;
            break;
          }

          count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

          if (count2 !== 0) {
            dest -= count2;
            cursor2 -= count2;
            length2 -= count2;
            customDest = dest + 1;
            customCursor = cursor2 + 1;

            for (i = 0; i < count2; i++) {
              array[customDest + i] = tmp[customCursor + i];
            }

            if (length2 <= 1) {
              exit = true;
              break;
            }
          }

          array[dest--] = array[cursor1--];

          if (--length1 === 0) {
            exit = true;
            break;
          }

          minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

        if (exit) {
          break;
        }

        if (minGallop < 0) {
          minGallop = 0;
        }

        minGallop += 2;
      }

      this.minGallop = minGallop;

      if (minGallop < 1) {
        this.minGallop = 1;
      }

      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;

        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }

        array[dest] = tmp[cursor2];
      } else if (length2 === 0) {
        throw new Error('mergeHigh preconditions were not respected');
      } else {
        customCursor = dest - (length2 - 1);
        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i];
        }
      }
    };

    return TimSort;
  })();

  function sort(array, compare, lo, hi) {
    if (!Array.isArray(array)) {
      throw new TypeError('Can only sort arrays');
    }

    if (!compare) {
      compare = alphabeticalCompare;
    } else if (typeof compare !== 'function') {
      hi = lo;
      lo = compare;
      compare = alphabeticalCompare;
    }

    if (!lo) {
      lo = 0;
    }
    if (!hi) {
      hi = array.length;
    }

    var remaining = hi - lo;

    if (remaining < 2) {
      return;
    }

    var runLength = 0;

    if (remaining < DEFAULT_MIN_MERGE) {
      runLength = makeAscendingRun(array, lo, hi, compare);
      binaryInsertionSort(array, lo, hi, lo + runLength, compare);
      return;
    }

    var ts = new TimSort(array, compare);

    var minRun = minRunLength(remaining);

    do {
      runLength = makeAscendingRun(array, lo, hi, compare);
      if (runLength < minRun) {
        var force = remaining;
        if (force > minRun) {
          force = minRun;
        }

        binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
        runLength = force;
      }

      ts.pushRun(lo, runLength);
      ts.mergeRuns();

      remaining -= runLength;
      lo += runLength;
    } while (remaining !== 0);

    ts.forceMergeRuns();
  }
});

},{}],"node_modules/timsort/index.js":[function(require,module,exports) {
module.exports = require('./build/timsort.js');
},{"./build/timsort.js":"node_modules/timsort/build/timsort.js"}],"node_modules/css-declaration-sorter/src/index.js":[function(require,module,exports) {
var __dirname = "/home/royyan/csspurge/node_modules/css-declaration-sorter/src";
'use strict';

const fs = require('fs');

const path = require('path');

const postcss = require('postcss');

const timsort = require('timsort').sort;

module.exports = postcss.plugin('css-declaration-sorter', function (options) {
  return function (css) {
    let sortOrderPath;
    options = options || {}; // Use included sorting order if order is passed and not alphabetically

    if (options.order && options.order !== 'alphabetically') {
      sortOrderPath = path.join(__dirname, '../orders/', options.order) + '.json';
    } else if (options.customOrder) {
      sortOrderPath = options.customOrder;
    } else {
      // Fallback to the default sorting order
      return processCss(css, 'alphabetically');
    } // Load in the array containing the order from a JSON file


    return new Promise(function (resolve, reject) {
      fs.readFile(sortOrderPath, function (error, data) {
        if (error) return reject(error);
        resolve(data);
      });
    }).then(function (data) {
      return processCss(css, JSON.parse(data));
    });
  };
});

function processCss(css, sortOrder) {
  const comments = [];
  const rulesCache = [];
  css.walk(function (node) {
    const nodes = node.nodes;
    const type = node.type;

    if (type === 'comment') {
      // Don't do anything to root comments or the last newline comment
      const isNewlineNode = ~node.raws.before.indexOf('\n');
      const lastNewlineNode = isNewlineNode && !node.next();
      const onlyNode = !node.prev() && !node.next();

      if (lastNewlineNode || onlyNode || node.parent.type === 'root') {
        return;
      }

      if (isNewlineNode) {
        const pairedNode = node.next() ? node.next() : node.prev().prev();

        if (pairedNode) {
          comments.unshift({
            'comment': node,
            'pairedNode': pairedNode,
            'insertPosition': node.next() ? 'Before' : 'After'
          });
          node.remove();
        }
      } else {
        const pairedNode = node.prev() ? node.prev() : node.next().next();

        if (pairedNode) {
          comments.push({
            'comment': node,
            'pairedNode': pairedNode,
            'insertPosition': 'After'
          });
          node.remove();
        }
      }

      return;
    } // Add rule-like nodes to a cache so that we can remove all
    // comment nodes before we start sorting.


    const isRule = type === 'rule' || type === 'atrule';

    if (isRule && nodes && nodes.length > 1) {
      rulesCache.push(nodes);
    }
  }); // Perform a sort once all comment nodes are removed

  rulesCache.forEach(function (nodes) {
    sortCssDecls(nodes, sortOrder);
  }); // Add comments back to the nodes they are paired with

  comments.forEach(function (node) {
    const pairedNode = node.pairedNode;
    node.comment.remove();
    pairedNode.parent['insert' + node.insertPosition](pairedNode, node.comment);
  });
} // Sort CSS declarations alphabetically or using the set sorting order


function sortCssDecls(cssDecls, sortOrder) {
  if (sortOrder === 'alphabetically') {
    timsort(cssDecls, function (a, b) {
      if (a.type === 'decl' && b.type === 'decl') {
        return comparator(a.prop, b.prop);
      } else {
        return compareDifferentType(a, b);
      }
    });
  } else {
    timsort(cssDecls, function (a, b) {
      if (a.type === 'decl' && b.type === 'decl') {
        const aIndex = sortOrder.indexOf(a.prop);
        const bIndex = sortOrder.indexOf(b.prop);
        return comparator(aIndex, bIndex);
      } else {
        return compareDifferentType(a, b);
      }
    });
  }
}

function comparator(a, b) {
  return a === b ? 0 : a < b ? -1 : 1;
}

function compareDifferentType(a, b) {
  if (b.type === 'atrule') {
    return 0;
  }

  return a.type === 'decl' ? -1 : b.type === 'decl' ? 1 : 0;
}
},{"fs":"node_modules/parcel-bundler/src/builtins/_empty.js","path":"node_modules/path-browserify/index.js","postcss":"node_modules/postcss/lib/postcss.js","timsort":"node_modules/timsort/index.js"}],"node_modules/postcss-discard-comments/dist/lib/commentRemover.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function CommentRemover(options) {
  this.options = options;
}

CommentRemover.prototype.canRemove = function (comment) {
  var remove = this.options.remove;

  if (remove) {
    return remove(comment);
  } else {
    var isImportant = comment.indexOf('!') === 0;

    if (!isImportant) {
      return true;
    }

    if (this.options.removeAll || this._hasFirst) {
      return true;
    } else if (this.options.removeAllButFirst && !this._hasFirst) {
      this._hasFirst = true;
      return false;
    }
  }
};

exports.default = CommentRemover;
module.exports = exports['default'];
},{}],"node_modules/postcss-discard-comments/dist/lib/commentParser.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = commentParser;

function commentParser(input) {
  var tokens = [];
  var length = input.length;
  var pos = 0;
  var next;

  while (pos < length) {
    next = input.indexOf('/*', pos);

    if (~next) {
      tokens.push([0, pos, next]);
      pos = next;
      next = input.indexOf('*/', pos + 2);
      tokens.push([1, pos + 2, next]);
      pos = next + 2;
    } else {
      tokens.push([0, pos, length]);
      pos = length;
    }
  }

  return tokens;
}

;
module.exports = exports['default'];
},{}],"node_modules/postcss-discard-comments/dist/index.js":[function(require,module,exports) {
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require("postcss");

var _commentRemover = require("./lib/commentRemover");

var _commentRemover2 = _interopRequireDefault(_commentRemover);

var _commentParser = require("./lib/commentParser");

var _commentParser2 = _interopRequireDefault(_commentParser);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var space = _postcss.list.space;
exports.default = (0, _postcss.plugin)("postcss-discard-comments", function () {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var remover = new _commentRemover2.default(opts);
  var matcherCache = {};
  var replacerCache = {};

  function matchesComments(source) {
    if (matcherCache[source]) {
      return matcherCache[source];
    }

    var result = (0, _commentParser2.default)(source).filter(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          type = _ref2[0];

      return type;
    });
    matcherCache[source] = result;
    return result;
  }

  function replaceComments(source) {
    var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : " ";
    var key = source + "@|@" + separator;

    if (replacerCache[key]) {
      return replacerCache[key];
    }

    var parsed = (0, _commentParser2.default)(source).reduce(function (value, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 3),
          type = _ref4[0],
          start = _ref4[1],
          end = _ref4[2];

      var contents = source.slice(start, end);

      if (!type) {
        return value + contents;
      }

      if (remover.canRemove(contents)) {
        return value + separator;
      }

      return "".concat(value, "/*").concat(contents, "*/");
    }, "");
    var result = space(parsed).join(" ");
    replacerCache[key] = result;
    return result;
  }

  return function (css) {
    css.walk(function (node) {
      if (node.type === "comment" && remover.canRemove(node.text)) {
        node.remove();
        return;
      }

      if (node.raws.between) {
        node.raws.between = replaceComments(node.raws.between);
      }

      if (node.type === "decl") {
        if (node.raws.value && node.raws.value.raw) {
          if (node.raws.value.value === node.value) {
            node.value = replaceComments(node.raws.value.raw);
          } else {
            node.value = replaceComments(node.value);
          }

          node.raws.value = null;
        }

        if (node.raws.important) {
          node.raws.important = replaceComments(node.raws.important);
          var b = matchesComments(node.raws.important);
          node.raws.important = b.length ? node.raws.important : "!important";
        }

        return;
      }

      if (node.type === "rule" && node.raws.selector && node.raws.selector.raw) {
        node.raws.selector.raw = replaceComments(node.raws.selector.raw, "");
        return;
      }

      if (node.type === "atrule") {
        if (node.raws.afterName) {
          var commentsReplaced = replaceComments(node.raws.afterName);

          if (!commentsReplaced.length) {
            node.raws.afterName = commentsReplaced + " ";
          } else {
            node.raws.afterName = " " + commentsReplaced + " ";
          }
        }

        if (node.raws.params && node.raws.params.raw) {
          node.raws.params.raw = replaceComments(node.raws.params.raw);
        }
      }
    });
  };
});
module.exports = exports["default"];
},{"postcss":"node_modules/postcss/lib/postcss.js","./lib/commentRemover":"node_modules/postcss-discard-comments/dist/lib/commentRemover.js","./lib/commentParser":"node_modules/postcss-discard-comments/dist/lib/commentParser.js"}],"node_modules/function-bind/implementation.js":[function(require,module,exports) {
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],"node_modules/function-bind/index.js":[function(require,module,exports) {
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":"node_modules/function-bind/implementation.js"}],"node_modules/has/src/index.js":[function(require,module,exports) {
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
},{"function-bind":"node_modules/function-bind/index.js"}],"node_modules/node-releases/data/processed/envs.json":[function(require,module,exports) {
module.exports = [
  {
    "name": "nodejs",
    "version": "0.2.0",
    "date": "2011-08-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.3.0",
    "date": "2011-08-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.4.0",
    "date": "2011-08-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.5.0",
    "date": "2011-08-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.6.0",
    "date": "2011-11-04",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.7.0",
    "date": "2012-01-17",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.8.0",
    "date": "2012-06-22",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.9.0",
    "date": "2012-07-20",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.10.0",
    "date": "2013-03-11",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.11.0",
    "date": "2013-03-28",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "0.12.0",
    "date": "2015-02-06",
    "lts": false,
    "security": false
  },
  {
    "name": "iojs",
    "version": "1.0.0",
    "date": "2015-01-14"
  },
  {
    "name": "iojs",
    "version": "1.1.0",
    "date": "2015-02-03"
  },
  {
    "name": "iojs",
    "version": "1.2.0",
    "date": "2015-02-11"
  },
  {
    "name": "iojs",
    "version": "1.3.0",
    "date": "2015-02-20"
  },
  {
    "name": "iojs",
    "version": "1.5.0",
    "date": "2015-03-06"
  },
  {
    "name": "iojs",
    "version": "1.6.0",
    "date": "2015-03-20"
  },
  {
    "name": "iojs",
    "version": "2.0.0",
    "date": "2015-05-04"
  },
  {
    "name": "iojs",
    "version": "2.1.0",
    "date": "2015-05-24"
  },
  {
    "name": "iojs",
    "version": "2.2.0",
    "date": "2015-06-01"
  },
  {
    "name": "iojs",
    "version": "2.3.0",
    "date": "2015-06-13"
  },
  {
    "name": "iojs",
    "version": "2.4.0",
    "date": "2015-07-17"
  },
  {
    "name": "iojs",
    "version": "2.5.0",
    "date": "2015-07-28"
  },
  {
    "name": "iojs",
    "version": "3.0.0",
    "date": "2015-08-04"
  },
  {
    "name": "iojs",
    "version": "3.1.0",
    "date": "2015-08-19"
  },
  {
    "name": "iojs",
    "version": "3.2.0",
    "date": "2015-08-25"
  },
  {
    "name": "iojs",
    "version": "3.3.0",
    "date": "2015-09-02"
  },
  {
    "name": "nodejs",
    "version": "4.0.0",
    "date": "2015-09-08",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.1.0",
    "date": "2015-09-17",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.2.0",
    "date": "2015-10-12",
    "lts": "Argon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.3.0",
    "date": "2016-02-09",
    "lts": "Argon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.4.0",
    "date": "2016-03-08",
    "lts": "Argon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.5.0",
    "date": "2016-08-16",
    "lts": "Argon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.6.0",
    "date": "2016-09-27",
    "lts": "Argon",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "4.7.0",
    "date": "2016-12-06",
    "lts": "Argon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.8.0",
    "date": "2017-02-21",
    "lts": "Argon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "4.9.0",
    "date": "2018-03-28",
    "lts": "Argon",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "5.0.0",
    "date": "2015-10-29",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.1.0",
    "date": "2015-11-17",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.2.0",
    "date": "2015-12-09",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.3.0",
    "date": "2015-12-15",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.4.0",
    "date": "2016-01-06",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.5.0",
    "date": "2016-01-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.6.0",
    "date": "2016-02-09",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.7.0",
    "date": "2016-02-23",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.8.0",
    "date": "2016-03-09",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.9.0",
    "date": "2016-03-16",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.10.0",
    "date": "2016-04-01",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.11.0",
    "date": "2016-04-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "5.12.0",
    "date": "2016-06-23",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.0.0",
    "date": "2016-04-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.1.0",
    "date": "2016-05-05",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.2.0",
    "date": "2016-05-17",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.3.0",
    "date": "2016-07-06",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.4.0",
    "date": "2016-08-12",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.5.0",
    "date": "2016-08-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.6.0",
    "date": "2016-09-14",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.7.0",
    "date": "2016-09-27",
    "lts": false,
    "security": true
  },
  {
    "name": "nodejs",
    "version": "6.8.0",
    "date": "2016-10-12",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.9.0",
    "date": "2016-10-18",
    "lts": "Boron",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.10.0",
    "date": "2017-02-21",
    "lts": "Boron",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.11.0",
    "date": "2017-06-06",
    "lts": "Boron",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.12.0",
    "date": "2017-11-06",
    "lts": "Boron",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.13.0",
    "date": "2018-02-10",
    "lts": "Boron",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.14.0",
    "date": "2018-03-28",
    "lts": "Boron",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "6.15.0",
    "date": "2018-11-27",
    "lts": "Boron",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "6.16.0",
    "date": "2018-12-26",
    "lts": "Boron",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "6.17.0",
    "date": "2019-02-28",
    "lts": "Boron",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "7.0.0",
    "date": "2016-10-25",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.1.0",
    "date": "2016-11-08",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.2.0",
    "date": "2016-11-22",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.3.0",
    "date": "2016-12-20",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.4.0",
    "date": "2017-01-04",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.5.0",
    "date": "2017-01-31",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.6.0",
    "date": "2017-02-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.7.0",
    "date": "2017-02-28",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.8.0",
    "date": "2017-03-29",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.9.0",
    "date": "2017-04-11",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "7.10.0",
    "date": "2017-05-02",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.0.0",
    "date": "2017-05-30",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.1.0",
    "date": "2017-06-08",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.2.0",
    "date": "2017-07-19",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.3.0",
    "date": "2017-08-08",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.4.0",
    "date": "2017-08-15",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.5.0",
    "date": "2017-09-12",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.6.0",
    "date": "2017-09-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.7.0",
    "date": "2017-10-11",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.8.0",
    "date": "2017-10-24",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.9.0",
    "date": "2017-10-31",
    "lts": "Carbon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.10.0",
    "date": "2018-03-06",
    "lts": "Carbon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.11.0",
    "date": "2018-03-28",
    "lts": "Carbon",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "8.12.0",
    "date": "2018-09-10",
    "lts": "Carbon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.13.0",
    "date": "2018-11-20",
    "lts": "Carbon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.14.0",
    "date": "2018-11-27",
    "lts": "Carbon",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "8.15.0",
    "date": "2018-12-26",
    "lts": "Carbon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.16.0",
    "date": "2019-04-16",
    "lts": "Carbon",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "8.17.0",
    "date": "2019-12-17",
    "lts": "Carbon",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "9.0.0",
    "date": "2017-10-31",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.1.0",
    "date": "2017-11-07",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.2.0",
    "date": "2017-11-14",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.3.0",
    "date": "2017-12-12",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.4.0",
    "date": "2018-01-10",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.5.0",
    "date": "2018-01-31",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.6.0",
    "date": "2018-02-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.7.0",
    "date": "2018-03-01",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.8.0",
    "date": "2018-03-07",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.9.0",
    "date": "2018-03-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "9.10.0",
    "date": "2018-03-28",
    "lts": false,
    "security": true
  },
  {
    "name": "nodejs",
    "version": "9.11.0",
    "date": "2018-04-04",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.0.0",
    "date": "2018-04-24",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.1.0",
    "date": "2018-05-08",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.2.0",
    "date": "2018-05-23",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.3.0",
    "date": "2018-05-29",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.4.0",
    "date": "2018-06-06",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.5.0",
    "date": "2018-06-20",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.6.0",
    "date": "2018-07-04",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.7.0",
    "date": "2018-07-18",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.8.0",
    "date": "2018-08-01",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.9.0",
    "date": "2018-08-15",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.10.0",
    "date": "2018-09-06",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.11.0",
    "date": "2018-09-19",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.12.0",
    "date": "2018-10-10",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.13.0",
    "date": "2018-10-30",
    "lts": "Dubnium",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.14.0",
    "date": "2018-11-27",
    "lts": "Dubnium",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "10.15.0",
    "date": "2018-12-26",
    "lts": "Dubnium",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.16.0",
    "date": "2019-05-28",
    "lts": "Dubnium",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.17.0",
    "date": "2019-10-21",
    "lts": "Dubnium",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "10.18.0",
    "date": "2019-12-16",
    "lts": "Dubnium",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "10.19.0",
    "date": "2020-02-05",
    "lts": "Dubnium",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "10.20.0",
    "date": "2020-03-24",
    "lts": "Dubnium",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.0.0",
    "date": "2018-10-23",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.1.0",
    "date": "2018-10-30",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.2.0",
    "date": "2018-11-15",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.3.0",
    "date": "2018-11-27",
    "lts": false,
    "security": true
  },
  {
    "name": "nodejs",
    "version": "11.4.0",
    "date": "2018-12-07",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.5.0",
    "date": "2018-12-18",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.6.0",
    "date": "2018-12-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.7.0",
    "date": "2019-01-17",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.8.0",
    "date": "2019-01-24",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.9.0",
    "date": "2019-01-30",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.10.0",
    "date": "2019-02-14",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.11.0",
    "date": "2019-03-05",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.12.0",
    "date": "2019-03-14",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.13.0",
    "date": "2019-03-28",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.14.0",
    "date": "2019-04-10",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "11.15.0",
    "date": "2019-04-30",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.0.0",
    "date": "2019-04-23",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.1.0",
    "date": "2019-04-29",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.2.0",
    "date": "2019-05-07",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.3.0",
    "date": "2019-05-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.4.0",
    "date": "2019-06-04",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.5.0",
    "date": "2019-06-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.6.0",
    "date": "2019-07-03",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.7.0",
    "date": "2019-07-23",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.8.0",
    "date": "2019-08-06",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.9.0",
    "date": "2019-08-20",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.10.0",
    "date": "2019-09-04",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.11.0",
    "date": "2019-09-25",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.12.0",
    "date": "2019-10-11",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.13.0",
    "date": "2019-10-21",
    "lts": "Erbium",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.14.0",
    "date": "2019-12-16",
    "lts": "Erbium",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "12.15.0",
    "date": "2020-02-05",
    "lts": "Erbium",
    "security": true
  },
  {
    "name": "nodejs",
    "version": "12.16.0",
    "date": "2020-02-11",
    "lts": "Erbium",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "12.17.0",
    "date": "2020-05-26",
    "lts": "Erbium",
    "security": false
  },
  {
    "name": "nodejs",
    "version": "13.0.0",
    "date": "2019-10-10",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "13.1.0",
    "date": "2019-11-05",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "13.2.0",
    "date": "2019-11-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "13.3.0",
    "date": "2019-12-03",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "13.4.0",
    "date": "2019-12-17",
    "lts": false,
    "security": true
  },
  {
    "name": "nodejs",
    "version": "13.5.0",
    "date": "2019-12-18",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "13.6.0",
    "date": "2020-01-07",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "13.7.0",
    "date": "2020-01-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "13.8.0",
    "date": "2020-02-05",
    "lts": false,
    "security": true
  },
  {
    "name": "nodejs",
    "version": "13.9.0",
    "date": "2020-02-18",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "13.10.0",
    "date": "2020-03-03",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "13.11.0",
    "date": "2020-03-12",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "13.12.0",
    "date": "2020-03-26",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "13.13.0",
    "date": "2020-04-14",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "13.14.0",
    "date": "2020-04-28",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "14.0.0",
    "date": "2020-04-21",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "14.1.0",
    "date": "2020-04-29",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "14.2.0",
    "date": "2020-05-05",
    "lts": false,
    "security": false
  },
  {
    "name": "nodejs",
    "version": "14.3.0",
    "date": "2020-05-19",
    "lts": false,
    "security": false
  }
];
},{}],"node_modules/caniuse-lite/data/browsers.js":[function(require,module,exports) {
module.exports={A:"ie",B:"edge",C:"firefox",D:"chrome",E:"safari",F:"opera",G:"ios_saf",H:"op_mini",I:"android",J:"bb",K:"op_mob",L:"and_chr",M:"and_ff",N:"ie_mob",O:"and_uc",P:"samsung",Q:"and_qq",R:"baidu",S:"kaios"};

},{}],"node_modules/caniuse-lite/dist/unpacker/browsers.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var browsers = exports.browsers = require('../../data/browsers');
},{"../../data/browsers":"node_modules/caniuse-lite/data/browsers.js"}],"node_modules/caniuse-lite/data/browserVersions.js":[function(require,module,exports) {
module.exports={"0":"50","1":"51","2":"52","3":"53","4":"54","5":"55","6":"56","7":"57","8":"58","9":"65",A:"10",B:"11",C:"12",D:"9",E:"8",F:"7",G:"4",H:"16",I:"6",J:"17",K:"18",L:"11.1",M:"68",N:"81",O:"13",P:"15",Q:"46",R:"67",S:"12.1",T:"14",U:"5",V:"19",W:"20",X:"21",Y:"22",Z:"23",a:"24",b:"25",c:"26",d:"27",e:"28",f:"29",g:"30",h:"31",i:"32",j:"33",k:"34",l:"35",m:"36",n:"37",o:"38",p:"39",q:"40",r:"41",s:"42",t:"43",u:"44",v:"45",w:"66",x:"47",y:"48",z:"49",AB:"60",BB:"64",CB:"62",DB:"63",EB:"11.5",FB:"61",GB:"3",HB:"4.2-4.3",IB:"80",JB:"69",KB:"70",LB:"71",MB:"72",NB:"73",OB:"74",PB:"75",QB:"76",RB:"77",SB:"78",TB:"59",UB:"79",VB:"10.1",WB:"3.2",XB:"10.0-10.2",YB:"85",ZB:"84",aB:"5.1",bB:"6.1",cB:"7.1",dB:"9.1",eB:"83",fB:"3.6",gB:"5.5",hB:"13.1",iB:"TP",jB:"9.5-9.6",kB:"10.0-10.1",lB:"10.5",mB:"10.6",nB:"3.5",oB:"11.6",pB:"4.0-4.1",qB:"2",rB:"5.0-5.1",sB:"6.0-6.1",tB:"7.0-7.1",uB:"8.1-8.4",vB:"9.0-9.2",wB:"9.3",xB:"3.1",yB:"10.3",zB:"11.0-11.2","0B":"11.3-11.4","1B":"12.0-12.1","2B":"12.2-12.4","3B":"13.0-13.1","4B":"13.2","5B":"13.3","6B":"13.4","7B":"all","8B":"2.1","9B":"2.2",AC:"2.3",BC:"4.1",CC:"4.4",DC:"4.4.3-4.4.4",EC:"12.12",FC:"5.0-5.4",GC:"6.2-6.4",HC:"7.2-7.4",IC:"8.2",JC:"9.2",KC:"10.4",LC:"7.12",MC:"2.5"};

},{}],"node_modules/caniuse-lite/dist/unpacker/browserVersions.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var browserVersions = exports.browserVersions = require('../../data/browserVersions');
},{"../../data/browserVersions":"node_modules/caniuse-lite/data/browserVersions.js"}],"node_modules/caniuse-lite/data/agents.js":[function(require,module,exports) {
module.exports={A:{A:{I:0.00545889,F:0.0108864,E:0.0873422,D:0.218356,A:0.0272944,B:1.43023,gB:0.009298},B:"ms",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","gB","I","F","E","D","A","B","","",""],E:"IE",F:{gB:962323200,I:998870400,F:1161129600,E:1237420800,D:1300060800,A:1346716800,B:1381968000}},B:{A:{C:0.00867,O:0.00867,T:0.013005,P:0.013005,H:0.030345,J:0.09537,K:2.00277,UB:0,IB:0,N:0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","C","O","T","P","H","J","K","UB","IB","N","","",""],E:"Edge",F:{C:1438128000,O:1447286400,T:1470096000,P:1491868800,H:1508198400,J:1525046400,K:1542067200,UB:1579046400,IB:1581033600,N:1586736000},D:{C:"ms",O:"ms",T:"ms",P:"ms",H:"ms",J:"ms",K:"ms"}},C:{A:{"0":0.00867,"1":0.004335,"2":0.11271,"3":0.004335,"4":0.013005,"5":0.00867,"6":0.021675,"7":0.00867,"8":0.013005,"9":0.021675,qB:0.004827,GB:0.004538,G:0.00974,U:0.004879,I:0.020136,F:0.005725,E:0.004525,D:0.00533,A:0.004283,B:0.009042,C:0.004471,O:0.004486,T:0.00453,P:0.004465,H:0.004417,J:0.008922,K:0.004393,V:0.004443,W:0.004283,X:0.013596,Y:0.013698,Z:0.013614,a:0.008786,b:0.004403,c:0.004317,d:0.004393,e:0.004418,f:0.008834,g:0.004403,h:0.008928,i:0.004471,j:0.021675,k:0.004707,l:0.009076,m:0.004465,n:0.004783,o:0.00867,p:0.004783,q:0.00487,r:0.005029,s:0.0047,t:0.01734,u:0.004335,v:0.00867,Q:0.004525,x:0.013005,y:0.021675,z:0.004538,TB:0.00867,AB:0.021675,FB:0.004335,CB:0.004335,DB:0.021675,BB:0.01734,w:0.01734,R:0.013005,M:0.108375,JB:0.013005,KB:0.01734,LB:0.01734,MB:0.06069,NB:0.04335,OB:1.16178,PB:2.01577,QB:0.039015,RB:0,SB:0,nB:0.008786,fB:0.00487},B:"moz",C:["","qB","GB","nB","fB","G","U","I","F","E","D","A","B","C","O","T","P","H","J","K","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","Q","x","y","z","0","1","2","3","4","5","6","7","8","TB","AB","FB","CB","DB","BB","9","w","R","M","JB","KB","LB","MB","NB","OB","PB","QB","RB","SB",""],E:"Firefox",F:{"0":1479168000,"1":1485216000,"2":1488844800,"3":1492560000,"4":1497312000,"5":1502150400,"6":1506556800,"7":1510617600,"8":1516665600,"9":1548720000,qB:1161648000,GB:1213660800,nB:1246320000,fB:1264032000,G:1300752000,U:1308614400,I:1313452800,F:1317081600,E:1317081600,D:1320710400,A:1324339200,B:1327968000,C:1331596800,O:1335225600,T:1338854400,P:1342483200,H:1346112000,J:1349740800,K:1353628800,V:1357603200,W:1361232000,X:1364860800,Y:1368489600,Z:1372118400,a:1375747200,b:1379376000,c:1386633600,d:1391472000,e:1395100800,f:1398729600,g:1402358400,h:1405987200,i:1409616000,j:1413244800,k:1417392000,l:1421107200,m:1424736000,n:1428278400,o:1431475200,p:1435881600,q:1439251200,r:1442880000,s:1446508800,t:1450137600,u:1453852800,v:1457395200,Q:1461628800,x:1465257600,y:1470096000,z:1474329600,TB:1520985600,AB:1525824000,FB:1529971200,CB:1536105600,DB:1540252800,BB:1544486400,w:1552953600,R:1558396800,M:1562630400,JB:1567468800,KB:1571788800,LB:1575331200,MB:1578355200,NB:1581379200,OB:1583798400,PB:1586304000,QB:1588636800,RB:null,SB:null}},D:{A:{"0":0.004335,"1":0.00867,"2":0.004403,"3":0.039015,"4":0.013005,"5":0.01734,"6":0.02601,"7":0.021675,"8":0.021675,"9":0.04335,G:0.004706,U:0.004879,I:0.004879,F:0.005591,E:0.005591,D:0.005591,A:0.004534,B:0.004464,C:0.010424,O:0.00867,T:0.004706,P:0.015087,H:0.004393,J:0.004393,K:0.008652,V:0.004418,W:0.004393,X:0.004317,Y:0.004335,Z:0.008786,a:0.004538,b:0.004461,c:0.004335,d:0.004326,e:0.0047,f:0.004538,g:0.004335,h:0.00867,i:0.004566,j:0.00867,k:0.00867,l:0.004335,m:0.004335,n:0.004464,o:0.02601,p:0.004464,q:0.01734,r:0.021675,s:0.004403,t:0.013005,u:0.004465,v:0.00867,Q:0.004538,x:0.013005,y:0.030345,z:0.35547,TB:0.013005,AB:0.01734,FB:0.02601,CB:0.01734,DB:0.056355,BB:0.01734,w:0.02601,R:0.05202,M:0.02601,JB:0.0867,KB:0.11271,LB:0.143055,MB:0.15606,NB:0.134385,OB:0.12138,PB:0.13005,QB:0.143055,RB:0.117045,SB:0.19941,UB:0.39015,IB:16.8978,N:8.70901,eB:0.02601,ZB:0.01734,YB:0},B:"webkit",C:["G","U","I","F","E","D","A","B","C","O","T","P","H","J","K","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","Q","x","y","z","0","1","2","3","4","5","6","7","8","TB","AB","FB","CB","DB","BB","9","w","R","M","JB","KB","LB","MB","NB","OB","PB","QB","RB","SB","UB","IB","N","eB","ZB","YB"],E:"Chrome",F:{"0":1460592000,"1":1464134400,"2":1469059200,"3":1472601600,"4":1476230400,"5":1480550400,"6":1485302400,"7":1489017600,"8":1492560000,"9":1520294400,G:1264377600,U:1274745600,I:1283385600,F:1287619200,E:1291248000,D:1296777600,A:1299542400,B:1303862400,C:1307404800,O:1312243200,T:1316131200,P:1316131200,H:1319500800,J:1323734400,K:1328659200,V:1332892800,W:1337040000,X:1340668800,Y:1343692800,Z:1348531200,a:1352246400,b:1357862400,c:1361404800,d:1364428800,e:1369094400,f:1374105600,g:1376956800,h:1384214400,i:1389657600,j:1392940800,k:1397001600,l:1400544000,m:1405468800,n:1409011200,o:1412640000,p:1416268800,q:1421798400,r:1425513600,s:1429401600,t:1432080000,u:1437523200,v:1441152000,Q:1444780800,x:1449014400,y:1453248000,z:1456963200,TB:1496707200,AB:1500940800,FB:1504569600,CB:1508198400,DB:1512518400,BB:1516752000,w:1523923200,R:1527552000,M:1532390400,JB:1536019200,KB:1539648000,LB:1543968000,MB:1548720000,NB:1552348800,OB:1555977600,PB:1559606400,QB:1564444800,RB:1568073600,SB:1571702400,UB:1575936000,IB:1580860800,N:1586304000,eB:null,ZB:null,YB:null}},E:{A:{G:0,U:0.004566,I:0.00867,F:0.004465,E:0.021675,D:0.00867,A:0.013005,B:0.030345,C:0.0867,O:2.04179,xB:0,WB:0.008692,aB:0.099705,bB:0.00456,cB:0.004283,dB:0.04335,VB:0.082365,L:0.169065,S:0.316455,hB:1.24848,iB:0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","xB","WB","G","U","aB","I","bB","F","cB","E","D","dB","A","VB","B","L","C","S","O","hB","iB","",""],E:"Safari",F:{xB:1205798400,WB:1226534400,G:1244419200,U:1275868800,aB:1311120000,I:1343174400,bB:1382400000,F:1382400000,cB:1410998400,E:1413417600,D:1443657600,dB:1458518400,A:1474329600,VB:1490572800,B:1505779200,L:1522281600,C:1537142400,S:1553472000,O:1568851200,hB:1585008000,iB:null}},F:{A:{"0":0.004707,"1":0.004707,"2":0.004326,"3":0.008922,"4":0.014349,"5":0.004725,"6":0.004335,"7":0.004335,"8":0.00867,"9":0.00867,D:0.0082,B:0.016581,C:0.004317,P:0.00685,H:0.00685,J:0.00685,K:0.005014,V:0.006015,W:0.004879,X:0.006597,Y:0.006597,Z:0.013434,a:0.006702,b:0.006015,c:0.005595,d:0.004393,e:0.008652,f:0.004879,g:0.004879,h:0.009132,i:0.005152,j:0.005014,k:0.009758,l:0.004879,m:0.00867,n:0.004283,o:0.004367,p:0.004534,q:0.004367,r:0.004227,s:0.004418,t:0.009042,u:0.004227,v:0.004725,Q:0.004417,x:0.008942,y:0.004707,z:0.004827,AB:0.004403,CB:0.004532,DB:0.004566,BB:0.02283,w:0.013005,R:0.906015,M:0.01734,jB:0.00685,kB:0,lB:0.008392,mB:0.004706,L:0.006229,EB:0.004879,oB:0.008786,S:0.004335},B:"webkit",C:["","","","","","","","","","","","","","","","D","jB","kB","lB","mB","B","L","EB","oB","C","S","P","H","J","K","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","Q","x","y","z","0","1","2","3","4","5","6","7","8","AB","CB","DB","BB","9","w","R","M","","",""],E:"Opera",F:{"0":1515024000,"1":1517961600,"2":1521676800,"3":1525910400,"4":1530144000,"5":1534982400,"6":1537833600,"7":1543363200,"8":1548201600,"9":1573689600,D:1150761600,jB:1223424000,kB:1251763200,lB:1267488000,mB:1277942400,B:1292457600,L:1302566400,EB:1309219200,oB:1323129600,C:1323129600,S:1352073600,P:1372723200,H:1377561600,J:1381104000,K:1386288000,V:1390867200,W:1393891200,X:1399334400,Y:1401753600,Z:1405987200,a:1409616000,b:1413331200,c:1417132800,d:1422316800,e:1425945600,f:1430179200,g:1433808000,h:1438646400,i:1442448000,j:1445904000,k:1449100800,l:1454371200,m:1457308800,n:1462320000,o:1465344000,p:1470096000,q:1474329600,r:1477267200,s:1481587200,t:1486425600,u:1490054400,v:1494374400,Q:1498003200,x:1502236800,y:1506470400,z:1510099200,AB:1554768000,CB:1561593600,DB:1566259200,BB:1570406400,w:1578441600,R:1583971200,M:1587513600},D:{D:"o",B:"o",C:"o",jB:"o",kB:"o",lB:"o",mB:"o",L:"o",EB:"o",oB:"o",S:"o"}},G:{A:{E:0.00150429,WB:0.00150429,pB:0,HB:0.00300858,rB:0.0150429,sB:0.00451286,tB:0.0150429,uB:0.02106,vB:0.0180515,wB:0.216617,XB:0.0556587,yB:0.191045,zB:0.123352,"0B":0.209096,"1B":0.258738,"2B":1.69533,"3B":0.361029,"4B":0.176002,"5B":9.85609,"6B":1.82621},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","WB","pB","HB","rB","sB","tB","E","uB","vB","wB","XB","yB","zB","0B","1B","2B","3B","4B","5B","6B","","",""],E:"iOS Safari",F:{WB:1270252800,pB:1283904000,HB:1299628800,rB:1331078400,sB:1359331200,tB:1394409600,E:1410912000,uB:1413763200,vB:1442361600,wB:1458518400,XB:1473724800,yB:1490572800,zB:1505779200,"0B":1522281600,"1B":1537142400,"2B":1553472000,"3B":1568851200,"4B":1572220800,"5B":1580169600,"6B":1585008000}},H:{A:{"7B":0.691982},B:"o",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","7B","","",""],E:"Opera Mini",F:{"7B":1426464000}},I:{A:{GB:0.000620932,G:0.00558838,N:0,"8B":0,"9B":0.00186279,AC:0.000620932,BC:0.0124186,HB:0.0260791,CC:0,DC:0.179449},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","8B","9B","AC","GB","G","BC","HB","CC","DC","N","","",""],E:"Android Browser",F:{"8B":1256515200,"9B":1274313600,AC:1291593600,GB:1298332800,G:1318896000,BC:1341792000,HB:1374624000,CC:1386547200,DC:1401667200,N:1587427200}},J:{A:{F:0,A:0.005666},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","F","A","","",""],E:"Blackberry Browser",F:{F:1325376000,A:1359504000}},K:{A:{A:0,B:0,C:0,Q:0.0111391,L:0,EB:0,S:0},B:"o",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","A","B","L","EB","C","S","Q","","",""],E:"Opera Mobile",F:{A:1287100800,B:1300752000,L:1314835200,EB:1318291200,C:1330300800,S:1349740800,Q:1474588800},D:{Q:"webkit"}},L:{A:{N:34.7979},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","N","","",""],E:"Chrome for Android",F:{N:1587427200}},M:{A:{M:0.22664},B:"moz",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","M","","",""],E:"Firefox for Android",F:{M:1567468800}},N:{A:{A:0.0115934,B:0.022664},B:"ms",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","A","B","","",""],E:"IE Mobile",F:{A:1340150400,B:1353456000}},O:{A:{EC:1.97743},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","EC","","",""],E:"UC Browser for Android",F:{EC:1471392000},D:{EC:"webkit"}},P:{A:{G:0.268735,FC:0.010336,GC:0.010336,HC:0.0930236,IC:0.0310079,JC:0.196383,VB:0.330751,L:2.64601},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","G","FC","GC","HC","IC","JC","VB","L","","",""],E:"Samsung Internet",F:{G:1461024000,FC:1481846400,GC:1509408000,HC:1528329600,IC:1546128000,JC:1554163200,VB:1567900800,L:1582588800}},Q:{A:{KC:0.215308},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","KC","","",""],E:"QQ Browser",F:{KC:1589846400}},R:{A:{LC:0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","LC","","",""],E:"Baidu Browser",F:{LC:1491004800}},S:{A:{MC:0.067992},B:"moz",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","MC","","",""],E:"KaiOS Browser",F:{MC:1527811200}}};

},{}],"node_modules/caniuse-lite/dist/unpacker/agents.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.agents = undefined;

var _browsers = require('./browsers');

var _browserVersions = require('./browserVersions');

var agentsData = require('../../data/agents');

function unpackBrowserVersions(versionsData) {
    return Object.keys(versionsData).reduce(function (usage, version) {
        usage[_browserVersions.browserVersions[version]] = versionsData[version];
        return usage;
    }, {});
}

var agents = exports.agents = Object.keys(agentsData).reduce(function (map, key) {
    var versionsData = agentsData[key];
    map[_browsers.browsers[key]] = Object.keys(versionsData).reduce(function (data, entry) {
        if (entry === 'A') {
            data.usage_global = unpackBrowserVersions(versionsData[entry]);
        } else if (entry === 'C') {
            data.versions = versionsData[entry].reduce(function (list, version) {
                if (version === '') {
                    list.push(null);
                } else {
                    list.push(_browserVersions.browserVersions[version]);
                }
                return list;
            }, []);
        } else if (entry === 'D') {
            data.prefix_exceptions = unpackBrowserVersions(versionsData[entry]);
        } else if (entry === 'E') {
            data.browser = versionsData[entry];
        } else if (entry === 'F') {
            data.release_date = Object.keys(versionsData[entry]).reduce(function (map, key) {
                map[_browserVersions.browserVersions[key]] = versionsData[entry][key];
                return map;
            }, {});
        } else {
            // entry is B
            data.prefix = versionsData[entry];
        }
        return data;
    }, {});
    return map;
}, {});
},{"./browsers":"node_modules/caniuse-lite/dist/unpacker/browsers.js","./browserVersions":"node_modules/caniuse-lite/dist/unpacker/browserVersions.js","../../data/agents":"node_modules/caniuse-lite/data/agents.js"}],"node_modules/node-releases/data/release-schedule/release-schedule.json":[function(require,module,exports) {
module.exports = {
  "v0.10": {
    "start": "2013-03-11",
    "end": "2016-10-31"
  },
  "v0.12": {
    "start": "2015-02-06",
    "end": "2016-12-31"
  },
  "v4": {
    "start": "2015-09-08",
    "lts": "2015-10-12",
    "maintenance": "2017-04-01",
    "end": "2018-04-30",
    "codename": "Argon"
  },
  "v5": {
    "start": "2015-10-29",
    "maintenance": "2016-04-30",
    "end": "2016-06-30"
  },
  "v6": {
    "start": "2016-04-26",
    "lts": "2016-10-18",
    "maintenance": "2018-04-30",
    "end": "2019-04-30",
    "codename": "Boron"
  },
  "v7": {
    "start": "2016-10-25",
    "maintenance": "2017-04-30",
    "end": "2017-06-30"
  },
  "v8": {
    "start": "2017-05-30",
    "lts": "2017-10-31",
    "maintenance": "2019-01-01",
    "end": "2019-12-31",
    "codename": "Carbon"
  },
  "v9": {
    "start": "2017-10-01",
    "maintenance": "2018-04-01",
    "end": "2018-06-30"
  },
  "v10": {
    "start": "2018-04-24",
    "lts": "2018-10-30",
    "maintenance": "2020-05-19",
    "end": "2021-04-30",
    "codename": "Dubnium"
  },
  "v11": {
    "start": "2018-10-23",
    "maintenance": "2019-04-22",
    "end": "2019-06-01"
  },
  "v12": {
    "start": "2019-04-23",
    "lts": "2019-10-21",
    "maintenance": "2020-10-20",
    "end": "2022-04-30",
    "codename": "Erbium"
  },
  "v13": {
    "start": "2019-10-22",
    "maintenance": "2020-04-01",
    "end": "2020-06-01"
  },
  "v14": {
    "start": "2020-04-21",
    "lts": "2020-10-20",
    "maintenance": "2021-10-19",
    "end": "2023-04-30",
    "codename": ""
  },
  "v15": {
    "start": "2020-10-21",
    "maintenance": "2021-04-01",
    "end": "2021-06-01"
  }
}
;
},{}],"node_modules/electron-to-chromium/versions.js":[function(require,module,exports) {
module.exports = {
	"10.0": "84",
	"9.0": "82",
	"8.3": "80",
	"8.2": "80",
	"8.1": "80",
	"8.0": "79",
	"7.3": "78",
	"7.2": "78",
	"7.1": "78",
	"7.0": "78",
	"6.1": "76",
	"6.0": "76",
	"5.0": "72",
	"4.2": "69",
	"4.1": "69",
	"4.0": "69",
	"3.1": "66",
	"3.0": "66",
	"2.1": "61",
	"2.0": "61",
	"1.8": "59",
	"1.7": "58",
	"1.6": "56",
	"1.5": "54",
	"1.4": "53",
	"1.3": "52",
	"1.2": "51",
	"1.1": "50",
	"1.0": "49",
	"0.37": "49",
	"0.36": "47",
	"0.35": "45",
	"0.34": "45",
	"0.33": "45",
	"0.32": "45",
	"0.31": "44",
	"0.30": "44",
	"0.29": "43",
	"0.28": "43",
	"0.27": "42",
	"0.26": "42",
	"0.25": "42",
	"0.24": "41",
	"0.23": "41",
	"0.22": "41",
	"0.21": "40",
	"0.20": "39"
};
},{}],"node_modules/browserslist/error.js":[function(require,module,exports) {
function BrowserslistError (message) {
  this.name = 'BrowserslistError'
  this.message = message
  this.browserslist = true
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, BrowserslistError)
  }
}

BrowserslistError.prototype = Error.prototype

module.exports = BrowserslistError

},{}],"node_modules/browserslist/browser.js":[function(require,module,exports) {
var BrowserslistError = require('./error')

function noop () { }

module.exports = {
  loadQueries: function loadQueries () {
    throw new BrowserslistError(
      'Sharable configs are not supported in client-side build of Browserslist')
  },

  getStat: function getStat (opts) {
    return opts.stats
  },

  loadConfig: function loadConfig (opts) {
    if (opts.config) {
      throw new BrowserslistError(
        'Browserslist config are not supported in client-side build')
    }
  },

  loadCountry: function loadCountry () {
    throw new BrowserslistError(
      'Country statistics is not supported ' +
      'in client-side build of Browserslist')
  },

  currentNode: function currentNode (resolve, context) {
    return resolve(['maintained node versions'], context)[0]
  },

  parseConfig: noop,

  readConfig: noop,

  findConfig: noop,

  clearCaches: noop,

  oldDataWarning: noop
}

},{"./error":"node_modules/browserslist/error.js"}],"node_modules/browserslist/index.js":[function(require,module,exports) {
var jsReleases = require('node-releases/data/processed/envs.json');

var agents = require('caniuse-lite/dist/unpacker/agents').agents;

var jsEOL = require('node-releases/data/release-schedule/release-schedule.json');

var path = require('path');

var e2c = require('electron-to-chromium/versions');

var BrowserslistError = require('./error');

var env = require('./node'); // Will load browser.js in webpack


var YEAR = 365.259641 * 24 * 60 * 60 * 1000;
var ANDROID_EVERGREEN_FIRST = 37;
var QUERY_OR = 1;
var QUERY_AND = 2;

function isVersionsMatch(versionA, versionB) {
  return (versionA + '.').indexOf(versionB + '.') === 0;
}

function isEolReleased(name) {
  var version = name.slice(1);
  return jsReleases.some(function (i) {
    return isVersionsMatch(i.version, version);
  });
}

function normalize(versions) {
  return versions.filter(function (version) {
    return typeof version === 'string';
  });
}

function normalizeElectron(version) {
  var versionToUse = version;

  if (version.split('.').length === 3) {
    versionToUse = version.split('.').slice(0, -1).join('.');
  }

  return versionToUse;
}

function nameMapper(name) {
  return function mapName(version) {
    return name + ' ' + version;
  };
}

function getMajor(version) {
  return parseInt(version.split('.')[0]);
}

function getMajorVersions(released, number) {
  if (released.length === 0) return [];
  var majorVersions = uniq(released.map(getMajor));
  var minimum = majorVersions[majorVersions.length - number];

  if (!minimum) {
    return released;
  }

  var selected = [];

  for (var i = released.length - 1; i >= 0; i--) {
    if (minimum > getMajor(released[i])) break;
    selected.unshift(released[i]);
  }

  return selected;
}

function uniq(array) {
  var filtered = [];

  for (var i = 0; i < array.length; i++) {
    if (filtered.indexOf(array[i]) === -1) filtered.push(array[i]);
  }

  return filtered;
} // Helpers


function fillUsage(result, name, data) {
  for (var i in data) {
    result[name + ' ' + i] = data[i];
  }
}

function generateFilter(sign, version) {
  version = parseFloat(version);

  if (sign === '>') {
    return function (v) {
      return parseFloat(v) > version;
    };
  } else if (sign === '>=') {
    return function (v) {
      return parseFloat(v) >= version;
    };
  } else if (sign === '<') {
    return function (v) {
      return parseFloat(v) < version;
    };
  } else {
    return function (v) {
      return parseFloat(v) <= version;
    };
  }
}

function generateSemverFilter(sign, version) {
  version = version.split('.').map(parseSimpleInt);
  version[1] = version[1] || 0;
  version[2] = version[2] || 0;

  if (sign === '>') {
    return function (v) {
      v = v.split('.').map(parseSimpleInt);
      return compareSemver(v, version) > 0;
    };
  } else if (sign === '>=') {
    return function (v) {
      v = v.split('.').map(parseSimpleInt);
      return compareSemver(v, version) >= 0;
    };
  } else if (sign === '<') {
    return function (v) {
      v = v.split('.').map(parseSimpleInt);
      return compareSemver(version, v) > 0;
    };
  } else {
    return function (v) {
      v = v.split('.').map(parseSimpleInt);
      return compareSemver(version, v) >= 0;
    };
  }
}

function parseSimpleInt(x) {
  return parseInt(x);
}

function compare(a, b) {
  if (a < b) return -1;
  if (a > b) return +1;
  return 0;
}

function compareSemver(a, b) {
  return compare(parseInt(a[0]), parseInt(b[0])) || compare(parseInt(a[1] || '0'), parseInt(b[1] || '0')) || compare(parseInt(a[2] || '0'), parseInt(b[2] || '0'));
} // this follows the npm-like semver behavior


function semverFilterLoose(operator, range) {
  range = range.split('.').map(parseSimpleInt);

  if (typeof range[1] === 'undefined') {
    range[1] = 'x';
  } // ignore any patch version because we only return minor versions
  // range[2] = 'x'


  switch (operator) {
    case '<=':
      return function (version) {
        version = version.split('.').map(parseSimpleInt);
        return compareSemverLoose(version, range) <= 0;
      };

    default:
    case '>=':
      return function (version) {
        version = version.split('.').map(parseSimpleInt);
        return compareSemverLoose(version, range) >= 0;
      };
  }
} // this follows the npm-like semver behavior


function compareSemverLoose(version, range) {
  if (version[0] !== range[0]) {
    return version[0] < range[0] ? -1 : +1;
  }

  if (range[1] === 'x') {
    return 0;
  }

  if (version[1] !== range[1]) {
    return version[1] < range[1] ? -1 : +1;
  }

  return 0;
}

function resolveVersion(data, version) {
  if (data.versions.indexOf(version) !== -1) {
    return version;
  } else if (browserslist.versionAliases[data.name][version]) {
    return browserslist.versionAliases[data.name][version];
  } else {
    return false;
  }
}

function normalizeVersion(data, version) {
  var resolved = resolveVersion(data, version);

  if (resolved) {
    return resolved;
  } else if (data.versions.length === 1) {
    return data.versions[0];
  } else {
    return false;
  }
}

function filterByYear(since, context) {
  since = since / 1000;
  return Object.keys(agents).reduce(function (selected, name) {
    var data = byName(name, context);
    if (!data) return selected;
    var versions = Object.keys(data.releaseDate).filter(function (v) {
      return data.releaseDate[v] >= since;
    });
    return selected.concat(versions.map(nameMapper(data.name)));
  }, []);
}

function cloneData(data) {
  return {
    name: data.name,
    versions: data.versions,
    released: data.released,
    releaseDate: data.releaseDate
  };
}

function mapVersions(data, map) {
  data.versions = data.versions.map(function (i) {
    return map[i] || i;
  });
  data.released = data.versions.map(function (i) {
    return map[i] || i;
  });
  var fixedDate = {};

  for (var i in data.releaseDate) {
    fixedDate[map[i] || i] = data.releaseDate[i];
  }

  data.releaseDate = fixedDate;
  return data;
}

function byName(name, context) {
  name = name.toLowerCase();
  name = browserslist.aliases[name] || name;

  if (context.mobileToDesktop && browserslist.desktopNames[name]) {
    var desktop = browserslist.data[browserslist.desktopNames[name]];

    if (name === 'android') {
      return normalizeAndroidData(cloneData(browserslist.data[name]), desktop);
    } else {
      var cloned = cloneData(desktop);
      cloned.name = name;

      if (name === 'op_mob') {
        cloned = mapVersions(cloned, {
          '10.0-10.1': '10'
        });
      }

      return cloned;
    }
  }

  return browserslist.data[name];
}

function normalizeAndroidVersions(androidVersions, chromeVersions) {
  var firstEvergreen = ANDROID_EVERGREEN_FIRST;
  var last = chromeVersions[chromeVersions.length - 1];
  return androidVersions.filter(function (version) {
    return /^(?:[2-4]\.|[34]$)/.test(version);
  }).concat(chromeVersions.slice(firstEvergreen - last - 1));
}

function normalizeAndroidData(android, chrome) {
  android.released = normalizeAndroidVersions(android.released, chrome.released);
  android.versions = normalizeAndroidVersions(android.versions, chrome.versions);
  return android;
}

function checkName(name, context) {
  var data = byName(name, context);
  if (!data) throw new BrowserslistError('Unknown browser ' + name);
  return data;
}

function unknownQuery(query) {
  return new BrowserslistError('Unknown browser query `' + query + '`. ' + 'Maybe you are using old Browserslist or made typo in query.');
}

function filterAndroid(list, versions, context) {
  if (context.mobileToDesktop) return list;
  var released = browserslist.data.android.released;
  var last = released[released.length - 1];
  var diff = last - ANDROID_EVERGREEN_FIRST - versions;

  if (diff > 0) {
    return list.slice(-1);
  } else {
    return list.slice(diff - 1);
  }
}
/**
 * Resolves queries into a browser list.
 * @param {string|string[]} queries Queries to combine.
 * Either an array of queries or a long string of queries.
 * @param {object} [context] Optional arguments to
 * the select function in `queries`.
 * @returns {string[]} A list of browsers
 */


function resolve(queries, context) {
  if (Array.isArray(queries)) {
    queries = flatten(queries.map(parse));
  } else {
    queries = parse(queries);
  }

  return queries.reduce(function (result, query, index) {
    var selection = query.queryString;
    var isExclude = selection.indexOf('not ') === 0;

    if (isExclude) {
      if (index === 0) {
        throw new BrowserslistError('Write any browsers query (for instance, `defaults`) ' + 'before `' + selection + '`');
      }

      selection = selection.slice(4);
    }

    for (var i = 0; i < QUERIES.length; i++) {
      var type = QUERIES[i];
      var match = selection.match(type.regexp);

      if (match) {
        var args = [context].concat(match.slice(1));
        var array = type.select.apply(browserslist, args).map(function (j) {
          var parts = j.split(' ');

          if (parts[1] === '0') {
            return parts[0] + ' ' + byName(parts[0], context).versions[0];
          } else {
            return j;
          }
        });

        switch (query.type) {
          case QUERY_AND:
            if (isExclude) {
              return result.filter(function (j) {
                return array.indexOf(j) === -1;
              });
            } else {
              return result.filter(function (j) {
                return array.indexOf(j) !== -1;
              });
            }

          case QUERY_OR:
          default:
            if (isExclude) {
              var filter = {};
              array.forEach(function (j) {
                filter[j] = true;
              });
              return result.filter(function (j) {
                return !filter[j];
              });
            }

            return result.concat(array);
        }
      }
    }

    throw unknownQuery(selection);
  }, []);
}

var cache = {};
/**
 * Return array of browsers by selection queries.
 *
 * @param {(string|string[])} [queries=browserslist.defaults] Browser queries.
 * @param {object} [opts] Options.
 * @param {string} [opts.path="."] Path to processed file.
 *                                 It will be used to find config files.
 * @param {string} [opts.env="production"] Processing environment.
 *                                         It will be used to take right
 *                                         queries from config file.
 * @param {string} [opts.config] Path to config file with queries.
 * @param {object} [opts.stats] Custom browser usage statistics
 *                              for "> 1% in my stats" query.
 * @param {boolean} [opts.ignoreUnknownVersions=false] Do not throw on unknown
 *                                                     version in direct query.
 * @param {boolean} [opts.dangerousExtend] Disable security checks
 *                                         for extend query.
 * @param {boolean} [opts.mobileToDesktop] Alias mobile browsers to the desktop
 *                                         version when Can I Use doesn't have
 *                                         data about the specified version.
 * @returns {string[]} Array with browser names in Can I Use.
 *
 * @example
 * browserslist('IE >= 10, IE 8') //=> ['ie 11', 'ie 10', 'ie 8']
 */

function browserslist(queries, opts) {
  if (typeof opts === 'undefined') opts = {};

  if (typeof opts.path === 'undefined') {
    opts.path = path.resolve ? path.resolve('.') : '.';
  }

  if (typeof queries === 'undefined' || queries === null) {
    var config = browserslist.loadConfig(opts);

    if (config) {
      queries = config;
    } else {
      queries = browserslist.defaults;
    }
  }

  if (!(typeof queries === 'string' || Array.isArray(queries))) {
    throw new BrowserslistError('Browser queries must be an array or string. Got ' + typeof queries + '.');
  }

  var context = {
    ignoreUnknownVersions: opts.ignoreUnknownVersions,
    dangerousExtend: opts.dangerousExtend,
    mobileToDesktop: opts.mobileToDesktop,
    env: opts.env
  };
  env.oldDataWarning(browserslist.data);
  var stats = env.getStat(opts, browserslist.data);

  if (stats) {
    context.customUsage = {};

    for (var browser in stats) {
      fillUsage(context.customUsage, browser, stats[browser]);
    }
  }

  var cacheKey = JSON.stringify([queries, context]);
  if (cache[cacheKey]) return cache[cacheKey];
  var result = uniq(resolve(queries, context)).sort(function (name1, name2) {
    name1 = name1.split(' ');
    name2 = name2.split(' ');

    if (name1[0] === name2[0]) {
      // assumptions on caniuse data
      // 1) version ranges never overlaps
      // 2) if version is not a range, it never contains `-`
      var version1 = name1[1].split('-')[0];
      var version2 = name2[1].split('-')[0];
      return compareSemver(version2.split('.'), version1.split('.'));
    } else {
      return compare(name1[0], name2[0]);
    }
  });

  if (!undefined) {
    cache[cacheKey] = result;
  }

  return result;
}

function parse(queries) {
  var qs = [];

  do {
    queries = doMatch(queries, qs);
  } while (queries);

  return qs;
}

function doMatch(string, qs) {
  var or = /^(?:,\s*|\s+or\s+)(.*)/i;
  var and = /^\s+and\s+(.*)/i;
  return find(string, function (parsed, n, max) {
    if (and.test(parsed)) {
      qs.unshift({
        type: QUERY_AND,
        queryString: parsed.match(and)[1]
      });
      return true;
    } else if (or.test(parsed)) {
      qs.unshift({
        type: QUERY_OR,
        queryString: parsed.match(or)[1]
      });
      return true;
    } else if (n === max) {
      qs.unshift({
        type: QUERY_OR,
        queryString: parsed.trim()
      });
      return true;
    }

    return false;
  });
}

function find(string, predicate) {
  for (var n = 1, max = string.length; n <= max; n++) {
    var parsed = string.substr(-n, n);

    if (predicate(parsed, n, max)) {
      return string.slice(0, -n);
    }
  }

  return '';
}

function flatten(array) {
  if (!Array.isArray(array)) return [array];
  return array.reduce(function (a, b) {
    return a.concat(flatten(b));
  }, []);
} // Will be filled by Can I Use data below


browserslist.data = {};
browserslist.usage = {
  global: {},
  custom: null
}; // Default browsers query

browserslist.defaults = ['> 0.5%', 'last 2 versions', 'Firefox ESR', 'not dead']; // Browser names aliases

browserslist.aliases = {
  fx: 'firefox',
  ff: 'firefox',
  ios: 'ios_saf',
  explorer: 'ie',
  blackberry: 'bb',
  explorermobile: 'ie_mob',
  operamini: 'op_mini',
  operamobile: 'op_mob',
  chromeandroid: 'and_chr',
  firefoxandroid: 'and_ff',
  ucandroid: 'and_uc',
  qqandroid: 'and_qq'
}; // Can I Use only provides a few versions for some browsers (e.g. and_chr).
// Fallback to a similar browser for unknown versions

browserslist.desktopNames = {
  and_chr: 'chrome',
  and_ff: 'firefox',
  ie_mob: 'ie',
  op_mob: 'opera',
  android: 'chrome' // has extra processing logic

}; // Aliases to work with joined versions like `ios_saf 7.0-7.1`

browserslist.versionAliases = {};
browserslist.clearCaches = env.clearCaches;
browserslist.parseConfig = env.parseConfig;
browserslist.readConfig = env.readConfig;
browserslist.findConfig = env.findConfig;
browserslist.loadConfig = env.loadConfig;
/**
 * Return browsers market coverage.
 *
 * @param {string[]} browsers Browsers names in Can I Use.
 * @param {string|object} [stats="global"] Which statistics should be used.
 *                                         Country code or custom statistics.
 *                                         Pass `"my stats"` to load statistics
 *                                         from Browserslist files.
 *
 * @return {number} Total market coverage for all selected browsers.
 *
 * @example
 * browserslist.coverage(browserslist('> 1% in US'), 'US') //=> 83.1
 */

browserslist.coverage = function (browsers, stats) {
  var data;

  if (typeof stats === 'undefined') {
    data = browserslist.usage.global;
  } else if (stats === 'my stats') {
    var opts = {};
    opts.path = path.resolve ? path.resolve('.') : '.';
    var customStats = env.getStat(opts);

    if (!customStats) {
      throw new BrowserslistError('Custom usage statistics was not provided');
    }

    data = {};

    for (var browser in customStats) {
      fillUsage(data, browser, customStats[browser]);
    }
  } else if (typeof stats === 'string') {
    if (stats.length > 2) {
      stats = stats.toLowerCase();
    } else {
      stats = stats.toUpperCase();
    }

    env.loadCountry(browserslist.usage, stats, browserslist.data);
    data = browserslist.usage[stats];
  } else {
    if ('dataByBrowser' in stats) {
      stats = stats.dataByBrowser;
    }

    data = {};

    for (var name in stats) {
      for (var version in stats[name]) {
        data[name + ' ' + version] = stats[name][version];
      }
    }
  }

  return browsers.reduce(function (all, i) {
    var usage = data[i];

    if (usage === undefined) {
      usage = data[i.replace(/ \S+$/, ' 0')];
    }

    return all + (usage || 0);
  }, 0);
};

var QUERIES = [{
  regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
  select: function (context, versions) {
    return Object.keys(agents).reduce(function (selected, name) {
      var data = byName(name, context);
      if (!data) return selected;
      var list = getMajorVersions(data.released, versions);
      list = list.map(nameMapper(data.name));

      if (data.name === 'android') {
        list = filterAndroid(list, versions, context);
      }

      return selected.concat(list);
    }, []);
  }
}, {
  regexp: /^last\s+(\d+)\s+versions?$/i,
  select: function (context, versions) {
    return Object.keys(agents).reduce(function (selected, name) {
      var data = byName(name, context);
      if (!data) return selected;
      var list = data.released.slice(-versions);
      list = list.map(nameMapper(data.name));

      if (data.name === 'android') {
        list = filterAndroid(list, versions, context);
      }

      return selected.concat(list);
    }, []);
  }
}, {
  regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
  select: function (context, versions) {
    var validVersions = getMajorVersions(Object.keys(e2c).reverse(), versions);
    return validVersions.map(function (i) {
      return 'chrome ' + e2c[i];
    });
  }
}, {
  regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
  select: function (context, versions, name) {
    var data = checkName(name, context);
    var validVersions = getMajorVersions(data.released, versions);
    var list = validVersions.map(nameMapper(data.name));

    if (data.name === 'android') {
      list = filterAndroid(list, versions, context);
    }

    return list;
  }
}, {
  regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
  select: function (context, versions) {
    return Object.keys(e2c).reverse().slice(-versions).map(function (i) {
      return 'chrome ' + e2c[i];
    });
  }
}, {
  regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
  select: function (context, versions, name) {
    var data = checkName(name, context);
    var list = data.released.slice(-versions).map(nameMapper(data.name));

    if (data.name === 'android') {
      list = filterAndroid(list, versions, context);
    }

    return list;
  }
}, {
  regexp: /^unreleased\s+versions$/i,
  select: function (context) {
    return Object.keys(agents).reduce(function (selected, name) {
      var data = byName(name, context);
      if (!data) return selected;
      var list = data.versions.filter(function (v) {
        return data.released.indexOf(v) === -1;
      });
      list = list.map(nameMapper(data.name));
      return selected.concat(list);
    }, []);
  }
}, {
  regexp: /^unreleased\s+electron\s+versions?$/i,
  select: function () {
    return [];
  }
}, {
  regexp: /^unreleased\s+(\w+)\s+versions?$/i,
  select: function (context, name) {
    var data = checkName(name, context);
    return data.versions.filter(function (v) {
      return data.released.indexOf(v) === -1;
    }).map(nameMapper(data.name));
  }
}, {
  regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
  select: function (context, years) {
    return filterByYear(Date.now() - YEAR * years, context);
  }
}, {
  regexp: /^since (\d+)(?:-(\d+))?(?:-(\d+))?$/i,
  select: function (context, year, month, date) {
    year = parseInt(year);
    month = parseInt(month || '01') - 1;
    date = parseInt(date || '01');
    return filterByYear(Date.UTC(year, month, date, 0, 0, 0), context);
  }
}, {
  regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%$/,
  select: function (context, sign, popularity) {
    popularity = parseFloat(popularity);
    var usage = browserslist.usage.global;
    return Object.keys(usage).reduce(function (result, version) {
      if (sign === '>') {
        if (usage[version] > popularity) {
          result.push(version);
        }
      } else if (sign === '<') {
        if (usage[version] < popularity) {
          result.push(version);
        }
      } else if (sign === '<=') {
        if (usage[version] <= popularity) {
          result.push(version);
        }
      } else if (usage[version] >= popularity) {
        result.push(version);
      }

      return result;
    }, []);
  }
}, {
  regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+my\s+stats$/,
  select: function (context, sign, popularity) {
    popularity = parseFloat(popularity);

    if (!context.customUsage) {
      throw new BrowserslistError('Custom usage statistics was not provided');
    }

    var usage = context.customUsage;
    return Object.keys(usage).reduce(function (result, version) {
      if (sign === '>') {
        if (usage[version] > popularity) {
          result.push(version);
        }
      } else if (sign === '<') {
        if (usage[version] < popularity) {
          result.push(version);
        }
      } else if (sign === '<=') {
        if (usage[version] <= popularity) {
          result.push(version);
        }
      } else if (usage[version] >= popularity) {
        result.push(version);
      }

      return result;
    }, []);
  }
}, {
  regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+(\S+)\s+stats$/,
  select: function (context, sign, popularity, name) {
    popularity = parseFloat(popularity);
    var stats = env.loadStat(context, name, browserslist.data);

    if (stats) {
      context.customUsage = {};

      for (var browser in stats) {
        fillUsage(context.customUsage, browser, stats[browser]);
      }
    }

    if (!context.customUsage) {
      throw new BrowserslistError('Custom usage statistics was not provided');
    }

    var usage = context.customUsage;
    return Object.keys(usage).reduce(function (result, version) {
      if (sign === '>') {
        if (usage[version] > popularity) {
          result.push(version);
        }
      } else if (sign === '<') {
        if (usage[version] < popularity) {
          result.push(version);
        }
      } else if (sign === '<=') {
        if (usage[version] <= popularity) {
          result.push(version);
        }
      } else if (usage[version] >= popularity) {
        result.push(version);
      }

      return result;
    }, []);
  }
}, {
  regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+((alt-)?\w\w)$/,
  select: function (context, sign, popularity, place) {
    popularity = parseFloat(popularity);

    if (place.length === 2) {
      place = place.toUpperCase();
    } else {
      place = place.toLowerCase();
    }

    env.loadCountry(browserslist.usage, place, browserslist.data);
    var usage = browserslist.usage[place];
    return Object.keys(usage).reduce(function (result, version) {
      if (sign === '>') {
        if (usage[version] > popularity) {
          result.push(version);
        }
      } else if (sign === '<') {
        if (usage[version] < popularity) {
          result.push(version);
        }
      } else if (sign === '<=') {
        if (usage[version] <= popularity) {
          result.push(version);
        }
      } else if (usage[version] >= popularity) {
        result.push(version);
      }

      return result;
    }, []);
  }
}, {
  regexp: /^cover\s+(\d*\.?\d+)%(\s+in\s+(my\s+stats|(alt-)?\w\w))?$/,
  select: function (context, coverage, statMode) {
    coverage = parseFloat(coverage);
    var usage = browserslist.usage.global;

    if (statMode) {
      if (statMode.match(/^\s+in\s+my\s+stats$/)) {
        if (!context.customUsage) {
          throw new BrowserslistError('Custom usage statistics was not provided');
        }

        usage = context.customUsage;
      } else {
        var match = statMode.match(/\s+in\s+((alt-)?\w\w)/);
        var place = match[1];

        if (place.length === 2) {
          place = place.toUpperCase();
        } else {
          place = place.toLowerCase();
        }

        env.loadCountry(browserslist.usage, place, browserslist.data);
        usage = browserslist.usage[place];
      }
    }

    var versions = Object.keys(usage).sort(function (a, b) {
      return usage[b] - usage[a];
    });
    var coveraged = 0;
    var result = [];
    var version;

    for (var i = 0; i <= versions.length; i++) {
      version = versions[i];
      if (usage[version] === 0) break;
      coveraged += usage[version];
      result.push(version);
      if (coveraged >= coverage) break;
    }

    return result;
  }
}, {
  regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
  select: function (context, from, to) {
    var fromToUse = normalizeElectron(from);
    var toToUse = normalizeElectron(to);

    if (!e2c[fromToUse]) {
      throw new BrowserslistError('Unknown version ' + from + ' of electron');
    }

    if (!e2c[toToUse]) {
      throw new BrowserslistError('Unknown version ' + to + ' of electron');
    }

    from = parseFloat(from);
    to = parseFloat(to);
    return Object.keys(e2c).filter(function (i) {
      var parsed = parseFloat(i);
      return parsed >= from && parsed <= to;
    }).map(function (i) {
      return 'chrome ' + e2c[i];
    });
  }
}, {
  regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
  select: function (context, from, to) {
    var nodeVersions = jsReleases.filter(function (i) {
      return i.name === 'nodejs';
    }).map(function (i) {
      return i.version;
    });
    var semverRegExp = /^(0|[1-9]\d*)(\.(0|[1-9]\d*)){0,2}$/;

    if (!semverRegExp.test(from)) {
      throw new BrowserslistError('Unknown version ' + from + ' of Node.js');
    }

    if (!semverRegExp.test(to)) {
      throw new BrowserslistError('Unknown version ' + to + ' of Node.js');
    }

    return nodeVersions.filter(semverFilterLoose('>=', from)).filter(semverFilterLoose('<=', to)).map(function (v) {
      return 'node ' + v;
    });
  }
}, {
  regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
  select: function (context, name, from, to) {
    var data = checkName(name, context);
    from = parseFloat(normalizeVersion(data, from) || from);
    to = parseFloat(normalizeVersion(data, to) || to);

    function filter(v) {
      var parsed = parseFloat(v);
      return parsed >= from && parsed <= to;
    }

    return data.released.filter(filter).map(nameMapper(data.name));
  }
}, {
  regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
  select: function (context, sign, version) {
    var versionToUse = normalizeElectron(version);
    return Object.keys(e2c).filter(generateFilter(sign, versionToUse)).map(function (i) {
      return 'chrome ' + e2c[i];
    });
  }
}, {
  regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
  select: function (context, sign, version) {
    var nodeVersions = jsReleases.filter(function (i) {
      return i.name === 'nodejs';
    }).map(function (i) {
      return i.version;
    });
    return nodeVersions.filter(generateSemverFilter(sign, version)).map(function (v) {
      return 'node ' + v;
    });
  }
}, {
  regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
  select: function (context, name, sign, version) {
    var data = checkName(name, context);
    var alias = browserslist.versionAliases[data.name][version];

    if (alias) {
      version = alias;
    }

    return data.released.filter(generateFilter(sign, version)).map(function (v) {
      return data.name + ' ' + v;
    });
  }
}, {
  regexp: /^(firefox|ff|fx)\s+esr$/i,
  select: function () {
    return ['firefox 68'];
  }
}, {
  regexp: /(operamini|op_mini)\s+all/i,
  select: function () {
    return ['op_mini all'];
  }
}, {
  regexp: /^electron\s+([\d.]+)$/i,
  select: function (context, version) {
    var versionToUse = normalizeElectron(version);
    var chrome = e2c[versionToUse];

    if (!chrome) {
      throw new BrowserslistError('Unknown version ' + version + ' of electron');
    }

    return ['chrome ' + chrome];
  }
}, {
  regexp: /^node\s+(\d+(\.\d+)?(\.\d+)?)$/i,
  select: function (context, version) {
    var nodeReleases = jsReleases.filter(function (i) {
      return i.name === 'nodejs';
    });
    var matched = nodeReleases.filter(function (i) {
      return isVersionsMatch(i.version, version);
    });

    if (matched.length === 0) {
      if (context.ignoreUnknownVersions) {
        return [];
      } else {
        throw new BrowserslistError('Unknown version ' + version + ' of Node.js');
      }
    }

    return ['node ' + matched[matched.length - 1].version];
  }
}, {
  regexp: /^current\s+node$/i,
  select: function (context) {
    return [env.currentNode(resolve, context)];
  }
}, {
  regexp: /^maintained\s+node\s+versions$/i,
  select: function (context) {
    var now = Date.now();
    var queries = Object.keys(jsEOL).filter(function (key) {
      return now < Date.parse(jsEOL[key].end) && now > Date.parse(jsEOL[key].start) && isEolReleased(key);
    }).map(function (key) {
      return 'node ' + key.slice(1);
    });
    return resolve(queries, context);
  }
}, {
  regexp: /^phantomjs\s+1.9$/i,
  select: function () {
    return ['safari 5'];
  }
}, {
  regexp: /^phantomjs\s+2.1$/i,
  select: function () {
    return ['safari 6'];
  }
}, {
  regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
  select: function (context, name, version) {
    if (/^tp$/i.test(version)) version = 'TP';
    var data = checkName(name, context);
    var alias = normalizeVersion(data, version);

    if (alias) {
      version = alias;
    } else {
      if (version.indexOf('.') === -1) {
        alias = version + '.0';
      } else {
        alias = version.replace(/\.0$/, '');
      }

      alias = normalizeVersion(data, alias);

      if (alias) {
        version = alias;
      } else if (context.ignoreUnknownVersions) {
        return [];
      } else {
        throw new BrowserslistError('Unknown version ' + version + ' of ' + name);
      }
    }

    return [data.name + ' ' + version];
  }
}, {
  regexp: /^extends (.+)$/i,
  select: function (context, name) {
    return resolve(env.loadQueries(context, name), context);
  }
}, {
  regexp: /^defaults$/i,
  select: function (context) {
    return resolve(browserslist.defaults, context);
  }
}, {
  regexp: /^dead$/i,
  select: function (context) {
    var dead = ['ie <= 10', 'ie_mob <= 11', 'bb <= 10', 'op_mob <= 12.1', 'samsung 4'];
    return resolve(dead, context);
  }
}, {
  regexp: /^(\w+)$/i,
  select: function (context, name) {
    if (byName(name, context)) {
      throw new BrowserslistError('Specify versions in Browserslist query for browser ' + name);
    } else {
      throw unknownQuery(name);
    }
  }
}]; // Get and convert Can I Use data

(function () {
  for (var name in agents) {
    var browser = agents[name];
    browserslist.data[name] = {
      name: name,
      versions: normalize(agents[name].versions),
      released: normalize(agents[name].versions.slice(0, -3)),
      releaseDate: agents[name].release_date
    };
    fillUsage(browserslist.usage.global, name, browser.usage_global);
    browserslist.versionAliases[name] = {};

    for (var i = 0; i < browser.versions.length; i++) {
      var full = browser.versions[i];
      if (!full) continue;

      if (full.indexOf('-') !== -1) {
        var interval = full.split('-');

        for (var j = 0; j < interval.length; j++) {
          browserslist.versionAliases[name][interval[j]] = full;
        }
      }
    }
  }
})();

module.exports = browserslist;
},{"node-releases/data/processed/envs.json":"node_modules/node-releases/data/processed/envs.json","caniuse-lite/dist/unpacker/agents":"node_modules/caniuse-lite/dist/unpacker/agents.js","node-releases/data/release-schedule/release-schedule.json":"node_modules/node-releases/data/release-schedule/release-schedule.json","path":"node_modules/parcel-bundler/src/builtins/_empty.js","electron-to-chromium/versions":"node_modules/electron-to-chromium/versions.js","./error":"node_modules/browserslist/error.js","./node":"node_modules/browserslist/browser.js"}],"node_modules/lodash.memoize/index.js":[function(require,module,exports) {
var global = arguments[3];
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = memoize;

},{}],"node_modules/caniuse-lite/dist/lib/statuses.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    1: "ls", // WHATWG Living Standard
    2: "rec", // W3C Recommendation
    3: "pr", // W3C Proposed Recommendation
    4: "cr", // W3C Candidate Recommendation
    5: "wd", // W3C Working Draft
    6: "other", // Non-W3C, but reputable
    7: "unoff" // Unofficial, Editor's Draft or W3C "Note"
};

},{}],"node_modules/caniuse-lite/dist/lib/supported.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    y: 1 << 0,
    n: 1 << 1,
    a: 1 << 2,
    p: 1 << 3,
    u: 1 << 4,
    x: 1 << 5,
    d: 1 << 6
};

},{}],"node_modules/caniuse-lite/dist/unpacker/feature.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = unpackFeature;

var _statuses = require('../lib/statuses');

var _statuses2 = _interopRequireDefault(_statuses);

var _supported = require('../lib/supported');

var _supported2 = _interopRequireDefault(_supported);

var _browsers = require('./browsers');

var _browserVersions = require('./browserVersions');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MATH2LOG = Math.log(2);

function unpackSupport(cipher) {
    // bit flags
    var stats = Object.keys(_supported2.default).reduce(function (list, support) {
        if (cipher & _supported2.default[support]) list.push(support);
        return list;
    }, []);

    // notes
    var notes = cipher >> 7;
    var notesArray = [];
    while (notes) {
        var note = Math.floor(Math.log(notes) / MATH2LOG) + 1;
        notesArray.unshift('#' + note);
        notes -= Math.pow(2, note - 1);
    }

    return stats.concat(notesArray).join(' ');
}

function unpackFeature(packed) {
    var unpacked = { status: _statuses2.default[packed.B], title: packed.C };
    unpacked.stats = Object.keys(packed.A).reduce(function (browserStats, key) {
        var browser = packed.A[key];
        browserStats[_browsers.browsers[key]] = Object.keys(browser).reduce(function (stats, support) {
            var packedVersions = browser[support].split(' ');
            var unpacked = unpackSupport(support);
            packedVersions.forEach(function (v) {
                return stats[_browserVersions.browserVersions[v]] = unpacked;
            });
            return stats;
        }, {});
        return browserStats;
    }, {});
    return unpacked;
}
},{"../lib/statuses":"node_modules/caniuse-lite/dist/lib/statuses.js","../lib/supported":"node_modules/caniuse-lite/dist/lib/supported.js","./browsers":"node_modules/caniuse-lite/dist/unpacker/browsers.js","./browserVersions":"node_modules/caniuse-lite/dist/unpacker/browserVersions.js"}],"node_modules/caniuse-lite/data/features/aac.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X nB fB","132":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D","16":"A B"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB"},H:{"2":"7B"},I:{"1":"GB G N BC HB CC DC","2":"8B 9B AC"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"132":"M"},N:{"1":"A","2":"B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"132":"MC"}},B:6,C:"AAC audio file format"};

},{}],"node_modules/caniuse-lite/data/features/abortcontroller.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"H J K UB IB N","2":"C O T P"},C:{"1":"7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB"},E:{"1":"O S hB iB","2":"G U I F E D A B xB WB aB bB cB dB VB","130":"C L"},F:{"1":"3 4 5 6 7 8 9 AB CB DB BB w R M","2":"0 1 2 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"1":"0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"JC VB L","2":"G FC GC HC IC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:1,C:"AbortController & AbortSignal"};

},{}],"node_modules/caniuse-lite/data/features/ac3-ec3.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K","2":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB","132":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F","132":"A"},K:{"2":"A B C Q L EB","132":"S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"132":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"AC-3 (Dolby Digital) and EC-3 (Dolby Digital Plus) codecs"};

},{}],"node_modules/caniuse-lite/data/features/accelerometer.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","194":"8 9 TB AB FB CB DB BB w"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"4 5 6 7 8 9 AB CB DB BB w R M","2":"0 1 2 3 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:4,C:"Accelerometer"};

},{}],"node_modules/caniuse-lite/data/features/addeventlistener.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","130":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","257":"qB GB G U I nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"EventTarget.addEventListener()"};

},{}],"node_modules/caniuse-lite/data/features/alternate-stylesheet.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"E D A B","2":"I F gB"},B:{"2":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"D B C jB kB lB mB L EB oB S","16":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"16":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"16":"F A"},K:{"16":"A B C Q L EB S"},L:{"16":"N"},M:{"16":"M"},N:{"16":"A B"},O:{"16":"EC"},P:{"16":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"16":"LC"},S:{"1":"MC"}},B:1,C:"Alternate stylesheet"};

},{}],"node_modules/caniuse-lite/data/features/ambient-light.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O","132":"T P H J K","322":"UB IB N"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X nB fB","132":"0 1 2 3 4 5 6 7 8 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB","194":"9 AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"0 1 2 3 4 5 6 7 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","322":"8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"132":"MC"}},B:4,C:"Ambient Light Sensor"};

},{}],"node_modules/caniuse-lite/data/features/apng.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB"},D:{"1":"9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"E D A B C O dB VB L S hB iB","2":"G U I F xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","2":"D P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v"},G:{"1":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"HC IC JC VB L","2":"G FC GC"},Q:{"2":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:7,C:"Animated PNG (APNG)"};

},{}],"node_modules/caniuse-lite/data/features/array-find-index.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"P H J K UB IB N","16":"C O T"},C:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u"},E:{"1":"E D A B C O cB dB VB L S hB iB","2":"G U I F xB WB aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h jB kB lB mB L EB oB S"},G:{"1":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F","16":"A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"Array.prototype.findIndex"};

},{}],"node_modules/caniuse-lite/data/features/array-find.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"P H J K UB IB N","16":"C O T"},C:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u"},E:{"1":"E D A B C O cB dB VB L S hB iB","2":"G U I F xB WB aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h jB kB lB mB L EB oB S"},G:{"1":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F","16":"A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"Array.prototype.find"};

},{}],"node_modules/caniuse-lite/data/features/array-flat.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"9 CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB nB fB"},D:{"1":"JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M"},E:{"1":"C O S hB iB","2":"G U I F E D A B xB WB aB bB cB dB VB L"},F:{"1":"6 7 8 9 AB CB DB BB w R M","2":"0 1 2 3 4 5 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"1":"1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"VB L","2":"G FC GC HC IC JC"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"flat & flatMap array methods"};

},{}],"node_modules/caniuse-lite/data/features/array-includes.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"T P H J K UB IB N","2":"C O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j jB kB lB mB L EB oB S"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"Array.prototype.includes"};

},{}],"node_modules/caniuse-lite/data/features/arrow-functions.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h jB kB lB mB L EB oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"Arrow functions"};

},{}],"node_modules/caniuse-lite/data/features/asmjs.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"O T P H J K","132":"UB IB N","322":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X nB fB"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d","132":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","132":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","132":"N"},J:{"2":"F A"},K:{"2":"A B C L EB S","132":"Q"},L:{"132":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G","132":"FC GC HC IC JC VB L"},Q:{"132":"KC"},R:{"132":"LC"},S:{"1":"MC"}},B:6,C:"asm.js"};

},{}],"node_modules/caniuse-lite/data/features/async-clipboard.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"9 CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","66":"8 TB AB FB"},E:{"1":"hB iB","2":"G U I F E D A B C O xB WB aB bB cB dB VB L S"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x jB kB lB mB L EB oB S","16":"0 1 2 3 4 5 6 7 8 9 y z AB CB DB BB w R M"},G:{"1":"6B","2":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B","16":"WB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"Asynchronous Clipboard API"};

},{}],"node_modules/caniuse-lite/data/features/async-functions.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"P H J K UB IB N","2":"C O","194":"T"},C:{"1":"2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"B C O L S hB iB","2":"G U I F E D A xB WB aB bB cB dB","514":"VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r jB kB lB mB L EB oB S"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB","514":"yB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"GC HC IC JC VB L","2":"G FC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"Async functions"};

},{}],"node_modules/caniuse-lite/data/features/async-iterations-and-generators.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"9 DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB"},E:{"1":"C O S hB iB","2":"G U I F E D A B xB WB aB bB cB dB VB L"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"Async iterators and generators"};

},{}],"node_modules/caniuse-lite/data/features/atob-btoa.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M mB L EB oB S","2":"D jB kB","16":"lB"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"B C Q L EB S","16":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Base64 encoding and decoding"};

},{}],"node_modules/caniuse-lite/data/features/audio-api.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D","33":"A B C O T P H J K V W X Y Z a b c d e f g h i j"},E:{"2":"G U xB WB aB","33":"I F E D A B C O bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","33":"P H J K V W X"},G:{"2":"WB pB HB rB","33":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"Web Audio API"};

},{}],"node_modules/caniuse-lite/data/features/audio.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB","132":"G U I F E D A B C O T P H J K V nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D","4":"jB kB"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB"},H:{"2":"7B"},I:{"1":"GB G N AC BC HB CC DC","2":"8B 9B"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Audio element"};

},{}],"node_modules/caniuse-lite/data/features/audiotracks.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K","322":"UB IB N"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i nB fB","194":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u","322":"0 1 2 3 4 5 6 7 8 9 v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","2":"G U I xB WB aB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h jB kB lB mB L EB oB S","322":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C L EB S","322":"Q"},L:{"322":"N"},M:{"2":"M"},N:{"1":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"194":"MC"}},B:1,C:"Audio Tracks"};

},{}],"node_modules/caniuse-lite/data/features/autofocus.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","2":"D"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N BC HB CC DC","2":"8B 9B AC"},J:{"1":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"2":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:1,C:"Autofocus attribute"};

},{}],"node_modules/caniuse-lite/data/features/auxclick.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","129":"3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C L EB S","16":"Q"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:5,C:"Auxclick"};

},{}],"node_modules/caniuse-lite/data/features/av1.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J","194":"K"},C:{"1":"R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","1090":"DB BB","1284":"9","1540":"w","2114":"5 6 7 8 TB AB","3138":"FB CB"},D:{"1":"KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w","4162":"R M JB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"7 8 9 AB CB DB BB w R M","2":"0 1 2 3 4 5 6 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"1090":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"AV1 video format"};

},{}],"node_modules/caniuse-lite/data/features/avif.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB nB fB","194":"RB SB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"AVIF image format"};

},{}],"node_modules/caniuse-lite/data/features/background-attachment.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","132":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","132":"qB GB G U I F E D A B C O T P H J K V W X Y Z a nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","132":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","132":"D jB kB"},G:{"2":"WB pB HB","772":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC CC DC","132":"BC HB"},J:{"260":"F A"},K:{"1":"B C Q L EB S","132":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"2":"G","1028":"FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1028":"LC"},S:{"1":"MC"}},B:4,C:"CSS background-attachment"};

},{}],"node_modules/caniuse-lite/data/features/background-clip-text.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"36":"UB IB N","257":"P H J K","548":"C O T"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","16":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x nB fB","130":"y"},D:{"36":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"16":"xB WB","36":"G U I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"16":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"16":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"16":"7B"},I:{"16":"GB G N 8B 9B AC BC HB CC DC"},J:{"16":"F A"},K:{"16":"A B C Q L EB S"},L:{"16":"N"},M:{"16":"M"},N:{"16":"A B"},O:{"16":"EC"},P:{"16":"G FC GC HC IC JC VB L"},Q:{"16":"KC"},R:{"16":"LC"},S:{"130":"MC"}},B:1,C:"CSS3 Background-clip: text"};

},{}],"node_modules/caniuse-lite/data/features/background-img-opts.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB","36":"fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","516":"G U I F E D A B C O T"},E:{"1":"F E D A B C O cB dB VB L S hB iB","772":"G U I xB WB aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D jB","36":"kB"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","4":"WB pB HB sB","516":"rB"},H:{"132":"7B"},I:{"1":"N CC DC","36":"8B","516":"GB G BC HB","548":"9B AC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS3 Background-image options"};

},{}],"node_modules/caniuse-lite/data/features/background-position-x-y.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:7,C:"background-position-x & background-position-y"};

},{}],"node_modules/caniuse-lite/data/features/background-repeat-round-space.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E gB","132":"D"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h"},E:{"1":"F E D A B C O cB dB VB L S hB iB","2":"G U I xB WB aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D P H J K jB kB"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB"},H:{"1":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:4,C:"CSS background-repeat round and space"};

},{}],"node_modules/caniuse-lite/data/features/background-sync.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB nB fB","16":"RB SB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Background Sync API"};

},{}],"node_modules/caniuse-lite/data/features/battery-status.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 t u v Q x y z","2":"2 3 4 5 6 7 8 9 qB GB G U I F E D TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","132":"H J K V W X Y Z a b c d e f g h i j k l m n o p q r s","164":"A B C O T P"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m","66":"n"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"Battery Status API"};

},{}],"node_modules/caniuse-lite/data/features/beacon.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"T P H J K UB IB N","2":"C O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o"},E:{"1":"C O L S hB iB","2":"G U I F E D A B xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b jB kB lB mB L EB oB S"},G:{"1":"0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"Beacon API"};

},{}],"node_modules/caniuse-lite/data/features/beforeafterprint.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A B","16":"gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U nB fB"},D:{"1":"9 DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"16":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"16":"A B"},O:{"16":"EC"},P:{"2":"FC GC HC IC JC VB L","16":"G"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:1,C:"Printing Events"};

},{}],"node_modules/caniuse-lite/data/features/bigint.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB nB fB","194":"9 w R"},D:{"1":"R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w"},E:{"1":"iB","2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB"},F:{"1":"4 5 6 7 8 9 AB CB DB BB w R M","2":"0 1 2 3 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"JC VB L","2":"G FC GC HC IC"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"BigInt"};

},{}],"node_modules/caniuse-lite/data/features/blobbuilder.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U nB fB","36":"I F E D A B C"},D:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F","36":"E D A B C O T P H J K V"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B C jB kB lB mB L EB oB"},G:{"1":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB"},H:{"2":"7B"},I:{"1":"N","2":"8B 9B AC","36":"GB G BC HB CC DC"},J:{"1":"A","2":"F"},K:{"1":"Q S","2":"A B C L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"Blob constructing"};

},{}],"node_modules/caniuse-lite/data/features/bloburls.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","129":"A B"},B:{"1":"P H J K UB IB N","129":"C O T"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F","33":"E D A B C O T P H J K V W X Y"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB","33":"I"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB","33":"sB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB 8B 9B AC","33":"G BC HB"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"Blob URLs"};

},{}],"node_modules/caniuse-lite/data/features/border-image.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D A gB"},B:{"1":"T P H J K UB IB N","129":"C O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB","260":"P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","804":"G U I F E D A B C O T nB fB"},D:{"1":"6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","260":"1 2 3 4 5","388":"0 g h i j k l m n o p q r s t u v Q x y z","1412":"P H J K V W X Y Z a b c d e f","1956":"G U I F E D A B C O T"},E:{"129":"A B C O dB VB L S hB iB","1412":"I F E D bB cB","1956":"G U xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z AB CB DB BB w R M","2":"D jB kB","260":"o p q r s","388":"P H J K V W X Y Z a b c d e f g h i j k l m n","1796":"lB mB","1828":"B C L EB oB S"},G:{"129":"wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","1412":"E sB tB uB vB","1956":"WB pB HB rB"},H:{"1828":"7B"},I:{"388":"N CC DC","1956":"GB G 8B 9B AC BC HB"},J:{"1412":"A","1924":"F"},K:{"2":"A","388":"Q","1828":"B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"388":"EC"},P:{"1":"HC IC JC VB L","260":"FC GC","388":"G"},Q:{"260":"KC"},R:{"260":"LC"},S:{"260":"MC"}},B:4,C:"CSS3 Border images"};

},{}],"node_modules/caniuse-lite/data/features/border-radius.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","257":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","289":"GB nB fB","292":"qB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","33":"G"},E:{"1":"U F E D A B C O cB dB VB L S hB iB","33":"G xB WB","129":"I aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D jB kB"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","33":"WB"},H:{"2":"7B"},I:{"1":"GB G N 9B AC BC HB CC DC","33":"8B"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"257":"MC"}},B:4,C:"CSS3 Border-radius (rounded corners)"};

},{}],"node_modules/caniuse-lite/data/features/broadcastchannel.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n nB fB"},D:{"1":"4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"HC IC JC VB L","2":"G FC GC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:1,C:"BroadcastChannel"};

},{}],"node_modules/caniuse-lite/data/features/brotli.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"P H J K UB IB N","2":"C O T"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t nB fB"},D:{"1":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y","194":"z","257":"0"},E:{"1":"O hB iB","2":"G U I F E D A xB WB aB bB cB dB VB","513":"B C L S"},F:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l jB kB lB mB L EB oB S","194":"m n"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:6,C:"Brotli Accept-Encoding/Content-Encoding"};

},{}],"node_modules/caniuse-lite/data/features/calc.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","260":"D","516":"A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","33":"G U I F E D A B C O T P"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K","33":"V W X Y Z a b"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB","33":"I"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB","33":"sB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB","132":"CC DC"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"calc() as CSS unit value"};

},{}],"node_modules/caniuse-lite/data/features/canvas-blending.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"O T P H J K UB IB N","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","2":"G U I xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H jB kB lB mB L EB oB S"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"Canvas blend modes"};

},{}],"node_modules/caniuse-lite/data/features/canvas-text.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"gB","8":"I F E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","8":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","8":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","8":"D jB kB"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"B C Q L EB S","8":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Text API for Canvas"};

},{}],"node_modules/caniuse-lite/data/features/canvas.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"gB","8":"I F E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB fB","132":"qB GB nB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","132":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"260":"7B"},I:{"1":"GB G N BC HB CC DC","132":"8B 9B AC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Canvas (basic support)"};

},{}],"node_modules/caniuse-lite/data/features/ch-unit.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","132":"D A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c"},E:{"1":"F E D A B C O cB dB VB L S hB iB","2":"G U I xB WB aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"ch (character) unit"};

},{}],"node_modules/caniuse-lite/data/features/chacha20-poly1305.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i","129":"j k l m n o p q r s t u v Q x y"},E:{"1":"C O L S hB iB","2":"G U I F E D A B xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l jB kB lB mB L EB oB S"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC","16":"DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"ChaCha20-Poly1305 cipher suites for TLS"};

},{}],"node_modules/caniuse-lite/data/features/channel-messaging.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b nB fB","194":"c d e f g h i j k l m n o p q"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M mB L EB oB S","2":"D jB kB","16":"lB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Channel messaging"};

},{}],"node_modules/caniuse-lite/data/features/childnode-remove.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"O T P H J K UB IB N","16":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB","16":"I"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"ChildNode.remove()"};

},{}],"node_modules/caniuse-lite/data/features/classlist.js":[function(require,module,exports) {
module.exports={A:{A:{"8":"I F E D gB","1924":"A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","8":"qB GB nB","516":"a b","772":"G U I F E D A B C O T P H J K V W X Y Z fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","8":"G U I F","516":"a b c d","772":"Z","900":"E D A B C O T P H J K V W X Y"},E:{"1":"F E D A B C O cB dB VB L S hB iB","8":"G U xB WB","900":"I aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","8":"D B jB kB lB mB L","900":"C EB oB S"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","8":"WB pB HB","900":"rB sB"},H:{"900":"7B"},I:{"1":"N CC DC","8":"8B 9B AC","900":"GB G BC HB"},J:{"1":"A","900":"F"},K:{"1":"Q","8":"A B","900":"C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"900":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"classList (DOMTokenList)"};

},{}],"node_modules/caniuse-lite/data/features/clear-site-data-header.js":[function(require,module,exports) {
module.exports={A:{A:{"16":"I F E D A B gB"},B:{"1":"UB IB N","16":"C O T P H J K"},C:{"1":"9 DB BB w R M JB KB LB MB NB OB PB QB RB SB","16":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB nB fB"},D:{"1":"9 FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB"},E:{"16":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB CB DB BB w R M","16":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x jB kB lB mB L EB oB S"},G:{"16":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"16":"7B"},I:{"1":"N","16":"GB G 8B 9B AC BC HB CC DC"},J:{"16":"F A"},K:{"16":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"16":"A B"},O:{"16":"EC"},P:{"16":"G FC GC HC IC JC VB L"},Q:{"16":"KC"},R:{"16":"LC"},S:{"16":"MC"}},B:5,C:"Clear-Site-Data Header"};

},{}],"node_modules/caniuse-lite/data/features/client-hints-dpr-width-viewport.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"2":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:6,C:"Client Hints: DPR, Width, Viewport-Width"};

},{}],"node_modules/caniuse-lite/data/features/clipboard.js":[function(require,module,exports) {
module.exports={A:{A:{"2436":"I F E D A B gB"},B:{"260":"J K","2436":"C O T P H","10244":"UB IB N"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X nB fB","772":"Y Z a b c d e f g h i j k l m n o p q","4100":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"G U I F E D A B C","2564":"O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s","10244":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"C O S hB iB","16":"xB WB","2308":"A B VB L","2820":"G U I F E D aB bB cB dB"},F:{"2":"D B jB kB lB mB L EB oB","16":"C","516":"S","2564":"P H J K V W X Y Z a b c d e f","10244":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"1":"1B 2B 3B 4B 5B 6B","2":"WB pB HB","2820":"E rB sB tB uB vB wB XB yB zB 0B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB","2308":"N CC DC"},J:{"2":"F","2308":"A"},K:{"2":"A B C L EB","16":"S","3076":"Q"},L:{"2052":"N"},M:{"1028":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2052":"FC GC HC IC JC VB L","2308":"G"},Q:{"10244":"KC"},R:{"2052":"LC"},S:{"4100":"MC"}},B:5,C:"Synchronous Clipboard API"};

},{}],"node_modules/caniuse-lite/data/features/comparedocumentposition.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","16":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T","132":"P H J K V W X Y Z a b c d e f"},E:{"1":"A B C O VB L S hB iB","16":"G U I xB WB","132":"F E D bB cB dB","260":"aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","16":"D B jB kB lB mB L EB","132":"P H"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB","132":"E pB HB rB sB tB uB vB wB"},H:{"1":"7B"},I:{"1":"N CC DC","16":"8B 9B","132":"GB G AC BC HB"},J:{"132":"F A"},K:{"1":"C Q S","16":"A B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Node.compareDocumentPosition()"};

},{}],"node_modules/caniuse-lite/data/features/console-basic.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F gB","132":"E D"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M L EB oB S","2":"D jB kB lB mB"},G:{"1":"WB pB HB rB","513":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"4097":"7B"},I:{"1025":"GB G N 8B 9B AC BC HB CC DC"},J:{"258":"F A"},K:{"2":"A","258":"B C Q L EB S"},L:{"1025":"N"},M:{"2049":"M"},N:{"258":"A B"},O:{"258":"EC"},P:{"1025":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1025":"LC"},S:{"1":"MC"}},B:1,C:"Basic console logging functions"};

},{}],"node_modules/caniuse-lite/data/features/console-time.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D A gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M L EB oB S","2":"D jB kB lB mB","16":"B"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"Q","16":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"console.time and console.timeEnd"};

},{}],"node_modules/caniuse-lite/data/features/const.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","2052":"B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","132":"qB GB G U I F E D A B C nB fB","260":"O T P H J K V W X Y Z a b c d e f g h i j k l"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","260":"G U I F E D A B C O T P H J K V W","772":"X Y Z a b c d e f g h i j k l m n o p q","1028":"r s t u v Q x y"},E:{"1":"A B C O VB L S hB iB","260":"G U xB WB","772":"I F E D aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D jB","132":"B kB lB mB L EB","644":"C oB S","772":"P H J K V W X Y Z a b c d","1028":"e f g h i j k l"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","260":"WB pB HB","772":"E rB sB tB uB vB wB"},H:{"644":"7B"},I:{"1":"N","16":"8B 9B","260":"AC","772":"GB G BC HB CC DC"},J:{"772":"F A"},K:{"1":"Q","132":"A B L EB","644":"C S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","1028":"G"},Q:{"1":"KC"},R:{"1028":"LC"},S:{"1":"MC"}},B:6,C:"const"};

},{}],"node_modules/caniuse-lite/data/features/constraint-validation.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","900":"A B"},B:{"1":"J K UB IB N","388":"T P H","900":"C O"},C:{"1":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","260":"0 z","388":"f g h i j k l m n o p q r s t u v Q x y","900":"G U I F E D A B C O T P H J K V W X Y Z a b c d e"},D:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T","388":"b c d e f g h i j k l m n o p","900":"P H J K V W X Y Z a"},E:{"1":"A B C O VB L S hB iB","16":"G U xB WB","388":"E D cB dB","900":"I F aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","16":"D B jB kB lB mB L EB","388":"P H J K V W X Y Z a b c","900":"C oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB","388":"E tB uB vB wB","900":"rB sB"},H:{"2":"7B"},I:{"1":"N","16":"GB 8B 9B AC","388":"CC DC","900":"G BC HB"},J:{"16":"F","388":"A"},K:{"1":"Q","16":"A B L EB","900":"C S"},L:{"1":"N"},M:{"1":"M"},N:{"900":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"388":"MC"}},B:1,C:"Constraint Validation API"};

},{}],"node_modules/caniuse-lite/data/features/contenteditable.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB","4":"GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"2":"7B"},I:{"1":"GB G N BC HB CC DC","2":"8B 9B AC"},J:{"1":"F A"},K:{"1":"Q S","2":"A B C L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"contenteditable attribute (basic support)"};

},{}],"node_modules/caniuse-lite/data/features/contentsecuritypolicy.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","132":"A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","129":"G U I F E D A B C O T P H J K V W X Y"},D:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O","257":"T P H J K V W X Y Z a"},E:{"1":"F E D A B C O cB dB VB L S hB iB","2":"G U xB WB","257":"I bB","260":"aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB","257":"sB","260":"rB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"2":"F","257":"A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"132":"A B"},O:{"257":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"Content Security Policy 1.0"};

},{}],"node_modules/caniuse-lite/data/features/contentsecuritypolicy2.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T","32772":"P H J K"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g nB fB","132":"h i j k","260":"l","516":"m n o p q r s t u","8196":"0 1 2 3 4 5 6 7 8 9 v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l","1028":"m n o","2052":"p"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y jB kB lB mB L EB oB S","1028":"Z a b","2052":"c"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"4100":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"8196":"MC"}},B:2,C:"Content Security Policy Level 2"};

},{}],"node_modules/caniuse-lite/data/features/cors.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F gB","132":"A","260":"E D"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB LB MB NB OB PB QB RB SB nB fB","2":"qB GB","1025":"9 FB CB DB BB w R M JB KB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","132":"G U I F E D A B C"},E:{"2":"xB WB","513":"I F E D A B C O bB cB dB VB L S hB iB","644":"G U aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B jB kB lB mB L EB oB"},G:{"513":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","644":"WB pB HB rB"},H:{"2":"7B"},I:{"1":"N CC DC","132":"GB G 8B 9B AC BC HB"},J:{"1":"A","132":"F"},K:{"1":"C Q S","2":"A B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","132":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Cross-Origin Resource Sharing"};

},{}],"node_modules/caniuse-lite/data/features/createimagebitmap.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r nB fB","3076":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","132":"0 1","260":"2 3","516":"4 5 6 7 8"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S","16":"hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m jB kB lB mB L EB oB S","132":"n o","260":"p q","516":"r s t u v"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"3076":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"GC HC IC JC VB L","16":"G FC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"3076":"MC"}},B:1,C:"createImageBitmap"};

},{}],"node_modules/caniuse-lite/data/features/credential-management.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x","66":"0 y z","129":"1 2 3 4 5 6"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"HC IC JC VB L","2":"G FC GC"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"Credential Management API"};

},{}],"node_modules/caniuse-lite/data/features/cryptography.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"gB","8":"I F E D A","164":"B"},B:{"1":"UB IB N","513":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","8":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h nB fB","66":"i j"},D:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","8":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m"},E:{"1":"B C O L S hB iB","8":"G U I F xB WB aB bB","289":"E D A cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","8":"D B C P H J K V W X Y Z jB kB lB mB L EB oB S"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","8":"WB pB HB rB sB tB","289":"E uB vB wB XB yB"},H:{"2":"7B"},I:{"1":"N","8":"GB G 8B 9B AC BC HB CC DC"},J:{"8":"F A"},K:{"1":"Q","8":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"8":"A","164":"B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"Web Cryptography"};

},{}],"node_modules/caniuse-lite/data/features/css-all.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m"},E:{"1":"A B C O dB VB L S hB iB","2":"G U I F E D xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z jB kB lB mB L EB oB S"},G:{"1":"wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB"},H:{"2":"7B"},I:{"1":"N DC","2":"GB G 8B 9B AC BC HB CC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS all property"};

},{}],"node_modules/caniuse-lite/data/features/css-animation.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G nB fB","33":"U I F E D A B C O T P"},D:{"1":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","33":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s"},E:{"1":"D A B C O dB VB L S hB iB","2":"xB WB","33":"I F E aB bB cB","292":"G U"},F:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B jB kB lB mB L EB oB","33":"C P H J K V W X Y Z a b c d e f"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","33":"E sB tB uB","164":"WB pB HB rB"},H:{"2":"7B"},I:{"1":"N","33":"G BC HB CC DC","164":"GB 8B 9B AC"},J:{"33":"F A"},K:{"1":"Q S","2":"A B C L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"33":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"CSS Animation"};

},{}],"node_modules/caniuse-lite/data/features/css-any-link.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","16":"qB","33":"GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"9 w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T","33":"0 1 2 3 4 5 6 7 8 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB"},E:{"1":"D A B C O dB VB L S hB iB","16":"G U I xB WB aB","33":"F E bB cB"},F:{"1":"2 3 4 5 6 7 8 9 AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","33":"0 1 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB rB","33":"E sB tB uB"},H:{"2":"7B"},I:{"1":"N","16":"GB G 8B 9B AC BC HB","33":"CC DC"},J:{"16":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"33":"EC"},P:{"1":"JC VB L","16":"G","33":"FC GC HC IC"},Q:{"1":"KC"},R:{"1":"LC"},S:{"33":"MC"}},B:5,C:"CSS :any-link selector"};

},{}],"node_modules/caniuse-lite/data/features/css-appearance.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"164":"UB IB N","388":"C O T P H J K"},C:{"164":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","676":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k nB fB"},D:{"1":"ZB YB","33":"eB","164":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N"},E:{"164":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","164":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"164":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"164":"GB G N 8B 9B AC BC HB CC DC"},J:{"164":"F A"},K:{"2":"A B C L EB S","164":"Q"},L:{"164":"N"},M:{"164":"M"},N:{"2":"A","388":"B"},O:{"164":"EC"},P:{"164":"G FC GC HC IC JC VB L"},Q:{"164":"KC"},R:{"164":"LC"},S:{"164":"MC"}},B:5,C:"CSS Appearance"};

},{}],"node_modules/caniuse-lite/data/features/css-apply-rule.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","194":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","194":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n jB kB lB mB L EB oB S","194":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C L EB S","194":"Q"},L:{"194":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G","194":"FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"194":"LC"},S:{"2":"MC"}},B:7,C:"CSS @apply rule"};

},{}],"node_modules/caniuse-lite/data/features/css-at-counter-style.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i nB fB","132":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"132":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"132":"MC"}},B:4,C:"CSS Counter Styles"};

},{}],"node_modules/caniuse-lite/data/features/css-backdrop-filter.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H","257":"J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB nB fB","578":"KB LB MB NB OB PB QB RB SB"},D:{"1":"QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q","194":"0 1 2 3 4 5 6 7 8 9 x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB"},E:{"2":"G U I F E xB WB aB bB cB","33":"D A B C O dB VB L S hB iB"},F:{"1":"9 BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j jB kB lB mB L EB oB S","194":"0 1 2 3 4 5 6 7 8 k l m n o p q r s t u v Q x y z AB CB DB"},G:{"2":"E WB pB HB rB sB tB uB","33":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C L EB S","194":"Q"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G","194":"FC GC HC IC JC VB L"},Q:{"194":"KC"},R:{"194":"LC"},S:{"2":"MC"}},B:7,C:"CSS Backdrop Filter"};

},{}],"node_modules/caniuse-lite/data/features/css-background-offsets.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a"},E:{"1":"F E D A B C O cB dB VB L S hB iB","2":"G U I xB WB aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D jB kB"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB"},H:{"1":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS background-position edge offsets"};

},{}],"node_modules/caniuse-lite/data/features/css-backgroundblendmode.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k","260":"Q"},E:{"1":"B C O VB L S hB iB","2":"G U I F xB WB aB bB","132":"E D A cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X jB kB lB mB L EB oB S","260":"j"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB","132":"E uB vB wB XB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C L EB S","260":"Q"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS background-blend-mode"};

},{}],"node_modules/caniuse-lite/data/features/css-boxdecorationbreak.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","164":"UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h nB fB"},D:{"2":"G U I F E D A B C O T P H J K V W X","164":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I xB WB aB","164":"F E D A B C O bB cB dB VB L S hB iB"},F:{"2":"D jB kB lB mB","129":"B C L EB oB S","164":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"WB pB HB rB sB","164":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"132":"7B"},I:{"2":"GB G 8B 9B AC BC HB","164":"N CC DC"},J:{"2":"F","164":"A"},K:{"2":"A","129":"B C L EB S","164":"Q"},L:{"164":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"164":"G FC GC HC IC JC VB L"},Q:{"164":"KC"},R:{"164":"LC"},S:{"1":"MC"}},B:5,C:"CSS box-decoration-break"};

},{}],"node_modules/caniuse-lite/data/features/css-boxshadow.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB","33":"nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","33":"G U I F E D"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","33":"U","164":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D jB kB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","33":"pB HB","164":"WB"},H:{"2":"7B"},I:{"1":"G N BC HB CC DC","164":"GB 8B 9B AC"},J:{"1":"A","33":"F"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS3 Box-shadow"};

},{}],"node_modules/caniuse-lite/data/features/css-canvas.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","16":"2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","33":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x"},E:{"2":"xB WB","33":"G U I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","33":"P H J K V W X Y Z a b c d e f g h i j k"},G:{"33":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"N","33":"GB G 8B 9B AC BC HB CC DC"},J:{"33":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"FC GC HC IC JC VB L","33":"G"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"CSS Canvas Drawings"};

},{}],"node_modules/caniuse-lite/data/features/css-caret-color.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"C O L S hB iB","2":"G U I F E D A B xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t jB kB lB mB L EB oB S"},G:{"1":"0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"HC IC JC VB L","2":"G FC GC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:4,C:"CSS caret-color"};

},{}],"node_modules/caniuse-lite/data/features/css-case-insensitive.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l jB kB lB mB L EB oB S"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:5,C:"Case-insensitive CSS attribute selectors"};

},{}],"node_modules/caniuse-lite/data/features/css-clip-path.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J","260":"UB IB N","3138":"K"},C:{"1":"4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB","132":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q nB fB","644":"0 1 2 3 x y z"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z","260":"5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","292":"0 1 2 3 4 a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"2":"G U I xB WB aB bB","292":"F E D A B C O cB dB VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","260":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z AB CB DB BB w R M","292":"P H J K V W X Y Z a b c d e f g h i j k l m n o p q r"},G:{"2":"WB pB HB rB sB","292":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB","260":"N","292":"CC DC"},J:{"2":"F A"},K:{"2":"A B C L EB S","292":"Q"},L:{"260":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"292":"EC"},P:{"292":"G FC GC HC IC JC VB L"},Q:{"292":"KC"},R:{"260":"LC"},S:{"644":"MC"}},B:4,C:"CSS clip-path property (for HTML)"};

},{}],"node_modules/caniuse-lite/data/features/css-color-adjust.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","33":"UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x nB fB"},D:{"16":"G U I F E D A B C O T P H J K","33":"0 1 2 3 4 5 6 7 8 9 V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U xB WB aB","33":"I F E D A B C O bB cB dB VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","33":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"16":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"16":"GB G N 8B 9B AC BC HB CC DC"},J:{"16":"F A"},K:{"2":"A B C Q L EB S"},L:{"16":"N"},M:{"1":"M"},N:{"16":"A B"},O:{"16":"EC"},P:{"16":"G FC GC HC IC JC VB L"},Q:{"33":"KC"},R:{"16":"LC"},S:{"1":"MC"}},B:5,C:"CSS color-adjust"};

},{}],"node_modules/caniuse-lite/data/features/css-conic-gradients.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB nB fB","578":"PB QB RB SB"},D:{"1":"JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","194":"9 TB AB FB CB DB BB w R M"},E:{"1":"O S hB iB","2":"G U I F E D A B C xB WB aB bB cB dB VB L"},F:{"1":"9 BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v jB kB lB mB L EB oB S","194":"0 1 2 3 4 5 6 7 8 Q x y z AB CB DB"},G:{"1":"2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"VB L","2":"G FC GC HC IC JC"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"CSS Conical Gradients"};

},{}],"node_modules/caniuse-lite/data/features/css-containment.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q nB fB","322":"0 1 r s t u v Q x y z","336":"2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M"},D:{"1":"2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","194":"1"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n jB kB lB mB L EB oB S","194":"o p"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"322":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"GC HC IC JC VB L","2":"G FC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"322":"MC"}},B:4,C:"CSS Containment"};

},{}],"node_modules/caniuse-lite/data/features/css-counters.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"E D A B","2":"I F gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"CSS Counters"};

},{}],"node_modules/caniuse-lite/data/features/css-crisp-edges.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I gB","2340":"F E D A B"},B:{"2":"C O T P H J K","1025":"UB IB N"},C:{"2":"qB GB nB","513":"9 w R M JB KB LB MB NB OB PB QB RB SB","545":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB fB"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q","1025":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"A B C O VB L S hB iB","2":"G U xB WB aB","164":"I","4644":"F E D bB cB dB"},F:{"2":"D B P H J K V W X Y Z a b c d jB kB lB mB L EB","545":"C oB S","1025":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB","4260":"rB sB","4644":"E tB uB vB wB"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","1025":"N"},J:{"2":"F","4260":"A"},K:{"2":"A B L EB","545":"C S","1025":"Q"},L:{"1025":"N"},M:{"545":"M"},N:{"2340":"A B"},O:{"1":"EC"},P:{"1025":"G FC GC HC IC JC VB L"},Q:{"1025":"KC"},R:{"1025":"LC"},S:{"4097":"MC"}},B:7,C:"Crisp edges/pixelated images"};

},{}],"node_modules/caniuse-lite/data/features/css-cross-fade.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","33":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"G U I F E D A B C O T P H","33":"0 1 2 3 4 5 6 7 8 9 J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"A B C O VB L S hB iB","2":"G U xB WB","33":"I F E D aB bB cB dB"},F:{"2":"D B C jB kB lB mB L EB oB S","33":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB","33":"E rB sB tB uB vB wB"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB","33":"N CC DC"},J:{"2":"F A"},K:{"2":"A B C L EB S","33":"Q"},L:{"33":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"33":"EC"},P:{"33":"G FC GC HC IC JC VB L"},Q:{"33":"KC"},R:{"33":"LC"},S:{"2":"MC"}},B:4,C:"CSS Cross-Fade Function"};

},{}],"node_modules/caniuse-lite/data/features/css-default-pseudo.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","16":"qB GB nB fB"},D:{"1":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T","132":"0 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"B C O VB L S hB iB","16":"G U xB WB","132":"I F E D A aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z AB CB DB BB w R M","16":"D B jB kB lB mB L EB","132":"P H J K V W X Y Z a b c d e f g h i j k l m n","260":"C oB S"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB rB sB","132":"E tB uB vB wB XB"},H:{"260":"7B"},I:{"1":"N","16":"GB 8B 9B AC","132":"G BC HB CC DC"},J:{"16":"F","132":"A"},K:{"1":"Q","16":"A B C L EB","260":"S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"132":"EC"},P:{"1":"FC GC HC IC JC VB L","132":"G"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:7,C:":default CSS pseudo-class"};

},{}],"node_modules/caniuse-lite/data/features/css-descendant-gtgt.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K IB N","16":"UB"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N","16":"eB ZB YB"},E:{"1":"B","2":"G U I F E D A C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Explicit descendant combinator >>"};

},{}],"node_modules/caniuse-lite/data/features/css-deviceadaptation.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","164":"A B"},B:{"66":"UB IB N","164":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e","66":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p jB kB lB mB L EB oB S","66":"0 1 2 3 4 5 6 7 8 9 q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"292":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A Q","292":"B C L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"164":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"66":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"CSS Device Adaptation"};

},{}],"node_modules/caniuse-lite/data/features/css-dir-pseudo.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H nB fB","33":"J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"33":"MC"}},B:5,C:":dir() CSS pseudo-class"};

},{}],"node_modules/caniuse-lite/data/features/css-display-contents.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","260":"UB IB N"},C:{"1":"9 CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m nB fB","260":"0 1 2 3 4 5 6 7 8 n o p q r s t u v Q x y z TB AB FB"},D:{"2":"0 1 2 3 4 5 6 7 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","194":"8 TB AB FB CB DB BB","260":"9 w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"hB iB","2":"G U I F E D A B xB WB aB bB cB dB VB","260":"O","772":"C L S"},F:{"2":"0 1 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S","260":"2 3 4 5 6 7 8 9 AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB","260":"0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","260":"N"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"260":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC","260":"JC VB L"},Q:{"260":"KC"},R:{"2":"LC"},S:{"260":"MC"}},B:5,C:"CSS display: contents"};

},{}],"node_modules/caniuse-lite/data/features/css-element-function.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"33":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","164":"qB GB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"33":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"33":"MC"}},B:5,C:"CSS element() function"};

},{}],"node_modules/caniuse-lite/data/features/css-env-function.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"9 w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB nB fB"},D:{"1":"JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M"},E:{"1":"C O L S hB iB","2":"G U I F E D A xB WB aB bB cB dB VB","132":"B"},F:{"1":"6 7 8 9 AB CB DB BB w R M","2":"0 1 2 3 4 5 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"1":"0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB","132":"zB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"VB L","2":"G FC GC HC IC JC"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"CSS Environment Variables env()"};

},{}],"node_modules/caniuse-lite/data/features/css-exclusions.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","33":"A B"},B:{"2":"UB IB N","33":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"33":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"CSS Exclusions Level 1"};

},{}],"node_modules/caniuse-lite/data/features/css-featurequeries.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B C jB kB lB mB L EB oB"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"1":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS Feature Queries"};

},{}],"node_modules/caniuse-lite/data/features/css-filter-function.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB","33":"D"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB","33":"vB wB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"CSS filter() function"};

},{}],"node_modules/caniuse-lite/data/features/css-filters.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","1028":"O T P H J K","1346":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB","196":"k","516":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j fB"},D:{"1":"3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J","33":"0 1 2 K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"A B C O dB VB L S hB iB","2":"G U xB WB aB","33":"I F E D bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","33":"P H J K V W X Y Z a b c d e f g h i j k l m n o p"},G:{"1":"wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB","33":"E sB tB uB vB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB","33":"CC DC"},J:{"2":"F","33":"A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"HC IC JC VB L","33":"G FC GC"},Q:{"1":"KC"},R:{"33":"LC"},S:{"1":"MC"}},B:5,C:"CSS Filter Effects"};

},{}],"node_modules/caniuse-lite/data/features/css-first-letter.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","16":"gB","516":"E","1540":"I F"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","132":"GB","260":"qB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"U I F E","132":"G"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","16":"U xB","132":"G WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","16":"D jB","260":"B kB lB mB L EB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB"},H:{"1":"7B"},I:{"1":"GB G N BC HB CC DC","16":"8B 9B","132":"AC"},J:{"1":"F A"},K:{"1":"C Q S","260":"A B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"::first-letter CSS pseudo-element selector"};

},{}],"node_modules/caniuse-lite/data/features/css-first-line.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","132":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"CSS first-line pseudo-element"};

},{}],"node_modules/caniuse-lite/data/features/css-fixed.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"F E D A B","2":"gB","8":"I"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB VB L S hB iB","1025":"dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB","132":"rB sB tB"},H:{"2":"7B"},I:{"1":"GB N CC DC","260":"8B 9B AC","513":"G BC HB"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"CSS position:fixed"};

},{}],"node_modules/caniuse-lite/data/features/css-focus-visible.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","328":"UB IB N"},C:{"2":"qB GB nB fB","161":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w","328":"R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB jB kB lB mB L EB oB S","328":"w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"328":"N"},M:{"161":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"161":"MC"}},B:7,C:":focus-visible CSS pseudo-class"};

},{}],"node_modules/caniuse-lite/data/features/css-focus-within.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"9 AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","194":"TB"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v jB kB lB mB L EB oB S","194":"Q"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"IC JC VB L","2":"G FC GC HC"},Q:{"1":"KC"},R:{"16":"LC"},S:{"2":"MC"}},B:7,C:":focus-within CSS pseudo-class"};

},{}],"node_modules/caniuse-lite/data/features/css-font-rendering-controls.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v nB fB","322":"0 1 2 3 4 5 6 7 Q x y z"},D:{"1":"9 AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y","194":"0 1 2 3 4 5 6 7 8 z TB"},E:{"1":"C O L S hB iB","2":"G U I F E D A B xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l jB kB lB mB L EB oB S","194":"m n o p q r s t u v Q"},G:{"1":"0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C L EB S","194":"Q"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"IC JC VB L","2":"G","194":"FC GC HC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"322":"MC"}},B:5,C:"CSS font-rendering controls"};

},{}],"node_modules/caniuse-lite/data/features/css-font-stretch.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x"},E:{"1":"B C O L S hB iB","2":"G U I F E D A xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS font-stretch"};

},{}],"node_modules/caniuse-lite/data/features/css-gencontent.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F gB","132":"E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"CSS Generated content for pseudo-elements"};

},{}],"node_modules/caniuse-lite/data/features/css-gradients.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB","260":"H J K V W X Y Z a b c d e f g h i j k l","292":"G U I F E D A B C O T P fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","33":"A B C O T P H J K V W X Y Z a b","548":"G U I F E D"},E:{"2":"xB WB","260":"F E D A B C O bB cB dB VB L S hB iB","292":"I aB","804":"G U"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B jB kB lB mB","33":"C oB","164":"L EB"},G:{"260":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","292":"rB sB","804":"WB pB HB"},H:{"2":"7B"},I:{"1":"N CC DC","33":"G BC HB","548":"GB 8B 9B AC"},J:{"1":"A","548":"F"},K:{"1":"Q S","2":"A B","33":"C","164":"L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS Gradients"};

},{}],"node_modules/caniuse-lite/data/features/css-grid.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","8":"D","292":"A B"},B:{"1":"H J K UB IB N","292":"C O T P"},C:{"1":"4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K nB fB","8":"V W X Y Z a b c d e f g h i j k l m n o p","584":"0 1 q r s t u v Q x y z","1025":"2 3"},D:{"1":"8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a","8":"b c d e","200":"0 1 2 3 4 5 6 f g h i j k l m n o p q r s t u v Q x y z","1025":"7"},E:{"1":"B C O VB L S hB iB","2":"G U xB WB aB","8":"I F E D A bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d jB kB lB mB L EB oB S","200":"e f g h i j k l m n o p q r s t"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB","8":"E sB tB uB vB wB XB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC","8":"HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"292":"A B"},O:{"1":"EC"},P:{"1":"GC HC IC JC VB L","2":"FC","8":"G"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:4,C:"CSS Grid Layout (level 1)"};

},{}],"node_modules/caniuse-lite/data/features/css-hanging-punctuation.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"CSS hanging-punctuation"};

},{}],"node_modules/caniuse-lite/data/features/css-has.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:":has() CSS relational pseudo-class"};

},{}],"node_modules/caniuse-lite/data/features/css-hyphenate.js":[function(require,module,exports) {
module.exports={A:{A:{"16":"I F E D A B gB"},B:{"1":"UB IB N","16":"C O T P H J K"},C:{"16":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"0 1 2 3 4 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"16":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"16":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"16":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"16":"7B"},I:{"16":"GB G N 8B 9B AC BC HB CC DC"},J:{"16":"F A"},K:{"16":"A B C Q L EB S"},L:{"16":"N"},M:{"16":"M"},N:{"16":"A B"},O:{"16":"EC"},P:{"16":"G FC GC HC IC JC VB L"},Q:{"16":"KC"},R:{"16":"LC"},S:{"16":"MC"}},B:5,C:"CSS4 Hyphenation"};

},{}],"node_modules/caniuse-lite/data/features/css-hyphens.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","33":"A B"},B:{"33":"C O T P H J K","132":"UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U nB fB","33":"I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s"},D:{"2":"0 1 2 3 4 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","132":"5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U xB WB","33":"I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r jB kB lB mB L EB oB S","132":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z AB CB DB BB w R M"},G:{"2":"WB pB","33":"E HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","132":"N"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"132":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"4":"EC"},P:{"1":"GC HC IC JC VB L","2":"G","132":"FC"},Q:{"2":"KC"},R:{"132":"LC"},S:{"1":"MC"}},B:5,C:"CSS Hyphenation"};

},{}],"node_modules/caniuse-lite/data/features/css-image-orientation.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"N","2":"C O T P H J K UB IB"},C:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b nB fB"},D:{"1":"N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"M","2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R jB kB lB mB L EB oB S"},G:{"132":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:4,C:"CSS3 image-orientation"};

},{}],"node_modules/caniuse-lite/data/features/css-image-set.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","33":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"G U I F E D A B C O T P H J K V W","33":"0 1 2 3 4 5 6 7 8 9 X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U xB WB aB","33":"I F E D bB cB dB","129":"A B C O VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","33":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"WB pB HB rB","33":"E sB tB uB vB wB","129":"XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB","33":"N CC DC"},J:{"2":"F","33":"A"},K:{"2":"A B C L EB S","33":"Q"},L:{"33":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"33":"EC"},P:{"33":"G FC GC HC IC JC VB L"},Q:{"33":"KC"},R:{"33":"LC"},S:{"2":"MC"}},B:5,C:"CSS image-set"};

},{}],"node_modules/caniuse-lite/data/features/css-in-out-of-range.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C","260":"O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e nB fB","516":"f g h i j k l m n o p q r s t u v Q x y z"},D:{"1":"3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G","16":"U I F E D A B C O T","260":"2","772":"0 1 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"B C O VB L S hB iB","2":"G xB WB","16":"U","772":"I F E D A aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v Q x y z AB CB DB BB w R M","16":"D jB","260":"B C p kB lB mB L EB oB S","772":"P H J K V W X Y Z a b c d e f g h i j k l m n o"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB","772":"E rB sB tB uB vB wB XB"},H:{"132":"7B"},I:{"1":"N","2":"GB 8B 9B AC","260":"G BC HB CC DC"},J:{"2":"F","260":"A"},K:{"1":"Q","260":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","260":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"516":"MC"}},B:5,C:":in-range and :out-of-range CSS pseudo-classes"};

},{}],"node_modules/caniuse-lite/data/features/css-indeterminate-pseudo.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","132":"A B","388":"D"},B:{"1":"UB IB N","132":"C O T P H J K"},C:{"1":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","16":"qB GB nB fB","132":"0 I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","388":"G U"},D:{"1":"0 1 2 3 4 5 6 7 8 9 p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T","132":"P H J K V W X Y Z a b c d e f g h i j k l m n o"},E:{"1":"B C O VB L S hB iB","16":"G U I xB WB","132":"F E D A bB cB dB","388":"aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","16":"D B jB kB lB mB L EB","132":"P H J K V W X Y Z a b","516":"C oB S"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB rB sB","132":"E tB uB vB wB XB"},H:{"516":"7B"},I:{"1":"N","16":"GB 8B 9B AC DC","132":"CC","388":"G BC HB"},J:{"16":"F","132":"A"},K:{"1":"Q","16":"A B C L EB","516":"S"},L:{"1":"N"},M:{"132":"M"},N:{"132":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"132":"MC"}},B:7,C:":indeterminate CSS pseudo-class"};

},{}],"node_modules/caniuse-lite/data/features/css-initial-letter.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E xB WB aB bB cB","4":"D","164":"A B C O dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB","164":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"CSS Initial Letter"};

},{}],"node_modules/caniuse-lite/data/features/css-initial-value.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","33":"G U I F E D A B C O T P H J K nB fB","164":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O WB aB bB cB dB VB L S hB iB","16":"xB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB"},H:{"2":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS initial value"};

},{}],"node_modules/caniuse-lite/data/features/css-letter-spacing.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","16":"gB","132":"I F E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","132":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","16":"xB","132":"G U I WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","16":"D jB","132":"B C P H kB lB mB L EB oB S"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB"},H:{"2":"7B"},I:{"1":"N CC DC","16":"8B 9B","132":"GB G AC BC HB"},J:{"132":"F A"},K:{"1":"Q","132":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"letter-spacing CSS property"};

},{}],"node_modules/caniuse-lite/data/features/css-line-clamp.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H","33":"UB IB N","129":"J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R nB fB","33":"M JB KB LB MB NB OB PB QB RB SB"},D:{"16":"G U I F E D A B C O","33":"0 1 2 3 4 5 6 7 8 9 T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G xB WB","33":"U I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","33":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"WB pB HB","33":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"16":"8B 9B","33":"GB G N AC BC HB CC DC"},J:{"33":"F A"},K:{"2":"A B C L EB S","33":"Q"},L:{"33":"N"},M:{"33":"M"},N:{"2":"A B"},O:{"33":"EC"},P:{"33":"G FC GC HC IC JC VB L"},Q:{"33":"KC"},R:{"33":"LC"},S:{"2":"MC"}},B:7,C:"CSS line-clamp"};

},{}],"node_modules/caniuse-lite/data/features/css-logical-props.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB","164":"GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q nB fB"},D:{"1":"JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","292":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M"},E:{"1":"O S hB iB","292":"G U I F E D A B C xB WB aB bB cB dB VB L"},F:{"1":"w R M","2":"D B C jB kB lB mB L EB oB S","292":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB"},G:{"1":"2B 3B 4B 5B 6B","292":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B"},H:{"2":"7B"},I:{"1":"N","292":"GB G 8B 9B AC BC HB CC DC"},J:{"292":"F A"},K:{"2":"A B C L EB S","292":"Q"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"292":"EC"},P:{"1":"VB L","292":"G FC GC HC IC JC"},Q:{"292":"KC"},R:{"292":"LC"},S:{"1":"MC"}},B:5,C:"CSS Logical Properties"};

},{}],"node_modules/caniuse-lite/data/features/css-marker-pseudo.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"1":"M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B xB WB aB bB cB dB VB","129":"C O L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"CSS ::marker pseudo-element"};

},{}],"node_modules/caniuse-lite/data/features/css-masks.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H","164":"UB IB N","3138":"J","12292":"K"},C:{"1":"3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB","260":"0 1 2 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"164":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"xB WB","164":"G U I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","164":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"164":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"164":"N CC DC","676":"GB G 8B 9B AC BC HB"},J:{"164":"F A"},K:{"2":"A B C L EB S","164":"Q"},L:{"164":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"164":"EC"},P:{"164":"G FC GC HC IC JC VB L"},Q:{"164":"KC"},R:{"164":"LC"},S:{"260":"MC"}},B:4,C:"CSS Masks"};

},{}],"node_modules/caniuse-lite/data/features/css-matches-pseudo.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","1348":"UB IB N"},C:{"16":"qB GB nB fB","548":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"16":"G U I F E D A B C O T","164":"0 1 2 3 4 5 6 7 8 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB","1348":"9 w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G xB WB","16":"U","164":"I F E aB bB cB","257":"D A B C O dB VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","164":"0 1 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","1220":"2 3 4 5 6 7 8 9 AB CB DB BB","1348":"w R M"},G:{"16":"WB pB HB rB sB","164":"E tB uB","257":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"16":"GB 8B 9B AC","164":"G N BC HB CC DC"},J:{"16":"F","164":"A"},K:{"2":"A B C L EB S","164":"Q"},L:{"1220":"N"},M:{"548":"M"},N:{"2":"A B"},O:{"164":"EC"},P:{"164":"G FC GC HC IC JC VB L"},Q:{"1348":"KC"},R:{"164":"LC"},S:{"548":"MC"}},B:5,C:":matches() CSS pseudo-class"};

},{}],"node_modules/caniuse-lite/data/features/css-math-functions.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB nB fB"},D:{"1":"UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},E:{"1":"hB iB","2":"G U I F E D A B xB WB aB bB cB dB VB","132":"C O L S"},F:{"1":"w R M","2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB jB kB lB mB L EB oB S"},G:{"1":"6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB","132":"0B 1B 2B 3B 4B 5B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"CSS math functions min(), max() and clamp()"};

},{}],"node_modules/caniuse-lite/data/features/css-media-interaction.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"9 BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d jB kB lB mB L EB oB S"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:5,C:"Media Queries: interaction media features"};

},{}],"node_modules/caniuse-lite/data/features/css-media-resolution.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","132":"D A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB","260":"G U I F E D A B C O T P nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","548":"G U I F E D A B C O T P H J K V W X Y Z a b c d e"},E:{"2":"xB WB","548":"G U I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D","548":"B C jB kB lB mB L EB oB"},G:{"16":"WB","548":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"132":"7B"},I:{"1":"N CC DC","16":"8B 9B","548":"GB G AC BC HB"},J:{"548":"F A"},K:{"1":"Q S","548":"A B C L EB"},L:{"1":"N"},M:{"1":"M"},N:{"132":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"Media Queries: resolution feature"};

},{}],"node_modules/caniuse-lite/data/features/css-media-scripting.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"16":"C O T P H J K UB IB N"},C:{"2":"0 1 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","16":"2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N","16":"eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"Media Queries: scripting media feature"};

},{}],"node_modules/caniuse-lite/data/features/css-mediaqueries.js":[function(require,module,exports) {
module.exports={A:{A:{"8":"I F E gB","129":"D A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","129":"G U I F E D A B C O T P H J K V W X Y Z a b"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","129":"G U I aB","388":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","2":"D"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","129":"WB pB HB rB sB"},H:{"1":"7B"},I:{"1":"N CC DC","129":"GB G 8B 9B AC BC HB"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"129":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"CSS3 Media Queries"};

},{}],"node_modules/caniuse-lite/data/features/css-mixblendmode.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e","194":"f g h i j k l m n o p q"},E:{"2":"G U I F xB WB aB bB","260":"E D A B C O cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e jB kB lB mB L EB oB S"},G:{"2":"WB pB HB rB sB tB","260":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"Blending of HTML/SVG elements"};

},{}],"node_modules/caniuse-lite/data/features/css-motion-paths.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s","194":"t u v"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f jB kB lB mB L EB oB S","194":"g h i"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:5,C:"CSS Motion Path"};

},{}],"node_modules/caniuse-lite/data/features/css-namespaces.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","16":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"CSS namespaces"};

},{}],"node_modules/caniuse-lite/data/features/css-not-sel-list.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K IB N","16":"UB"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB nB fB","16":"RB SB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N","16":"eB ZB YB"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"selector list argument of :not()"};

},{}],"node_modules/caniuse-lite/data/features/css-nth-child-of.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"selector list argument of :nth-child and :nth-last-child CSS pseudo-classes"};

},{}],"node_modules/caniuse-lite/data/features/css-opacity.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","4":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"CSS3 Opacity"};

},{}],"node_modules/caniuse-lite/data/features/css-optional-pseudo.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","16":"D jB","132":"B C kB lB mB L EB oB S"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"132":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"Q","132":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:7,C:":optional CSS pseudo-class"};

},{}],"node_modules/caniuse-lite/data/features/css-overflow-anchor.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB nB fB"},D:{"1":"6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"2":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:5,C:"CSS overflow-anchor (Scroll Anchoring)"};

},{}],"node_modules/caniuse-lite/data/features/css-overflow.js":[function(require,module,exports) {
module.exports={A:{A:{"388":"I F E D A B gB"},B:{"260":"UB IB N","388":"C O T P H J K"},C:{"260":"9 FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","388":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB nB fB"},D:{"260":"M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","388":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R"},E:{"260":"hB iB","388":"G U I F E D A B C O xB WB aB bB cB dB VB L S"},F:{"260":"5 6 7 8 9 AB CB DB BB w R M","388":"0 1 2 3 4 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"260":"6B","388":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B"},H:{"388":"7B"},I:{"388":"GB G N 8B 9B AC BC HB CC DC"},J:{"388":"F A"},K:{"388":"A B C Q L EB S"},L:{"260":"N"},M:{"260":"M"},N:{"388":"A B"},O:{"388":"EC"},P:{"388":"G FC GC HC IC JC VB L"},Q:{"388":"KC"},R:{"388":"LC"},S:{"388":"MC"}},B:5,C:"CSS overflow property"};

},{}],"node_modules/caniuse-lite/data/features/css-overscroll-behavior.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","132":"A B"},B:{"1":"UB IB N","132":"C O T P H J","516":"K"},C:{"1":"9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"9 w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB","260":"DB BB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"2 3 4 5 6 7 8 9 AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S","260":"0 1"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"132":"A B"},O:{"2":"EC"},P:{"1":"IC JC VB L","2":"G FC GC HC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"CSS overscroll-behavior"};

},{}],"node_modules/caniuse-lite/data/features/css-page-break.js":[function(require,module,exports) {
module.exports={A:{A:{"388":"A B","900":"I F E D gB"},B:{"388":"C O T P H J K","900":"UB IB N"},C:{"772":"9 w R M JB KB LB MB NB OB PB QB RB SB","900":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB nB fB"},D:{"900":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"772":"A","900":"G U I F E D B C O xB WB aB bB cB dB VB L S hB iB"},F:{"16":"D jB","129":"B C kB lB mB L EB oB S","900":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"900":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"129":"7B"},I:{"900":"GB G N 8B 9B AC BC HB CC DC"},J:{"900":"F A"},K:{"129":"A B C L EB S","900":"Q"},L:{"900":"N"},M:{"900":"M"},N:{"388":"A B"},O:{"900":"EC"},P:{"900":"G FC GC HC IC JC VB L"},Q:{"900":"KC"},R:{"900":"LC"},S:{"900":"MC"}},B:2,C:"CSS page-break properties"};

},{}],"node_modules/caniuse-lite/data/features/css-paged-media.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F gB","132":"E D A B"},B:{"1":"UB IB N","132":"C O T P H J K"},C:{"2":"qB GB G U I F E D A B C O T P H J K nB fB","132":"0 1 2 3 4 5 6 7 8 9 V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","132":"D B C jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"16":"7B"},I:{"16":"GB G N 8B 9B AC BC HB CC DC"},J:{"16":"F A"},K:{"16":"A B C L EB S","258":"Q"},L:{"1":"N"},M:{"132":"M"},N:{"258":"A B"},O:{"258":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"132":"MC"}},B:5,C:"CSS Paged Media (@page)"};

},{}],"node_modules/caniuse-lite/data/features/css-paint-api.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"9 w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB"},E:{"2":"G U I F E D A B C xB WB aB bB cB dB VB L","194":"O S hB iB"},F:{"1":"2 3 4 5 6 7 8 9 AB CB DB BB w R M","2":"0 1 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"CSS Paint API"};

},{}],"node_modules/caniuse-lite/data/features/css-placeholder-shown.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","292":"A B"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","164":"0 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j jB kB lB mB L EB oB S"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"164":"MC"}},B:5,C:":placeholder-shown CSS pseudo-class"};

},{}],"node_modules/caniuse-lite/data/features/css-placeholder.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","36":"C O T P H J K"},C:{"1":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K nB fB","33":"0 V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},D:{"1":"7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","36":"0 1 2 3 4 5 6 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"B C O VB L S hB iB","2":"G xB WB","36":"U I F E D A aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","36":"P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB","36":"E HB rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"1":"N","36":"GB G 8B 9B AC BC HB CC DC"},J:{"36":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"36":"A B"},O:{"1":"EC"},P:{"1":"HC IC JC VB L","36":"G FC GC"},Q:{"1":"KC"},R:{"1":"LC"},S:{"33":"MC"}},B:5,C:"::placeholder CSS pseudo-element"};

},{}],"node_modules/caniuse-lite/data/features/css-read-only-write.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"O T P H J K UB IB N","2":"C"},C:{"1":"SB","16":"qB","33":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T","132":"P H J K V W X Y Z a b c d e f g h i j k l"},E:{"1":"D A B C O dB VB L S hB iB","16":"xB WB","132":"G U I F E aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","16":"D B jB kB lB mB L","132":"C P H J K V W X Y EB oB S"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB","132":"E HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"N","16":"8B 9B","132":"GB G AC BC HB CC DC"},J:{"1":"A","132":"F"},K:{"1":"Q","2":"A B L","132":"C EB S"},L:{"1":"N"},M:{"33":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"33":"MC"}},B:1,C:"CSS :read-only and :read-write selectors"};

},{}],"node_modules/caniuse-lite/data/features/css-rebeccapurple.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","132":"B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n"},E:{"1":"F E D A B C O cB dB VB L S hB iB","2":"G U I xB WB aB","16":"bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a jB kB lB mB L EB oB S"},G:{"1":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"Rebeccapurple color"};

},{}],"node_modules/caniuse-lite/data/features/css-reflections.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","33":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"33":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"xB WB","33":"G U I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","33":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"33":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"33":"GB G N 8B 9B AC BC HB CC DC"},J:{"33":"F A"},K:{"2":"A B C L EB S","33":"Q"},L:{"33":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"33":"G FC GC HC IC JC VB L"},Q:{"33":"KC"},R:{"33":"LC"},S:{"2":"MC"}},B:7,C:"CSS Reflections"};

},{}],"node_modules/caniuse-lite/data/features/css-regions.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","420":"A B"},B:{"2":"UB IB N","420":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","36":"P H J K","66":"V W X Y Z a b c d e f g h i j k"},E:{"2":"G U I C O xB WB aB L S hB iB","33":"F E D A B bB cB dB VB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"WB pB HB rB sB 0B 1B 2B 3B 4B 5B 6B","33":"E tB uB vB wB XB yB zB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"420":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"CSS Regions"};

},{}],"node_modules/caniuse-lite/data/features/css-repeating-gradients.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB","33":"G U I F E D A B C O T P fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D","33":"A B C O T P H J K V W X Y Z a b"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB","33":"I aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B jB kB lB mB","33":"C oB","36":"L EB"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB","33":"rB sB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB 8B 9B AC","33":"G BC HB"},J:{"1":"A","2":"F"},K:{"1":"Q S","2":"A B","33":"C","36":"L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS Repeating Gradients"};

},{}],"node_modules/caniuse-lite/data/features/css-resize.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","33":"G"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB","132":"S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:4,C:"CSS resize property"};

},{}],"node_modules/caniuse-lite/data/features/css-revert-value.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"1":"R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w nB fB"},D:{"1":"ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB"},E:{"1":"A B C O dB VB L S hB iB","2":"G U I F E D xB WB aB bB cB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"CSS revert value"};

},{}],"node_modules/caniuse-lite/data/features/css-rrggbbaa.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y nB fB"},D:{"1":"9 CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","194":"2 3 4 5 6 7 8 TB AB FB"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"1":"2 3 4 5 6 7 8 9 AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o jB kB lB mB L EB oB S","194":"0 1 p q r s t u v Q x y z"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"IC JC VB L","2":"G","194":"FC GC HC"},Q:{"2":"KC"},R:{"194":"LC"},S:{"2":"MC"}},B:7,C:"#rrggbbaa hex color notation"};

},{}],"node_modules/caniuse-lite/data/features/css-scroll-behavior.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","129":"UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l nB fB"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q","129":"9 FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","450":"0 1 2 3 4 5 6 7 8 r s t u v Q x y z TB AB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c d jB kB lB mB L EB oB S","129":"0 1 2 3 4 5 6 7 8 9 y z AB CB DB BB w R M","450":"e f g h i j k l m n o p q r s t u v Q x"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"129":"EC"},P:{"1":"IC JC VB L","2":"G FC GC HC"},Q:{"129":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"CSSOM Scroll-behavior"};

},{}],"node_modules/caniuse-lite/data/features/css-scrollbar.js":[function(require,module,exports) {
module.exports={A:{A:{"132":"I F E D A B gB"},B:{"2":"C O T P H J K","292":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB nB fB","3074":"DB","4100":"9 BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"292":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"16":"G U xB WB","292":"I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","292":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"16":"WB pB HB rB sB","292":"tB","804":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"16":"8B 9B","292":"GB G N AC BC HB CC DC"},J:{"292":"F A"},K:{"2":"A B C L EB S","292":"Q"},L:{"292":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"292":"EC"},P:{"292":"G FC GC HC IC JC VB L"},Q:{"292":"KC"},R:{"292":"LC"},S:{"2":"MC"}},B:7,C:"CSS scrollbar styling"};

},{}],"node_modules/caniuse-lite/data/features/css-sel2.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"F E D A B","2":"gB","8":"I"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"CSS 2.1 selectors"};

},{}],"node_modules/caniuse-lite/data/features/css-sel3.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"gB","8":"I","132":"F E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O WB aB bB cB dB VB L S hB iB","2":"xB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","2":"D"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"CSS3 selectors"};

},{}],"node_modules/caniuse-lite/data/features/css-selection.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"9 CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","33":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","2":"D"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"C Q EB S","16":"A B L"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"33":"MC"}},B:5,C:"::selection CSS pseudo-element"};

},{}],"node_modules/caniuse-lite/data/features/css-shapes.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"9 CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","322":"1 2 3 4 5 6 7 8 TB AB FB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j","194":"k l m"},E:{"1":"B C O VB L S hB iB","2":"G U I F xB WB aB bB","33":"E D A cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z jB kB lB mB L EB oB S"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB","33":"E uB vB wB XB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:4,C:"CSS Shapes Level 1"};

},{}],"node_modules/caniuse-lite/data/features/css-snappoints.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","6308":"A","6436":"B"},B:{"1":"UB IB N","6436":"C O T P H J K"},C:{"1":"M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o nB fB","2052":"0 1 2 3 4 5 6 7 8 9 p q r s t u v Q x y z TB AB FB CB DB BB w R"},D:{"1":"JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB","8258":"w R M"},E:{"1":"B C O L S hB iB","2":"G U I F E xB WB aB bB cB","3108":"D A dB VB"},F:{"1":"9 BB w R M","2":"0 1 2 3 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S","8258":"4 5 6 7 8 AB CB DB"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB","3108":"vB wB XB yB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2052":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"VB L","2":"G FC GC HC IC JC"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2052":"MC"}},B:4,C:"CSS Scroll Snap"};

},{}],"node_modules/caniuse-lite/data/features/css-sticky.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P","1028":"UB IB N","4100":"H J K"},C:{"1":"9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b nB fB","194":"c d e f g h","516":"0 1 2 3 4 5 6 7 8 i j k l m n o p q r s t u v Q x y z"},D:{"2":"0 1 G U I F E D A B C O T P H J K V W X Y n o p q r s t u v Q x y z","322":"2 3 4 5 Z a b c d e f g h i j k l m","1028":"6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"O hB iB","2":"G U I xB WB aB","33":"E D A B C cB dB VB L S","2084":"F bB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o jB kB lB mB L EB oB S","322":"p q r","1028":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z AB CB DB BB w R M"},G:{"1":"3B 4B 5B 6B","2":"WB pB HB rB","33":"E uB vB wB XB yB zB 0B 1B 2B","2084":"sB tB"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","1028":"N"},J:{"2":"F A"},K:{"2":"A B C L EB S","1028":"Q"},L:{"1028":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1028":"EC"},P:{"1":"GC HC IC JC VB L","2":"G FC"},Q:{"1028":"KC"},R:{"2":"LC"},S:{"516":"MC"}},B:5,C:"CSS position:sticky"};

},{}],"node_modules/caniuse-lite/data/features/css-subgrid.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"1":"LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"CSS Subgrid"};

},{}],"node_modules/caniuse-lite/data/features/css-supports-api.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","260":"C O T P H J K"},C:{"1":"5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V nB fB","66":"W X","260":"0 1 2 3 4 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},D:{"1":"9 FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d","260":"0 1 2 3 4 5 6 7 8 e f g h i j k l m n o p q r s t u v Q x y z TB AB"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB","132":"S"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"132":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB","132":"S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS.supports() API"};

},{}],"node_modules/caniuse-lite/data/features/css-table.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"E D A B","2":"I F gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","132":"qB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"CSS Table display"};

},{}],"node_modules/caniuse-lite/data/features/css-text-align-last.js":[function(require,module,exports) {
module.exports={A:{A:{"132":"I F E D A B gB"},B:{"1":"UB IB N","4":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B nB fB","33":"C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y"},D:{"1":"0 1 2 3 4 5 6 7 8 9 x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k","322":"l m n o p q r s t u v Q"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X jB kB lB mB L EB oB S","578":"Y Z a b c d e f g h i j"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"132":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"2":"KC"},R:{"1":"LC"},S:{"33":"MC"}},B:5,C:"CSS3 text-align-last"};

},{}],"node_modules/caniuse-lite/data/features/css-text-indent.js":[function(require,module,exports) {
module.exports={A:{A:{"132":"I F E D A B gB"},B:{"132":"C O T P H J K","388":"UB IB N"},C:{"132":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"132":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n","388":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"132":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"132":"D B C P H J K V W X Y Z a jB kB lB mB L EB oB S","388":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"132":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"132":"7B"},I:{"132":"GB G N 8B 9B AC BC HB CC DC"},J:{"132":"F A"},K:{"132":"A B C L EB S","388":"Q"},L:{"388":"N"},M:{"132":"M"},N:{"132":"A B"},O:{"132":"EC"},P:{"132":"G","388":"FC GC HC IC JC VB L"},Q:{"388":"KC"},R:{"388":"LC"},S:{"132":"MC"}},B:5,C:"CSS text-indent"};

},{}],"node_modules/caniuse-lite/data/features/css-text-justify.js":[function(require,module,exports) {
module.exports={A:{A:{"16":"I F gB","132":"E D A B"},B:{"132":"C O T P H J K","322":"UB IB N"},C:{"2":"0 1 2 3 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","1025":"5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","1602":"4"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s","322":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f jB kB lB mB L EB oB S","322":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","322":"N"},J:{"2":"F A"},K:{"2":"A B C L EB S","322":"Q"},L:{"322":"N"},M:{"1025":"M"},N:{"132":"A B"},O:{"2":"EC"},P:{"2":"G","322":"FC GC HC IC JC VB L"},Q:{"322":"KC"},R:{"322":"LC"},S:{"2":"MC"}},B:5,C:"CSS text-justify"};

},{}],"node_modules/caniuse-lite/data/features/css-text-orientation.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n nB fB","194":"o p q"},D:{"1":"0 1 2 3 4 5 6 7 8 9 y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x"},E:{"2":"G U I F E D xB WB aB bB cB dB","16":"A","33":"B C O VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k jB kB lB mB L EB oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS text-orientation"};

},{}],"node_modules/caniuse-lite/data/features/css-text-spacing.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F gB","161":"E D A B"},B:{"2":"UB IB N","161":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"16":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"CSS Text 4 text-spacing"};

},{}],"node_modules/caniuse-lite/data/features/css-textshadow.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","129":"A B"},B:{"1":"UB IB N","129":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","260":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","2":"D"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"4":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"A","4":"F"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"129":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS3 Text-shadow"};

},{}],"node_modules/caniuse-lite/data/features/css-touch-action-2.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","132":"B","164":"A"},B:{"1":"UB IB N","132":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","260":"5"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r jB kB lB mB L EB oB S","260":"s"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"132":"B","164":"A"},O:{"2":"EC"},P:{"1":"FC GC HC IC JC VB L","16":"G"},Q:{"2":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:5,C:"CSS touch-action level 2 values"};

},{}],"node_modules/caniuse-lite/data/features/css-touch-action.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D gB","289":"A"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e nB fB","194":"0 1 f g h i j k l m n o p q r s t u v Q x y z","1025":"2 3 4 5 6"},D:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y jB kB lB mB L EB oB S"},G:{"1":"3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB","516":"wB XB yB zB 0B 1B 2B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","289":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"194":"MC"}},B:2,C:"CSS touch-action property"};

},{}],"node_modules/caniuse-lite/data/features/css-transitions.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","33":"U I F E D A B C O T P","164":"G"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","33":"G U I F E D A B C O T P H J K V W X Y Z a b"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","33":"I aB","164":"G U xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D jB kB","33":"C","164":"B lB mB L EB oB"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","33":"sB","164":"WB pB HB rB"},H:{"2":"7B"},I:{"1":"N CC DC","33":"GB G 8B 9B AC BC HB"},J:{"1":"A","33":"F"},K:{"1":"Q S","33":"C","164":"A B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"CSS3 Transitions"};

},{}],"node_modules/caniuse-lite/data/features/css-unicode-bidi.js":[function(require,module,exports) {
module.exports={A:{A:{"132":"I F E D A B gB"},B:{"1":"UB IB N","132":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","33":"J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","132":"qB GB G U I F E D nB fB","292":"A B C O T P H"},D:{"1":"0 1 2 3 4 5 6 7 8 9 y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","132":"G U I F E D A B C O T P H","548":"J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x"},E:{"132":"G U I F E xB WB aB bB cB","548":"D A B C O dB VB L S hB iB"},F:{"132":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"132":"E WB pB HB rB sB tB uB","548":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"16":"7B"},I:{"1":"N","16":"GB G 8B 9B AC BC HB CC DC"},J:{"16":"F A"},K:{"16":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"132":"A B"},O:{"16":"EC"},P:{"1":"FC GC HC IC JC VB L","16":"G"},Q:{"16":"KC"},R:{"16":"LC"},S:{"33":"MC"}},B:4,C:"CSS unicode-bidi property"};

},{}],"node_modules/caniuse-lite/data/features/css-unset-value.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"O T P H J K UB IB N","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q"},E:{"1":"A B C O dB VB L S hB iB","2":"G U I F E D xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d jB kB lB mB L EB oB S"},G:{"1":"wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS unset value"};

},{}],"node_modules/caniuse-lite/data/features/css-variables.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"H J K UB IB N","2":"C O T","260":"P"},C:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x","194":"y"},E:{"1":"A B C O dB VB L S hB iB","2":"G U I F E D xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k jB kB lB mB L EB oB S","194":"l"},G:{"1":"wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"2":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:4,C:"CSS Variables (Custom Properties)"};

},{}],"node_modules/caniuse-lite/data/features/css-widows-orphans.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F gB","129":"E D"},B:{"1":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a"},E:{"1":"F E D A B C O cB dB VB L S hB iB","2":"G U I xB WB aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","129":"D B jB kB lB mB L EB oB"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB"},H:{"1":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"2":"F A"},K:{"1":"Q S","2":"A B C L EB"},L:{"1":"N"},M:{"2":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:2,C:"CSS widows & orphans"};

},{}],"node_modules/caniuse-lite/data/features/css-writing-mode.js":[function(require,module,exports) {
module.exports={A:{A:{"132":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l nB fB","322":"m n o p q"},D:{"1":"0 1 2 3 4 5 6 7 8 9 y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I","16":"F","33":"E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x"},E:{"1":"B C O L S hB iB","2":"G xB WB","16":"U","33":"I F E D A aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","33":"P H J K V W X Y Z a b c d e f g h i j k"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB","33":"E rB sB tB uB vB wB XB yB"},H:{"2":"7B"},I:{"1":"N","2":"8B 9B AC","33":"GB G BC HB CC DC"},J:{"33":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"36":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","33":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS writing-mode property"};

},{}],"node_modules/caniuse-lite/data/features/css-zoom.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F gB","129":"E D A B"},B:{"1":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB"},H:{"2":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"129":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:7,C:"CSS zoom"};

},{}],"node_modules/caniuse-lite/data/features/css3-attr.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:4,C:"CSS3 attr() function for all properties"};

},{}],"node_modules/caniuse-lite/data/features/css3-boxsizing.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"E D A B","8":"I F gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","33":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","33":"G U I F E D"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","33":"G U xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","2":"D"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","33":"WB pB HB"},H:{"1":"7B"},I:{"1":"G N BC HB CC DC","33":"GB 8B 9B AC"},J:{"1":"A","33":"F"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"CSS3 Box-sizing"};

},{}],"node_modules/caniuse-lite/data/features/css3-colors.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","4":"qB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M kB lB mB L EB oB S","2":"D","4":"jB"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"CSS3 Colors"};

},{}],"node_modules/caniuse-lite/data/features/css3-cursors-grab.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"P H J K UB IB N","2":"C O T"},C:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","33":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c nB fB"},D:{"1":"M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","33":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R"},E:{"1":"B C O L S hB iB","33":"G U I F E D A xB WB aB bB cB dB VB"},F:{"1":"5 6 7 8 9 C AB CB DB BB w R M oB S","2":"D B jB kB lB mB L EB","33":"0 1 2 3 4 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"33":"F A"},K:{"2":"A B C L EB S","33":"Q"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"33":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:3,C:"CSS grab & grabbing cursors"};

},{}],"node_modules/caniuse-lite/data/features/css3-cursors-newer.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","33":"qB GB G U I F E D A B C O T P H J K V W X Y Z nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","33":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m"},E:{"1":"D A B C O dB VB L S hB iB","33":"G U I F E xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","2":"D B jB kB lB mB L EB","33":"P H J K V W X Y Z"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"33":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:4,C:"CSS3 Cursors: zoom-in & zoom-out"};

},{}],"node_modules/caniuse-lite/data/features/css3-cursors.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","132":"I F E gB"},B:{"1":"T P H J K UB IB N","260":"C O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","4":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","4":"G"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","4":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","260":"D B C jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F","16":"A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:4,C:"CSS3 Cursors (original values)"};

},{}],"node_modules/caniuse-lite/data/features/css3-tabsize.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"qB GB nB fB","33":"3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","164":"0 1 2 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W","132":"X Y Z a b c d e f g h i j k l m n o p q r"},E:{"1":"hB iB","2":"G U I xB WB aB","132":"F E D A B C O bB cB dB VB L S"},F:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D jB kB lB","132":"P H J K V W X Y Z a b c d e","164":"B C mB L EB oB S"},G:{"1":"6B","2":"WB pB HB rB sB","132":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B"},H:{"164":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB","132":"CC DC"},J:{"132":"F A"},K:{"1":"Q","2":"A","164":"B C L EB S"},L:{"1":"N"},M:{"33":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"164":"MC"}},B:5,C:"CSS3 tab-size"};

},{}],"node_modules/caniuse-lite/data/features/currentcolor.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","2":"D"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"CSS currentColor value"};

},{}],"node_modules/caniuse-lite/data/features/custom-elements.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","8":"A B"},B:{"1":"UB","2":"IB N","8":"C O T P H J K"},C:{"2":"9 qB GB G U I F E D A B C O T P H J K V W X Y TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","66":"Z a b c d e f","72":"0 1 2 3 4 5 6 7 8 g h i j k l m n o p q r s t u v Q x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c IB N eB ZB YB","66":"d e f g h i"},E:{"2":"G U xB WB aB","8":"I F E D A B C O bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w","2":"D B C R M jB kB lB mB L EB oB S","66":"P H J K V"},G:{"2":"WB pB HB rB sB","8":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"DC","2":"GB G N 8B 9B AC BC HB CC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"72":"MC"}},B:7,C:"Custom Elements (deprecated V0 spec)"};

},{}],"node_modules/caniuse-lite/data/features/custom-elementsv1.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","8":"A B"},B:{"1":"UB IB N","8":"C O T P H J K"},C:{"1":"9 DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f nB fB","8":"g h i j k l m n o p q r s t u v Q x y z","456":"0 1 2 3 4 5 6 7 8","712":"TB AB FB CB"},D:{"1":"R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","8":"2 3","132":"4 5 6 7 8 9 TB AB FB CB DB BB w"},E:{"2":"G U I F xB WB aB bB cB","8":"E D A dB","132":"B C O VB L S hB iB"},F:{"1":"9 BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q jB kB lB mB L EB oB S","132":"0 1 2 3 4 5 6 7 8 r s t u v Q x y z AB CB DB"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB","132":"yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C L EB S","132":"Q"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"GC HC IC JC VB L","2":"G","132":"FC"},Q:{"132":"KC"},R:{"132":"LC"},S:{"8":"MC"}},B:1,C:"Custom Elements (V1)"};

},{}],"node_modules/caniuse-lite/data/features/customevent.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","132":"D A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U nB fB","132":"I F E D A"},D:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G","16":"U I F E O T","388":"D A B C"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","2":"G xB WB","16":"U I","388":"aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","2":"D jB kB lB mB","132":"B L EB"},G:{"1":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"pB","16":"WB HB","388":"rB"},H:{"1":"7B"},I:{"1":"N CC DC","2":"8B 9B AC","388":"GB G BC HB"},J:{"1":"A","388":"F"},K:{"1":"C Q S","2":"A","132":"B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"132":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"CustomEvent"};

},{}],"node_modules/caniuse-lite/data/features/datalist.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"gB","8":"I F E D","260":"A B"},B:{"1":"UB IB N","260":"C O T P","1284":"H J K"},C:{"8":"qB GB nB fB","4612":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","8":"G U I F E D A B C O T P H J K V","132":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M"},E:{"1":"O S hB iB","8":"G U I F E D A B C xB WB aB bB cB dB VB L"},F:{"1":"9 D B C BB w R M jB kB lB mB L EB oB S","132":"0 1 2 3 4 5 6 7 8 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB"},G:{"8":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B","2049":"2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"DC","8":"GB G 8B 9B AC BC HB CC","132":"N"},J:{"1":"A","8":"F"},K:{"1":"A B C L EB S","8":"Q"},L:{"1":"N"},M:{"516":"M"},N:{"8":"A B"},O:{"8":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"132":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:1,C:"Datalist element"};

},{}],"node_modules/caniuse-lite/data/features/dataset.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","4":"I F E D A gB"},B:{"1":"C O T P H","129":"J K UB IB N"},C:{"1":"0 I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","4":"qB GB G U nB fB","129":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"0 1 2 3 4 v Q x y z","4":"G U I","129":"5 6 7 8 9 F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"4":"G U xB WB","129":"I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"1":"C i j k l m n o p q r L EB oB S","4":"D B jB kB lB mB","129":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h s t u v Q x y z AB CB DB BB w R M"},G:{"4":"WB pB HB","129":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"4":"7B"},I:{"4":"8B 9B AC","129":"GB G N BC HB CC DC"},J:{"129":"F A"},K:{"1":"C L EB S","4":"A B","129":"Q"},L:{"129":"N"},M:{"129":"M"},N:{"1":"B","4":"A"},O:{"129":"EC"},P:{"129":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"129":"LC"},S:{"1":"MC"}},B:1,C:"dataset & data-* attributes"};

},{}],"node_modules/caniuse-lite/data/features/datauri.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F gB","132":"E","260":"D A B"},B:{"1":"UB IB N","260":"C O P H J K","772":"T"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"260":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"Data URIs"};

},{}],"node_modules/caniuse-lite/data/features/date-tolocaledatestring.js":[function(require,module,exports) {
module.exports={A:{A:{"16":"gB","132":"I F E D A B"},B:{"1":"K UB IB N","132":"C O T P H J"},C:{"1":"6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","132":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e nB fB","260":"2 3 4 5","772":"0 1 f g h i j k l m n o p q r s t u v Q x y z"},D:{"1":"KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","132":"G U I F E D A B C O T P H J K V W X Y Z","260":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB","772":"a b c d e f g h i j k l m n"},E:{"1":"C O S hB iB","16":"G U xB WB","132":"I F E D A aB bB cB dB","260":"B VB L"},F:{"1":"7 8 9 AB CB DB BB w R M","16":"D B C jB kB lB mB L EB oB","132":"S","260":"0 1 2 3 4 5 6 b c d e f g h i j k l m n o p q r s t u v Q x y z","772":"P H J K V W X Y Z a"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB rB","132":"E sB tB uB vB wB XB"},H:{"132":"7B"},I:{"1":"N","16":"GB 8B 9B AC","132":"G BC HB","772":"CC DC"},J:{"132":"F A"},K:{"1":"Q","16":"A B C L EB","132":"S"},L:{"1":"N"},M:{"1":"M"},N:{"132":"A B"},O:{"260":"EC"},P:{"1":"JC VB L","260":"G FC GC HC IC"},Q:{"260":"KC"},R:{"132":"LC"},S:{"132":"MC"}},B:6,C:"Date.prototype.toLocaleDateString"};

},{}],"node_modules/caniuse-lite/data/features/details.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"D A B gB","8":"I F E"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB","8":"GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q nB fB","194":"x y"},D:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","8":"G U I F E D A B","257":"V W X Y Z a b c d e f g h i j k l","769":"C O T P H J K"},E:{"1":"C O S hB iB","8":"G U xB WB aB","257":"I F E D A bB cB dB","1025":"B VB L"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"C L EB oB S","8":"D B jB kB lB mB"},G:{"1":"E sB tB uB vB wB 0B 1B 2B 3B 4B 5B 6B","8":"WB pB HB rB","1025":"XB yB zB"},H:{"8":"7B"},I:{"1":"G N BC HB CC DC","8":"GB 8B 9B AC"},J:{"1":"A","8":"F"},K:{"1":"Q","8":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"769":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Details & Summary elements"};

},{}],"node_modules/caniuse-lite/data/features/deviceorientation.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","132":"B"},B:{"1":"C O T P H J K","4":"UB IB N"},C:{"2":"qB GB nB","4":"0 1 2 3 4 5 6 7 8 9 I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","8":"G U fB"},D:{"2":"G U I","4":"0 1 2 3 4 5 6 7 8 9 F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","4":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"WB pB","4":"E HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"8B 9B AC","4":"GB G N BC HB CC DC"},J:{"2":"F","4":"A"},K:{"1":"C S","2":"A B L EB","4":"Q"},L:{"4":"N"},M:{"4":"M"},N:{"1":"B","2":"A"},O:{"4":"EC"},P:{"4":"G FC GC HC IC JC VB L"},Q:{"4":"KC"},R:{"4":"LC"},S:{"4":"MC"}},B:4,C:"DeviceOrientation & DeviceMotion events"};

},{}],"node_modules/caniuse-lite/data/features/devicepixelratio.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D A gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","2":"D B jB kB lB mB L EB"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"C Q S","2":"A B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"Window.devicePixelRatio"};

},{}],"node_modules/caniuse-lite/data/features/dialog.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","194":"3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h","322":"i j k l m"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K jB kB lB mB L EB oB S","578":"V W X Y Z"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:1,C:"Dialog element"};

},{}],"node_modules/caniuse-lite/data/features/dispatchevent.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","16":"gB","129":"D A","130":"I F E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O WB aB bB cB dB VB L S hB iB","16":"xB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","16":"D"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB"},H:{"1":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","129":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"EventTarget.dispatchEvent"};

},{}],"node_modules/caniuse-lite/data/features/dnssec.js":[function(require,module,exports) {
module.exports={A:{A:{"132":"I F E D A B gB"},B:{"132":"C O T P H J K UB IB N"},C:{"132":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"132":"0 1 2 3 4 5 6 7 8 9 G U h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","388":"I F E D A B C O T P H J K V W X Y Z a b c d e f g"},E:{"132":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"132":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"132":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"132":"7B"},I:{"132":"GB G N 8B 9B AC BC HB CC DC"},J:{"132":"F A"},K:{"132":"A B C Q L EB S"},L:{"132":"N"},M:{"132":"M"},N:{"132":"A B"},O:{"132":"EC"},P:{"132":"G FC GC HC IC JC VB L"},Q:{"132":"KC"},R:{"132":"LC"},S:{"132":"MC"}},B:6,C:"DNSSEC and DANE"};

},{}],"node_modules/caniuse-lite/data/features/do-not-track.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","164":"D A","260":"B"},B:{"1":"J K UB IB N","260":"C O T P H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E nB fB","516":"D A B C O T P H J K V W X Y Z a b c d e f g h"},D:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y"},E:{"1":"I A B C aB dB VB L","2":"G U O xB WB S hB iB","1028":"F E D bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B jB kB lB mB L EB oB"},G:{"1":"vB wB XB yB zB 0B 1B","2":"WB pB HB rB sB 2B 3B 4B 5B 6B","1028":"E tB uB"},H:{"1":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"16":"F","1028":"A"},K:{"1":"Q S","16":"A B C L EB"},L:{"1":"N"},M:{"1":"M"},N:{"164":"A","260":"B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"Do Not Track API"};

},{}],"node_modules/caniuse-lite/data/features/document-currentscript.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e"},E:{"1":"E D A B C O dB VB L S hB iB","2":"G U I F xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P jB kB lB mB L EB oB S"},G:{"1":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"document.currentScript"};

},{}],"node_modules/caniuse-lite/data/features/document-evaluate-xpath.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","16":"qB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","16":"D"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:7,C:"document.evaluate & XPath"};

},{}],"node_modules/caniuse-lite/data/features/document-execcommand.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","16":"G U xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M kB lB mB L EB oB S","16":"D jB"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB","16":"HB rB sB"},H:{"2":"7B"},I:{"1":"N BC HB CC DC","2":"GB G 8B 9B AC"},J:{"1":"A","2":"F"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"2":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:7,C:"Document.execCommand()"};

},{}],"node_modules/caniuse-lite/data/features/document-scrollingelement.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"T P H J K UB IB N","16":"C O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g jB kB lB mB L EB oB S"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"document.scrollingElement"};

},{}],"node_modules/caniuse-lite/data/features/documenthead.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB","16":"U"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M L EB oB S","2":"D jB kB lB mB"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB"},H:{"1":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"document.head"};

},{}],"node_modules/caniuse-lite/data/features/dom-manip-convenience.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"J K UB IB N","2":"C O T P H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y nB fB"},D:{"1":"4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","194":"2 3"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p jB kB lB mB L EB oB S","194":"q"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"GC HC IC JC VB L","2":"G FC"},Q:{"194":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:1,C:"DOM manipulation convenience methods"};

},{}],"node_modules/caniuse-lite/data/features/dom-range.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"gB","8":"I F E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Document Object Model Range"};

},{}],"node_modules/caniuse-lite/data/features/domcontentloaded.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"DOMContentLoaded"};

},{}],"node_modules/caniuse-lite/data/features/domfocusin-domfocusout-events.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T P H J K V W X Y Z a b"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB","16":"U"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","16":"D B jB kB lB mB L EB"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB rB sB"},H:{"16":"7B"},I:{"1":"G N BC HB CC DC","16":"GB 8B 9B AC"},J:{"16":"F A"},K:{"16":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"16":"A B"},O:{"16":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:5,C:"DOMFocusIn & DOMFocusOut events"};

},{}],"node_modules/caniuse-lite/data/features/dommatrix.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","132":"A B"},B:{"132":"C O T P H J K","1028":"UB IB N"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i nB fB","2564":"j k l m n o p q r s t u v Q x y","3076":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"16":"G U I F","132":"0 1 2 3 4 5 6 7 8 D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB","388":"E","1028":"9 FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"16":"G xB WB","132":"U I F E D A aB bB cB dB VB","1028":"B C O L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","132":"P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x","1028":"0 1 2 3 4 5 6 7 8 9 y z AB CB DB BB w R M"},G:{"16":"WB pB HB","132":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","132":"G BC HB CC DC","292":"GB 8B 9B AC"},J:{"16":"F","132":"A"},K:{"2":"A B C L EB S","132":"Q"},L:{"1028":"N"},M:{"1":"M"},N:{"132":"A B"},O:{"132":"EC"},P:{"132":"G FC GC HC IC JC VB L"},Q:{"132":"KC"},R:{"132":"LC"},S:{"2564":"MC"}},B:4,C:"DOMMatrix"};

},{}],"node_modules/caniuse-lite/data/features/download.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"O T P H J K UB IB N","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Download attribute"};

},{}],"node_modules/caniuse-lite/data/features/dragndrop.js":[function(require,module,exports) {
module.exports={A:{A:{"644":"I F E D gB","772":"A B"},B:{"1":"K UB IB N","260":"C O T P H J"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","8":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","8":"D B jB kB lB mB L EB oB"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","1025":"N"},J:{"2":"F A"},K:{"1":"S","8":"A B C L EB","1025":"Q"},L:{"1025":"N"},M:{"2":"M"},N:{"1":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:1,C:"Drag and Drop"};

},{}],"node_modules/caniuse-lite/data/features/element-closest.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"P H J K UB IB N","2":"C O T"},C:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d jB kB lB mB L EB oB S"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"2":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Element.closest()"};

},{}],"node_modules/caniuse-lite/data/features/element-from-point.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A B","16":"gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","16":"qB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","16":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M L EB oB S","16":"D jB kB lB mB"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB"},H:{"1":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"C Q S","16":"A B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"document.elementFromPoint()"};

},{}],"node_modules/caniuse-lite/data/features/element-scroll-methods.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l nB fB"},D:{"1":"9 FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB"},E:{"2":"G U I F E D xB WB aB bB cB dB","132":"A B C O VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB","132":"XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"IC JC VB L","2":"G FC GC HC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:5,C:"Scroll methods on elements (scroll, scrollTo, scrollBy)"};

},{}],"node_modules/caniuse-lite/data/features/eme.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","164":"B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k","132":"l m n o p q r"},E:{"1":"C O S hB iB","2":"G U I xB WB aB bB","164":"F E D A B cB dB VB L"},F:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X jB kB lB mB L EB oB S","132":"Y Z a b c d e"},G:{"1":"0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"16":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:2,C:"Encrypted Media Extensions"};

},{}],"node_modules/caniuse-lite/data/features/eot.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A B","2":"gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"EOT - Embedded OpenType fonts"};

},{}],"node_modules/caniuse-lite/data/features/es5.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F gB","260":"D","1026":"E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","4":"qB GB nB fB","132":"G U I F E D A B C O T P H J K V W"},D:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","4":"G U I F E D A B C O T P H J K","132":"V W X Y"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","4":"G U xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","4":"D B C jB kB lB mB L EB oB","132":"S"},G:{"1":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","4":"WB pB HB rB"},H:{"132":"7B"},I:{"1":"N CC DC","4":"GB 8B 9B AC","132":"BC HB","900":"G"},J:{"1":"A","4":"F"},K:{"1":"Q","4":"A B C L EB","132":"S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"ECMAScript 5"};

},{}],"node_modules/caniuse-lite/data/features/es6-class.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r","132":"s t u v Q x y"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e jB kB lB mB L EB oB S","132":"f g h i j k l"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"ES6 classes"};

},{}],"node_modules/caniuse-lite/data/features/es6-generators.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"O T P H J K UB IB N","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b jB kB lB mB L EB oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"ES6 Generators"};

},{}],"node_modules/caniuse-lite/data/features/es6-module-dynamic-import.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB nB fB","194":"w"},D:{"1":"9 DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB"},E:{"1":"C O L S hB iB","2":"G U I F E D A B xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"IC JC VB L","2":"G FC GC HC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"JavaScript modules: dynamic import()"};

},{}],"node_modules/caniuse-lite/data/features/es6-module.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T","4097":"H J K","4290":"P"},C:{"1":"9 AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","322":"4 5 6 7 8 TB"},D:{"1":"9 FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB","194":"AB"},E:{"1":"B C O L S hB iB","2":"G U I F E D A xB WB aB bB cB dB","3076":"VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q jB kB lB mB L EB oB S","194":"x"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB","3076":"yB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"IC JC VB L","2":"G FC GC HC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:1,C:"JavaScript modules via script tag"};

},{}],"node_modules/caniuse-lite/data/features/es6-number.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P nB fB","132":"H J K V W X Y Z a","260":"b c d e f g","516":"h"},D:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K","1028":"V W X Y Z a b c d e f g h i j"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","1028":"P H J K V W"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC","1028":"BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"ES6 Number"};

},{}],"node_modules/caniuse-lite/data/features/es6-string-includes.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d jB kB lB mB L EB oB S"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"String.prototype.includes"};

},{}],"node_modules/caniuse-lite/data/features/es6.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","388":"B"},B:{"257":"UB IB N","260":"C O T","769":"P H J K"},C:{"2":"qB GB G U nB fB","4":"0 1 2 3 I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","257":"4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"G U I F E D A B C O T P H J K V W","4":"0 X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","257":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"A B C O VB L S hB iB","2":"G U I F xB WB aB bB","4":"E D cB dB"},F:{"2":"D B C jB kB lB mB L EB oB S","4":"P H J K V W X Y Z a b c d e f g h i j k l m n","257":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB","4":"E tB uB vB wB"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB","4":"CC DC","257":"N"},J:{"2":"F","4":"A"},K:{"2":"A B C L EB S","257":"Q"},L:{"257":"N"},M:{"257":"M"},N:{"2":"A","388":"B"},O:{"257":"EC"},P:{"4":"G","257":"FC GC HC IC JC VB L"},Q:{"257":"KC"},R:{"4":"LC"},S:{"4":"MC"}},B:6,C:"ECMAScript 2015 (ES6)"};

},{}],"node_modules/caniuse-lite/data/features/eventsource.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M L EB oB S","4":"D jB kB lB mB"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"F A"},K:{"1":"C Q L EB S","4":"A B"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Server-sent events"};

},{}],"node_modules/caniuse-lite/data/features/extended-system-fonts.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"hB iB","2":"G U I F E D A B C O xB WB aB bB cB dB VB L S"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"ui-serif, ui-sans-serif, ui-monospace and ui-rounded values for font-family"};

},{}],"node_modules/caniuse-lite/data/features/feature-policy.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","132":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB nB fB","260":"OB PB QB RB SB"},D:{"2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB","132":"9 AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B xB WB aB bB cB dB VB","772":"C O L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q jB kB lB mB L EB oB S","132":"0 1 2 3 4 5 6 7 8 9 x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB","16":"0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","132":"N"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"132":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC","132":"IC JC VB L"},Q:{"132":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Feature Policy"};

},{}],"node_modules/caniuse-lite/data/features/fetch.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"T P H J K UB IB N","2":"C O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j nB fB","1025":"p","1218":"k l m n o"},D:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p","260":"q","772":"r"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c jB kB lB mB L EB oB S","260":"d","772":"e"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Fetch"};

},{}],"node_modules/caniuse-lite/data/features/fieldset-disabled.js":[function(require,module,exports) {
module.exports={A:{A:{"16":"gB","132":"E D","388":"I F A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P","16":"H J K V"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M kB lB mB L EB oB S","16":"D jB"},G:{"1":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB"},H:{"388":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A","260":"B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"disabled attribute of the fieldset element"};

},{}],"node_modules/caniuse-lite/data/features/fileapi.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","260":"A B"},B:{"1":"UB IB N","260":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB","260":"G U I F E D A B C O T P H J K V W X Y Z a b c d fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U","260":"O T P H J K V W X Y Z a b c d e f g h i j k l m n","388":"I F E D A B C"},E:{"1":"A B C O VB L S hB iB","2":"G U xB WB","260":"I F E D bB cB dB","388":"aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B jB kB lB mB","260":"C P H J K V W X Y Z a L EB oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB","260":"E sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N DC","2":"8B 9B AC","260":"CC","388":"GB G BC HB"},J:{"260":"A","388":"F"},K:{"1":"Q","2":"A B","260":"C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A","260":"B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"File API"};

},{}],"node_modules/caniuse-lite/data/features/filereader.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","132":"A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB fB","2":"qB GB nB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M L EB oB S","2":"D B jB kB lB mB"},G:{"1":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB"},H:{"2":"7B"},I:{"1":"GB G N BC HB CC DC","2":"8B 9B AC"},J:{"1":"A","2":"F"},K:{"1":"C Q L EB S","2":"A B"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"FileReader API"};

},{}],"node_modules/caniuse-lite/data/features/filereadersync.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","2":"D jB kB","16":"B lB mB L EB"},G:{"1":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"C Q EB S","2":"A","16":"B L"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"FileReaderSync"};

},{}],"node_modules/caniuse-lite/data/features/filesystem.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","33":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"G U I F","33":"0 1 2 3 4 5 6 7 8 9 O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","36":"E D A B C"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","33":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F","33":"A"},K:{"2":"A B C L EB S","33":"Q"},L:{"33":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G","33":"FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Filesystem & FileWriter API"};

},{}],"node_modules/caniuse-lite/data/features/flac.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"H J K UB IB N","2":"C O T P"},C:{"1":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t","16":"u v Q","388":"0 1 2 3 4 5 x y z"},E:{"1":"O hB iB","2":"G U I F E D A xB WB aB bB cB dB VB","516":"B C L S"},F:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r jB kB lB mB L EB oB S"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB"},H:{"2":"7B"},I:{"1":"N","2":"8B 9B AC","16":"GB G BC HB CC DC"},J:{"1":"A","2":"F"},K:{"1":"S","16":"A B C L EB","129":"Q"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","129":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:6,C:"FLAC audio format"};

},{}],"node_modules/caniuse-lite/data/features/flexbox-gap.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"1":"9 DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB nB fB"},D:{"1":"ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"gap property for Flexbox"};

},{}],"node_modules/caniuse-lite/data/features/flexbox.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","1028":"B","1316":"A"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","164":"qB GB G U I F E D A B C O T P H J K V W X nB fB","516":"Y Z a b c d"},D:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","33":"X Y Z a b c d e","164":"G U I F E D A B C O T P H J K V W"},E:{"1":"D A B C O dB VB L S hB iB","33":"F E bB cB","164":"G U I xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B C jB kB lB mB L EB oB","33":"P H"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","33":"E tB uB","164":"WB pB HB rB sB"},H:{"1":"7B"},I:{"1":"N CC DC","164":"GB G 8B 9B AC BC HB"},J:{"1":"A","164":"F"},K:{"1":"Q S","2":"A B C L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","292":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS Flexible Box Layout Module"};

},{}],"node_modules/caniuse-lite/data/features/flow-root.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"O hB iB","2":"G U I F E D A B C xB WB aB bB cB dB VB L S"},F:{"1":"0 1 2 3 4 5 6 7 8 9 v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u jB kB lB mB L EB oB S"},G:{"1":"3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"HC IC JC VB L","2":"G FC GC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"display: flow-root"};

},{}],"node_modules/caniuse-lite/data/features/focusin-focusout-events.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A B","2":"gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","16":"G U xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","2":"D jB kB lB mB","16":"B L EB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"2":"7B"},I:{"1":"G N BC HB CC DC","2":"8B 9B AC","16":"GB"},J:{"1":"F A"},K:{"1":"C Q S","2":"A","16":"B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:5,C:"focusin & focusout events"};

},{}],"node_modules/caniuse-lite/data/features/focusoptions-preventscroll.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"9 BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"1 2 3 4 5 6 7 8 9 AB CB DB BB w R M","2":"0 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:1,C:"preventScroll support in focus"};

},{}],"node_modules/caniuse-lite/data/features/font-family-system-ui.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s nB fB","132":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","260":"3 4 5"},E:{"1":"B C O L S hB iB","2":"G U I F E xB WB aB bB cB","16":"D","132":"A dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s jB kB lB mB L EB oB S"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB","132":"vB wB XB yB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"GC HC IC JC VB L","2":"G FC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"132":"MC"}},B:5,C:"system-ui value for font-family"};

},{}],"node_modules/caniuse-lite/data/features/font-feature.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","33":"P H J K V W X Y Z a b c d e f g h i j","164":"G U I F E D A B C O T"},D:{"1":"0 1 2 3 4 5 6 7 8 9 y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P","33":"X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x","292":"H J K V W"},E:{"1":"A B C O dB VB L S hB iB","2":"F E D xB WB bB cB","4":"G U I aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","33":"P H J K V W X Y Z a b c d e f g h i j k"},G:{"1":"wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E tB uB vB","4":"WB pB HB rB sB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB","33":"CC DC"},J:{"2":"F","33":"A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","33":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS font-feature-settings"};

},{}],"node_modules/caniuse-lite/data/features/font-kerning.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z nB fB","194":"a b c d e f g h i j"},D:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e","33":"f g h i"},E:{"1":"A B C O dB VB L S hB iB","2":"G U I xB WB aB bB","33":"F E D cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P jB kB lB mB L EB oB S","33":"H J K V"},G:{"2":"WB pB HB rB sB tB","33":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N DC","2":"GB G 8B 9B AC BC HB","33":"CC"},J:{"2":"F","33":"A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS3 font-kerning"};

},{}],"node_modules/caniuse-lite/data/features/font-loading.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k nB fB","194":"l m n o p q"},D:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X jB kB lB mB L EB oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"CSS Font Loading"};

},{}],"node_modules/caniuse-lite/data/features/font-size-adjust.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","194":"UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s","194":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f jB kB lB mB L EB oB S","194":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"258":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"194":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:4,C:"CSS font-size-adjust"};

},{}],"node_modules/caniuse-lite/data/features/font-smooth.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","676":"UB IB N"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a nB fB","804":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"G","676":"0 1 2 3 4 5 6 7 8 9 U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"xB WB","676":"G U I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","676":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"804":"MC"}},B:7,C:"CSS font-smooth"};

},{}],"node_modules/caniuse-lite/data/features/font-unicode-range.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","4":"D A B"},B:{"1":"J K UB IB N","4":"C O T P H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l nB fB","194":"m n o p q r s t"},D:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","4":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l"},E:{"1":"A B C O VB L S hB iB","4":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","4":"P H J K V W X Y"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","4":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N","4":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F","4":"A"},K:{"2":"A B C L EB S","4":"Q"},L:{"1":"N"},M:{"1":"M"},N:{"4":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","4":"G"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:4,C:"Font unicode-range subsetting"};

},{}],"node_modules/caniuse-lite/data/features/font-variant-alternates.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","130":"A B"},B:{"130":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","130":"G U I F E D A B C O T P H J K V W X Y Z","322":"a b c d e f g h i j"},D:{"2":"G U I F E D A B C O T P","130":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"A B C O dB VB L S hB iB","2":"F E D xB WB bB cB","130":"G U I aB"},F:{"2":"D B C jB kB lB mB L EB oB S","130":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"1":"wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB tB uB vB","130":"pB HB rB sB"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB","130":"N CC DC"},J:{"2":"F","130":"A"},K:{"2":"A B C L EB S","130":"Q"},L:{"130":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"130":"EC"},P:{"130":"G FC GC HC IC JC VB L"},Q:{"130":"KC"},R:{"130":"LC"},S:{"1":"MC"}},B:5,C:"CSS font-variant-alternates"};

},{}],"node_modules/caniuse-lite/data/features/font-variant-east-asian.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z nB fB","132":"a b c d e f g h i j"},D:{"1":"9 DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"2":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"132":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:4,C:"CSS font-variant-east-asian "};

},{}],"node_modules/caniuse-lite/data/features/font-variant-numeric.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j nB fB"},D:{"1":"2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"A B C O dB VB L S hB iB","2":"G U I F E D xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o jB kB lB mB L EB oB S"},G:{"1":"wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F","16":"A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"GC HC IC JC VB L","2":"G FC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:2,C:"CSS font-variant-numeric"};

},{}],"node_modules/caniuse-lite/data/features/fontface.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","132":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O WB aB bB cB dB VB L S hB iB","2":"xB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M kB lB mB L EB oB S","2":"D jB"},G:{"1":"E HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","260":"WB pB"},H:{"2":"7B"},I:{"1":"G N BC HB CC DC","2":"8B","4":"GB 9B AC"},J:{"1":"A","4":"F"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"@font-face Web fonts"};

},{}],"node_modules/caniuse-lite/data/features/form-attribute.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"H J K UB IB N","2":"C O T P"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB","16":"U"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","2":"D"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"1":"7B"},I:{"1":"GB G N BC HB CC DC","2":"8B 9B AC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Form attribute"};

},{}],"node_modules/caniuse-lite/data/features/form-submit-attributes.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","2":"G U xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M mB L EB oB S","2":"D jB","16":"kB lB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"1":"7B"},I:{"1":"G N BC HB CC DC","2":"8B 9B AC","16":"GB"},J:{"1":"A","2":"F"},K:{"1":"B C Q L EB S","16":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Attributes for form submission"};

},{}],"node_modules/caniuse-lite/data/features/form-validation.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D"},E:{"1":"B C O VB L S hB iB","2":"G xB WB","132":"U I F E D A aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M kB lB mB L EB oB S","2":"D jB"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB","132":"E pB HB rB sB tB uB vB wB XB"},H:{"516":"7B"},I:{"1":"N DC","2":"GB 8B 9B AC","132":"G BC HB CC"},J:{"1":"A","132":"F"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"260":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"132":"MC"}},B:1,C:"Form validation"};

},{}],"node_modules/caniuse-lite/data/features/forms.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"gB","4":"A B","8":"I F E D"},B:{"1":"H J K UB IB N","4":"C O T P"},C:{"4":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","8":"qB GB nB fB"},D:{"1":"9 FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","4":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB"},E:{"4":"G U I F E D A B C O aB bB cB dB VB L S hB iB","8":"xB WB"},F:{"1":"2 3 4 5 6 7 8 9 D B C AB CB DB BB w R M jB kB lB mB L EB oB S","4":"0 1 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},G:{"2":"WB","4":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB","4":"CC DC"},J:{"2":"F","4":"A"},K:{"1":"A B C L EB S","4":"Q"},L:{"1":"N"},M:{"4":"M"},N:{"4":"A B"},O:{"1":"EC"},P:{"1":"IC JC VB L","4":"G FC GC HC"},Q:{"1":"KC"},R:{"4":"LC"},S:{"4":"MC"}},B:1,C:"HTML5 form features"};

},{}],"node_modules/caniuse-lite/data/features/fullscreen.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","548":"B"},B:{"1":"UB IB N","516":"C O T P H J K"},C:{"1":"9 BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D nB fB","676":"A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q","1700":"0 1 2 3 4 5 6 7 8 x y z TB AB FB CB DB"},D:{"1":"LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T","676":"P H J K V","804":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB"},E:{"2":"G U xB WB","676":"aB","804":"I F E D A B C O bB cB dB VB L S hB iB"},F:{"1":"9 BB w R M S","2":"D B C jB kB lB mB L EB oB","804":"0 1 2 3 4 5 6 7 8 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B","2052":"1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F","292":"A"},K:{"2":"A B C L EB S","804":"Q"},L:{"804":"N"},M:{"1":"M"},N:{"2":"A","548":"B"},O:{"804":"EC"},P:{"1":"VB L","804":"G FC GC HC IC JC"},Q:{"804":"KC"},R:{"804":"LC"},S:{"1":"MC"}},B:1,C:"Full Screen API"};

},{}],"node_modules/caniuse-lite/data/features/gamepad.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W","33":"X Y Z a"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z jB kB lB mB L EB oB S"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:5,C:"Gamepad API"};

},{}],"node_modules/caniuse-lite/data/features/geolocation.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"gB","8":"I F E"},B:{"1":"C O T P H J K","129":"UB IB N"},C:{"1":"0 1 2 3 4 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","8":"qB GB","129":"5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","4":"G","129":"0 1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"U I F E D B C O aB bB cB dB VB L S hB iB","8":"G xB WB","129":"A"},F:{"1":"B C H J K V W X Y Z a b c d e f g h i j k l m n o mB L EB oB S","2":"D P jB","8":"kB lB","129":"0 1 2 3 4 5 6 7 8 9 p q r s t u v Q x y z AB CB DB BB w R M"},G:{"1":"E WB pB HB rB sB tB uB vB wB","129":"XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G 8B 9B AC BC HB CC DC","129":"N"},J:{"1":"F A"},K:{"1":"B C Q L EB S","8":"A"},L:{"129":"N"},M:{"129":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G","129":"FC GC HC IC JC VB L"},Q:{"129":"KC"},R:{"129":"LC"},S:{"1":"MC"}},B:2,C:"Geolocation"};

},{}],"node_modules/caniuse-lite/data/features/getboundingclientrect.js":[function(require,module,exports) {
module.exports={A:{A:{"644":"I F gB","2049":"D A B","2692":"E"},B:{"1":"UB IB N","2049":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB","260":"G U I F E D A B","1156":"GB","1284":"nB","1796":"fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","16":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M mB L EB oB S","16":"D jB","132":"kB lB"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB"},H:{"1":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"B C Q L EB S","132":"A"},L:{"1":"N"},M:{"1":"M"},N:{"2049":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"Element.getBoundingClientRect()"};

},{}],"node_modules/caniuse-lite/data/features/getcomputedstyle.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB","132":"GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","260":"G U I F E D A"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","260":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M mB L EB oB S","260":"D jB kB lB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","260":"WB pB HB"},H:{"260":"7B"},I:{"1":"G N BC HB CC DC","260":"GB 8B 9B AC"},J:{"1":"A","260":"F"},K:{"1":"B C Q L EB S","260":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"getComputedStyle"};

},{}],"node_modules/caniuse-lite/data/features/getelementsbyclassname.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"gB","8":"I F E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","8":"qB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","2":"D"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"getElementsByClassName"};

},{}],"node_modules/caniuse-lite/data/features/getrandomvalues.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","33":"B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","2":"G U I xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A","33":"B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"crypto.getRandomValues()"};

},{}],"node_modules/caniuse-lite/data/features/gyroscope.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","194":"8 9 TB AB FB CB DB BB w"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"4 5 6 7 8 9 AB CB DB BB w R M","2":"0 1 2 3 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:4,C:"Gyroscope"};

},{}],"node_modules/caniuse-lite/data/features/hardwareconcurrency.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"P H J K UB IB N","2":"C O T"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m"},E:{"2":"G U I F xB WB aB bB cB","129":"B C O VB L S hB iB","194":"E D A dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z jB kB lB mB L EB oB S"},G:{"2":"WB pB HB rB sB tB","129":"yB zB 0B 1B 2B 3B 4B 5B 6B","194":"E uB vB wB XB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"navigator.hardwareConcurrency"};

},{}],"node_modules/caniuse-lite/data/features/hashchange.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"E D A B","8":"I F gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB fB","8":"qB GB nB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","8":"G"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","8":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M mB L EB oB S","8":"D jB kB lB"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB"},H:{"2":"7B"},I:{"1":"GB G N 9B AC BC HB CC DC","2":"8B"},J:{"1":"F A"},K:{"1":"B C Q L EB S","8":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Hashchange event"};

},{}],"node_modules/caniuse-lite/data/features/heif.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A xB WB aB bB cB dB VB","130":"B C O L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB","130":"zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"HEIF/ISO Base Media File Format"};

},{}],"node_modules/caniuse-lite/data/features/hevc.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","132":"B"},B:{"2":"UB IB N","132":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"O hB iB","2":"G U I F E D A xB WB aB bB cB dB VB","516":"B C L S"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","258":"N"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"258":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G","258":"FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"HEVC/H.265 video format"};

},{}],"node_modules/caniuse-lite/data/features/hidden.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D A gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","2":"G U xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M L EB oB S","2":"D B jB kB lB mB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"1":"7B"},I:{"1":"G N BC HB CC DC","2":"GB 8B 9B AC"},J:{"1":"A","2":"F"},K:{"1":"C Q L EB S","2":"A B"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"hidden attribute"};

},{}],"node_modules/caniuse-lite/data/features/high-resolution-time.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V","33":"W X Y Z"},E:{"1":"E D A B C O dB VB L S hB iB","2":"G U I F xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"High Resolution Time API"};

},{}],"node_modules/caniuse-lite/data/features/history.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G xB WB","4":"U aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M EB oB S","2":"D B jB kB lB mB L"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB","4":"HB"},H:{"2":"7B"},I:{"1":"N 9B AC HB CC DC","2":"GB G 8B BC"},J:{"1":"F A"},K:{"1":"C Q L EB S","2":"A B"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Session history management"};

},{}],"node_modules/caniuse-lite/data/features/html-media-capture.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"WB pB HB rB","129":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N BC HB CC DC","2":"8B","257":"9B AC"},J:{"1":"A","16":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"516":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"16":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:4,C:"HTML Media Capture"};

},{}],"node_modules/caniuse-lite/data/features/html5semantic.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"gB","8":"I F E","260":"D A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB","132":"GB nB fB","260":"G U I F E D A B C O T P H J K V W"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","132":"G U","260":"I F E D A B C O T P H J K V W X Y Z a b"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","132":"G xB WB","260":"U I aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","132":"D B jB kB lB mB","260":"C L EB oB S"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","132":"WB","260":"pB HB rB sB"},H:{"132":"7B"},I:{"1":"N CC DC","132":"8B","260":"GB G 9B AC BC HB"},J:{"260":"F A"},K:{"1":"Q","132":"A","260":"B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"260":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"HTML5 semantic elements"};

},{}],"node_modules/caniuse-lite/data/features/http-live-streaming.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K","2":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N BC HB CC DC","2":"8B 9B AC"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:7,C:"HTTP Live Streaming (HLS)"};

},{}],"node_modules/caniuse-lite/data/features/http2.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","132":"B"},B:{"1":"C O T P H J K","513":"UB IB N"},C:{"1":"0 1 2 m n o p q r s t u v Q x y z","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l nB fB","513":"3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"0 r s t u v Q x y z","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q","513":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"B C O L S hB iB","2":"G U I F E xB WB aB bB cB","260":"D A dB VB"},F:{"1":"e f g h i j k l m n","2":"D B C P H J K V W X Y Z a b c d jB kB lB mB L EB oB S","513":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","513":"N"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"513":"N"},M:{"513":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G","513":"FC GC HC IC JC VB L"},Q:{"513":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"HTTP/2 protocol"};

},{}],"node_modules/caniuse-lite/data/features/http3.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB nB fB","194":"MB NB OB PB QB RB SB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","322":"UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"HTTP/3 protocol"};

},{}],"node_modules/caniuse-lite/data/features/iframe-sandbox.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H nB fB","4":"J K V W X Y Z a b c d"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB"},H:{"2":"7B"},I:{"1":"GB G N 9B AC BC HB CC DC","2":"8B"},J:{"1":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"sandbox attribute for iframes"};

},{}],"node_modules/caniuse-lite/data/features/iframe-seamless.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","66":"W X Y Z a b c"},E:{"2":"G U I E D A B C O xB WB aB bB dB VB L S hB iB","130":"F cB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","130":"tB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"seamless attribute for iframes"};

},{}],"node_modules/caniuse-lite/data/features/iframe-srcdoc.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"gB","8":"I F E D A B"},B:{"1":"UB IB N","8":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB","8":"GB G U I F E D A B C O T P H J K V W X Y Z a nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O","8":"T P H J K V"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"xB WB","8":"G U aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B jB kB lB mB","8":"C L EB oB S"},G:{"1":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB","8":"pB HB rB"},H:{"2":"7B"},I:{"1":"N CC DC","8":"GB G 8B 9B AC BC HB"},J:{"1":"A","8":"F"},K:{"1":"Q","2":"A B","8":"C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"8":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"srcdoc attribute for iframes"};

},{}],"node_modules/caniuse-lite/data/features/imagecapture.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","322":"UB IB N"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k nB fB","194":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"0 1 2 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","322":"3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p jB kB lB mB L EB oB S","322":"0 1 2 3 4 5 6 7 8 9 q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"322":"KC"},R:{"1":"LC"},S:{"194":"MC"}},B:5,C:"ImageCapture API"};

},{}],"node_modules/caniuse-lite/data/features/ime.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","161":"B"},B:{"2":"UB IB N","161":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A","161":"B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"Input Method Editor API"};

},{}],"node_modules/caniuse-lite/data/features/img-naturalwidth-naturalheight.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"naturalWidth & naturalHeight image properties"};

},{}],"node_modules/caniuse-lite/data/features/imports.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","8":"A B"},B:{"1":"UB","2":"IB N","8":"C O T P H J K"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f nB fB","8":"6 7 8 9 g h TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","72":"0 1 2 3 4 5 i j k l m n o p q r s t u v Q x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f IB N eB ZB YB","66":"g h i j k","72":"l"},E:{"2":"G U xB WB aB","8":"I F E D A B C O bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w","2":"D B C P H R M jB kB lB mB L EB oB S","66":"J K V W X","72":"Y"},G:{"2":"WB pB HB rB sB","8":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"2":"N"},M:{"8":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"HTML Imports"};

},{}],"node_modules/caniuse-lite/data/features/indeterminate-checkbox.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A B","16":"gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB fB","2":"qB GB","16":"nB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","2":"D B jB kB lB mB L EB"},G:{"1":"2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"2":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"indeterminate checkbox"};

},{}],"node_modules/caniuse-lite/data/features/indexeddb.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","132":"A B"},B:{"1":"UB IB N","132":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","33":"A B C O T P","36":"G U I F E D"},D:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"A","8":"G U I F E D","33":"Z","36":"B C O T P H J K V W X Y"},E:{"1":"A B C O VB L S hB iB","8":"G U I F xB WB aB bB","260":"E D cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D jB kB","8":"B C lB mB L EB oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","8":"WB pB HB rB sB tB","260":"E uB vB wB"},H:{"2":"7B"},I:{"1":"N CC DC","8":"GB G 8B 9B AC BC HB"},J:{"1":"A","8":"F"},K:{"1":"Q","2":"A","8":"B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"132":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"IndexedDB"};

},{}],"node_modules/caniuse-lite/data/features/indexeddb2.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t nB fB","132":"u v Q","260":"0 x y z"},D:{"1":"8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x","132":"0 1 y z","260":"2 3 4 5 6 7"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k jB kB lB mB L EB oB S","132":"l m n o","260":"p q r s t u"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB","16":"XB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"HC IC JC VB L","2":"G","260":"FC GC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"260":"MC"}},B:4,C:"IndexedDB 2.0"};

},{}],"node_modules/caniuse-lite/data/features/inline-block.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"E D A B","4":"gB","132":"I F"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","36":"qB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"CSS inline-block"};

},{}],"node_modules/caniuse-lite/data/features/innertext.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A B","16":"gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O WB aB bB cB dB VB L S hB iB","16":"xB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","16":"D"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB"},H:{"1":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"HTMLElement.innerText"};

},{}],"node_modules/caniuse-lite/data/features/input-autocomplete-onoff.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A gB","132":"B"},B:{"132":"C O T P H J K","260":"UB IB N"},C:{"1":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f nB fB","516":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"J K V W X Y Z a b c","2":"G U I F E D A B C O T P H","132":"d e f g h i j k l m n o p q","260":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"I aB bB","2":"G U xB WB","2052":"F E D A B C O cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"WB pB HB","1025":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1025":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2052":"A B"},O:{"1025":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"260":"KC"},R:{"1":"LC"},S:{"516":"MC"}},B:1,C:"autocomplete attribute: on & off values"};

},{}],"node_modules/caniuse-lite/data/features/input-color.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"T P H J K UB IB N","2":"C O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V"},E:{"1":"O S hB iB","2":"G U I F E D A B C xB WB aB bB cB dB VB L"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M L EB oB S","2":"D P H jB kB lB mB"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B","129":"2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:1,C:"Color input type"};

},{}],"node_modules/caniuse-lite/data/features/input-datetime.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"O T P H J K UB IB N","132":"C"},C:{"2":"0 1 2 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","1090":"3 4 5 6","2052":"7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V","2052":"W X Y Z a"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"WB pB HB","260":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB 8B 9B AC","514":"G BC HB"},J:{"1":"A","2":"F"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2052":"MC"}},B:1,C:"Date and time input types"};

},{}],"node_modules/caniuse-lite/data/features/input-email-tel-url.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","2":"D"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N BC HB CC DC","132":"8B 9B AC"},J:{"1":"A","132":"F"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Email, telephone & URL input types"};

},{}],"node_modules/caniuse-lite/data/features/input-event.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","2561":"A B","2692":"D"},B:{"1":"UB IB N","2561":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","16":"qB","1537":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y fB","1796":"GB nB"},D:{"1":"w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T","1025":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z TB AB FB CB DB BB","1537":"P H J K V W X Y Z a b c d e f g h i j k"},E:{"1":"hB iB","16":"G U I xB WB","1025":"F E D A B C bB cB dB VB L","1537":"aB","4097":"O S"},F:{"1":"2 3 4 5 6 7 8 9 AB CB DB BB w R M S","16":"D B C jB kB lB mB L EB","260":"oB","1025":"0 1 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","1537":"P H J K V W X"},G:{"16":"WB pB HB","1025":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","1537":"rB sB tB"},H:{"2":"7B"},I:{"16":"8B 9B","1025":"N DC","1537":"GB G AC BC HB CC"},J:{"1025":"A","1537":"F"},K:{"1":"A B C L EB S","1025":"Q"},L:{"1":"N"},M:{"1537":"M"},N:{"2561":"A B"},O:{"1537":"EC"},P:{"1025":"G FC GC HC IC JC VB L"},Q:{"1025":"KC"},R:{"1025":"LC"},S:{"1537":"MC"}},B:1,C:"input event"};

},{}],"node_modules/caniuse-lite/data/features/input-file-accept.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","132":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G","16":"U I F E X Y Z a b","132":"D A B C O T P H J K V W"},E:{"1":"C O L S hB iB","2":"G U xB WB aB","132":"I F E D A B bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"2":"sB tB","132":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","514":"WB pB HB rB"},H:{"2":"7B"},I:{"2":"8B 9B AC","260":"GB G BC HB","514":"N CC DC"},J:{"132":"A","260":"F"},K:{"2":"A B C L EB S","260":"Q"},L:{"260":"N"},M:{"2":"M"},N:{"514":"A","1028":"B"},O:{"2":"EC"},P:{"260":"G FC GC HC IC JC VB L"},Q:{"260":"KC"},R:{"260":"LC"},S:{"1":"MC"}},B:1,C:"accept attribute for file input"};

},{}],"node_modules/caniuse-lite/data/features/input-file-directory.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"T P H J K UB IB N","2":"C O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f"},E:{"1":"C O L S hB iB","2":"G U I F E D A B xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Directory selection from file input"};

},{}],"node_modules/caniuse-lite/data/features/input-file-multiple.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB fB","2":"qB GB nB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M mB L EB oB S","2":"D jB kB lB"},G:{"1":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB"},H:{"130":"7B"},I:{"130":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"130":"A B C Q L EB S"},L:{"132":"N"},M:{"130":"M"},N:{"2":"A B"},O:{"130":"EC"},P:{"130":"G","132":"FC GC HC IC JC VB L"},Q:{"132":"KC"},R:{"132":"LC"},S:{"2":"MC"}},B:1,C:"Multiple file selection"};

},{}],"node_modules/caniuse-lite/data/features/input-inputmode.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"qB GB G U I F E D A B C O T P H nB fB","4":"J K V W","194":"0 1 2 3 4 5 6 7 8 9 X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","66":"6 7 8 9 TB AB FB CB DB BB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"3 4 5 6 7 8 9 AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s jB kB lB mB L EB oB S","66":"0 1 2 t u v Q x y z"},G:{"1":"2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"194":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"JC VB L","2":"G FC GC HC IC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"194":"MC"}},B:1,C:"inputmode attribute"};

},{}],"node_modules/caniuse-lite/data/features/input-minlength.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"J K UB IB N","2":"C O T P H"},C:{"1":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c jB kB lB mB L EB oB S"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:1,C:"Minimum length attribute for input fields"};

},{}],"node_modules/caniuse-lite/data/features/input-number.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","129":"A B"},B:{"1":"UB IB N","129":"C O","1025":"T P H J K"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e nB fB","513":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"388":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB 8B 9B AC","388":"G N BC HB CC DC"},J:{"2":"F","388":"A"},K:{"1":"A B C L EB S","388":"Q"},L:{"388":"N"},M:{"641":"M"},N:{"388":"A B"},O:{"388":"EC"},P:{"388":"G FC GC HC IC JC VB L"},Q:{"388":"KC"},R:{"388":"LC"},S:{"513":"MC"}},B:1,C:"Number input type"};

},{}],"node_modules/caniuse-lite/data/features/input-pattern.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D"},E:{"1":"B C O VB L S hB iB","2":"G xB WB","16":"U","388":"I F E D A aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","2":"D"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB","388":"E rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"1":"N DC","2":"GB G 8B 9B AC BC HB CC"},J:{"1":"A","2":"F"},K:{"1":"A B C L EB S","132":"Q"},L:{"1":"N"},M:{"1":"M"},N:{"132":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Pattern attribute for input fields"};

},{}],"node_modules/caniuse-lite/data/features/input-placeholder.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","132":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M EB oB S","2":"D jB kB lB mB","132":"B L"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB N 8B 9B AC HB CC DC","4":"G BC"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"input placeholder attribute"};

},{}],"node_modules/caniuse-lite/data/features/input-range.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"2":"7B"},I:{"1":"N HB CC DC","4":"GB G 8B 9B AC BC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Range input type"};

},{}],"node_modules/caniuse-lite/data/features/input-search.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","129":"A B"},B:{"1":"UB IB N","129":"C O T P H J K"},C:{"2":"qB GB nB fB","129":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T X Y Z a b","129":"P H J K V W"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","16":"G U xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","2":"D jB kB lB mB","16":"B L EB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB"},H:{"129":"7B"},I:{"1":"N CC DC","16":"8B 9B","129":"GB G AC BC HB"},J:{"1":"F","129":"A"},K:{"1":"C","2":"A","16":"B L EB","129":"Q S"},L:{"1":"N"},M:{"129":"M"},N:{"129":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"129":"MC"}},B:1,C:"Search input type"};

},{}],"node_modules/caniuse-lite/data/features/input-selection.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","16":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M mB L EB oB S","16":"D jB kB lB"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB"},H:{"2":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Selection controls for input & textarea"};

},{}],"node_modules/caniuse-lite/data/features/insert-adjacent.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A B","16":"gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","16":"D"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Element.insertAdjacentElement() & Element.insertAdjacentText()"};

},{}],"node_modules/caniuse-lite/data/features/insertadjacenthtml.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","16":"gB","132":"I F E D"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M kB lB mB L EB oB S","16":"D jB"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB"},H:{"1":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"Element.insertAdjacentHTML()"};

},{}],"node_modules/caniuse-lite/data/features/internationalization.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D A gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:6,C:"Internationalization API"};

},{}],"node_modules/caniuse-lite/data/features/intersectionobserver-v2.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"9 CB DB BB w R M","2":"0 1 2 3 4 5 6 7 8 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"L","2":"G FC GC HC IC JC VB"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"IntersectionObserver V2"};

},{}],"node_modules/caniuse-lite/data/features/intersectionobserver.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"H J K","2":"C O T","516":"P","1025":"UB IB N"},C:{"1":"5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","194":"2 3 4"},D:{"1":"8 TB AB FB CB DB BB","2":"0 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","516":"1 2 3 4 5 6 7","1025":"9 w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"O S hB iB","2":"G U I F E D A B C xB WB aB bB cB dB VB L"},F:{"1":"0 1 2 3 4 5 6 7 8 v Q x y z AB CB DB","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n jB kB lB mB L EB oB S","516":"o p q r s t u","1025":"9 BB w R M"},G:{"1":"2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","1025":"N"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"516":"EC"},P:{"1":"HC IC JC VB L","2":"G","516":"FC GC"},Q:{"1025":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"IntersectionObserver"};

},{}],"node_modules/caniuse-lite/data/features/intl-pluralrules.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J","130":"K"},C:{"1":"8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"9 DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB"},E:{"1":"O hB iB","2":"G U I F E D A B C xB WB aB bB cB dB VB L S"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"1":"3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"IC JC VB L","2":"G FC GC HC"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"Intl.PluralRules API"};

},{}],"node_modules/caniuse-lite/data/features/intrinsic-width.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","1537":"UB IB N"},C:{"2":"qB","932":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB nB fB","2308":"w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"G U I F E D A B C O T P H J K V W X","545":"Y Z a b c d e f g h i j k l m n o p q r s t u v","1537":"0 1 2 3 4 5 6 7 8 9 Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I xB WB aB","516":"B C O L S hB iB","548":"D A dB VB","676":"F E bB cB"},F:{"2":"D B C jB kB lB mB L EB oB S","513":"k","545":"P H J K V W X Y Z a b c d e f g h i","1537":"0 1 2 3 4 5 6 7 8 9 j l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"WB pB HB rB sB","548":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","676":"E tB uB"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB","545":"CC DC","1537":"N"},J:{"2":"F","545":"A"},K:{"2":"A B C L EB S","1537":"Q"},L:{"1537":"N"},M:{"2340":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"545":"G","1537":"FC GC HC IC JC VB L"},Q:{"545":"KC"},R:{"1537":"LC"},S:{"932":"MC"}},B:5,C:"Intrinsic & Extrinsic Sizing"};

},{}],"node_modules/caniuse-lite/data/features/jpeg2000.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G xB WB","129":"U aB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"JPEG 2000 image format"};

},{}],"node_modules/caniuse-lite/data/features/jpegxr.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K","2":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"1":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"JPEG XR image format"};

},{}],"node_modules/caniuse-lite/data/features/js-regexp-lookbehind.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"9 CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"IC JC VB L","2":"G FC GC HC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"Lookbehind in JS regular expressions"};

},{}],"node_modules/caniuse-lite/data/features/json.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F gB","129":"E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D jB kB"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"JSON parsing"};

},{}],"node_modules/caniuse-lite/data/features/justify-content-space-evenly.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P","132":"H J K"},C:{"1":"2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"9 AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","132":"7 8 TB"},E:{"1":"B C O L S hB iB","2":"G U I F E D A xB WB aB bB cB dB","132":"VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t jB kB lB mB L EB oB S","132":"u v Q"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB","132":"yB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"132":"EC"},P:{"1":"IC JC VB L","2":"G FC GC","132":"HC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"132":"MC"}},B:5,C:"CSS justify-content: space-evenly"};

},{}],"node_modules/caniuse-lite/data/features/kerning-pairs-ligatures.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"K UB IB N","2":"C O T P H J"},C:{"1":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"8B 9B AC","132":"GB G BC HB"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:7,C:"High-quality kerning pairs & ligatures"};

},{}],"node_modules/caniuse-lite/data/features/keyboardevent-charcode.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","16":"qB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","16":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B jB kB lB mB L EB oB","16":"C"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB"},H:{"2":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"S","2":"A B L EB","16":"C","130":"Q"},L:{"1":"N"},M:{"130":"M"},N:{"130":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:7,C:"KeyboardEvent.charCode"};

},{}],"node_modules/caniuse-lite/data/features/keyboardevent-code.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r","194":"s t u v Q x"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e jB kB lB mB L EB oB S","194":"f g h i j k"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C L EB S","194":"Q"},L:{"194":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G","194":"FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"194":"LC"},S:{"1":"MC"}},B:5,C:"KeyboardEvent.code"};

},{}],"node_modules/caniuse-lite/data/features/keyboardevent-getmodifierstate.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B P H jB kB lB mB L EB oB","16":"C"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"2":"F A"},K:{"1":"Q S","2":"A B L EB","16":"C"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"KeyboardEvent.getModifierState()"};

},{}],"node_modules/caniuse-lite/data/features/keyboardevent-key.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","260":"D A B"},B:{"1":"UB IB N","260":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y nB fB","132":"Z a b c d e"},D:{"1":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B P H J K V W X Y Z a b c d e f g h i j k l m n jB kB lB mB L EB oB","16":"C"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"1":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"S","2":"A B L EB","16":"C Q"},L:{"1":"N"},M:{"1":"M"},N:{"260":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"2":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:5,C:"KeyboardEvent.key"};

},{}],"node_modules/caniuse-lite/data/features/keyboardevent-location.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","132":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","16":"I xB WB","132":"G U aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B jB kB lB mB L EB oB","16":"C","132":"P H"},G:{"1":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB","132":"rB sB tB"},H:{"2":"7B"},I:{"1":"N CC DC","16":"8B 9B","132":"GB G AC BC HB"},J:{"132":"F A"},K:{"1":"Q S","2":"A B L EB","16":"C"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"KeyboardEvent.location"};

},{}],"node_modules/caniuse-lite/data/features/keyboardevent-which.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB","16":"U"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M kB lB mB L EB oB S","16":"D jB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB"},H:{"2":"7B"},I:{"1":"GB G N AC BC HB","16":"8B 9B","132":"CC DC"},J:{"1":"F A"},K:{"1":"A B C L EB S","132":"Q"},L:{"132":"N"},M:{"132":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"2":"G","132":"FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"132":"LC"},S:{"1":"MC"}},B:7,C:"KeyboardEvent.which"};

},{}],"node_modules/caniuse-lite/data/features/lazyload.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D A gB"},B:{"1":"C O T P H J K","2":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"1":"B","2":"A"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Resource Hints: Lazyload"};

},{}],"node_modules/caniuse-lite/data/features/let.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","2052":"B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","194":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K","322":"V W X Y Z a b c d e f g h i j k l m n o p q","516":"r s t u v Q x y"},E:{"1":"B C O L S hB iB","2":"G U I F E D xB WB aB bB cB dB","1028":"A VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","322":"P H J K V W X Y Z a b c d","516":"e f g h i j k l"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB","1028":"XB yB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","516":"G"},Q:{"1":"KC"},R:{"516":"LC"},S:{"1":"MC"}},B:6,C:"let"};

},{}],"node_modules/caniuse-lite/data/features/link-icon-png.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D A gB"},B:{"1":"C O T P H J K","129":"UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"129":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"257":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"129":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","513":"D B C jB kB lB mB L EB oB S"},G:{"1026":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1026":"7B"},I:{"1":"GB G 8B 9B AC BC HB","513":"N CC DC"},J:{"1":"F","1026":"A"},K:{"1026":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1026":"A B"},O:{"257":"EC"},P:{"1":"FC GC HC IC JC VB L","513":"G"},Q:{"129":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"PNG favicons"};

},{}],"node_modules/caniuse-lite/data/features/link-icon-svg.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB","3073":"IB N"},C:{"2":"qB GB nB fB","260":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q","1025":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB","3073":"IB N eB ZB YB"},E:{"2":"G U I F E xB WB aB bB cB","516":"D A B C O dB VB L S hB iB"},F:{"1":"0 1 2 3 u v Q x y z","2":"4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t AB CB DB BB w jB kB lB mB L EB oB S","3073":"R M"},G:{"130":"E WB pB HB rB sB tB uB","516":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"130":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F","130":"A"},K:{"130":"A B C Q L EB S"},L:{"3073":"N"},M:{"2":"M"},N:{"130":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"1025":"MC"}},B:1,C:"SVG favicons"};

},{}],"node_modules/caniuse-lite/data/features/link-rel-dns-prefetch.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E gB","132":"D"},B:{"1":"C O T P H J K UB IB N"},C:{"2":"qB GB","260":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"16":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"16":"GB G N 8B 9B AC BC HB CC DC"},J:{"16":"F A"},K:{"16":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"16":"EC"},P:{"1":"FC GC HC IC JC VB L","16":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"Resource Hints: dns-prefetch"};

},{}],"node_modules/caniuse-lite/data/features/link-rel-modulepreload.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"3 4 5 6 7 8 9 AB CB DB BB w R M","2":"0 1 2 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"JC VB L","2":"G FC GC HC IC"},Q:{"16":"KC"},R:{"16":"LC"},S:{"2":"MC"}},B:1,C:"Resource Hints: modulepreload"};

},{}],"node_modules/caniuse-lite/data/features/link-rel-preconnect.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T","260":"P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o nB fB","129":"p"},D:{"1":"0 1 2 3 4 5 6 7 8 9 Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v"},E:{"1":"C O L S hB iB","2":"G U I F E D A B xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i jB kB lB mB L EB oB S"},G:{"1":"0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"16":"M"},N:{"2":"A B"},O:{"16":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"Resource Hints: preconnect"};

},{}],"node_modules/caniuse-lite/data/features/link-rel-prefetch.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D A gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"G N CC DC","2":"GB 8B 9B AC BC HB"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"Resource Hints: prefetch"};

},{}],"node_modules/caniuse-lite/data/features/link-rel-preload.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H","1028":"J K"},C:{"2":"0 1 2 3 4 5 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","132":"6","578":"7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"C O L S hB iB","2":"G U I F E D A xB WB aB bB cB dB VB","322":"B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m jB kB lB mB L EB oB S"},G:{"1":"0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB","322":"zB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"578":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:4,C:"Resource Hints: preload"};

},{}],"node_modules/caniuse-lite/data/features/link-rel-prerender.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D A gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"1":"B","2":"A"},O:{"2":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:5,C:"Resource Hints: prerender"};

},{}],"node_modules/caniuse-lite/data/features/loading-lazy-attr.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB nB fB"},D:{"1":"QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB","194":"PB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S","322":"hB iB"},F:{"1":"9 BB w R M","2":"0 1 2 3 4 5 6 7 8 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B","322":"6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:1,C:"Lazy loading via attribute for images & iframes"};

},{}],"node_modules/caniuse-lite/data/features/localecompare.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","16":"gB","132":"I F E D A"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","132":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","132":"G U I F E D A B C O T P H J K V W X Y Z"},E:{"1":"A B C O VB L S hB iB","132":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","16":"D B C jB kB lB mB L EB oB","132":"S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","132":"E WB pB HB rB sB tB uB vB wB"},H:{"132":"7B"},I:{"1":"N CC DC","132":"GB G 8B 9B AC BC HB"},J:{"132":"F A"},K:{"1":"Q","16":"A B C L EB","132":"S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","132":"A"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","132":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"4":"MC"}},B:6,C:"localeCompare()"};

},{}],"node_modules/caniuse-lite/data/features/magnetometer.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","194":"8 9 TB AB FB CB DB BB w"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"4 5 6 7 8 9 AB CB DB BB w R M","2":"0 1 2 3 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"194":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:4,C:"Magnetometer"};

},{}],"node_modules/caniuse-lite/data/features/matchesselector.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","36":"D A B"},B:{"1":"P H J K UB IB N","36":"C O T"},C:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB","36":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","36":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j"},E:{"1":"E D A B C O cB dB VB L S hB iB","2":"G xB WB","36":"U I F aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B jB kB lB mB L","36":"C P H J K V W EB oB S"},G:{"1":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB","36":"pB HB rB sB tB"},H:{"2":"7B"},I:{"1":"N","2":"8B","36":"GB G 9B AC BC HB CC DC"},J:{"36":"F A"},K:{"1":"Q","2":"A B","36":"C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"36":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","36":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"matches() DOM method"};

},{}],"node_modules/caniuse-lite/data/features/matchmedia.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","2":"G U xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B C jB kB lB mB L EB oB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"1":"7B"},I:{"1":"GB G N BC HB CC DC","2":"8B 9B AC"},J:{"1":"A","2":"F"},K:{"1":"Q S","2":"A B C L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"matchMedia"};

},{}],"node_modules/caniuse-lite/data/features/mathml.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"D A B gB","8":"I F E"},B:{"2":"C O T P H J K","8":"UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","129":"qB GB nB fB"},D:{"1":"a","8":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"A B C O VB L S hB iB","260":"G U I F E D xB WB aB bB cB dB"},F:{"2":"D","4":"B C jB kB lB mB L EB oB S","8":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","8":"WB pB HB"},H:{"8":"7B"},I:{"8":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"A","8":"F"},K:{"8":"A B C Q L EB S"},L:{"8":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"4":"EC"},P:{"8":"G FC GC HC IC JC VB L"},Q:{"8":"KC"},R:{"8":"LC"},S:{"1":"MC"}},B:2,C:"MathML"};

},{}],"node_modules/caniuse-lite/data/features/maxlength.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","16":"gB","900":"I F E D"},B:{"1":"UB IB N","1025":"C O T P H J K"},C:{"1":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","900":"qB GB nB fB","1025":"0 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","16":"U xB","900":"G WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","16":"D","132":"B C jB kB lB mB L EB oB S"},G:{"1":"pB HB rB sB tB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB","2052":"E uB"},H:{"132":"7B"},I:{"1":"GB G AC BC HB CC DC","16":"8B 9B","4097":"N"},J:{"1":"F A"},K:{"132":"A B C L EB S","4100":"Q"},L:{"4097":"N"},M:{"4097":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"4097":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1025":"MC"}},B:1,C:"maxlength attribute for input and textarea elements"};

},{}],"node_modules/caniuse-lite/data/features/media-attribute.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K","16":"UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T nB fB"},D:{"1":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j","2":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N","16":"eB ZB YB"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","2":"G U xB WB"},F:{"1":"B C P H J K V W X Y Z a kB lB mB L EB oB S","2":"0 1 2 3 4 5 6 7 8 9 D b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB"},H:{"16":"7B"},I:{"1":"G N BC HB CC DC","16":"GB 8B 9B AC"},J:{"16":"F A"},K:{"1":"C Q S","16":"A B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"16":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Media attribute"};

},{}],"node_modules/caniuse-lite/data/features/media-fragments.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","132":"UB IB N"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j nB fB","132":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"G U I F E D A B C O T P H J","132":"0 1 2 3 4 5 6 7 8 9 K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U xB WB aB","132":"I F E D A B C O bB cB dB VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","132":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"WB pB HB rB sB tB","132":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB","132":"N CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"132":"N"},M:{"132":"M"},N:{"132":"A B"},O:{"2":"EC"},P:{"2":"G FC","132":"GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"132":"MC"}},B:2,C:"Media Fragments"};

},{}],"node_modules/caniuse-lite/data/features/media-session-api.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S","16":"hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"Media Session API"};

},{}],"node_modules/caniuse-lite/data/features/mediacapture-fromelement.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s nB fB","260":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"9 CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","324":"1 2 3 4 5 6 7 8 TB AB FB"},E:{"2":"G U I F E D A xB WB aB bB cB dB VB","132":"B C O L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l jB kB lB mB L EB oB S","324":"m n o p q r s t u v Q x"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"260":"M"},N:{"2":"A B"},O:{"132":"EC"},P:{"1":"IC JC VB L","2":"G","132":"FC GC HC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"260":"MC"}},B:5,C:"Media Capture from DOM Elements API"};

},{}],"node_modules/caniuse-lite/data/features/mediarecorder.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q","194":"x y"},E:{"1":"hB iB","2":"G U I F E D A B C xB WB aB bB cB dB VB L","322":"O S"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j jB kB lB mB L EB oB S","194":"k l"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B","578":"1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:5,C:"MediaRecorder API"};

},{}],"node_modules/caniuse-lite/data/features/mediasource.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","260":"B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a nB fB","194":"b c d e f g h i j k l m n o p q r"},D:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H","33":"Z a b c d e f g","66":"J K V W X Y"},E:{"1":"E D A B C O dB VB L S hB iB","2":"G U I F xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B","1028":"3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N DC","2":"GB G 8B 9B AC BC HB CC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"1":"EC"},P:{"514":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"Media Source Extensions"};

},{}],"node_modules/caniuse-lite/data/features/menu.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","2114":"UB IB N"},C:{"2":"qB GB G U I F nB fB","132":"0 1 2 3 4 5 6 7 8 9 E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q","322":"0 1 y z","578":"r s t u v Q x","2114":"2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k jB kB lB mB L EB oB S","322":"l m n o","2114":"0 1 2 3 4 5 6 7 8 9 p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"1156":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2114":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Context menu item (menuitem element)"};

},{}],"node_modules/caniuse-lite/data/features/meta-theme-color.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o","132":"NB OB PB QB RB SB UB IB N eB ZB YB","258":"0 1 2 3 4 5 6 7 8 9 p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"513":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"GC HC IC JC VB L","2":"G","16":"FC"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:1,C:"theme-color Meta Tag"};

},{}],"node_modules/caniuse-lite/data/features/meter.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"O T P H J K UB IB N","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M L EB oB S","2":"D jB kB lB mB"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"1":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"meter element"};

},{}],"node_modules/caniuse-lite/data/features/midi.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:5,C:"Web MIDI API"};

},{}],"node_modules/caniuse-lite/data/features/minmaxwh.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","8":"I gB","129":"F","257":"E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"CSS min/max-width/height"};

},{}],"node_modules/caniuse-lite/data/features/mp3.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB","132":"G U I F E D A B C O T P H J K V W X nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB"},H:{"2":"7B"},I:{"1":"GB G N AC BC HB CC DC","2":"8B 9B"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"MP3 audio format"};

},{}],"node_modules/caniuse-lite/data/features/mpeg-dash.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K","2":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","386":"X Y"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"Dynamic Adaptive Streaming over HTTP (MPEG-DASH)"};

},{}],"node_modules/caniuse-lite/data/features/mpeg4.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W nB fB","4":"X Y Z a b c d e f g h i j k"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O WB aB bB cB dB VB L S hB iB","2":"xB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N CC DC","4":"GB G 8B 9B BC HB","132":"AC"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"260":"M"},N:{"1":"A B"},O:{"4":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"MPEG-4/H.264 video format"};

},{}],"node_modules/caniuse-lite/data/features/multibackgrounds.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB fB","2":"qB GB nB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D jB kB"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS3 Multiple backgrounds"};

},{}],"node_modules/caniuse-lite/data/features/multicolumn.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K","516":"UB IB N"},C:{"132":"2 3 4 5 6 7 8 TB AB FB CB DB BB","164":"0 1 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","516":"9 w R M JB KB LB MB NB OB PB QB RB SB"},D:{"420":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","516":"0 1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"A B C O VB L S hB iB","132":"D dB","164":"F E cB","420":"G U I xB WB aB bB"},F:{"1":"C L EB oB S","2":"D B jB kB lB mB","420":"P H J K V W X Y Z a b c d e f g h i j k l m","516":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","132":"vB wB","164":"E tB uB","420":"WB pB HB rB sB"},H:{"1":"7B"},I:{"420":"GB G 8B 9B AC BC HB CC DC","516":"N"},J:{"420":"F A"},K:{"1":"C L EB S","2":"A B","132":"Q"},L:{"516":"N"},M:{"132":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","420":"G"},Q:{"132":"KC"},R:{"132":"LC"},S:{"164":"MC"}},B:4,C:"CSS3 Multiple column layout"};

},{}],"node_modules/caniuse-lite/data/features/mutation-events.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","260":"D A B"},B:{"132":"UB IB N","260":"C O T P H J K"},C:{"2":"qB GB G U nB fB","260":"0 1 2 3 4 5 6 7 8 9 I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"16":"G U I F E D A B C O T","132":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"16":"xB WB","132":"G U I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"1":"C oB S","2":"D jB kB lB mB","16":"B L EB","132":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"16":"WB pB","132":"E HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"16":"8B 9B","132":"GB G N AC BC HB CC DC"},J:{"132":"F A"},K:{"1":"C S","2":"A","16":"B L EB","132":"Q"},L:{"132":"N"},M:{"260":"M"},N:{"260":"A B"},O:{"132":"EC"},P:{"132":"G FC GC HC IC JC VB L"},Q:{"132":"KC"},R:{"132":"LC"},S:{"260":"MC"}},B:5,C:"Mutation events"};

},{}],"node_modules/caniuse-lite/data/features/mutationobserver.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E gB","8":"D A"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J","33":"K V W X Y Z a b c"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB","33":"I"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB","33":"sB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB 8B 9B AC","8":"G BC HB"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","8":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Mutation Observer"};

},{}],"node_modules/caniuse-lite/data/features/namevalue-storage.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"E D A B","2":"gB","8":"I F"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","4":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D jB kB"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Web Storage - name/value pairs"};

},{}],"node_modules/caniuse-lite/data/features/native-filesystem-api.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB","194":"QB RB UB IB N eB ZB YB","450":"SB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"194":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Native Filesystem API"};

},{}],"node_modules/caniuse-lite/data/features/nav-timing.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U","33":"I F E D A B C"},E:{"1":"E D A B C O dB VB L S hB iB","2":"G U I F xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"G N BC HB CC DC","2":"GB 8B 9B AC"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"Navigation Timing API"};

},{}],"node_modules/caniuse-lite/data/features/navigator-language.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"H J K UB IB N","2":"C O T P"},C:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z jB kB lB mB L EB oB S"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"16":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"16":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"16":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"16":"KC"},R:{"16":"LC"},S:{"1":"MC"}},B:2,C:"Navigator Language API"};

},{}],"node_modules/caniuse-lite/data/features/netinfo.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","1028":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB","1028":"9 FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x jB kB lB mB L EB oB S","1028":"0 1 2 3 4 5 6 7 8 9 y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"8B CC DC","132":"GB G 9B AC BC HB"},J:{"2":"F A"},K:{"2":"A B C L EB S","516":"Q"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"IC JC VB L","132":"G","516":"FC GC HC"},Q:{"1":"KC"},R:{"516":"LC"},S:{"260":"MC"}},B:7,C:"Network Information API"};

},{}],"node_modules/caniuse-lite/data/features/node-contains.js":[function(require,module,exports) {
module.exports={A:{A:{"16":"gB","644":"D A B","2308":"I F E"},B:{"1":"O T P H J K UB IB N","16":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T P H J K V W X Y Z a b"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","16":"G U I xB WB","1668":"aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","16":"D B C jB kB lB mB L EB","132":"oB"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB rB sB"},H:{"16":"7B"},I:{"1":"N CC DC","16":"GB 8B 9B AC","1668":"G BC HB"},J:{"16":"F A"},K:{"16":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"16":"A B"},O:{"16":"EC"},P:{"1":"FC GC HC IC JC VB L","16":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Node.contains()"};

},{}],"node_modules/caniuse-lite/data/features/node-parentelement.js":[function(require,module,exports) {
module.exports={A:{A:{"16":"gB","132":"D A B","260":"I F E"},B:{"1":"O T P H J K UB IB N","16":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T P H J K V W X Y Z a b"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","16":"G U xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","16":"D B jB kB lB mB L EB","132":"C oB S"},G:{"1":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB rB"},H:{"16":"7B"},I:{"1":"G N BC HB CC DC","16":"GB 8B 9B AC"},J:{"16":"F A"},K:{"16":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"16":"A B"},O:{"16":"EC"},P:{"1":"FC GC HC IC JC VB L","16":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Node.parentElement"};

},{}],"node_modules/caniuse-lite/data/features/notifications.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"T P H J K UB IB N","2":"C O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G","36":"U I F E D A B C O T P H J K V W X"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB","36":"N CC DC"},J:{"1":"A","2":"F"},K:{"2":"A B C L EB S","36":"Q"},L:{"513":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"36":"G","258":"FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"258":"LC"},S:{"1":"MC"}},B:1,C:"Web Notifications"};

},{}],"node_modules/caniuse-lite/data/features/object-entries.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"T P H J K UB IB N","2":"C O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q nB fB"},D:{"1":"4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q jB kB lB mB L EB oB S"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F","16":"A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"GC HC IC JC VB L","2":"G FC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:6,C:"Object.entries"};

},{}],"node_modules/caniuse-lite/data/features/object-fit.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P","260":"H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g"},E:{"1":"A B C O VB L S hB iB","2":"G U I F xB WB aB bB","132":"E D cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D P H J K jB kB lB","33":"B C mB L EB oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB","132":"E uB vB wB"},H:{"33":"7B"},I:{"1":"N DC","2":"GB G 8B 9B AC BC HB CC"},J:{"2":"F A"},K:{"1":"Q","2":"A","33":"B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS3 object-fit/object-position"};

},{}],"node_modules/caniuse-lite/data/features/object-observe.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"m n o p q r s t u v Q x y z","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"Z a b c d e f g h i j k l m","2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"G","2":"FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:7,C:"Object.observe data binding"};

},{}],"node_modules/caniuse-lite/data/features/object-values.js":[function(require,module,exports) {
module.exports={A:{A:{"8":"I F E D A B gB"},B:{"1":"T P H J K UB IB N","2":"C O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","8":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q nB fB"},D:{"1":"4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","8":"0 1 2 3 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"B C O VB L S hB iB","8":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z AB CB DB BB w R M","8":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q jB kB lB mB L EB oB S"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","8":"E WB pB HB rB sB tB uB vB wB XB"},H:{"8":"7B"},I:{"1":"N","8":"GB G 8B 9B AC BC HB CC DC"},J:{"8":"F A"},K:{"1":"Q","8":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"8":"A B"},O:{"1":"EC"},P:{"1":"GC HC IC JC VB L","8":"G FC"},Q:{"1":"KC"},R:{"8":"LC"},S:{"1":"MC"}},B:6,C:"Object.values method"};

},{}],"node_modules/caniuse-lite/data/features/objectrtc.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"O T P H J K","2":"C UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F","130":"A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"Object RTC (ORTC) API for WebRTC"};

},{}],"node_modules/caniuse-lite/data/features/offline-apps.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"D gB","8":"I F E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","4":"GB","8":"qB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB","2":"YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","8":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M mB L EB oB S","2":"D jB","8":"kB lB"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:7,C:"Offline web applications"};

},{}],"node_modules/caniuse-lite/data/features/offscreencanvas.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t nB fB","194":"0 1 2 3 4 5 6 7 8 9 u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","322":"8 9 TB AB FB CB DB BB w R M"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"9 BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u jB kB lB mB L EB oB S","322":"0 1 2 3 4 5 6 7 8 v Q x y z AB CB DB"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"194":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"VB L","2":"G FC GC HC IC JC"},Q:{"2":"KC"},R:{"2":"LC"},S:{"194":"MC"}},B:1,C:"OffscreenCanvas"};

},{}],"node_modules/caniuse-lite/data/features/ogg-vorbis.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"J K UB IB N","2":"C O T P H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D jB kB"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"A","2":"F"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"Ogg Vorbis audio format"};

},{}],"node_modules/caniuse-lite/data/features/ogv.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","8":"D A B"},B:{"1":"J K UB IB N","8":"C O T P H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D jB kB"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"1":"M"},N:{"8":"A B"},O:{"1":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:6,C:"Ogg/Theora video format"};

},{}],"node_modules/caniuse-lite/data/features/ol-reversed.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P","16":"H J K V"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB","16":"I"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B jB kB lB mB L EB oB","16":"C"},G:{"1":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB"},H:{"1":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Reversed attribute of ordered lists"};

},{}],"node_modules/caniuse-lite/data/features/once-event-listener.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"H J K UB IB N","2":"C O T P"},C:{"1":"0 1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r jB kB lB mB L EB oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"GC HC IC JC VB L","2":"G FC"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:1,C:"\"once\" event listener option"};

},{}],"node_modules/caniuse-lite/data/features/online-status.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F gB","260":"E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB GB","516":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q"},D:{"1":"0 1 2 3 4 5 6 7 8 9 T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB","4":"S"},G:{"1":"E HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB"},H:{"2":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"A","132":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Online/offline status"};

},{}],"node_modules/caniuse-lite/data/features/opus.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"T P H J K UB IB N","2":"C O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i"},E:{"2":"G U I F E D A xB WB aB bB cB dB VB","132":"B C O L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB","132":"zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"Opus"};

},{}],"node_modules/caniuse-lite/data/features/orientation-sensor.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","194":"8 9 TB AB FB CB DB BB w"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"4 5 6 7 8 9 AB CB DB BB w R M","2":"0 1 2 3 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:4,C:"Orientation Sensor"};

},{}],"node_modules/caniuse-lite/data/features/outline.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F gB","260":"E","388":"D A B"},B:{"1":"P H J K UB IB N","388":"C O T"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB","129":"S","260":"D B jB kB lB mB L EB"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"C Q S","260":"A B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"388":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS outline properties"};

},{}],"node_modules/caniuse-lite/data/features/pad-start-end.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"P H J K UB IB N","2":"C O T"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x nB fB"},D:{"1":"7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t jB kB lB mB L EB oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"HC IC JC VB L","2":"G FC GC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:6,C:"String.prototype.padStart(), String.prototype.padEnd()"};

},{}],"node_modules/caniuse-lite/data/features/page-transition-events.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D A gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB"},H:{"2":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"PageTransitionEvent"};

},{}],"node_modules/caniuse-lite/data/features/pagevisibility.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D nB fB","33":"A B C O T P H J"},D:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O","33":"T P H J K V W X Y Z a b c d e f g h i"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","2":"G U I xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B C jB kB lB mB L EB oB","33":"P H J K V"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB","33":"CC DC"},J:{"1":"A","2":"F"},K:{"1":"Q S","2":"A B C L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","33":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"Page Visibility"};

},{}],"node_modules/caniuse-lite/data/features/passive-event-listener.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"H J K UB IB N","2":"C O T P"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y nB fB"},D:{"1":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n jB kB lB mB L EB oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:1,C:"Passive event listeners"};

},{}],"node_modules/caniuse-lite/data/features/passwordrules.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","16":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB nB fB","16":"RB SB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N","16":"eB ZB YB"},E:{"1":"C O S","2":"G U I F E D A B xB WB aB bB cB dB VB L","16":"hB iB"},F:{"2":"0 1 2 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S","16":"3 4 5 6 7 8 9 AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"16":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","16":"N"},J:{"2":"F","16":"A"},K:{"2":"A B C L EB S","16":"Q"},L:{"16":"N"},M:{"16":"M"},N:{"2":"A","16":"B"},O:{"16":"EC"},P:{"2":"G FC GC","16":"HC IC JC VB L"},Q:{"16":"KC"},R:{"16":"LC"},S:{"2":"MC"}},B:1,C:"Password Rules"};

},{}],"node_modules/caniuse-lite/data/features/path2d.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O","132":"T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g nB fB","132":"h i j k l m n o p q r s t u v Q x"},D:{"1":"M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l","132":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R"},E:{"1":"A B C O dB VB L S hB iB","2":"G U I F xB WB aB bB","132":"E D cB"},F:{"1":"5 6 7 8 9 AB CB DB BB w R M","2":"D B C P H J K V W X Y jB kB lB mB L EB oB S","132":"0 1 2 3 4 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB","16":"E","132":"uB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"1":"A","2":"F"},K:{"2":"A B C L EB S","132":"Q"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"132":"EC"},P:{"1":"VB L","132":"G FC GC HC IC JC"},Q:{"132":"KC"},R:{"132":"LC"},S:{"1":"MC"}},B:1,C:"Path2D"};

},{}],"node_modules/caniuse-lite/data/features/payment-request.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O","322":"T","8196":"P H J K"},C:{"2":"0 1 2 3 4 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","4162":"5 6 7 8 9 TB AB FB CB DB BB","16452":"w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"SB UB IB N eB ZB YB","2":"0 1 2 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","194":"3 4 5 6 7 8","1090":"TB AB","8196":"9 FB CB DB BB w R M JB KB LB MB NB OB PB QB RB"},E:{"1":"O S hB iB","2":"G U I F E D xB WB aB bB cB dB","514":"A B VB","8196":"C L"},F:{"1":"w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p jB kB lB mB L EB oB S","194":"q r s t u v Q x","8196":"0 1 2 3 4 5 6 7 8 9 y z AB CB DB BB"},G:{"1":"2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB","514":"XB yB zB","8196":"0B 1B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2052":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G","8196":"FC GC HC IC JC VB L"},Q:{"8196":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:4,C:"Payment Request API"};

},{}],"node_modules/caniuse-lite/data/features/permissions-api.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:7,C:"Permissions API"};

},{}],"node_modules/caniuse-lite/data/features/picture-in-picture.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w nB fB","132":"MB NB OB PB QB RB SB","1090":"R","1412":"LB","1668":"M JB KB"},D:{"1":"KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M","2114":"JB"},E:{"1":"hB iB","2":"G U I F E D xB WB aB bB cB dB","4100":"A B C O VB L S"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m jB kB lB mB L EB oB S","8196":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB","4100":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"16388":"N"},M:{"16388":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Picture-in-Picture"};

},{}],"node_modules/caniuse-lite/data/features/picture.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"O T P H J K UB IB N","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j nB fB","578":"k l m n"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m","194":"n"},E:{"1":"A B C O dB VB L S hB iB","2":"G U I F E D xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z jB kB lB mB L EB oB S","322":"a"},G:{"1":"wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Picture element"};

},{}],"node_modules/caniuse-lite/data/features/ping.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"J K UB IB N","2":"C O T P H"},C:{"2":"qB","194":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"194":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"194":"MC"}},B:1,C:"Ping attribute"};

},{}],"node_modules/caniuse-lite/data/features/png-alpha.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"F E D A B","2":"gB","8":"I"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"PNG alpha transparency"};

},{}],"node_modules/caniuse-lite/data/features/pointer-events.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D A gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB fB","2":"qB GB nB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:7,C:"CSS pointer-events (for HTML)"};

},{}],"node_modules/caniuse-lite/data/features/pointer.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D gB","164":"A"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U nB fB","8":"I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q","328":"0 1 2 3 4 5 6 7 8 r s t u v Q x y z"},D:{"1":"5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X","8":"0 1 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","584":"2 3 4"},E:{"1":"O hB iB","2":"G U I xB WB aB","8":"F E D A B C bB cB dB VB L","1096":"S"},F:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","8":"P H J K V W X Y Z a b c d e f g h i j k l m n o","584":"p q r"},G:{"1":"4B 5B 6B","8":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B","6148":"3B"},H:{"2":"7B"},I:{"1":"N","8":"GB G 8B 9B AC BC HB CC DC"},J:{"8":"F A"},K:{"1":"Q","2":"A","8":"B C L EB S"},L:{"1":"N"},M:{"328":"M"},N:{"1":"B","36":"A"},O:{"8":"EC"},P:{"1":"GC HC IC JC VB L","2":"FC","8":"G"},Q:{"1":"KC"},R:{"2":"LC"},S:{"328":"MC"}},B:2,C:"Pointer events"};

},{}],"node_modules/caniuse-lite/data/features/pointerlock.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"O T P H J K UB IB N","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O nB fB","33":"T P H J K V W X Y Z a b c d e f g h i j k l m n o p q"},D:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P","33":"Y Z a b c d e f g h i j k l m","66":"H J K V W X"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","33":"P H J K V W X Y Z"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:2,C:"Pointer Lock API"};

},{}],"node_modules/caniuse-lite/data/features/prefers-color-scheme.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w nB fB"},D:{"1":"QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB"},E:{"1":"O S hB iB","2":"G U I F E D A B C xB WB aB bB cB dB VB L"},F:{"1":"9 CB DB BB w R M","2":"0 1 2 3 4 5 6 7 8 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB jB kB lB mB L EB oB S"},G:{"1":"3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"prefers-color-scheme media query"};

},{}],"node_modules/caniuse-lite/data/features/prefers-reduced-motion.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"9 DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB nB fB"},D:{"1":"OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"9 BB w R M","2":"0 1 2 3 4 5 6 7 8 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB jB kB lB mB L EB oB S"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"prefers-reduced-motion media query"};

},{}],"node_modules/caniuse-lite/data/features/private-class-fields.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Private class fields"};

},{}],"node_modules/caniuse-lite/data/features/private-methods-and-accessors.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Public class fields"};

},{}],"node_modules/caniuse-lite/data/features/progress.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M L EB oB S","2":"D jB kB lB mB"},G:{"2":"WB pB HB rB sB","132":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"progress element"};

},{}],"node_modules/caniuse-lite/data/features/promise-finally.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"K UB IB N","2":"C O T P H J"},C:{"1":"8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"9 DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB"},E:{"1":"C O L S hB iB","2":"G U I F E D A B xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"1":"0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"IC JC VB L","2":"G FC GC HC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"Promise.prototype.finally"};

},{}],"node_modules/caniuse-lite/data/features/promises.js":[function(require,module,exports) {
module.exports={A:{A:{"8":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","4":"d e","8":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","4":"i","8":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h"},E:{"1":"E D A B C O cB dB VB L S hB iB","8":"G U I F xB WB aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","4":"V","8":"D B C P H J K jB kB lB mB L EB oB S"},G:{"1":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","8":"WB pB HB rB sB tB"},H:{"8":"7B"},I:{"1":"N DC","8":"GB G 8B 9B AC BC HB CC"},J:{"8":"F A"},K:{"1":"Q","8":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"8":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"Promises"};

},{}],"node_modules/caniuse-lite/data/features/proximity.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:4,C:"Proximity API"};

},{}],"node_modules/caniuse-lite/data/features/proxy.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K o p q r s t u v Q x y","66":"V W X Y Z a b c d e f g h i j k l m n"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C b c d e f g h i j k l jB kB lB mB L EB oB S","66":"P H J K V W X Y Z a"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:6,C:"Proxy object"};

},{}],"node_modules/caniuse-lite/data/features/public-class-fields.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Public class fields"};

},{}],"node_modules/caniuse-lite/data/features/publickeypinning.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB","2":"D B C P H J K V w R M jB kB lB mB L EB oB S","4":"Z","16":"W X Y a"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB","2":"L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"Public Key Pinning"};

},{}],"node_modules/caniuse-lite/data/features/push-api.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"J K","2":"C O T P H","257":"UB IB N"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t nB fB","257":"0 1 3 4 5 6 7 8 9 u Q x y z TB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","1281":"2 v AB"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t","257":"0 1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","388":"u v Q x y z"},E:{"2":"G U I F E D xB WB aB bB cB","514":"A B C O dB VB L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m jB kB lB mB L EB oB S","16":"n o p q r","257":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"2":"LC"},S:{"257":"MC"}},B:5,C:"Push API"};

},{}],"node_modules/caniuse-lite/data/features/queryselector.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"gB","8":"I F","132":"E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","8":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M kB lB mB L EB oB S","8":"D jB"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"querySelector/querySelectorAll"};

},{}],"node_modules/caniuse-lite/data/features/readonly-attr.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A B","16":"gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","16":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T P H J K V W X Y Z a b"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","16":"G U xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","16":"D jB","132":"B C kB lB mB L EB oB S"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB rB sB"},H:{"1":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"Q","132":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"257":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"readonly attribute of input and textarea elements"};

},{}],"node_modules/caniuse-lite/data/features/referrer-policy.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","132":"B"},B:{"1":"UB IB N","132":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l nB fB"},D:{"1":"9 FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB","2":"G U I F E D A B C O T P H J K V W","260":"0 1 2 3 4 5 6 7 8 X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB","513":"ZB YB"},E:{"1":"C O L S hB iB","2":"G U I F xB WB aB bB","132":"E D A B cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB","132":"E uB vB wB XB yB zB 0B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"Referrer Policy"};

},{}],"node_modules/caniuse-lite/data/features/registerprotocolhandler.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","129":"UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB"},D:{"2":"G U I F E D A B C","129":"0 1 2 3 4 5 6 7 8 9 O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B jB kB lB mB L EB","129":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F","129":"A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:1,C:"Custom protocol handling"};

},{}],"node_modules/caniuse-lite/data/features/rel-noopener.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l jB kB lB mB L EB oB S"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:1,C:"rel=noopener"};

},{}],"node_modules/caniuse-lite/data/features/rel-noreferrer.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","132":"B"},B:{"1":"O T P H J K UB IB N","16":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T P"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB"},H:{"2":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Link type \"noreferrer\""};

},{}],"node_modules/caniuse-lite/data/features/rellist.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"K UB IB N","2":"C O T P H","132":"J"},C:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f nB fB"},D:{"1":"9 w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","132":"0 1 2 3 4 5 6 7 8 TB AB FB CB DB BB"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F E xB WB aB bB cB"},F:{"1":"2 3 4 5 6 7 8 9 AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m jB kB lB mB L EB oB S","132":"0 1 n o p q r s t u v Q x y z"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"132":"EC"},P:{"1":"JC VB L","2":"G","132":"FC GC HC IC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:1,C:"relList (DOMTokenList)"};

},{}],"node_modules/caniuse-lite/data/features/rem.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E gB","132":"D A"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB fB","2":"qB GB nB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","2":"D B jB kB lB mB L EB"},G:{"1":"E pB HB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB","260":"rB"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"C Q S","2":"A B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"rem (root em) units"};

},{}],"node_modules/caniuse-lite/data/features/replace-all.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"1":"MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"hB iB","2":"G U I F E D A B C O xB WB aB bB cB dB VB L S"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"16":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"16":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"16":"LC"},S:{"16":"MC"}},B:7,C:"String.prototype.replaceAll()"};

},{}],"node_modules/caniuse-lite/data/features/requestanimationframe.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","33":"B C O T P H J K V W X Y","164":"G U I F E D A"},D:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D","33":"Y Z","164":"K V W X","420":"A B C O T P H J"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB","33":"I"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB","33":"sB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"requestAnimationFrame"};

},{}],"node_modules/caniuse-lite/data/features/requestidlecallback.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","194":"3 4"},D:{"1":"0 1 2 3 4 5 6 7 8 9 x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:5,C:"requestIdleCallback"};

},{}],"node_modules/caniuse-lite/data/features/resizeobserver.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M nB fB"},D:{"1":"9 BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","194":"4 5 6 7 8 TB AB FB CB DB"},E:{"1":"hB iB","2":"G U I F E D A B C xB WB aB bB cB dB VB L S","66":"O"},F:{"1":"2 3 4 5 6 7 8 9 AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q jB kB lB mB L EB oB S","194":"0 1 r s t u v Q x y z"},G:{"1":"6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"JC VB L","2":"G FC GC HC IC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Resize Observer"};

},{}],"node_modules/caniuse-lite/data/features/resource-timing.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g nB fB","194":"h i j k"},D:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a"},E:{"1":"C O L S hB iB","2":"G U I F E D A xB WB aB bB cB dB VB","260":"B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"Resource Timing"};

},{}],"node_modules/caniuse-lite/data/features/rest-parameters.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t","194":"u v Q"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g jB kB lB mB L EB oB S","194":"h i j"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"Rest parameters"};

},{}],"node_modules/caniuse-lite/data/features/rtcpeerconnection.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T","516":"P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X nB fB","33":"Y Z a b c d e f g h i j k l m n o p q r s t"},D:{"1":"6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y","33":"0 1 2 3 4 5 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"B C O L S hB iB","2":"G U I F E D A xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z AB CB DB BB w R M","2":"D B C P H J jB kB lB mB L EB oB S","33":"K V W X Y Z a b c d e f g h i j k l m n o p q r s"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F","130":"A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"33":"G FC GC HC IC JC VB L"},Q:{"33":"KC"},R:{"33":"LC"},S:{"1":"MC"}},B:5,C:"WebRTC Peer-to-peer connections"};

},{}],"node_modules/caniuse-lite/data/features/ruby.js":[function(require,module,exports) {
module.exports={A:{A:{"4":"I F E D A B gB"},B:{"4":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","8":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n nB fB"},D:{"4":"0 1 2 3 4 5 6 7 8 9 U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","8":"G"},E:{"4":"U I F E D A B C O aB bB cB dB VB L S hB iB","8":"G xB WB"},F:{"4":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","8":"D B C jB kB lB mB L EB oB S"},G:{"4":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","8":"WB pB HB"},H:{"8":"7B"},I:{"4":"GB G N BC HB CC DC","8":"8B 9B AC"},J:{"4":"A","8":"F"},K:{"4":"Q","8":"A B C L EB S"},L:{"4":"N"},M:{"1":"M"},N:{"4":"A B"},O:{"4":"EC"},P:{"4":"G FC GC HC IC JC VB L"},Q:{"4":"KC"},R:{"4":"LC"},S:{"1":"MC"}},B:1,C:"Ruby annotation"};

},{}],"node_modules/caniuse-lite/data/features/run-in.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"E D A B","2":"I F gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h","2":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"U I aB","2":"F E D A B C O cB dB VB L S hB iB","16":"bB","129":"G xB WB"},F:{"1":"D B C P H J K jB kB lB mB L EB oB S","2":"0 1 2 3 4 5 6 7 8 9 V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"1":"pB HB rB sB tB","2":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","129":"WB"},H:{"1":"7B"},I:{"1":"GB G 8B 9B AC BC HB CC","2":"N DC"},J:{"1":"F A"},K:{"1":"A B C L EB S","2":"Q"},L:{"2":"N"},M:{"2":"M"},N:{"1":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"display: run-in"};

},{}],"node_modules/caniuse-lite/data/features/same-site-cookie-attribute.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","388":"B"},B:{"1":"K UB IB N","2":"C O T P","129":"H J"},C:{"1":"9 AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB nB fB"},D:{"1":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB","2":"0 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","513":"IB N eB ZB YB"},E:{"2":"G U I F E D A B xB WB aB bB cB dB VB L","2052":"hB iB","3076":"C O S"},F:{"1":"0 1 2 3 4 5 6 7 8 9 p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o jB kB lB mB L EB oB S"},G:{"1":"3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B","2052":"1B 2B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"513":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"16":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:6,C:"'SameSite' cookie attribute"};

},{}],"node_modules/caniuse-lite/data/features/screen-orientation.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","164":"B"},B:{"1":"UB IB N","36":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J nB fB","36":"K V W X Y Z a b c d e f g h i j k l m n o p q r s t"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A","36":"B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","16":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"Screen Orientation"};

},{}],"node_modules/caniuse-lite/data/features/script-async.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB fB","2":"qB GB nB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB","132":"U"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"2":"7B"},I:{"1":"GB G N BC HB CC DC","2":"8B 9B AC"},J:{"1":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"async attribute for external scripts"};

},{}],"node_modules/caniuse-lite/data/features/script-defer.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","132":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB","257":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"G xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"2":"7B"},I:{"1":"GB G N BC HB CC DC","2":"8B 9B AC"},J:{"1":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"defer attribute for external scripts"};

},{}],"node_modules/caniuse-lite/data/features/scrollintoview.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F gB","132":"E D A B"},B:{"1":"UB IB N","132":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","132":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l nB fB"},D:{"1":"9 FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","132":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB"},E:{"2":"G U xB WB","132":"I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB CB DB BB w R M","2":"D jB kB lB mB","16":"B L EB","132":"C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x oB S"},G:{"16":"WB pB HB","132":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"16":"8B 9B","132":"GB G N AC BC HB CC DC"},J:{"132":"F A"},K:{"132":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"132":"A B"},O:{"132":"EC"},P:{"132":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"132":"LC"},S:{"1":"MC"}},B:5,C:"scrollIntoView"};

},{}],"node_modules/caniuse-lite/data/features/scrollintoviewifneeded.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","16":"G U xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB"},H:{"2":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:7,C:"Element.scrollIntoViewIfNeeded()"};

},{}],"node_modules/caniuse-lite/data/features/sdch.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","2":"9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"SDCH Accept-Encoding/Content-Encoding"};

},{}],"node_modules/caniuse-lite/data/features/selection-api.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","16":"gB","260":"I F E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","132":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s nB fB","2180":"0 1 t u v Q x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","16":"G U xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","132":"D B C jB kB lB mB L EB oB S"},G:{"16":"HB","132":"WB pB","516":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N CC DC","16":"GB G 8B 9B AC BC","1025":"HB"},J:{"1":"A","16":"F"},K:{"1":"Q","16":"A B C L EB","132":"S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","16":"A"},O:{"1025":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2180":"MC"}},B:5,C:"Selection API"};

},{}],"node_modules/caniuse-lite/data/features/server-timing.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"9 FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB nB fB"},D:{"1":"9 w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB","196":"AB FB CB DB","324":"BB"},E:{"2":"G U I F E D A B C xB WB aB bB cB dB VB L","516":"O S hB iB"},F:{"1":"2 3 4 5 6 7 8 9 AB CB DB BB w R M","2":"0 1 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"Server Timing"};

},{}],"node_modules/caniuse-lite/data/features/serviceworkers.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"J K UB IB N","2":"C O T","322":"P H"},C:{"1":"0 1 3 4 5 6 7 8 9 u Q x y z TB FB CB DB BB w R JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i nB fB","194":"j k l m n o p q r s t","513":"2 v AB M"},D:{"1":"0 1 2 3 4 5 6 7 8 9 v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p","4":"q r s t u"},E:{"1":"C O L S hB iB","2":"G U I F E D A B xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c jB kB lB mB L EB oB S","4":"d e f g h"},G:{"1":"0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","4":"N"},J:{"2":"F A"},K:{"2":"A B C L EB S","4":"Q"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"4":"LC"},S:{"2":"MC"}},B:5,C:"Service Workers"};

},{}],"node_modules/caniuse-lite/data/features/setimmediate.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K","2":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"1":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Efficient Script Yielding: setImmediate()"};

},{}],"node_modules/caniuse-lite/data/features/sha-2.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A B","2":"gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","132":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"16":"7B"},I:{"1":"GB G N 9B AC BC HB CC DC","260":"8B"},J:{"1":"F A"},K:{"16":"A B C Q L EB S"},L:{"1":"N"},M:{"16":"M"},N:{"16":"A B"},O:{"16":"EC"},P:{"1":"FC GC HC IC JC VB L","16":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"SHA-2 SSL certificates"};

},{}],"node_modules/caniuse-lite/data/features/shadowdom.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB","2":"C O T P H J K IB N"},C:{"2":"9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","66":"0 1 2 3 4 5 6 7 8 f g h i j k l m n o p q r s t u v Q x y z TB AB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB","2":"G U I F E D A B C O T P H J K V W X Y Z a IB N eB ZB YB","33":"b c d e f g h i j k"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w","2":"D B C R M jB kB lB mB L EB oB S","33":"P H J K V W X"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB","33":"CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","33":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:7,C:"Shadow DOM (deprecated V0 spec)"};

},{}],"node_modules/caniuse-lite/data/features/shadowdomv1.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"9 DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","322":"8","578":"TB AB FB CB"},D:{"1":"3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"A B C O VB L S hB iB","2":"G U I F E D xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB","132":"XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"GC HC IC JC VB L","2":"G","4":"FC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"Shadow DOM (V1)"};

},{}],"node_modules/caniuse-lite/data/features/sharedarraybuffer.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P","194":"H J K"},C:{"2":"0 1 2 3 4 5 6 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","194":"7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB","450":"OB PB QB RB SB"},D:{"1":"M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB","194":"9 AB FB CB DB BB w R"},E:{"2":"G U I F E D A xB WB aB bB cB dB","194":"B C O VB L S hB iB"},F:{"1":"9 BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q jB kB lB mB L EB oB S","194":"0 1 2 3 4 5 6 7 8 x y z AB CB DB"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB","194":"yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"194":"N"},M:{"194":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"Shared Array Buffer"};

},{}],"node_modules/caniuse-lite/data/features/sharedworkers.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"U I aB","2":"G F E D A B C O xB WB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M mB L EB oB S","2":"D jB kB lB"},G:{"1":"rB sB","2":"E WB pB HB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"B C L EB S","2":"Q","16":"A"},L:{"2":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"G","2":"FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:1,C:"Shared Web Workers"};

},{}],"node_modules/caniuse-lite/data/features/sni.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I gB","132":"F E"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB"},H:{"1":"7B"},I:{"1":"GB G N BC HB CC DC","2":"8B 9B AC"},J:{"1":"A","2":"F"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"Server Name Indication"};

},{}],"node_modules/caniuse-lite/data/features/spdy.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D A gB"},B:{"2":"C O T P H J K UB IB N"},C:{"1":"0 O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","2":"1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","2":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"E D A B C dB VB L","2":"G U I F xB WB aB bB cB","129":"O S hB iB"},F:{"1":"P H J K V W X Y Z a b c d e f g h i j k l m n o p s u S","2":"0 1 2 3 4 5 6 7 8 9 D B C q r t v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB"},G:{"1":"E uB vB wB XB yB zB 0B 1B","2":"WB pB HB rB sB tB","257":"2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G BC HB CC DC","2":"N 8B 9B AC"},J:{"2":"F A"},K:{"1":"S","2":"A B C Q L EB"},L:{"2":"N"},M:{"2":"M"},N:{"1":"B","2":"A"},O:{"2":"EC"},P:{"1":"G","2":"FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"16":"LC"},S:{"1":"MC"}},B:7,C:"SPDY protocol"};

},{}],"node_modules/caniuse-lite/data/features/speech-recognition.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","1026":"UB IB N"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X nB fB","322":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a","164":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c jB kB lB mB L EB oB S","1026":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"164":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"164":"G FC GC HC IC JC VB L"},Q:{"164":"KC"},R:{"164":"LC"},S:{"322":"MC"}},B:7,C:"Speech Recognition API"};

},{}],"node_modules/caniuse-lite/data/features/speech-synthesis.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"T P H J K","2":"C O","257":"UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g nB fB","194":"h i j k l m n o p q r s t u v Q x y"},D:{"1":"0 1 2 3 4 j k l m n o p q r s t u v Q x y z","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i","257":"5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"F E D A B C O cB dB VB L S hB iB","2":"G U I xB WB aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB","2":"D B C P H J K V W X Y Z a b c jB kB lB mB L EB oB S","257":"9 BB w R M"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:7,C:"Speech Synthesis API"};

},{}],"node_modules/caniuse-lite/data/features/spellcheck-attribute.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","2":"G U xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D jB kB"},G:{"4":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"4":"7B"},I:{"4":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"A","4":"F"},K:{"4":"A B C Q L EB S"},L:{"4":"N"},M:{"4":"M"},N:{"4":"A B"},O:{"4":"EC"},P:{"4":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"4":"LC"},S:{"2":"MC"}},B:1,C:"Spellcheck attribute"};

},{}],"node_modules/caniuse-lite/data/features/sql-storage.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C xB WB aB bB cB dB VB L S","2":"O hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D jB kB"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B","2":"3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:7,C:"Web SQL Database"};

},{}],"node_modules/caniuse-lite/data/features/srcset.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"H J K UB IB N","260":"C","514":"O T P"},C:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h nB fB","194":"i j k l m n"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j","260":"k l m n"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F xB WB aB bB","260":"E cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W jB kB lB mB L EB oB S","260":"X Y Z a"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB","260":"E uB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Srcset and sizes attributes"};

},{}],"node_modules/caniuse-lite/data/features/stopimmediatepropagation.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T P H J K V W X Y Z a b"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","16":"G U xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B jB kB lB mB L EB oB","16":"C"},G:{"1":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB rB"},H:{"16":"7B"},I:{"1":"G N BC HB CC DC","16":"GB 8B 9B AC"},J:{"16":"F A"},K:{"16":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"16":"A B"},O:{"16":"EC"},P:{"1":"FC GC HC IC JC VB L","16":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Event.stopImmediatePropagation()"};

},{}],"node_modules/caniuse-lite/data/features/stream.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H nB fB","129":"m n o p q r","420":"J K V W X Y Z a b c d e f g h i j k l"},D:{"1":"3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W","420":"0 1 2 X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"1":"B C O L S hB iB","2":"G U I F E D A xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 q r s t u v Q x y z AB CB DB BB w R M","2":"D B P H J jB kB lB mB L EB oB","420":"C K V W X Y Z a b c d e f g h i j k l m n o p S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB","513":"zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F","420":"A"},K:{"1":"Q","2":"A B L EB","420":"C S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"GC HC IC JC VB L","420":"G FC"},Q:{"1":"KC"},R:{"420":"LC"},S:{"2":"MC"}},B:4,C:"getUserMedia/Stream API"};

},{}],"node_modules/caniuse-lite/data/features/streams.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","130":"B"},B:{"16":"C O","260":"T P","1028":"UB IB N","5124":"H J K"},C:{"2":"0 1 2 3 4 5 6 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","6148":"9 w R M JB KB LB MB NB OB PB QB RB SB","6722":"7 8 TB AB FB CB DB BB"},D:{"2":"0 1 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","260":"2 3 4 5 6 7 8","1028":"9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D xB WB aB bB cB dB","3076":"A B C O VB L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o jB kB lB mB L EB oB S","260":"p q r s t u v","1028":"0 1 2 3 4 5 6 7 8 9 Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB","16":"XB","1028":"yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","260":"N"},J:{"2":"F A"},K:{"2":"A B C L EB S","1028":"Q"},L:{"1028":"N"},M:{"2626":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC","1028":"HC IC JC VB L"},Q:{"1028":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:1,C:"Streams"};

},{}],"node_modules/caniuse-lite/data/features/stricttransportsecurity.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A gB","129":"B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"F E D A B C O cB dB VB L S hB iB","2":"G U I xB WB aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B jB kB lB mB L EB oB"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"Strict Transport Security"};

},{}],"node_modules/caniuse-lite/data/features/style-scoped.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","2":"9 qB GB G U I F E D A B C O T P H J K V W FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","322":"5 6 7 8 TB AB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","194":"W X Y Z a b c d e f g h i j k l m"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"322":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:7,C:"Scoped CSS"};

},{}],"node_modules/caniuse-lite/data/features/subresource-integrity.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"J K UB IB N","2":"C O T P H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u"},E:{"1":"B C O L S hB iB","2":"G U I F E D A xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h jB kB lB mB L EB oB S"},G:{"1":"0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB","194":"zB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"Subresource Integrity"};

},{}],"node_modules/caniuse-lite/data/features/svg-css.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"H J K UB IB N","516":"C O T P"},C:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","260":"G U I F E D A B C O T P H J K V W X Y Z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","4":"G"},E:{"1":"U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB","132":"G WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","2":"D"},G:{"1":"E HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","132":"WB pB"},H:{"260":"7B"},I:{"1":"GB G N BC HB CC DC","2":"8B 9B AC"},J:{"1":"F A"},K:{"1":"Q","260":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"SVG in CSS backgrounds"};

},{}],"node_modules/caniuse-lite/data/features/svg-filters.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G","4":"U I F"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB"},H:{"1":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"SVG filters"};

},{}],"node_modules/caniuse-lite/data/features/svg-fonts.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"D A B gB","8":"I F E"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n","2":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","130":"0 o p q r s t u v Q x y z"},E:{"1":"G U I F E D A B C O WB aB bB cB dB VB L S hB iB","2":"xB"},F:{"1":"D B C P H J K V W X Y Z a jB kB lB mB L EB oB S","2":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v Q x y z AB CB DB BB w R M","130":"b c d e f g h i j k l m"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"258":"7B"},I:{"1":"GB G BC HB CC DC","2":"N 8B 9B AC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"130":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"G","130":"FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"130":"LC"},S:{"2":"MC"}},B:2,C:"SVG fonts"};

},{}],"node_modules/caniuse-lite/data/features/svg-fragment.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","260":"D A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l","132":"m n o p q r s t u v Q x y z"},E:{"1":"C O L S hB iB","2":"G U I F D A B xB WB aB bB dB VB","132":"E cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"P H J K V W X Y","4":"B C kB lB mB L EB oB","16":"D jB","132":"Z a b c d e f g h i j k l m"},G:{"1":"0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB vB wB XB yB zB","132":"E uB"},H:{"1":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F","132":"A"},K:{"1":"Q S","4":"A B C L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","132":"G"},Q:{"1":"KC"},R:{"132":"LC"},S:{"1":"MC"}},B:4,C:"SVG fragment identifiers"};

},{}],"node_modules/caniuse-lite/data/features/svg-html.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","388":"D A B"},B:{"4":"UB IB N","260":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB","4":"GB"},D:{"4":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"xB WB","4":"G U I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"4":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"4":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB","4":"N CC DC"},J:{"1":"A","2":"F"},K:{"4":"A B C Q L EB S"},L:{"4":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"4":"G FC GC HC IC JC VB L"},Q:{"4":"KC"},R:{"4":"LC"},S:{"1":"MC"}},B:2,C:"SVG effects for HTML"};

},{}],"node_modules/caniuse-lite/data/features/svg-html5.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"gB","8":"I F E","129":"D A B"},B:{"1":"J K UB IB N","129":"C O T P H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","8":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","8":"G U I"},E:{"1":"D A B C O dB VB L S hB iB","8":"G U xB WB","129":"I F E aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","2":"B mB L EB","8":"D jB kB lB"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","8":"WB pB HB","129":"E rB sB tB uB"},H:{"1":"7B"},I:{"1":"N CC DC","2":"8B 9B AC","129":"GB G BC HB"},J:{"1":"A","129":"F"},K:{"1":"C Q S","8":"A B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"129":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Inline SVG in HTML5"};

},{}],"node_modules/caniuse-lite/data/features/svg-img.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","132":"G U I F E D A B C O T P H J K V W X Y Z a b c d"},E:{"1":"D A B C O dB VB L S hB iB","2":"xB","4":"WB","132":"G U I F E aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","132":"E WB pB HB rB sB tB uB"},H:{"1":"7B"},I:{"1":"N CC DC","2":"8B 9B AC","132":"GB G BC HB"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"SVG in HTML img element"};

},{}],"node_modules/caniuse-lite/data/features/svg-smil.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"gB","8":"I F E D A B"},B:{"1":"UB IB N","8":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","8":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","4":"G"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","8":"xB WB","132":"G U aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","132":"WB pB HB rB"},H:{"2":"7B"},I:{"1":"GB G N BC HB CC DC","2":"8B 9B AC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"8":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"SVG SMIL animation"};

},{}],"node_modules/caniuse-lite/data/features/svg.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"gB","8":"I F E","772":"D A B"},B:{"1":"UB IB N","513":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","4":"qB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O WB aB bB cB dB VB L S hB iB","4":"xB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"N CC DC","2":"8B 9B AC","132":"GB G BC HB"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"257":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"SVG (basic support)"};

},{}],"node_modules/caniuse-lite/data/features/sxg.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB","132":"LB MB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"9 BB w R M","2":"0 1 2 3 4 5 6 7 8 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"16":"EC"},P:{"2":"G FC GC HC IC JC VB","16":"L"},Q:{"16":"KC"},R:{"16":"LC"},S:{"2":"MC"}},B:6,C:"Signed HTTP Exchanges (SXG)"};

},{}],"node_modules/caniuse-lite/data/features/symbols.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n"},E:{"1":"D A B C O xB WB aB bB cB dB VB L S hB iB","2":"G U I F E"},F:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a jB kB lB mB L EB oB S"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"16":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"16":"EC"},P:{"16":"G FC GC HC IC JC VB L"},Q:{"16":"KC"},R:{"16":"LC"},S:{"1":"MC"}},B:6,C:"Symbols"};

},{}],"node_modules/caniuse-lite/data/features/tabindex-attr.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"F E D A B","16":"I gB"},B:{"1":"C O T P H J K UB IB N"},C:{"16":"qB GB nB fB","129":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T"},E:{"16":"G U xB WB","257":"I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","16":"D"},G:{"769":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"16":"7B"},I:{"16":"GB G N 8B 9B AC BC HB CC DC"},J:{"16":"F A"},K:{"16":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"16":"A B"},O:{"16":"EC"},P:{"16":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"16":"LC"},S:{"129":"MC"}},B:1,C:"tabindex global attribute"};

},{}],"node_modules/caniuse-lite/data/features/template-literals.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"O T P H J K UB IB N","16":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q"},E:{"1":"A B O dB VB L S hB iB","2":"G U I F E D xB WB aB bB cB","129":"C"},F:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e jB kB lB mB L EB oB S"},G:{"1":"vB wB XB yB zB 0B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB","129":"1B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"ES6 Template Literals (Template Strings)"};

},{}],"node_modules/caniuse-lite/data/features/template.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"P H J K UB IB N","2":"C","388":"O T"},C:{"1":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b","132":"c d e f g h i j k"},E:{"1":"D A B C O dB VB L S hB iB","2":"G U I F xB WB aB","388":"E cB","514":"bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","132":"P H J K V W X"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB","388":"E uB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"HTML templates"};

},{}],"node_modules/caniuse-lite/data/features/testfeat.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E A B gB","16":"D"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","16":"G U"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"B C"},E:{"2":"G I xB WB aB","16":"U F E D A B C O bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB EB oB S","16":"L"},G:{"2":"WB pB HB rB sB","16":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B BC HB CC DC","16":"AC"},J:{"2":"A","16":"F"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Test feature - updated"};

},{}],"node_modules/caniuse-lite/data/features/text-decoration.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","2052":"UB IB N"},C:{"2":"qB GB G U nB fB","1028":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","1060":"I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b","226":"0 1 2 3 4 5 6 c d e f g h i j k l m n o p q r s t u v Q x y z","2052":"7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F xB WB aB bB","772":"O S hB iB","804":"E D A B C dB VB L","1316":"cB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k jB kB lB mB L EB oB S","226":"l m n o p q r s t","2052":"0 1 2 3 4 5 6 7 8 9 u v Q x y z AB CB DB BB w R M"},G:{"2":"WB pB HB rB sB tB","292":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C L EB S","2052":"Q"},L:{"2052":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2052":"EC"},P:{"2":"G FC GC","2052":"HC IC JC VB L"},Q:{"2":"KC"},R:{"1":"LC"},S:{"1028":"MC"}},B:4,C:"text-decoration styling"};

},{}],"node_modules/caniuse-lite/data/features/text-emphasis.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","164":"UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u nB fB","322":"v"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a","164":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"E D A B C O cB dB VB L S hB iB","2":"G U I xB WB aB","164":"F bB"},F:{"2":"D B C jB kB lB mB L EB oB S","164":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB","164":"N CC DC"},J:{"2":"F","164":"A"},K:{"2":"A B C L EB S","164":"Q"},L:{"164":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"164":"EC"},P:{"164":"G FC GC HC IC JC VB L"},Q:{"164":"KC"},R:{"164":"LC"},S:{"1":"MC"}},B:4,C:"text-emphasis styling"};

},{}],"node_modules/caniuse-lite/data/features/text-overflow.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A B","2":"gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","8":"qB GB G U I nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M L EB oB S","33":"D jB kB lB mB"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"Q S","33":"A B C L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"CSS3 Text-overflow"};

},{}],"node_modules/caniuse-lite/data/features/text-size-adjust.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","33":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 G U I F E D A B C O T P H J K V W X Y Z a b d e f g h i j k l m n o p q r s t u v Q x y z","258":"c"},E:{"2":"G U I F E D A B C O xB WB bB cB dB VB L S hB iB","258":"aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 t v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s u jB kB lB mB L EB oB S"},G:{"2":"WB pB HB","33":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"33":"M"},N:{"161":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"CSS text-size-adjust"};

},{}],"node_modules/caniuse-lite/data/features/text-stroke.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T","33":"UB IB N","161":"P H J K"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x nB fB","161":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","450":"y"},D:{"33":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"33":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C jB kB lB mB L EB oB S","33":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"33":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","36":"WB"},H:{"2":"7B"},I:{"2":"GB","33":"G N 8B 9B AC BC HB CC DC"},J:{"33":"F A"},K:{"2":"A B C L EB S","33":"Q"},L:{"33":"N"},M:{"161":"M"},N:{"2":"A B"},O:{"33":"EC"},P:{"33":"G FC GC HC IC JC VB L"},Q:{"33":"KC"},R:{"33":"LC"},S:{"161":"MC"}},B:7,C:"CSS text-stroke and text-fill"};

},{}],"node_modules/caniuse-lite/data/features/text-underline-offset.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"1":"KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M nB fB","130":"JB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"O S hB iB","2":"G U I F E D A B C xB WB aB bB cB dB VB L"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"text-underline-offset"};

},{}],"node_modules/caniuse-lite/data/features/textcontent.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O WB aB bB cB dB VB L S hB iB","16":"xB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","16":"D"},G:{"1":"E pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB"},H:{"1":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Node.textContent"};

},{}],"node_modules/caniuse-lite/data/features/textencoder.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K nB fB","132":"V"},D:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a jB kB lB mB L EB oB S"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"TextEncoder & TextDecoder"};

},{}],"node_modules/caniuse-lite/data/features/tls1-1.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F gB","66":"E D A"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB","2":"qB GB G U I F E D A B C O T P H J K V W X Y nB fB","16":"RB SB","66":"Z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB","2":"G U I F E D A B C O T P H J K V W X ZB YB"},E:{"1":"F E D A B C O cB dB VB L S hB iB","2":"G U I xB WB aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B C jB kB lB mB L EB oB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"1":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"1":"A","2":"F"},K:{"1":"Q S","2":"A B C L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","66":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"TLS 1.1"};

},{}],"node_modules/caniuse-lite/data/features/tls1-2.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F gB","66":"E D A"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z nB fB","66":"a b c"},D:{"1":"0 1 2 3 4 5 6 7 8 9 f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e"},E:{"1":"F E D A B C O cB dB VB L S hB iB","2":"G U I xB WB aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D P jB","66":"B C kB lB mB L EB oB S"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"1":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"1":"A","2":"F"},K:{"1":"Q S","2":"A B C L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","66":"A"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"TLS 1.2"};

},{}],"node_modules/caniuse-lite/data/features/tls1-3.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"9 DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","132":"AB FB CB","450":"1 2 3 4 5 6 7 8 TB"},D:{"1":"KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","706":"4 5 6 7 8 9 TB AB FB CB DB BB w R M JB"},E:{"2":"G U I F E D A B C xB WB aB bB cB dB VB L","1028":"O S hB iB"},F:{"1":"7 8 9 AB CB DB BB w R M","2":"0 1 2 3 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S","706":"4 5 6"},G:{"1":"2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"VB L","2":"G FC GC HC IC JC"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:6,C:"TLS 1.3"};

},{}],"node_modules/caniuse-lite/data/features/token-binding.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T","194":"UB IB N","257":"P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB nB fB","16":"RB SB"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o","16":"0 1 2 3 4 5 6 7 p q r s t u v Q x y z","194":"8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E xB WB aB bB cB","16":"D A B C O dB VB L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f jB kB lB mB L EB oB S","16":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB","16":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"16":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","16":"N"},J:{"2":"F A"},K:{"2":"A B C L EB S","16":"Q"},L:{"16":"N"},M:{"16":"M"},N:{"2":"A","16":"B"},O:{"16":"EC"},P:{"16":"G FC GC HC IC JC VB L"},Q:{"16":"KC"},R:{"16":"LC"},S:{"2":"MC"}},B:6,C:"Token Binding"};

},{}],"node_modules/caniuse-lite/data/features/touch.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","8":"A B"},B:{"1":"UB IB N","578":"C O T P H J K"},C:{"1":"2 3 4 5 6 7 8 9 K V W X Y Z a TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","4":"G U I F E D A B C O T P H J","194":"0 1 b c d e f g h i j k l m n o p q r s t u v Q x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"8":"A","260":"B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"2":"MC"}},B:2,C:"Touch events"};

},{}],"node_modules/caniuse-lite/data/features/transforms2d.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"gB","8":"I F E","129":"A B","161":"D"},B:{"1":"J K UB IB N","129":"C O T P H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB","33":"G U I F E D A B C O T P nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","33":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l"},E:{"1":"D A B C O dB VB L S hB iB","33":"G U I F E xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D jB kB","33":"B C P H J K V W X Y lB mB L EB oB"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","33":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"N","33":"GB G 8B 9B AC BC HB CC DC"},J:{"33":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"CSS3 2D Transforms"};

},{}],"node_modules/caniuse-lite/data/features/transforms3d.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","132":"A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D nB fB","33":"A B C O T P"},D:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B","33":"C O T P H J K V W X Y Z a b c d e f g h i j k l"},E:{"2":"xB WB","33":"G U I F E aB bB cB","257":"D A B C O dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","33":"P H J K V W X Y"},G:{"33":"E WB pB HB rB sB tB uB","257":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"8B 9B AC","33":"GB G BC HB CC DC"},J:{"33":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"132":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"CSS3 3D Transforms"};

},{}],"node_modules/caniuse-lite/data/features/trusted-types.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Trusted Types for DOM manipulation"};

},{}],"node_modules/caniuse-lite/data/features/ttf.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","132":"D A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M kB lB mB L EB oB S","2":"D jB"},G:{"1":"E HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB"},H:{"2":"7B"},I:{"1":"GB G N 9B AC BC HB CC DC","2":"8B"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"132":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"TTF/OTF - TrueType and OpenType font support"};

},{}],"node_modules/caniuse-lite/data/features/typedarrays.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"B","2":"I F E D gB","132":"A"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB","260":"aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","2":"D B jB kB lB mB L EB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB","260":"HB"},H:{"1":"7B"},I:{"1":"G N BC HB CC DC","2":"GB 8B 9B AC"},J:{"1":"A","2":"F"},K:{"1":"C Q S","2":"A B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"132":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"Typed Arrays"};

},{}],"node_modules/caniuse-lite/data/features/u2f.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","513":"UB IB N"},C:{"1":"R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q nB fB","322":"0 1 2 3 4 5 6 7 8 9 x y z TB AB FB CB DB BB w"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n","130":"o p q","513":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"O hB iB","2":"G U I F E D A B C xB WB aB bB cB dB VB L S"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p r jB kB lB mB L EB oB S","513":"0 1 2 3 4 5 6 7 8 9 q s t u v Q x y z AB CB DB BB w R M"},G:{"1":"5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"322":"MC"}},B:6,C:"FIDO U2F API"};

},{}],"node_modules/caniuse-lite/data/features/unhandledrejection.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y"},E:{"1":"B C O L S hB iB","2":"G U I F E D A xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l jB kB lB mB L EB oB S"},G:{"1":"0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB","16":"zB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:1,C:"unhandledrejection/rejectionhandled events"};

},{}],"node_modules/caniuse-lite/data/features/upgradeinsecurerequests.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"J K UB IB N","2":"C O T P H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f jB kB lB mB L EB oB S"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"Upgrade Insecure Requests"};

},{}],"node_modules/caniuse-lite/data/features/url-scroll-to-text-fragment.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB","66":"OB PB QB RB SB UB IB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"M","2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"URL Scroll-To-Text Fragment"};

},{}],"node_modules/caniuse-lite/data/features/url.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y","130":"Z a b c d e f g h"},E:{"1":"E D A B C O cB dB VB L S hB iB","2":"G U I xB WB aB bB","130":"F"},F:{"1":"0 1 2 3 4 5 6 7 8 9 V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","130":"P H J K"},G:{"1":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB","130":"tB"},H:{"2":"7B"},I:{"1":"N DC","2":"GB G 8B 9B AC BC HB","130":"CC"},J:{"2":"F","130":"A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"URL API"};

},{}],"node_modules/caniuse-lite/data/features/urlsearchparams.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"J K UB IB N","2":"C O T P H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e nB fB","132":"f g h i j k l m n o p q r s t"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y"},E:{"1":"B C O VB L S hB iB","2":"G U I F E D A xB WB aB bB cB dB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l jB kB lB mB L EB oB S"},G:{"1":"yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","2":"G"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:1,C:"URLSearchParams"};

},{}],"node_modules/caniuse-lite/data/features/use-strict.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G xB WB","132":"U aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","2":"D B jB kB lB mB L EB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"1":"7B"},I:{"1":"GB G N BC HB CC DC","2":"8B 9B AC"},J:{"1":"F A"},K:{"1":"C Q EB S","2":"A B L"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"ECMAScript 5 Strict Mode"};

},{}],"node_modules/caniuse-lite/data/features/user-select-none.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","33":"A B"},B:{"1":"UB IB N","33":"C O T P H J K"},C:{"1":"JB KB LB MB NB OB PB QB RB SB","33":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M nB fB"},D:{"1":"4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","33":"0 1 2 3 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z"},E:{"33":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","33":"P H J K V W X Y Z a b c d e f g h i j k l m n o p q"},G:{"33":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","33":"GB G 8B 9B AC BC HB CC DC"},J:{"33":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"33":"M"},N:{"33":"A B"},O:{"2":"EC"},P:{"33":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"2":"LC"},S:{"33":"MC"}},B:5,C:"CSS user-select: none"};

},{}],"node_modules/caniuse-lite/data/features/user-timing.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a"},E:{"1":"B C O L S hB iB","2":"G U I F E D A xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"User Timing API"};

},{}],"node_modules/caniuse-lite/data/features/variable-fonts.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"J K UB IB N","2":"C O T P H"},C:{"2":"0 1 2 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","4609":"9 CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","4674":"FB","5698":"AB","7490":"3 4 5 6 7","7746":"8 TB"},D:{"1":"R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","4097":"w","4290":"TB AB FB","6148":"9 CB DB BB"},E:{"2":"G U I F E D A xB WB aB bB cB dB VB","4097":"O hB iB","4609":"B C L S"},F:{"1":"4 5 6 7 8 9 AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y jB kB lB mB L EB oB S","4097":"3","6148":"0 1 2 z"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB","4097":"zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"4097":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC","4097":"IC JC VB L"},Q:{"4097":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"Variable fonts"};

},{}],"node_modules/caniuse-lite/data/features/vibration.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A nB fB","33":"B C O T P"},D:{"1":"0 1 2 3 4 5 6 7 8 9 g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"Vibration API"};

},{}],"node_modules/caniuse-lite/data/features/video.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB","260":"G U I F E D A B C O T P H J K V nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A aB bB cB dB VB","2":"xB WB","513":"B C O L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D jB kB"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB","513":"zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N AC BC HB CC DC","132":"8B 9B"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Video element"};

},{}],"node_modules/caniuse-lite/data/features/videotracks.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K","322":"UB IB N"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i nB fB","194":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u","322":"0 1 2 3 4 5 6 7 8 9 v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","2":"G U I xB WB aB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h jB kB lB mB L EB oB S","322":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C L EB S","322":"Q"},L:{"322":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"194":"MC"}},B:1,C:"Video Tracks"};

},{}],"node_modules/caniuse-lite/data/features/viewport-units.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","132":"D","260":"A B"},B:{"1":"H J K UB IB N","260":"C O T P"},C:{"1":"0 1 2 3 4 5 6 7 8 9 V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V","260":"W X Y Z a b"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB","260":"I"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB","516":"tB","772":"sB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"260":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"Viewport units: vw, vh, vmin, vmax"};

},{}],"node_modules/caniuse-lite/data/features/wai-aria.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F gB","4":"E D A B"},B:{"4":"C O T P H J K UB IB N"},C:{"4":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"4":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"xB WB","4":"G U I F E D A B C O aB bB cB dB VB L S hB iB"},F:{"2":"D","4":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"4":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"4":"7B"},I:{"2":"GB G 8B 9B AC BC HB","4":"N CC DC"},J:{"2":"F A"},K:{"4":"A B C Q L EB S"},L:{"4":"N"},M:{"4":"M"},N:{"4":"A B"},O:{"2":"EC"},P:{"4":"G FC GC HC IC JC VB L"},Q:{"4":"KC"},R:{"4":"LC"},S:{"4":"MC"}},B:2,C:"WAI-ARIA Accessibility features"};

},{}],"node_modules/caniuse-lite/data/features/wasm.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"H J K UB IB N","2":"C O T","578":"P"},C:{"1":"3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q nB fB","194":"0 1 x y z","1025":"2"},D:{"1":"7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","322":"1 2 3 4 5 6"},E:{"1":"B C O L S hB iB","2":"G U I F E D A xB WB aB bB cB dB VB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n jB kB lB mB L EB oB S","322":"o p q r s t"},G:{"1":"zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"HC IC JC VB L","2":"G FC GC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"194":"MC"}},B:6,C:"WebAssembly"};

},{}],"node_modules/caniuse-lite/data/features/wav.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M lB mB L EB oB S","2":"D jB kB"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"B C Q L EB S","16":"A"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"Wav audio format"};

},{}],"node_modules/caniuse-lite/data/features/wbr-element.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F gB","2":"E D A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O WB aB bB cB dB VB L S hB iB","16":"xB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","16":"D"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB"},H:{"1":"7B"},I:{"1":"GB G N AC BC HB CC DC","16":"8B 9B"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"wbr (word break opportunity) element"};

},{}],"node_modules/caniuse-lite/data/features/web-animation.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","260":"UB IB N"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i nB fB","260":"9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","516":"0 1 2 3 4 5 6 7 8 x y z","580":"j k l m n o p q r s t u v Q"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l","132":"m n o","260":"0 1 2 3 4 5 6 7 8 9 p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A xB WB aB bB cB dB VB","1090":"B C O L S","2049":"hB iB"},F:{"2":"D B C P H J K V W X Y jB kB lB mB L EB oB S","132":"Z a b","260":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB","1090":"zB 0B 1B 2B 3B 4B 5B","2049":"6B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","260":"N"},J:{"2":"F A"},K:{"2":"A B C L EB S","260":"Q"},L:{"260":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"260":"EC"},P:{"260":"G FC GC HC IC JC VB L"},Q:{"260":"KC"},R:{"260":"LC"},S:{"516":"MC"}},B:5,C:"Web Animations API"};

},{}],"node_modules/caniuse-lite/data/features/web-app-manifest.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H","514":"J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o","132":"0 1 2 3 4 5 6 7 8 9 p q r s t u v Q x y z TB AB FB CB DB BB w","260":"R M JB KB LB MB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB","132":"0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C L EB S","132":"Q"},L:{"1":"N"},M:{"132":"M"},N:{"2":"A B"},O:{"132":"EC"},P:{"132":"G FC GC HC IC JC VB L"},Q:{"132":"KC"},R:{"132":"LC"},S:{"2":"MC"}},B:5,C:"Web App Manifest"};

},{}],"node_modules/caniuse-lite/data/features/web-bluetooth.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","1025":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u","194":"0 1 2 v Q x y z","706":"3 4 5","1025":"6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"D B C P H J K V W X Y Z a b c d e f g h i j k l jB kB lB mB L EB oB S","450":"m n o p","706":"q r s","1025":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z AB CB DB BB w R M"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC DC","1025":"N"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1025":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"GC HC IC JC VB L","2":"G FC"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"Web Bluetooth"};

},{}],"node_modules/caniuse-lite/data/features/web-share.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","258":"K V W X Y Z a"},E:{"1":"O S hB iB","2":"G U I F E D A B C xB WB aB cB dB VB L","16":"bB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B"},H:{"2":"7B"},I:{"2":"GB G 8B 9B AC BC HB CC","514":"N DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"514":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G","514":"FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"16":"LC"},S:{"2":"MC"}},B:7,C:"Web Share API"};

},{}],"node_modules/caniuse-lite/data/features/webauthn.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"K UB IB N","2":"C","226":"O T P H J"},C:{"1":"9 AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB nB fB"},D:{"1":"R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w"},E:{"1":"O hB iB","2":"G U I F E D A B C xB WB aB bB cB dB VB L","322":"S"},F:{"1":"4 5 6 7 8 9 AB CB DB BB w R M","2":"0 1 2 3 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z jB kB lB mB L EB oB S"},G:{"1":"5B 6B","2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B","578":"4B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:2,C:"Web Authentication API"};

},{}],"node_modules/caniuse-lite/data/features/webgl.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"gB","8":"I F E D A","129":"B"},B:{"1":"UB IB N","129":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","129":"G U I F E D A B C O T P H J K V W X Y Z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F","129":"E D A B C O T P H J K V W X Y Z a b c d e f g h i"},E:{"1":"E D A B C O dB VB L S hB iB","2":"G U xB WB","129":"I F aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B jB kB lB mB L EB oB","129":"C P H J K S"},G:{"1":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB tB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"1":"A","2":"F"},K:{"1":"C Q S","2":"A B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"8":"A","129":"B"},O:{"129":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"129":"MC"}},B:6,C:"WebGL - 3D Canvas graphics"};

},{}],"node_modules/caniuse-lite/data/features/webgl2.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"1 2 3 4 5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a nB fB","194":"s t u","450":"b c d e f g h i j k l m n o p q r","2242":"0 v Q x y z"},D:{"1":"6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s","578":"0 1 2 3 4 5 t u v Q x y z"},E:{"2":"G U I F E D A xB WB aB bB cB dB","1090":"B C O VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B","1090":"1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"HC IC JC VB L","2":"G FC GC"},Q:{"578":"KC"},R:{"2":"LC"},S:{"2242":"MC"}},B:6,C:"WebGL 2.0"};

},{}],"node_modules/caniuse-lite/data/features/webgpu.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K UB","578":"IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB nB fB","194":"9 DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB","578":"IB N eB ZB YB"},E:{"2":"G U I F E D A B xB WB aB bB cB dB VB","322":"C O L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"194":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"WebGPU"};

},{}],"node_modules/caniuse-lite/data/features/webhid.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","194":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB","194":"SB UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"WebHID API"};

},{}],"node_modules/caniuse-lite/data/features/webm.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E gB","8":"D A B"},B:{"1":"UB IB N","4":"T P H J K","8":"C O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","4":"G U I F E D A B C O T P H J K V W X Y Z a b c d"},D:{"1":"0 1 2 3 4 5 6 7 8 9 b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U","4":"I F E D A B C O T P H J K V W X Y Z a"},E:{"2":"xB","8":"G U I F E D A B C WB aB bB cB dB VB L","132":"O S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D jB kB lB","4":"B C P mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B","132":"2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"1":"N","2":"8B 9B","4":"GB G AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C L EB S","4":"Q"},L:{"1":"N"},M:{"1":"M"},N:{"8":"A B"},O:{"1":"EC"},P:{"1":"FC GC HC IC JC VB L","4":"G"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:6,C:"WebM video format"};

},{}],"node_modules/caniuse-lite/data/features/webp.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"K UB IB N","2":"C O T P H J"},C:{"1":"9 w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","8":"0 1 2 3 4 5 6 7 8 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U","8":"I F E","132":"D A B C O T P H J K V W X Y","260":"Z a b c d e f g h"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D jB kB lB","8":"B mB","132":"L EB oB","260":"C P H J K S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"N HB CC DC","2":"GB 8B 9B AC","132":"G BC"},J:{"2":"F A"},K:{"1":"C Q L EB S","2":"A","132":"B"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"8":"MC"}},B:7,C:"WebP image format"};

},{}],"node_modules/caniuse-lite/data/features/websockets.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB nB fB","132":"G U","292":"I F E D A"},D:{"1":"0 1 2 3 4 5 6 7 8 9 H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","132":"G U I F E D A B C O T","260":"P"},E:{"1":"F E D A B C O cB dB VB L S hB iB","2":"G xB WB","132":"U aB","260":"I bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D jB kB lB mB","132":"B C L EB oB"},G:{"1":"E sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB","132":"HB rB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","129":"F"},K:{"1":"Q S","2":"A","132":"B C L EB"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Web Sockets"};

},{}],"node_modules/caniuse-lite/data/features/webusb.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"9 FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"0 1 2 3 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z","66":"4 5 6 7 8 TB AB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q jB kB lB mB L EB oB S","66":"r s t u v Q x"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"1":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1":"IC JC VB L","2":"G FC GC HC"},Q:{"1":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:7,C:"WebUSB"};

},{}],"node_modules/caniuse-lite/data/features/webvr.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T","322":"UB IB N","513":"P H J K"},C:{"2":"0 1 2 3 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z nB fB","129":"5 6 7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","194":"4"},D:{"2":"0 1 2 3 4 5 6 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z IB N eB ZB YB","322":"7 8 9 TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"2049":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"1025":"G","1028":"FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"322":"LC"},S:{"2":"MC"}},B:7,C:"WebVR API"};

},{}],"node_modules/caniuse-lite/data/features/webvtt.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"2":"qB GB G U I F E D A B C O T P H J K V W X Y Z nB fB","66":"a b c d e f g","129":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J"},E:{"1":"I F E D A B C O bB cB dB VB L S hB iB","2":"G U xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB rB sB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB G 8B 9B AC BC HB"},J:{"1":"A","2":"F"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"B","2":"A"},O:{"2":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"129":"MC"}},B:5,C:"WebVTT - Web Video Text Tracks"};

},{}],"node_modules/caniuse-lite/data/features/webworkers.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","2":"gB","8":"I F E D"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","8":"qB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","8":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M mB L EB oB S","2":"D jB","8":"kB lB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"2":"7B"},I:{"1":"N 8B CC DC","2":"GB G 9B AC BC HB"},J:{"1":"F A"},K:{"1":"B C Q L EB S","8":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Web Workers"};

},{}],"node_modules/caniuse-lite/data/features/webxr.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"2":"C O T P H J K","132":"UB IB N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB","66":"w R M JB KB LB MB NB OB PB QB RB SB","132":"UB IB N eB ZB YB"},E:{"2":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"2":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"2":"7B"},I:{"2":"GB G N 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"2":"A B C Q L EB S"},L:{"132":"N"},M:{"2":"M"},N:{"2":"A B"},O:{"2":"EC"},P:{"2":"G FC GC HC IC JC VB L"},Q:{"2":"KC"},R:{"2":"LC"},S:{"2":"MC"}},B:5,C:"WebXR Device API"};

},{}],"node_modules/caniuse-lite/data/features/will-change.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"UB IB N","2":"C O T P H J K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e nB fB","194":"f g h i j k l"},D:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l"},E:{"1":"A B C O dB VB L S hB iB","2":"G U I F E D xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y Z jB kB lB mB L EB oB S"},G:{"1":"wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"CSS will-change property"};

},{}],"node_modules/caniuse-lite/data/features/woff.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB fB","2":"qB GB nB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G"},E:{"1":"I F E D A B C O aB bB cB dB VB L S hB iB","2":"G U xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M L EB oB S","2":"D B jB kB lB mB"},G:{"1":"E rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB"},H:{"2":"7B"},I:{"1":"N CC DC","2":"GB 8B 9B AC BC HB","130":"G"},J:{"1":"F A"},K:{"1":"B C Q L EB S","2":"A"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:2,C:"WOFF - Web Open Font Format"};

},{}],"node_modules/caniuse-lite/data/features/woff2.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D A B gB"},B:{"1":"T P H J K UB IB N","2":"C O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","2":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l"},E:{"1":"C O S hB iB","2":"G U I F E D xB WB aB bB cB dB","132":"A B VB L"},F:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C P H J K V W X Y jB kB lB mB L EB oB S"},G:{"1":"XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"E WB pB HB rB sB tB uB vB wB"},H:{"2":"7B"},I:{"1":"N","2":"GB G 8B 9B AC BC HB CC DC"},J:{"2":"F A"},K:{"1":"Q","2":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"2":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"WOFF 2.0 - Web Open Font Format"};

},{}],"node_modules/caniuse-lite/data/features/word-break.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"I F E D A B gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB G U I F E D A B C O T nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","4":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t"},E:{"1":"D A B C O dB VB L S hB iB","4":"G U I F E xB WB aB bB cB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","2":"D B C jB kB lB mB L EB oB S","4":"P H J K V W X Y Z a b c d e f g"},G:{"1":"vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","4":"E WB pB HB rB sB tB uB"},H:{"2":"7B"},I:{"1":"N","4":"GB G 8B 9B AC BC HB CC DC"},J:{"4":"F A"},K:{"2":"A B C L EB S","4":"Q"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"4":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"4":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:5,C:"CSS3 word-break"};

},{}],"node_modules/caniuse-lite/data/features/wordwrap.js":[function(require,module,exports) {
module.exports={A:{A:{"4":"I F E D A B gB"},B:{"1":"K UB IB N","4":"C O T P H J"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB","4":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","4":"G U I F E D A B C O T P H J K V W X Y"},E:{"1":"F E D A B C O bB cB dB VB L S hB iB","4":"G U I xB WB aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D jB kB","4":"B C lB mB L EB oB"},G:{"1":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","4":"WB pB HB rB sB"},H:{"4":"7B"},I:{"1":"N CC DC","4":"GB G 8B 9B AC BC HB"},J:{"1":"A","4":"F"},K:{"1":"Q","4":"A B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"4":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"4":"MC"}},B:5,C:"CSS3 Overflow-wrap"};

},{}],"node_modules/caniuse-lite/data/features/x-doc-messaging.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F gB","132":"E D","260":"A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB","2":"qB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O aB bB cB dB VB L S hB iB","2":"xB WB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S","2":"D"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"4":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"Cross-document messaging"};

},{}],"node_modules/caniuse-lite/data/features/x-frame-options.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"E D A B","2":"I F gB"},B:{"1":"C O T P H J K","4":"UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB","4":"G U I F E D A B C O T P H J KB LB MB NB OB PB QB RB SB","16":"qB GB nB fB"},D:{"4":"0 1 2 3 4 5 6 7 8 9 c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I F E D A B C O T P H J K V W X Y Z a b"},E:{"4":"I F E D A B C O aB bB cB dB VB L S hB iB","16":"G U xB WB"},F:{"4":"0 1 2 3 4 5 6 7 8 9 C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M oB S","16":"D B jB kB lB mB L EB"},G:{"4":"E tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","16":"WB pB HB rB sB"},H:{"2":"7B"},I:{"4":"G N BC HB CC DC","16":"GB 8B 9B AC"},J:{"4":"F A"},K:{"4":"Q S","16":"A B C L EB"},L:{"4":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"4":"EC"},P:{"4":"G FC GC HC IC JC VB L"},Q:{"4":"KC"},R:{"4":"LC"},S:{"1":"MC"}},B:6,C:"X-Frame-Options HTTP header"};

},{}],"node_modules/caniuse-lite/data/features/xhr2.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"I F E D gB","132":"A B"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","2":"qB GB","260":"A B","388":"I F E D","900":"G U nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","16":"G U I","132":"f g","388":"F E D A B C O T P H J K V W X Y Z a b c d e"},E:{"1":"E D A B C O cB dB VB L S hB iB","2":"G xB WB","132":"F bB","388":"U I aB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M S","2":"D B jB kB lB mB L EB oB","132":"P H J"},G:{"1":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","2":"WB pB HB","132":"tB","388":"rB sB"},H:{"2":"7B"},I:{"1":"N DC","2":"8B 9B AC","388":"CC","900":"GB G BC HB"},J:{"132":"A","388":"F"},K:{"1":"C Q S","2":"A B L EB"},L:{"1":"N"},M:{"1":"M"},N:{"132":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:1,C:"XMLHttpRequest advanced features"};

},{}],"node_modules/caniuse-lite/data/features/xhtml.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"D A B","2":"I F E gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"1":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"1":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"1":"7B"},I:{"1":"GB G N 8B 9B AC BC HB CC DC"},J:{"1":"F A"},K:{"1":"A B C Q L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"2":"LC"},S:{"1":"MC"}},B:1,C:"XHTML served as application/xhtml+xml"};

},{}],"node_modules/caniuse-lite/data/features/xhtmlsmil.js":[function(require,module,exports) {
module.exports={A:{A:{"2":"D A B gB","4":"I F E"},B:{"2":"C O T P H J K","8":"UB IB N"},C:{"8":"0 1 2 3 4 5 6 7 8 9 qB GB G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB nB fB"},D:{"8":"0 1 2 3 4 5 6 7 8 9 G U I F E D A B C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB"},E:{"8":"G U I F E D A B C O xB WB aB bB cB dB VB L S hB iB"},F:{"8":"0 1 2 3 4 5 6 7 8 9 D B C P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M jB kB lB mB L EB oB S"},G:{"8":"E WB pB HB rB sB tB uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B"},H:{"8":"7B"},I:{"8":"GB G N 8B 9B AC BC HB CC DC"},J:{"8":"F A"},K:{"8":"A B C Q L EB S"},L:{"8":"N"},M:{"8":"M"},N:{"2":"A B"},O:{"8":"EC"},P:{"8":"G FC GC HC IC JC VB L"},Q:{"8":"KC"},R:{"8":"LC"},S:{"8":"MC"}},B:7,C:"XHTML+SMIL animation"};

},{}],"node_modules/caniuse-lite/data/features/xml-serializer.js":[function(require,module,exports) {
module.exports={A:{A:{"1":"A B","260":"I F E D gB"},B:{"1":"C O T P H J K UB IB N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 C O T P H J K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB","132":"B","260":"qB GB G U I F nB fB","516":"E D A"},D:{"1":"0 1 2 3 4 5 6 7 8 9 h i j k l m n o p q r s t u v Q x y z TB AB FB CB DB BB w R M JB KB LB MB NB OB PB QB RB SB UB IB N eB ZB YB","132":"G U I F E D A B C O T P H J K V W X Y Z a b c d e f g"},E:{"1":"E D A B C O cB dB VB L S hB iB","132":"G U I F xB WB aB bB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 K V W X Y Z a b c d e f g h i j k l m n o p q r s t u v Q x y z AB CB DB BB w R M","16":"D jB","132":"B C P H J kB lB mB L EB oB S"},G:{"1":"E uB vB wB XB yB zB 0B 1B 2B 3B 4B 5B 6B","132":"WB pB HB rB sB tB"},H:{"132":"7B"},I:{"1":"N CC DC","132":"GB G 8B 9B AC BC HB"},J:{"132":"F A"},K:{"1":"Q","16":"A","132":"B C L EB S"},L:{"1":"N"},M:{"1":"M"},N:{"1":"A B"},O:{"1":"EC"},P:{"1":"G FC GC HC IC JC VB L"},Q:{"1":"KC"},R:{"1":"LC"},S:{"1":"MC"}},B:4,C:"DOM Parsing and Serialization"};

},{}],"node_modules/caniuse-lite/data/features.js":[function(require,module,exports) {
module.exports={"aac":require("./features/aac"),"abortcontroller":require("./features/abortcontroller"),"ac3-ec3":require("./features/ac3-ec3"),"accelerometer":require("./features/accelerometer"),"addeventlistener":require("./features/addeventlistener"),"alternate-stylesheet":require("./features/alternate-stylesheet"),"ambient-light":require("./features/ambient-light"),"apng":require("./features/apng"),"array-find-index":require("./features/array-find-index"),"array-find":require("./features/array-find"),"array-flat":require("./features/array-flat"),"array-includes":require("./features/array-includes"),"arrow-functions":require("./features/arrow-functions"),"asmjs":require("./features/asmjs"),"async-clipboard":require("./features/async-clipboard"),"async-functions":require("./features/async-functions"),"async-iterations-and-generators":require("./features/async-iterations-and-generators"),"atob-btoa":require("./features/atob-btoa"),"audio-api":require("./features/audio-api"),"audio":require("./features/audio"),"audiotracks":require("./features/audiotracks"),"autofocus":require("./features/autofocus"),"auxclick":require("./features/auxclick"),"av1":require("./features/av1"),"avif":require("./features/avif"),"background-attachment":require("./features/background-attachment"),"background-clip-text":require("./features/background-clip-text"),"background-img-opts":require("./features/background-img-opts"),"background-position-x-y":require("./features/background-position-x-y"),"background-repeat-round-space":require("./features/background-repeat-round-space"),"background-sync":require("./features/background-sync"),"battery-status":require("./features/battery-status"),"beacon":require("./features/beacon"),"beforeafterprint":require("./features/beforeafterprint"),"bigint":require("./features/bigint"),"blobbuilder":require("./features/blobbuilder"),"bloburls":require("./features/bloburls"),"border-image":require("./features/border-image"),"border-radius":require("./features/border-radius"),"broadcastchannel":require("./features/broadcastchannel"),"brotli":require("./features/brotli"),"calc":require("./features/calc"),"canvas-blending":require("./features/canvas-blending"),"canvas-text":require("./features/canvas-text"),"canvas":require("./features/canvas"),"ch-unit":require("./features/ch-unit"),"chacha20-poly1305":require("./features/chacha20-poly1305"),"channel-messaging":require("./features/channel-messaging"),"childnode-remove":require("./features/childnode-remove"),"classlist":require("./features/classlist"),"clear-site-data-header":require("./features/clear-site-data-header"),"client-hints-dpr-width-viewport":require("./features/client-hints-dpr-width-viewport"),"clipboard":require("./features/clipboard"),"comparedocumentposition":require("./features/comparedocumentposition"),"console-basic":require("./features/console-basic"),"console-time":require("./features/console-time"),"const":require("./features/const"),"constraint-validation":require("./features/constraint-validation"),"contenteditable":require("./features/contenteditable"),"contentsecuritypolicy":require("./features/contentsecuritypolicy"),"contentsecuritypolicy2":require("./features/contentsecuritypolicy2"),"cors":require("./features/cors"),"createimagebitmap":require("./features/createimagebitmap"),"credential-management":require("./features/credential-management"),"cryptography":require("./features/cryptography"),"css-all":require("./features/css-all"),"css-animation":require("./features/css-animation"),"css-any-link":require("./features/css-any-link"),"css-appearance":require("./features/css-appearance"),"css-apply-rule":require("./features/css-apply-rule"),"css-at-counter-style":require("./features/css-at-counter-style"),"css-backdrop-filter":require("./features/css-backdrop-filter"),"css-background-offsets":require("./features/css-background-offsets"),"css-backgroundblendmode":require("./features/css-backgroundblendmode"),"css-boxdecorationbreak":require("./features/css-boxdecorationbreak"),"css-boxshadow":require("./features/css-boxshadow"),"css-canvas":require("./features/css-canvas"),"css-caret-color":require("./features/css-caret-color"),"css-case-insensitive":require("./features/css-case-insensitive"),"css-clip-path":require("./features/css-clip-path"),"css-color-adjust":require("./features/css-color-adjust"),"css-conic-gradients":require("./features/css-conic-gradients"),"css-containment":require("./features/css-containment"),"css-counters":require("./features/css-counters"),"css-crisp-edges":require("./features/css-crisp-edges"),"css-cross-fade":require("./features/css-cross-fade"),"css-default-pseudo":require("./features/css-default-pseudo"),"css-descendant-gtgt":require("./features/css-descendant-gtgt"),"css-deviceadaptation":require("./features/css-deviceadaptation"),"css-dir-pseudo":require("./features/css-dir-pseudo"),"css-display-contents":require("./features/css-display-contents"),"css-element-function":require("./features/css-element-function"),"css-env-function":require("./features/css-env-function"),"css-exclusions":require("./features/css-exclusions"),"css-featurequeries":require("./features/css-featurequeries"),"css-filter-function":require("./features/css-filter-function"),"css-filters":require("./features/css-filters"),"css-first-letter":require("./features/css-first-letter"),"css-first-line":require("./features/css-first-line"),"css-fixed":require("./features/css-fixed"),"css-focus-visible":require("./features/css-focus-visible"),"css-focus-within":require("./features/css-focus-within"),"css-font-rendering-controls":require("./features/css-font-rendering-controls"),"css-font-stretch":require("./features/css-font-stretch"),"css-gencontent":require("./features/css-gencontent"),"css-gradients":require("./features/css-gradients"),"css-grid":require("./features/css-grid"),"css-hanging-punctuation":require("./features/css-hanging-punctuation"),"css-has":require("./features/css-has"),"css-hyphenate":require("./features/css-hyphenate"),"css-hyphens":require("./features/css-hyphens"),"css-image-orientation":require("./features/css-image-orientation"),"css-image-set":require("./features/css-image-set"),"css-in-out-of-range":require("./features/css-in-out-of-range"),"css-indeterminate-pseudo":require("./features/css-indeterminate-pseudo"),"css-initial-letter":require("./features/css-initial-letter"),"css-initial-value":require("./features/css-initial-value"),"css-letter-spacing":require("./features/css-letter-spacing"),"css-line-clamp":require("./features/css-line-clamp"),"css-logical-props":require("./features/css-logical-props"),"css-marker-pseudo":require("./features/css-marker-pseudo"),"css-masks":require("./features/css-masks"),"css-matches-pseudo":require("./features/css-matches-pseudo"),"css-math-functions":require("./features/css-math-functions"),"css-media-interaction":require("./features/css-media-interaction"),"css-media-resolution":require("./features/css-media-resolution"),"css-media-scripting":require("./features/css-media-scripting"),"css-mediaqueries":require("./features/css-mediaqueries"),"css-mixblendmode":require("./features/css-mixblendmode"),"css-motion-paths":require("./features/css-motion-paths"),"css-namespaces":require("./features/css-namespaces"),"css-not-sel-list":require("./features/css-not-sel-list"),"css-nth-child-of":require("./features/css-nth-child-of"),"css-opacity":require("./features/css-opacity"),"css-optional-pseudo":require("./features/css-optional-pseudo"),"css-overflow-anchor":require("./features/css-overflow-anchor"),"css-overflow":require("./features/css-overflow"),"css-overscroll-behavior":require("./features/css-overscroll-behavior"),"css-page-break":require("./features/css-page-break"),"css-paged-media":require("./features/css-paged-media"),"css-paint-api":require("./features/css-paint-api"),"css-placeholder-shown":require("./features/css-placeholder-shown"),"css-placeholder":require("./features/css-placeholder"),"css-read-only-write":require("./features/css-read-only-write"),"css-rebeccapurple":require("./features/css-rebeccapurple"),"css-reflections":require("./features/css-reflections"),"css-regions":require("./features/css-regions"),"css-repeating-gradients":require("./features/css-repeating-gradients"),"css-resize":require("./features/css-resize"),"css-revert-value":require("./features/css-revert-value"),"css-rrggbbaa":require("./features/css-rrggbbaa"),"css-scroll-behavior":require("./features/css-scroll-behavior"),"css-scrollbar":require("./features/css-scrollbar"),"css-sel2":require("./features/css-sel2"),"css-sel3":require("./features/css-sel3"),"css-selection":require("./features/css-selection"),"css-shapes":require("./features/css-shapes"),"css-snappoints":require("./features/css-snappoints"),"css-sticky":require("./features/css-sticky"),"css-subgrid":require("./features/css-subgrid"),"css-supports-api":require("./features/css-supports-api"),"css-table":require("./features/css-table"),"css-text-align-last":require("./features/css-text-align-last"),"css-text-indent":require("./features/css-text-indent"),"css-text-justify":require("./features/css-text-justify"),"css-text-orientation":require("./features/css-text-orientation"),"css-text-spacing":require("./features/css-text-spacing"),"css-textshadow":require("./features/css-textshadow"),"css-touch-action-2":require("./features/css-touch-action-2"),"css-touch-action":require("./features/css-touch-action"),"css-transitions":require("./features/css-transitions"),"css-unicode-bidi":require("./features/css-unicode-bidi"),"css-unset-value":require("./features/css-unset-value"),"css-variables":require("./features/css-variables"),"css-widows-orphans":require("./features/css-widows-orphans"),"css-writing-mode":require("./features/css-writing-mode"),"css-zoom":require("./features/css-zoom"),"css3-attr":require("./features/css3-attr"),"css3-boxsizing":require("./features/css3-boxsizing"),"css3-colors":require("./features/css3-colors"),"css3-cursors-grab":require("./features/css3-cursors-grab"),"css3-cursors-newer":require("./features/css3-cursors-newer"),"css3-cursors":require("./features/css3-cursors"),"css3-tabsize":require("./features/css3-tabsize"),"currentcolor":require("./features/currentcolor"),"custom-elements":require("./features/custom-elements"),"custom-elementsv1":require("./features/custom-elementsv1"),"customevent":require("./features/customevent"),"datalist":require("./features/datalist"),"dataset":require("./features/dataset"),"datauri":require("./features/datauri"),"date-tolocaledatestring":require("./features/date-tolocaledatestring"),"details":require("./features/details"),"deviceorientation":require("./features/deviceorientation"),"devicepixelratio":require("./features/devicepixelratio"),"dialog":require("./features/dialog"),"dispatchevent":require("./features/dispatchevent"),"dnssec":require("./features/dnssec"),"do-not-track":require("./features/do-not-track"),"document-currentscript":require("./features/document-currentscript"),"document-evaluate-xpath":require("./features/document-evaluate-xpath"),"document-execcommand":require("./features/document-execcommand"),"document-scrollingelement":require("./features/document-scrollingelement"),"documenthead":require("./features/documenthead"),"dom-manip-convenience":require("./features/dom-manip-convenience"),"dom-range":require("./features/dom-range"),"domcontentloaded":require("./features/domcontentloaded"),"domfocusin-domfocusout-events":require("./features/domfocusin-domfocusout-events"),"dommatrix":require("./features/dommatrix"),"download":require("./features/download"),"dragndrop":require("./features/dragndrop"),"element-closest":require("./features/element-closest"),"element-from-point":require("./features/element-from-point"),"element-scroll-methods":require("./features/element-scroll-methods"),"eme":require("./features/eme"),"eot":require("./features/eot"),"es5":require("./features/es5"),"es6-class":require("./features/es6-class"),"es6-generators":require("./features/es6-generators"),"es6-module-dynamic-import":require("./features/es6-module-dynamic-import"),"es6-module":require("./features/es6-module"),"es6-number":require("./features/es6-number"),"es6-string-includes":require("./features/es6-string-includes"),"es6":require("./features/es6"),"eventsource":require("./features/eventsource"),"extended-system-fonts":require("./features/extended-system-fonts"),"feature-policy":require("./features/feature-policy"),"fetch":require("./features/fetch"),"fieldset-disabled":require("./features/fieldset-disabled"),"fileapi":require("./features/fileapi"),"filereader":require("./features/filereader"),"filereadersync":require("./features/filereadersync"),"filesystem":require("./features/filesystem"),"flac":require("./features/flac"),"flexbox-gap":require("./features/flexbox-gap"),"flexbox":require("./features/flexbox"),"flow-root":require("./features/flow-root"),"focusin-focusout-events":require("./features/focusin-focusout-events"),"focusoptions-preventscroll":require("./features/focusoptions-preventscroll"),"font-family-system-ui":require("./features/font-family-system-ui"),"font-feature":require("./features/font-feature"),"font-kerning":require("./features/font-kerning"),"font-loading":require("./features/font-loading"),"font-size-adjust":require("./features/font-size-adjust"),"font-smooth":require("./features/font-smooth"),"font-unicode-range":require("./features/font-unicode-range"),"font-variant-alternates":require("./features/font-variant-alternates"),"font-variant-east-asian":require("./features/font-variant-east-asian"),"font-variant-numeric":require("./features/font-variant-numeric"),"fontface":require("./features/fontface"),"form-attribute":require("./features/form-attribute"),"form-submit-attributes":require("./features/form-submit-attributes"),"form-validation":require("./features/form-validation"),"forms":require("./features/forms"),"fullscreen":require("./features/fullscreen"),"gamepad":require("./features/gamepad"),"geolocation":require("./features/geolocation"),"getboundingclientrect":require("./features/getboundingclientrect"),"getcomputedstyle":require("./features/getcomputedstyle"),"getelementsbyclassname":require("./features/getelementsbyclassname"),"getrandomvalues":require("./features/getrandomvalues"),"gyroscope":require("./features/gyroscope"),"hardwareconcurrency":require("./features/hardwareconcurrency"),"hashchange":require("./features/hashchange"),"heif":require("./features/heif"),"hevc":require("./features/hevc"),"hidden":require("./features/hidden"),"high-resolution-time":require("./features/high-resolution-time"),"history":require("./features/history"),"html-media-capture":require("./features/html-media-capture"),"html5semantic":require("./features/html5semantic"),"http-live-streaming":require("./features/http-live-streaming"),"http2":require("./features/http2"),"http3":require("./features/http3"),"iframe-sandbox":require("./features/iframe-sandbox"),"iframe-seamless":require("./features/iframe-seamless"),"iframe-srcdoc":require("./features/iframe-srcdoc"),"imagecapture":require("./features/imagecapture"),"ime":require("./features/ime"),"img-naturalwidth-naturalheight":require("./features/img-naturalwidth-naturalheight"),"imports":require("./features/imports"),"indeterminate-checkbox":require("./features/indeterminate-checkbox"),"indexeddb":require("./features/indexeddb"),"indexeddb2":require("./features/indexeddb2"),"inline-block":require("./features/inline-block"),"innertext":require("./features/innertext"),"input-autocomplete-onoff":require("./features/input-autocomplete-onoff"),"input-color":require("./features/input-color"),"input-datetime":require("./features/input-datetime"),"input-email-tel-url":require("./features/input-email-tel-url"),"input-event":require("./features/input-event"),"input-file-accept":require("./features/input-file-accept"),"input-file-directory":require("./features/input-file-directory"),"input-file-multiple":require("./features/input-file-multiple"),"input-inputmode":require("./features/input-inputmode"),"input-minlength":require("./features/input-minlength"),"input-number":require("./features/input-number"),"input-pattern":require("./features/input-pattern"),"input-placeholder":require("./features/input-placeholder"),"input-range":require("./features/input-range"),"input-search":require("./features/input-search"),"input-selection":require("./features/input-selection"),"insert-adjacent":require("./features/insert-adjacent"),"insertadjacenthtml":require("./features/insertadjacenthtml"),"internationalization":require("./features/internationalization"),"intersectionobserver-v2":require("./features/intersectionobserver-v2"),"intersectionobserver":require("./features/intersectionobserver"),"intl-pluralrules":require("./features/intl-pluralrules"),"intrinsic-width":require("./features/intrinsic-width"),"jpeg2000":require("./features/jpeg2000"),"jpegxr":require("./features/jpegxr"),"js-regexp-lookbehind":require("./features/js-regexp-lookbehind"),"json":require("./features/json"),"justify-content-space-evenly":require("./features/justify-content-space-evenly"),"kerning-pairs-ligatures":require("./features/kerning-pairs-ligatures"),"keyboardevent-charcode":require("./features/keyboardevent-charcode"),"keyboardevent-code":require("./features/keyboardevent-code"),"keyboardevent-getmodifierstate":require("./features/keyboardevent-getmodifierstate"),"keyboardevent-key":require("./features/keyboardevent-key"),"keyboardevent-location":require("./features/keyboardevent-location"),"keyboardevent-which":require("./features/keyboardevent-which"),"lazyload":require("./features/lazyload"),"let":require("./features/let"),"link-icon-png":require("./features/link-icon-png"),"link-icon-svg":require("./features/link-icon-svg"),"link-rel-dns-prefetch":require("./features/link-rel-dns-prefetch"),"link-rel-modulepreload":require("./features/link-rel-modulepreload"),"link-rel-preconnect":require("./features/link-rel-preconnect"),"link-rel-prefetch":require("./features/link-rel-prefetch"),"link-rel-preload":require("./features/link-rel-preload"),"link-rel-prerender":require("./features/link-rel-prerender"),"loading-lazy-attr":require("./features/loading-lazy-attr"),"localecompare":require("./features/localecompare"),"magnetometer":require("./features/magnetometer"),"matchesselector":require("./features/matchesselector"),"matchmedia":require("./features/matchmedia"),"mathml":require("./features/mathml"),"maxlength":require("./features/maxlength"),"media-attribute":require("./features/media-attribute"),"media-fragments":require("./features/media-fragments"),"media-session-api":require("./features/media-session-api"),"mediacapture-fromelement":require("./features/mediacapture-fromelement"),"mediarecorder":require("./features/mediarecorder"),"mediasource":require("./features/mediasource"),"menu":require("./features/menu"),"meta-theme-color":require("./features/meta-theme-color"),"meter":require("./features/meter"),"midi":require("./features/midi"),"minmaxwh":require("./features/minmaxwh"),"mp3":require("./features/mp3"),"mpeg-dash":require("./features/mpeg-dash"),"mpeg4":require("./features/mpeg4"),"multibackgrounds":require("./features/multibackgrounds"),"multicolumn":require("./features/multicolumn"),"mutation-events":require("./features/mutation-events"),"mutationobserver":require("./features/mutationobserver"),"namevalue-storage":require("./features/namevalue-storage"),"native-filesystem-api":require("./features/native-filesystem-api"),"nav-timing":require("./features/nav-timing"),"navigator-language":require("./features/navigator-language"),"netinfo":require("./features/netinfo"),"node-contains":require("./features/node-contains"),"node-parentelement":require("./features/node-parentelement"),"notifications":require("./features/notifications"),"object-entries":require("./features/object-entries"),"object-fit":require("./features/object-fit"),"object-observe":require("./features/object-observe"),"object-values":require("./features/object-values"),"objectrtc":require("./features/objectrtc"),"offline-apps":require("./features/offline-apps"),"offscreencanvas":require("./features/offscreencanvas"),"ogg-vorbis":require("./features/ogg-vorbis"),"ogv":require("./features/ogv"),"ol-reversed":require("./features/ol-reversed"),"once-event-listener":require("./features/once-event-listener"),"online-status":require("./features/online-status"),"opus":require("./features/opus"),"orientation-sensor":require("./features/orientation-sensor"),"outline":require("./features/outline"),"pad-start-end":require("./features/pad-start-end"),"page-transition-events":require("./features/page-transition-events"),"pagevisibility":require("./features/pagevisibility"),"passive-event-listener":require("./features/passive-event-listener"),"passwordrules":require("./features/passwordrules"),"path2d":require("./features/path2d"),"payment-request":require("./features/payment-request"),"permissions-api":require("./features/permissions-api"),"picture-in-picture":require("./features/picture-in-picture"),"picture":require("./features/picture"),"ping":require("./features/ping"),"png-alpha":require("./features/png-alpha"),"pointer-events":require("./features/pointer-events"),"pointer":require("./features/pointer"),"pointerlock":require("./features/pointerlock"),"prefers-color-scheme":require("./features/prefers-color-scheme"),"prefers-reduced-motion":require("./features/prefers-reduced-motion"),"private-class-fields":require("./features/private-class-fields"),"private-methods-and-accessors":require("./features/private-methods-and-accessors"),"progress":require("./features/progress"),"promise-finally":require("./features/promise-finally"),"promises":require("./features/promises"),"proximity":require("./features/proximity"),"proxy":require("./features/proxy"),"public-class-fields":require("./features/public-class-fields"),"publickeypinning":require("./features/publickeypinning"),"push-api":require("./features/push-api"),"queryselector":require("./features/queryselector"),"readonly-attr":require("./features/readonly-attr"),"referrer-policy":require("./features/referrer-policy"),"registerprotocolhandler":require("./features/registerprotocolhandler"),"rel-noopener":require("./features/rel-noopener"),"rel-noreferrer":require("./features/rel-noreferrer"),"rellist":require("./features/rellist"),"rem":require("./features/rem"),"replace-all":require("./features/replace-all"),"requestanimationframe":require("./features/requestanimationframe"),"requestidlecallback":require("./features/requestidlecallback"),"resizeobserver":require("./features/resizeobserver"),"resource-timing":require("./features/resource-timing"),"rest-parameters":require("./features/rest-parameters"),"rtcpeerconnection":require("./features/rtcpeerconnection"),"ruby":require("./features/ruby"),"run-in":require("./features/run-in"),"same-site-cookie-attribute":require("./features/same-site-cookie-attribute"),"screen-orientation":require("./features/screen-orientation"),"script-async":require("./features/script-async"),"script-defer":require("./features/script-defer"),"scrollintoview":require("./features/scrollintoview"),"scrollintoviewifneeded":require("./features/scrollintoviewifneeded"),"sdch":require("./features/sdch"),"selection-api":require("./features/selection-api"),"server-timing":require("./features/server-timing"),"serviceworkers":require("./features/serviceworkers"),"setimmediate":require("./features/setimmediate"),"sha-2":require("./features/sha-2"),"shadowdom":require("./features/shadowdom"),"shadowdomv1":require("./features/shadowdomv1"),"sharedarraybuffer":require("./features/sharedarraybuffer"),"sharedworkers":require("./features/sharedworkers"),"sni":require("./features/sni"),"spdy":require("./features/spdy"),"speech-recognition":require("./features/speech-recognition"),"speech-synthesis":require("./features/speech-synthesis"),"spellcheck-attribute":require("./features/spellcheck-attribute"),"sql-storage":require("./features/sql-storage"),"srcset":require("./features/srcset"),"stopimmediatepropagation":require("./features/stopimmediatepropagation"),"stream":require("./features/stream"),"streams":require("./features/streams"),"stricttransportsecurity":require("./features/stricttransportsecurity"),"style-scoped":require("./features/style-scoped"),"subresource-integrity":require("./features/subresource-integrity"),"svg-css":require("./features/svg-css"),"svg-filters":require("./features/svg-filters"),"svg-fonts":require("./features/svg-fonts"),"svg-fragment":require("./features/svg-fragment"),"svg-html":require("./features/svg-html"),"svg-html5":require("./features/svg-html5"),"svg-img":require("./features/svg-img"),"svg-smil":require("./features/svg-smil"),"svg":require("./features/svg"),"sxg":require("./features/sxg"),"symbols":require("./features/symbols"),"tabindex-attr":require("./features/tabindex-attr"),"template-literals":require("./features/template-literals"),"template":require("./features/template"),"testfeat":require("./features/testfeat"),"text-decoration":require("./features/text-decoration"),"text-emphasis":require("./features/text-emphasis"),"text-overflow":require("./features/text-overflow"),"text-size-adjust":require("./features/text-size-adjust"),"text-stroke":require("./features/text-stroke"),"text-underline-offset":require("./features/text-underline-offset"),"textcontent":require("./features/textcontent"),"textencoder":require("./features/textencoder"),"tls1-1":require("./features/tls1-1"),"tls1-2":require("./features/tls1-2"),"tls1-3":require("./features/tls1-3"),"token-binding":require("./features/token-binding"),"touch":require("./features/touch"),"transforms2d":require("./features/transforms2d"),"transforms3d":require("./features/transforms3d"),"trusted-types":require("./features/trusted-types"),"ttf":require("./features/ttf"),"typedarrays":require("./features/typedarrays"),"u2f":require("./features/u2f"),"unhandledrejection":require("./features/unhandledrejection"),"upgradeinsecurerequests":require("./features/upgradeinsecurerequests"),"url-scroll-to-text-fragment":require("./features/url-scroll-to-text-fragment"),"url":require("./features/url"),"urlsearchparams":require("./features/urlsearchparams"),"use-strict":require("./features/use-strict"),"user-select-none":require("./features/user-select-none"),"user-timing":require("./features/user-timing"),"variable-fonts":require("./features/variable-fonts"),"vibration":require("./features/vibration"),"video":require("./features/video"),"videotracks":require("./features/videotracks"),"viewport-units":require("./features/viewport-units"),"wai-aria":require("./features/wai-aria"),"wasm":require("./features/wasm"),"wav":require("./features/wav"),"wbr-element":require("./features/wbr-element"),"web-animation":require("./features/web-animation"),"web-app-manifest":require("./features/web-app-manifest"),"web-bluetooth":require("./features/web-bluetooth"),"web-share":require("./features/web-share"),"webauthn":require("./features/webauthn"),"webgl":require("./features/webgl"),"webgl2":require("./features/webgl2"),"webgpu":require("./features/webgpu"),"webhid":require("./features/webhid"),"webm":require("./features/webm"),"webp":require("./features/webp"),"websockets":require("./features/websockets"),"webusb":require("./features/webusb"),"webvr":require("./features/webvr"),"webvtt":require("./features/webvtt"),"webworkers":require("./features/webworkers"),"webxr":require("./features/webxr"),"will-change":require("./features/will-change"),"woff":require("./features/woff"),"woff2":require("./features/woff2"),"word-break":require("./features/word-break"),"wordwrap":require("./features/wordwrap"),"x-doc-messaging":require("./features/x-doc-messaging"),"x-frame-options":require("./features/x-frame-options"),"xhr2":require("./features/xhr2"),"xhtml":require("./features/xhtml"),"xhtmlsmil":require("./features/xhtmlsmil"),"xml-serializer":require("./features/xml-serializer")};

},{"./features/aac":"node_modules/caniuse-lite/data/features/aac.js","./features/abortcontroller":"node_modules/caniuse-lite/data/features/abortcontroller.js","./features/ac3-ec3":"node_modules/caniuse-lite/data/features/ac3-ec3.js","./features/accelerometer":"node_modules/caniuse-lite/data/features/accelerometer.js","./features/addeventlistener":"node_modules/caniuse-lite/data/features/addeventlistener.js","./features/alternate-stylesheet":"node_modules/caniuse-lite/data/features/alternate-stylesheet.js","./features/ambient-light":"node_modules/caniuse-lite/data/features/ambient-light.js","./features/apng":"node_modules/caniuse-lite/data/features/apng.js","./features/array-find-index":"node_modules/caniuse-lite/data/features/array-find-index.js","./features/array-find":"node_modules/caniuse-lite/data/features/array-find.js","./features/array-flat":"node_modules/caniuse-lite/data/features/array-flat.js","./features/array-includes":"node_modules/caniuse-lite/data/features/array-includes.js","./features/arrow-functions":"node_modules/caniuse-lite/data/features/arrow-functions.js","./features/asmjs":"node_modules/caniuse-lite/data/features/asmjs.js","./features/async-clipboard":"node_modules/caniuse-lite/data/features/async-clipboard.js","./features/async-functions":"node_modules/caniuse-lite/data/features/async-functions.js","./features/async-iterations-and-generators":"node_modules/caniuse-lite/data/features/async-iterations-and-generators.js","./features/atob-btoa":"node_modules/caniuse-lite/data/features/atob-btoa.js","./features/audio-api":"node_modules/caniuse-lite/data/features/audio-api.js","./features/audio":"node_modules/caniuse-lite/data/features/audio.js","./features/audiotracks":"node_modules/caniuse-lite/data/features/audiotracks.js","./features/autofocus":"node_modules/caniuse-lite/data/features/autofocus.js","./features/auxclick":"node_modules/caniuse-lite/data/features/auxclick.js","./features/av1":"node_modules/caniuse-lite/data/features/av1.js","./features/avif":"node_modules/caniuse-lite/data/features/avif.js","./features/background-attachment":"node_modules/caniuse-lite/data/features/background-attachment.js","./features/background-clip-text":"node_modules/caniuse-lite/data/features/background-clip-text.js","./features/background-img-opts":"node_modules/caniuse-lite/data/features/background-img-opts.js","./features/background-position-x-y":"node_modules/caniuse-lite/data/features/background-position-x-y.js","./features/background-repeat-round-space":"node_modules/caniuse-lite/data/features/background-repeat-round-space.js","./features/background-sync":"node_modules/caniuse-lite/data/features/background-sync.js","./features/battery-status":"node_modules/caniuse-lite/data/features/battery-status.js","./features/beacon":"node_modules/caniuse-lite/data/features/beacon.js","./features/beforeafterprint":"node_modules/caniuse-lite/data/features/beforeafterprint.js","./features/bigint":"node_modules/caniuse-lite/data/features/bigint.js","./features/blobbuilder":"node_modules/caniuse-lite/data/features/blobbuilder.js","./features/bloburls":"node_modules/caniuse-lite/data/features/bloburls.js","./features/border-image":"node_modules/caniuse-lite/data/features/border-image.js","./features/border-radius":"node_modules/caniuse-lite/data/features/border-radius.js","./features/broadcastchannel":"node_modules/caniuse-lite/data/features/broadcastchannel.js","./features/brotli":"node_modules/caniuse-lite/data/features/brotli.js","./features/calc":"node_modules/caniuse-lite/data/features/calc.js","./features/canvas-blending":"node_modules/caniuse-lite/data/features/canvas-blending.js","./features/canvas-text":"node_modules/caniuse-lite/data/features/canvas-text.js","./features/canvas":"node_modules/caniuse-lite/data/features/canvas.js","./features/ch-unit":"node_modules/caniuse-lite/data/features/ch-unit.js","./features/chacha20-poly1305":"node_modules/caniuse-lite/data/features/chacha20-poly1305.js","./features/channel-messaging":"node_modules/caniuse-lite/data/features/channel-messaging.js","./features/childnode-remove":"node_modules/caniuse-lite/data/features/childnode-remove.js","./features/classlist":"node_modules/caniuse-lite/data/features/classlist.js","./features/clear-site-data-header":"node_modules/caniuse-lite/data/features/clear-site-data-header.js","./features/client-hints-dpr-width-viewport":"node_modules/caniuse-lite/data/features/client-hints-dpr-width-viewport.js","./features/clipboard":"node_modules/caniuse-lite/data/features/clipboard.js","./features/comparedocumentposition":"node_modules/caniuse-lite/data/features/comparedocumentposition.js","./features/console-basic":"node_modules/caniuse-lite/data/features/console-basic.js","./features/console-time":"node_modules/caniuse-lite/data/features/console-time.js","./features/const":"node_modules/caniuse-lite/data/features/const.js","./features/constraint-validation":"node_modules/caniuse-lite/data/features/constraint-validation.js","./features/contenteditable":"node_modules/caniuse-lite/data/features/contenteditable.js","./features/contentsecuritypolicy":"node_modules/caniuse-lite/data/features/contentsecuritypolicy.js","./features/contentsecuritypolicy2":"node_modules/caniuse-lite/data/features/contentsecuritypolicy2.js","./features/cors":"node_modules/caniuse-lite/data/features/cors.js","./features/createimagebitmap":"node_modules/caniuse-lite/data/features/createimagebitmap.js","./features/credential-management":"node_modules/caniuse-lite/data/features/credential-management.js","./features/cryptography":"node_modules/caniuse-lite/data/features/cryptography.js","./features/css-all":"node_modules/caniuse-lite/data/features/css-all.js","./features/css-animation":"node_modules/caniuse-lite/data/features/css-animation.js","./features/css-any-link":"node_modules/caniuse-lite/data/features/css-any-link.js","./features/css-appearance":"node_modules/caniuse-lite/data/features/css-appearance.js","./features/css-apply-rule":"node_modules/caniuse-lite/data/features/css-apply-rule.js","./features/css-at-counter-style":"node_modules/caniuse-lite/data/features/css-at-counter-style.js","./features/css-backdrop-filter":"node_modules/caniuse-lite/data/features/css-backdrop-filter.js","./features/css-background-offsets":"node_modules/caniuse-lite/data/features/css-background-offsets.js","./features/css-backgroundblendmode":"node_modules/caniuse-lite/data/features/css-backgroundblendmode.js","./features/css-boxdecorationbreak":"node_modules/caniuse-lite/data/features/css-boxdecorationbreak.js","./features/css-boxshadow":"node_modules/caniuse-lite/data/features/css-boxshadow.js","./features/css-canvas":"node_modules/caniuse-lite/data/features/css-canvas.js","./features/css-caret-color":"node_modules/caniuse-lite/data/features/css-caret-color.js","./features/css-case-insensitive":"node_modules/caniuse-lite/data/features/css-case-insensitive.js","./features/css-clip-path":"node_modules/caniuse-lite/data/features/css-clip-path.js","./features/css-color-adjust":"node_modules/caniuse-lite/data/features/css-color-adjust.js","./features/css-conic-gradients":"node_modules/caniuse-lite/data/features/css-conic-gradients.js","./features/css-containment":"node_modules/caniuse-lite/data/features/css-containment.js","./features/css-counters":"node_modules/caniuse-lite/data/features/css-counters.js","./features/css-crisp-edges":"node_modules/caniuse-lite/data/features/css-crisp-edges.js","./features/css-cross-fade":"node_modules/caniuse-lite/data/features/css-cross-fade.js","./features/css-default-pseudo":"node_modules/caniuse-lite/data/features/css-default-pseudo.js","./features/css-descendant-gtgt":"node_modules/caniuse-lite/data/features/css-descendant-gtgt.js","./features/css-deviceadaptation":"node_modules/caniuse-lite/data/features/css-deviceadaptation.js","./features/css-dir-pseudo":"node_modules/caniuse-lite/data/features/css-dir-pseudo.js","./features/css-display-contents":"node_modules/caniuse-lite/data/features/css-display-contents.js","./features/css-element-function":"node_modules/caniuse-lite/data/features/css-element-function.js","./features/css-env-function":"node_modules/caniuse-lite/data/features/css-env-function.js","./features/css-exclusions":"node_modules/caniuse-lite/data/features/css-exclusions.js","./features/css-featurequeries":"node_modules/caniuse-lite/data/features/css-featurequeries.js","./features/css-filter-function":"node_modules/caniuse-lite/data/features/css-filter-function.js","./features/css-filters":"node_modules/caniuse-lite/data/features/css-filters.js","./features/css-first-letter":"node_modules/caniuse-lite/data/features/css-first-letter.js","./features/css-first-line":"node_modules/caniuse-lite/data/features/css-first-line.js","./features/css-fixed":"node_modules/caniuse-lite/data/features/css-fixed.js","./features/css-focus-visible":"node_modules/caniuse-lite/data/features/css-focus-visible.js","./features/css-focus-within":"node_modules/caniuse-lite/data/features/css-focus-within.js","./features/css-font-rendering-controls":"node_modules/caniuse-lite/data/features/css-font-rendering-controls.js","./features/css-font-stretch":"node_modules/caniuse-lite/data/features/css-font-stretch.js","./features/css-gencontent":"node_modules/caniuse-lite/data/features/css-gencontent.js","./features/css-gradients":"node_modules/caniuse-lite/data/features/css-gradients.js","./features/css-grid":"node_modules/caniuse-lite/data/features/css-grid.js","./features/css-hanging-punctuation":"node_modules/caniuse-lite/data/features/css-hanging-punctuation.js","./features/css-has":"node_modules/caniuse-lite/data/features/css-has.js","./features/css-hyphenate":"node_modules/caniuse-lite/data/features/css-hyphenate.js","./features/css-hyphens":"node_modules/caniuse-lite/data/features/css-hyphens.js","./features/css-image-orientation":"node_modules/caniuse-lite/data/features/css-image-orientation.js","./features/css-image-set":"node_modules/caniuse-lite/data/features/css-image-set.js","./features/css-in-out-of-range":"node_modules/caniuse-lite/data/features/css-in-out-of-range.js","./features/css-indeterminate-pseudo":"node_modules/caniuse-lite/data/features/css-indeterminate-pseudo.js","./features/css-initial-letter":"node_modules/caniuse-lite/data/features/css-initial-letter.js","./features/css-initial-value":"node_modules/caniuse-lite/data/features/css-initial-value.js","./features/css-letter-spacing":"node_modules/caniuse-lite/data/features/css-letter-spacing.js","./features/css-line-clamp":"node_modules/caniuse-lite/data/features/css-line-clamp.js","./features/css-logical-props":"node_modules/caniuse-lite/data/features/css-logical-props.js","./features/css-marker-pseudo":"node_modules/caniuse-lite/data/features/css-marker-pseudo.js","./features/css-masks":"node_modules/caniuse-lite/data/features/css-masks.js","./features/css-matches-pseudo":"node_modules/caniuse-lite/data/features/css-matches-pseudo.js","./features/css-math-functions":"node_modules/caniuse-lite/data/features/css-math-functions.js","./features/css-media-interaction":"node_modules/caniuse-lite/data/features/css-media-interaction.js","./features/css-media-resolution":"node_modules/caniuse-lite/data/features/css-media-resolution.js","./features/css-media-scripting":"node_modules/caniuse-lite/data/features/css-media-scripting.js","./features/css-mediaqueries":"node_modules/caniuse-lite/data/features/css-mediaqueries.js","./features/css-mixblendmode":"node_modules/caniuse-lite/data/features/css-mixblendmode.js","./features/css-motion-paths":"node_modules/caniuse-lite/data/features/css-motion-paths.js","./features/css-namespaces":"node_modules/caniuse-lite/data/features/css-namespaces.js","./features/css-not-sel-list":"node_modules/caniuse-lite/data/features/css-not-sel-list.js","./features/css-nth-child-of":"node_modules/caniuse-lite/data/features/css-nth-child-of.js","./features/css-opacity":"node_modules/caniuse-lite/data/features/css-opacity.js","./features/css-optional-pseudo":"node_modules/caniuse-lite/data/features/css-optional-pseudo.js","./features/css-overflow-anchor":"node_modules/caniuse-lite/data/features/css-overflow-anchor.js","./features/css-overflow":"node_modules/caniuse-lite/data/features/css-overflow.js","./features/css-overscroll-behavior":"node_modules/caniuse-lite/data/features/css-overscroll-behavior.js","./features/css-page-break":"node_modules/caniuse-lite/data/features/css-page-break.js","./features/css-paged-media":"node_modules/caniuse-lite/data/features/css-paged-media.js","./features/css-paint-api":"node_modules/caniuse-lite/data/features/css-paint-api.js","./features/css-placeholder-shown":"node_modules/caniuse-lite/data/features/css-placeholder-shown.js","./features/css-placeholder":"node_modules/caniuse-lite/data/features/css-placeholder.js","./features/css-read-only-write":"node_modules/caniuse-lite/data/features/css-read-only-write.js","./features/css-rebeccapurple":"node_modules/caniuse-lite/data/features/css-rebeccapurple.js","./features/css-reflections":"node_modules/caniuse-lite/data/features/css-reflections.js","./features/css-regions":"node_modules/caniuse-lite/data/features/css-regions.js","./features/css-repeating-gradients":"node_modules/caniuse-lite/data/features/css-repeating-gradients.js","./features/css-resize":"node_modules/caniuse-lite/data/features/css-resize.js","./features/css-revert-value":"node_modules/caniuse-lite/data/features/css-revert-value.js","./features/css-rrggbbaa":"node_modules/caniuse-lite/data/features/css-rrggbbaa.js","./features/css-scroll-behavior":"node_modules/caniuse-lite/data/features/css-scroll-behavior.js","./features/css-scrollbar":"node_modules/caniuse-lite/data/features/css-scrollbar.js","./features/css-sel2":"node_modules/caniuse-lite/data/features/css-sel2.js","./features/css-sel3":"node_modules/caniuse-lite/data/features/css-sel3.js","./features/css-selection":"node_modules/caniuse-lite/data/features/css-selection.js","./features/css-shapes":"node_modules/caniuse-lite/data/features/css-shapes.js","./features/css-snappoints":"node_modules/caniuse-lite/data/features/css-snappoints.js","./features/css-sticky":"node_modules/caniuse-lite/data/features/css-sticky.js","./features/css-subgrid":"node_modules/caniuse-lite/data/features/css-subgrid.js","./features/css-supports-api":"node_modules/caniuse-lite/data/features/css-supports-api.js","./features/css-table":"node_modules/caniuse-lite/data/features/css-table.js","./features/css-text-align-last":"node_modules/caniuse-lite/data/features/css-text-align-last.js","./features/css-text-indent":"node_modules/caniuse-lite/data/features/css-text-indent.js","./features/css-text-justify":"node_modules/caniuse-lite/data/features/css-text-justify.js","./features/css-text-orientation":"node_modules/caniuse-lite/data/features/css-text-orientation.js","./features/css-text-spacing":"node_modules/caniuse-lite/data/features/css-text-spacing.js","./features/css-textshadow":"node_modules/caniuse-lite/data/features/css-textshadow.js","./features/css-touch-action-2":"node_modules/caniuse-lite/data/features/css-touch-action-2.js","./features/css-touch-action":"node_modules/caniuse-lite/data/features/css-touch-action.js","./features/css-transitions":"node_modules/caniuse-lite/data/features/css-transitions.js","./features/css-unicode-bidi":"node_modules/caniuse-lite/data/features/css-unicode-bidi.js","./features/css-unset-value":"node_modules/caniuse-lite/data/features/css-unset-value.js","./features/css-variables":"node_modules/caniuse-lite/data/features/css-variables.js","./features/css-widows-orphans":"node_modules/caniuse-lite/data/features/css-widows-orphans.js","./features/css-writing-mode":"node_modules/caniuse-lite/data/features/css-writing-mode.js","./features/css-zoom":"node_modules/caniuse-lite/data/features/css-zoom.js","./features/css3-attr":"node_modules/caniuse-lite/data/features/css3-attr.js","./features/css3-boxsizing":"node_modules/caniuse-lite/data/features/css3-boxsizing.js","./features/css3-colors":"node_modules/caniuse-lite/data/features/css3-colors.js","./features/css3-cursors-grab":"node_modules/caniuse-lite/data/features/css3-cursors-grab.js","./features/css3-cursors-newer":"node_modules/caniuse-lite/data/features/css3-cursors-newer.js","./features/css3-cursors":"node_modules/caniuse-lite/data/features/css3-cursors.js","./features/css3-tabsize":"node_modules/caniuse-lite/data/features/css3-tabsize.js","./features/currentcolor":"node_modules/caniuse-lite/data/features/currentcolor.js","./features/custom-elements":"node_modules/caniuse-lite/data/features/custom-elements.js","./features/custom-elementsv1":"node_modules/caniuse-lite/data/features/custom-elementsv1.js","./features/customevent":"node_modules/caniuse-lite/data/features/customevent.js","./features/datalist":"node_modules/caniuse-lite/data/features/datalist.js","./features/dataset":"node_modules/caniuse-lite/data/features/dataset.js","./features/datauri":"node_modules/caniuse-lite/data/features/datauri.js","./features/date-tolocaledatestring":"node_modules/caniuse-lite/data/features/date-tolocaledatestring.js","./features/details":"node_modules/caniuse-lite/data/features/details.js","./features/deviceorientation":"node_modules/caniuse-lite/data/features/deviceorientation.js","./features/devicepixelratio":"node_modules/caniuse-lite/data/features/devicepixelratio.js","./features/dialog":"node_modules/caniuse-lite/data/features/dialog.js","./features/dispatchevent":"node_modules/caniuse-lite/data/features/dispatchevent.js","./features/dnssec":"node_modules/caniuse-lite/data/features/dnssec.js","./features/do-not-track":"node_modules/caniuse-lite/data/features/do-not-track.js","./features/document-currentscript":"node_modules/caniuse-lite/data/features/document-currentscript.js","./features/document-evaluate-xpath":"node_modules/caniuse-lite/data/features/document-evaluate-xpath.js","./features/document-execcommand":"node_modules/caniuse-lite/data/features/document-execcommand.js","./features/document-scrollingelement":"node_modules/caniuse-lite/data/features/document-scrollingelement.js","./features/documenthead":"node_modules/caniuse-lite/data/features/documenthead.js","./features/dom-manip-convenience":"node_modules/caniuse-lite/data/features/dom-manip-convenience.js","./features/dom-range":"node_modules/caniuse-lite/data/features/dom-range.js","./features/domcontentloaded":"node_modules/caniuse-lite/data/features/domcontentloaded.js","./features/domfocusin-domfocusout-events":"node_modules/caniuse-lite/data/features/domfocusin-domfocusout-events.js","./features/dommatrix":"node_modules/caniuse-lite/data/features/dommatrix.js","./features/download":"node_modules/caniuse-lite/data/features/download.js","./features/dragndrop":"node_modules/caniuse-lite/data/features/dragndrop.js","./features/element-closest":"node_modules/caniuse-lite/data/features/element-closest.js","./features/element-from-point":"node_modules/caniuse-lite/data/features/element-from-point.js","./features/element-scroll-methods":"node_modules/caniuse-lite/data/features/element-scroll-methods.js","./features/eme":"node_modules/caniuse-lite/data/features/eme.js","./features/eot":"node_modules/caniuse-lite/data/features/eot.js","./features/es5":"node_modules/caniuse-lite/data/features/es5.js","./features/es6-class":"node_modules/caniuse-lite/data/features/es6-class.js","./features/es6-generators":"node_modules/caniuse-lite/data/features/es6-generators.js","./features/es6-module-dynamic-import":"node_modules/caniuse-lite/data/features/es6-module-dynamic-import.js","./features/es6-module":"node_modules/caniuse-lite/data/features/es6-module.js","./features/es6-number":"node_modules/caniuse-lite/data/features/es6-number.js","./features/es6-string-includes":"node_modules/caniuse-lite/data/features/es6-string-includes.js","./features/es6":"node_modules/caniuse-lite/data/features/es6.js","./features/eventsource":"node_modules/caniuse-lite/data/features/eventsource.js","./features/extended-system-fonts":"node_modules/caniuse-lite/data/features/extended-system-fonts.js","./features/feature-policy":"node_modules/caniuse-lite/data/features/feature-policy.js","./features/fetch":"node_modules/caniuse-lite/data/features/fetch.js","./features/fieldset-disabled":"node_modules/caniuse-lite/data/features/fieldset-disabled.js","./features/fileapi":"node_modules/caniuse-lite/data/features/fileapi.js","./features/filereader":"node_modules/caniuse-lite/data/features/filereader.js","./features/filereadersync":"node_modules/caniuse-lite/data/features/filereadersync.js","./features/filesystem":"node_modules/caniuse-lite/data/features/filesystem.js","./features/flac":"node_modules/caniuse-lite/data/features/flac.js","./features/flexbox-gap":"node_modules/caniuse-lite/data/features/flexbox-gap.js","./features/flexbox":"node_modules/caniuse-lite/data/features/flexbox.js","./features/flow-root":"node_modules/caniuse-lite/data/features/flow-root.js","./features/focusin-focusout-events":"node_modules/caniuse-lite/data/features/focusin-focusout-events.js","./features/focusoptions-preventscroll":"node_modules/caniuse-lite/data/features/focusoptions-preventscroll.js","./features/font-family-system-ui":"node_modules/caniuse-lite/data/features/font-family-system-ui.js","./features/font-feature":"node_modules/caniuse-lite/data/features/font-feature.js","./features/font-kerning":"node_modules/caniuse-lite/data/features/font-kerning.js","./features/font-loading":"node_modules/caniuse-lite/data/features/font-loading.js","./features/font-size-adjust":"node_modules/caniuse-lite/data/features/font-size-adjust.js","./features/font-smooth":"node_modules/caniuse-lite/data/features/font-smooth.js","./features/font-unicode-range":"node_modules/caniuse-lite/data/features/font-unicode-range.js","./features/font-variant-alternates":"node_modules/caniuse-lite/data/features/font-variant-alternates.js","./features/font-variant-east-asian":"node_modules/caniuse-lite/data/features/font-variant-east-asian.js","./features/font-variant-numeric":"node_modules/caniuse-lite/data/features/font-variant-numeric.js","./features/fontface":"node_modules/caniuse-lite/data/features/fontface.js","./features/form-attribute":"node_modules/caniuse-lite/data/features/form-attribute.js","./features/form-submit-attributes":"node_modules/caniuse-lite/data/features/form-submit-attributes.js","./features/form-validation":"node_modules/caniuse-lite/data/features/form-validation.js","./features/forms":"node_modules/caniuse-lite/data/features/forms.js","./features/fullscreen":"node_modules/caniuse-lite/data/features/fullscreen.js","./features/gamepad":"node_modules/caniuse-lite/data/features/gamepad.js","./features/geolocation":"node_modules/caniuse-lite/data/features/geolocation.js","./features/getboundingclientrect":"node_modules/caniuse-lite/data/features/getboundingclientrect.js","./features/getcomputedstyle":"node_modules/caniuse-lite/data/features/getcomputedstyle.js","./features/getelementsbyclassname":"node_modules/caniuse-lite/data/features/getelementsbyclassname.js","./features/getrandomvalues":"node_modules/caniuse-lite/data/features/getrandomvalues.js","./features/gyroscope":"node_modules/caniuse-lite/data/features/gyroscope.js","./features/hardwareconcurrency":"node_modules/caniuse-lite/data/features/hardwareconcurrency.js","./features/hashchange":"node_modules/caniuse-lite/data/features/hashchange.js","./features/heif":"node_modules/caniuse-lite/data/features/heif.js","./features/hevc":"node_modules/caniuse-lite/data/features/hevc.js","./features/hidden":"node_modules/caniuse-lite/data/features/hidden.js","./features/high-resolution-time":"node_modules/caniuse-lite/data/features/high-resolution-time.js","./features/history":"node_modules/caniuse-lite/data/features/history.js","./features/html-media-capture":"node_modules/caniuse-lite/data/features/html-media-capture.js","./features/html5semantic":"node_modules/caniuse-lite/data/features/html5semantic.js","./features/http-live-streaming":"node_modules/caniuse-lite/data/features/http-live-streaming.js","./features/http2":"node_modules/caniuse-lite/data/features/http2.js","./features/http3":"node_modules/caniuse-lite/data/features/http3.js","./features/iframe-sandbox":"node_modules/caniuse-lite/data/features/iframe-sandbox.js","./features/iframe-seamless":"node_modules/caniuse-lite/data/features/iframe-seamless.js","./features/iframe-srcdoc":"node_modules/caniuse-lite/data/features/iframe-srcdoc.js","./features/imagecapture":"node_modules/caniuse-lite/data/features/imagecapture.js","./features/ime":"node_modules/caniuse-lite/data/features/ime.js","./features/img-naturalwidth-naturalheight":"node_modules/caniuse-lite/data/features/img-naturalwidth-naturalheight.js","./features/imports":"node_modules/caniuse-lite/data/features/imports.js","./features/indeterminate-checkbox":"node_modules/caniuse-lite/data/features/indeterminate-checkbox.js","./features/indexeddb":"node_modules/caniuse-lite/data/features/indexeddb.js","./features/indexeddb2":"node_modules/caniuse-lite/data/features/indexeddb2.js","./features/inline-block":"node_modules/caniuse-lite/data/features/inline-block.js","./features/innertext":"node_modules/caniuse-lite/data/features/innertext.js","./features/input-autocomplete-onoff":"node_modules/caniuse-lite/data/features/input-autocomplete-onoff.js","./features/input-color":"node_modules/caniuse-lite/data/features/input-color.js","./features/input-datetime":"node_modules/caniuse-lite/data/features/input-datetime.js","./features/input-email-tel-url":"node_modules/caniuse-lite/data/features/input-email-tel-url.js","./features/input-event":"node_modules/caniuse-lite/data/features/input-event.js","./features/input-file-accept":"node_modules/caniuse-lite/data/features/input-file-accept.js","./features/input-file-directory":"node_modules/caniuse-lite/data/features/input-file-directory.js","./features/input-file-multiple":"node_modules/caniuse-lite/data/features/input-file-multiple.js","./features/input-inputmode":"node_modules/caniuse-lite/data/features/input-inputmode.js","./features/input-minlength":"node_modules/caniuse-lite/data/features/input-minlength.js","./features/input-number":"node_modules/caniuse-lite/data/features/input-number.js","./features/input-pattern":"node_modules/caniuse-lite/data/features/input-pattern.js","./features/input-placeholder":"node_modules/caniuse-lite/data/features/input-placeholder.js","./features/input-range":"node_modules/caniuse-lite/data/features/input-range.js","./features/input-search":"node_modules/caniuse-lite/data/features/input-search.js","./features/input-selection":"node_modules/caniuse-lite/data/features/input-selection.js","./features/insert-adjacent":"node_modules/caniuse-lite/data/features/insert-adjacent.js","./features/insertadjacenthtml":"node_modules/caniuse-lite/data/features/insertadjacenthtml.js","./features/internationalization":"node_modules/caniuse-lite/data/features/internationalization.js","./features/intersectionobserver-v2":"node_modules/caniuse-lite/data/features/intersectionobserver-v2.js","./features/intersectionobserver":"node_modules/caniuse-lite/data/features/intersectionobserver.js","./features/intl-pluralrules":"node_modules/caniuse-lite/data/features/intl-pluralrules.js","./features/intrinsic-width":"node_modules/caniuse-lite/data/features/intrinsic-width.js","./features/jpeg2000":"node_modules/caniuse-lite/data/features/jpeg2000.js","./features/jpegxr":"node_modules/caniuse-lite/data/features/jpegxr.js","./features/js-regexp-lookbehind":"node_modules/caniuse-lite/data/features/js-regexp-lookbehind.js","./features/json":"node_modules/caniuse-lite/data/features/json.js","./features/justify-content-space-evenly":"node_modules/caniuse-lite/data/features/justify-content-space-evenly.js","./features/kerning-pairs-ligatures":"node_modules/caniuse-lite/data/features/kerning-pairs-ligatures.js","./features/keyboardevent-charcode":"node_modules/caniuse-lite/data/features/keyboardevent-charcode.js","./features/keyboardevent-code":"node_modules/caniuse-lite/data/features/keyboardevent-code.js","./features/keyboardevent-getmodifierstate":"node_modules/caniuse-lite/data/features/keyboardevent-getmodifierstate.js","./features/keyboardevent-key":"node_modules/caniuse-lite/data/features/keyboardevent-key.js","./features/keyboardevent-location":"node_modules/caniuse-lite/data/features/keyboardevent-location.js","./features/keyboardevent-which":"node_modules/caniuse-lite/data/features/keyboardevent-which.js","./features/lazyload":"node_modules/caniuse-lite/data/features/lazyload.js","./features/let":"node_modules/caniuse-lite/data/features/let.js","./features/link-icon-png":"node_modules/caniuse-lite/data/features/link-icon-png.js","./features/link-icon-svg":"node_modules/caniuse-lite/data/features/link-icon-svg.js","./features/link-rel-dns-prefetch":"node_modules/caniuse-lite/data/features/link-rel-dns-prefetch.js","./features/link-rel-modulepreload":"node_modules/caniuse-lite/data/features/link-rel-modulepreload.js","./features/link-rel-preconnect":"node_modules/caniuse-lite/data/features/link-rel-preconnect.js","./features/link-rel-prefetch":"node_modules/caniuse-lite/data/features/link-rel-prefetch.js","./features/link-rel-preload":"node_modules/caniuse-lite/data/features/link-rel-preload.js","./features/link-rel-prerender":"node_modules/caniuse-lite/data/features/link-rel-prerender.js","./features/loading-lazy-attr":"node_modules/caniuse-lite/data/features/loading-lazy-attr.js","./features/localecompare":"node_modules/caniuse-lite/data/features/localecompare.js","./features/magnetometer":"node_modules/caniuse-lite/data/features/magnetometer.js","./features/matchesselector":"node_modules/caniuse-lite/data/features/matchesselector.js","./features/matchmedia":"node_modules/caniuse-lite/data/features/matchmedia.js","./features/mathml":"node_modules/caniuse-lite/data/features/mathml.js","./features/maxlength":"node_modules/caniuse-lite/data/features/maxlength.js","./features/media-attribute":"node_modules/caniuse-lite/data/features/media-attribute.js","./features/media-fragments":"node_modules/caniuse-lite/data/features/media-fragments.js","./features/media-session-api":"node_modules/caniuse-lite/data/features/media-session-api.js","./features/mediacapture-fromelement":"node_modules/caniuse-lite/data/features/mediacapture-fromelement.js","./features/mediarecorder":"node_modules/caniuse-lite/data/features/mediarecorder.js","./features/mediasource":"node_modules/caniuse-lite/data/features/mediasource.js","./features/menu":"node_modules/caniuse-lite/data/features/menu.js","./features/meta-theme-color":"node_modules/caniuse-lite/data/features/meta-theme-color.js","./features/meter":"node_modules/caniuse-lite/data/features/meter.js","./features/midi":"node_modules/caniuse-lite/data/features/midi.js","./features/minmaxwh":"node_modules/caniuse-lite/data/features/minmaxwh.js","./features/mp3":"node_modules/caniuse-lite/data/features/mp3.js","./features/mpeg-dash":"node_modules/caniuse-lite/data/features/mpeg-dash.js","./features/mpeg4":"node_modules/caniuse-lite/data/features/mpeg4.js","./features/multibackgrounds":"node_modules/caniuse-lite/data/features/multibackgrounds.js","./features/multicolumn":"node_modules/caniuse-lite/data/features/multicolumn.js","./features/mutation-events":"node_modules/caniuse-lite/data/features/mutation-events.js","./features/mutationobserver":"node_modules/caniuse-lite/data/features/mutationobserver.js","./features/namevalue-storage":"node_modules/caniuse-lite/data/features/namevalue-storage.js","./features/native-filesystem-api":"node_modules/caniuse-lite/data/features/native-filesystem-api.js","./features/nav-timing":"node_modules/caniuse-lite/data/features/nav-timing.js","./features/navigator-language":"node_modules/caniuse-lite/data/features/navigator-language.js","./features/netinfo":"node_modules/caniuse-lite/data/features/netinfo.js","./features/node-contains":"node_modules/caniuse-lite/data/features/node-contains.js","./features/node-parentelement":"node_modules/caniuse-lite/data/features/node-parentelement.js","./features/notifications":"node_modules/caniuse-lite/data/features/notifications.js","./features/object-entries":"node_modules/caniuse-lite/data/features/object-entries.js","./features/object-fit":"node_modules/caniuse-lite/data/features/object-fit.js","./features/object-observe":"node_modules/caniuse-lite/data/features/object-observe.js","./features/object-values":"node_modules/caniuse-lite/data/features/object-values.js","./features/objectrtc":"node_modules/caniuse-lite/data/features/objectrtc.js","./features/offline-apps":"node_modules/caniuse-lite/data/features/offline-apps.js","./features/offscreencanvas":"node_modules/caniuse-lite/data/features/offscreencanvas.js","./features/ogg-vorbis":"node_modules/caniuse-lite/data/features/ogg-vorbis.js","./features/ogv":"node_modules/caniuse-lite/data/features/ogv.js","./features/ol-reversed":"node_modules/caniuse-lite/data/features/ol-reversed.js","./features/once-event-listener":"node_modules/caniuse-lite/data/features/once-event-listener.js","./features/online-status":"node_modules/caniuse-lite/data/features/online-status.js","./features/opus":"node_modules/caniuse-lite/data/features/opus.js","./features/orientation-sensor":"node_modules/caniuse-lite/data/features/orientation-sensor.js","./features/outline":"node_modules/caniuse-lite/data/features/outline.js","./features/pad-start-end":"node_modules/caniuse-lite/data/features/pad-start-end.js","./features/page-transition-events":"node_modules/caniuse-lite/data/features/page-transition-events.js","./features/pagevisibility":"node_modules/caniuse-lite/data/features/pagevisibility.js","./features/passive-event-listener":"node_modules/caniuse-lite/data/features/passive-event-listener.js","./features/passwordrules":"node_modules/caniuse-lite/data/features/passwordrules.js","./features/path2d":"node_modules/caniuse-lite/data/features/path2d.js","./features/payment-request":"node_modules/caniuse-lite/data/features/payment-request.js","./features/permissions-api":"node_modules/caniuse-lite/data/features/permissions-api.js","./features/picture-in-picture":"node_modules/caniuse-lite/data/features/picture-in-picture.js","./features/picture":"node_modules/caniuse-lite/data/features/picture.js","./features/ping":"node_modules/caniuse-lite/data/features/ping.js","./features/png-alpha":"node_modules/caniuse-lite/data/features/png-alpha.js","./features/pointer-events":"node_modules/caniuse-lite/data/features/pointer-events.js","./features/pointer":"node_modules/caniuse-lite/data/features/pointer.js","./features/pointerlock":"node_modules/caniuse-lite/data/features/pointerlock.js","./features/prefers-color-scheme":"node_modules/caniuse-lite/data/features/prefers-color-scheme.js","./features/prefers-reduced-motion":"node_modules/caniuse-lite/data/features/prefers-reduced-motion.js","./features/private-class-fields":"node_modules/caniuse-lite/data/features/private-class-fields.js","./features/private-methods-and-accessors":"node_modules/caniuse-lite/data/features/private-methods-and-accessors.js","./features/progress":"node_modules/caniuse-lite/data/features/progress.js","./features/promise-finally":"node_modules/caniuse-lite/data/features/promise-finally.js","./features/promises":"node_modules/caniuse-lite/data/features/promises.js","./features/proximity":"node_modules/caniuse-lite/data/features/proximity.js","./features/proxy":"node_modules/caniuse-lite/data/features/proxy.js","./features/public-class-fields":"node_modules/caniuse-lite/data/features/public-class-fields.js","./features/publickeypinning":"node_modules/caniuse-lite/data/features/publickeypinning.js","./features/push-api":"node_modules/caniuse-lite/data/features/push-api.js","./features/queryselector":"node_modules/caniuse-lite/data/features/queryselector.js","./features/readonly-attr":"node_modules/caniuse-lite/data/features/readonly-attr.js","./features/referrer-policy":"node_modules/caniuse-lite/data/features/referrer-policy.js","./features/registerprotocolhandler":"node_modules/caniuse-lite/data/features/registerprotocolhandler.js","./features/rel-noopener":"node_modules/caniuse-lite/data/features/rel-noopener.js","./features/rel-noreferrer":"node_modules/caniuse-lite/data/features/rel-noreferrer.js","./features/rellist":"node_modules/caniuse-lite/data/features/rellist.js","./features/rem":"node_modules/caniuse-lite/data/features/rem.js","./features/replace-all":"node_modules/caniuse-lite/data/features/replace-all.js","./features/requestanimationframe":"node_modules/caniuse-lite/data/features/requestanimationframe.js","./features/requestidlecallback":"node_modules/caniuse-lite/data/features/requestidlecallback.js","./features/resizeobserver":"node_modules/caniuse-lite/data/features/resizeobserver.js","./features/resource-timing":"node_modules/caniuse-lite/data/features/resource-timing.js","./features/rest-parameters":"node_modules/caniuse-lite/data/features/rest-parameters.js","./features/rtcpeerconnection":"node_modules/caniuse-lite/data/features/rtcpeerconnection.js","./features/ruby":"node_modules/caniuse-lite/data/features/ruby.js","./features/run-in":"node_modules/caniuse-lite/data/features/run-in.js","./features/same-site-cookie-attribute":"node_modules/caniuse-lite/data/features/same-site-cookie-attribute.js","./features/screen-orientation":"node_modules/caniuse-lite/data/features/screen-orientation.js","./features/script-async":"node_modules/caniuse-lite/data/features/script-async.js","./features/script-defer":"node_modules/caniuse-lite/data/features/script-defer.js","./features/scrollintoview":"node_modules/caniuse-lite/data/features/scrollintoview.js","./features/scrollintoviewifneeded":"node_modules/caniuse-lite/data/features/scrollintoviewifneeded.js","./features/sdch":"node_modules/caniuse-lite/data/features/sdch.js","./features/selection-api":"node_modules/caniuse-lite/data/features/selection-api.js","./features/server-timing":"node_modules/caniuse-lite/data/features/server-timing.js","./features/serviceworkers":"node_modules/caniuse-lite/data/features/serviceworkers.js","./features/setimmediate":"node_modules/caniuse-lite/data/features/setimmediate.js","./features/sha-2":"node_modules/caniuse-lite/data/features/sha-2.js","./features/shadowdom":"node_modules/caniuse-lite/data/features/shadowdom.js","./features/shadowdomv1":"node_modules/caniuse-lite/data/features/shadowdomv1.js","./features/sharedarraybuffer":"node_modules/caniuse-lite/data/features/sharedarraybuffer.js","./features/sharedworkers":"node_modules/caniuse-lite/data/features/sharedworkers.js","./features/sni":"node_modules/caniuse-lite/data/features/sni.js","./features/spdy":"node_modules/caniuse-lite/data/features/spdy.js","./features/speech-recognition":"node_modules/caniuse-lite/data/features/speech-recognition.js","./features/speech-synthesis":"node_modules/caniuse-lite/data/features/speech-synthesis.js","./features/spellcheck-attribute":"node_modules/caniuse-lite/data/features/spellcheck-attribute.js","./features/sql-storage":"node_modules/caniuse-lite/data/features/sql-storage.js","./features/srcset":"node_modules/caniuse-lite/data/features/srcset.js","./features/stopimmediatepropagation":"node_modules/caniuse-lite/data/features/stopimmediatepropagation.js","./features/stream":"node_modules/caniuse-lite/data/features/stream.js","./features/streams":"node_modules/caniuse-lite/data/features/streams.js","./features/stricttransportsecurity":"node_modules/caniuse-lite/data/features/stricttransportsecurity.js","./features/style-scoped":"node_modules/caniuse-lite/data/features/style-scoped.js","./features/subresource-integrity":"node_modules/caniuse-lite/data/features/subresource-integrity.js","./features/svg-css":"node_modules/caniuse-lite/data/features/svg-css.js","./features/svg-filters":"node_modules/caniuse-lite/data/features/svg-filters.js","./features/svg-fonts":"node_modules/caniuse-lite/data/features/svg-fonts.js","./features/svg-fragment":"node_modules/caniuse-lite/data/features/svg-fragment.js","./features/svg-html":"node_modules/caniuse-lite/data/features/svg-html.js","./features/svg-html5":"node_modules/caniuse-lite/data/features/svg-html5.js","./features/svg-img":"node_modules/caniuse-lite/data/features/svg-img.js","./features/svg-smil":"node_modules/caniuse-lite/data/features/svg-smil.js","./features/svg":"node_modules/caniuse-lite/data/features/svg.js","./features/sxg":"node_modules/caniuse-lite/data/features/sxg.js","./features/symbols":"node_modules/caniuse-lite/data/features/symbols.js","./features/tabindex-attr":"node_modules/caniuse-lite/data/features/tabindex-attr.js","./features/template-literals":"node_modules/caniuse-lite/data/features/template-literals.js","./features/template":"node_modules/caniuse-lite/data/features/template.js","./features/testfeat":"node_modules/caniuse-lite/data/features/testfeat.js","./features/text-decoration":"node_modules/caniuse-lite/data/features/text-decoration.js","./features/text-emphasis":"node_modules/caniuse-lite/data/features/text-emphasis.js","./features/text-overflow":"node_modules/caniuse-lite/data/features/text-overflow.js","./features/text-size-adjust":"node_modules/caniuse-lite/data/features/text-size-adjust.js","./features/text-stroke":"node_modules/caniuse-lite/data/features/text-stroke.js","./features/text-underline-offset":"node_modules/caniuse-lite/data/features/text-underline-offset.js","./features/textcontent":"node_modules/caniuse-lite/data/features/textcontent.js","./features/textencoder":"node_modules/caniuse-lite/data/features/textencoder.js","./features/tls1-1":"node_modules/caniuse-lite/data/features/tls1-1.js","./features/tls1-2":"node_modules/caniuse-lite/data/features/tls1-2.js","./features/tls1-3":"node_modules/caniuse-lite/data/features/tls1-3.js","./features/token-binding":"node_modules/caniuse-lite/data/features/token-binding.js","./features/touch":"node_modules/caniuse-lite/data/features/touch.js","./features/transforms2d":"node_modules/caniuse-lite/data/features/transforms2d.js","./features/transforms3d":"node_modules/caniuse-lite/data/features/transforms3d.js","./features/trusted-types":"node_modules/caniuse-lite/data/features/trusted-types.js","./features/ttf":"node_modules/caniuse-lite/data/features/ttf.js","./features/typedarrays":"node_modules/caniuse-lite/data/features/typedarrays.js","./features/u2f":"node_modules/caniuse-lite/data/features/u2f.js","./features/unhandledrejection":"node_modules/caniuse-lite/data/features/unhandledrejection.js","./features/upgradeinsecurerequests":"node_modules/caniuse-lite/data/features/upgradeinsecurerequests.js","./features/url-scroll-to-text-fragment":"node_modules/caniuse-lite/data/features/url-scroll-to-text-fragment.js","./features/url":"node_modules/caniuse-lite/data/features/url.js","./features/urlsearchparams":"node_modules/caniuse-lite/data/features/urlsearchparams.js","./features/use-strict":"node_modules/caniuse-lite/data/features/use-strict.js","./features/user-select-none":"node_modules/caniuse-lite/data/features/user-select-none.js","./features/user-timing":"node_modules/caniuse-lite/data/features/user-timing.js","./features/variable-fonts":"node_modules/caniuse-lite/data/features/variable-fonts.js","./features/vibration":"node_modules/caniuse-lite/data/features/vibration.js","./features/video":"node_modules/caniuse-lite/data/features/video.js","./features/videotracks":"node_modules/caniuse-lite/data/features/videotracks.js","./features/viewport-units":"node_modules/caniuse-lite/data/features/viewport-units.js","./features/wai-aria":"node_modules/caniuse-lite/data/features/wai-aria.js","./features/wasm":"node_modules/caniuse-lite/data/features/wasm.js","./features/wav":"node_modules/caniuse-lite/data/features/wav.js","./features/wbr-element":"node_modules/caniuse-lite/data/features/wbr-element.js","./features/web-animation":"node_modules/caniuse-lite/data/features/web-animation.js","./features/web-app-manifest":"node_modules/caniuse-lite/data/features/web-app-manifest.js","./features/web-bluetooth":"node_modules/caniuse-lite/data/features/web-bluetooth.js","./features/web-share":"node_modules/caniuse-lite/data/features/web-share.js","./features/webauthn":"node_modules/caniuse-lite/data/features/webauthn.js","./features/webgl":"node_modules/caniuse-lite/data/features/webgl.js","./features/webgl2":"node_modules/caniuse-lite/data/features/webgl2.js","./features/webgpu":"node_modules/caniuse-lite/data/features/webgpu.js","./features/webhid":"node_modules/caniuse-lite/data/features/webhid.js","./features/webm":"node_modules/caniuse-lite/data/features/webm.js","./features/webp":"node_modules/caniuse-lite/data/features/webp.js","./features/websockets":"node_modules/caniuse-lite/data/features/websockets.js","./features/webusb":"node_modules/caniuse-lite/data/features/webusb.js","./features/webvr":"node_modules/caniuse-lite/data/features/webvr.js","./features/webvtt":"node_modules/caniuse-lite/data/features/webvtt.js","./features/webworkers":"node_modules/caniuse-lite/data/features/webworkers.js","./features/webxr":"node_modules/caniuse-lite/data/features/webxr.js","./features/will-change":"node_modules/caniuse-lite/data/features/will-change.js","./features/woff":"node_modules/caniuse-lite/data/features/woff.js","./features/woff2":"node_modules/caniuse-lite/data/features/woff2.js","./features/word-break":"node_modules/caniuse-lite/data/features/word-break.js","./features/wordwrap":"node_modules/caniuse-lite/data/features/wordwrap.js","./features/x-doc-messaging":"node_modules/caniuse-lite/data/features/x-doc-messaging.js","./features/x-frame-options":"node_modules/caniuse-lite/data/features/x-frame-options.js","./features/xhr2":"node_modules/caniuse-lite/data/features/xhr2.js","./features/xhtml":"node_modules/caniuse-lite/data/features/xhtml.js","./features/xhtmlsmil":"node_modules/caniuse-lite/data/features/xhtmlsmil.js","./features/xml-serializer":"node_modules/caniuse-lite/data/features/xml-serializer.js"}],"node_modules/caniuse-lite/dist/unpacker/features.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * Load this dynamically so that it
 * doesn't appear in the rollup bundle.
 */

var features = exports.features = require('../../data/features');
},{"../../data/features":"node_modules/caniuse-lite/data/features.js"}],"node_modules/caniuse-lite/dist/unpacker/region.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = unpackRegion;

var _browsers = require('./browsers');

function unpackRegion(packed) {
    return Object.keys(packed).reduce(function (list, browser) {
        var data = packed[browser];
        list[_browsers.browsers[browser]] = Object.keys(data).reduce(function (memo, key) {
            var stats = data[key];
            if (key === '_') {
                stats.split(' ').forEach(function (version) {
                    return memo[version] = null;
                });
            } else {
                memo[key] = stats;
            }
            return memo;
        }, {});
        return list;
    }, {});
}
},{"./browsers":"node_modules/caniuse-lite/dist/unpacker/browsers.js"}],"node_modules/caniuse-lite/dist/unpacker/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _agents = require('./agents');

Object.defineProperty(exports, 'agents', {
  enumerable: true,
  get: function get() {
    return _agents.agents;
  }
});

var _feature = require('./feature');

Object.defineProperty(exports, 'feature', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_feature).default;
  }
});

var _features = require('./features');

Object.defineProperty(exports, 'features', {
  enumerable: true,
  get: function get() {
    return _features.features;
  }
});

var _region = require('./region');

Object.defineProperty(exports, 'region', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_region).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./agents":"node_modules/caniuse-lite/dist/unpacker/agents.js","./feature":"node_modules/caniuse-lite/dist/unpacker/feature.js","./features":"node_modules/caniuse-lite/dist/unpacker/features.js","./region":"node_modules/caniuse-lite/dist/unpacker/region.js"}],"node_modules/lodash.uniq/index.js":[function(require,module,exports) {
var global = arguments[3];
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    Set = getNative(root, 'Set'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length)
    ? baseUniq(array)
    : [];
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = uniq;

},{}],"node_modules/caniuse-api/dist/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.contains = contains;
exports.parseCaniuseData = parseCaniuseData;
exports.cleanBrowsersList = cleanBrowsersList;

var _lodash = require("lodash.uniq");

var _lodash2 = _interopRequireDefault(_lodash);

var _browserslist = require("browserslist");

var _browserslist2 = _interopRequireDefault(_browserslist);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function contains(str, substr) {
  return !!~str.indexOf(substr);
}

function parseCaniuseData(feature, browsers) {
  var support = {};
  var letters;
  var letter;

  browsers.forEach(function (browser) {
    support[browser] = {};
    for (var info in feature.stats[browser]) {
      letters = feature.stats[browser][info].replace(/#\d+/, "").trim().split(" ");
      info = parseFloat(info.split("-")[0]); //if info is a range, take the left
      if (isNaN(info)) continue;
      for (var i = 0; i < letters.length; i++) {
        letter = letters[i];
        if (letter === "d") {
          // skip this letter, we don't support it yet
          continue;
        } else if (letter === "y") {
          // min support asked, need to find the min value
          if (typeof support[browser][letter] === "undefined" || info < support[browser][letter]) {
            support[browser][letter] = info;
          }
        } else {
          // any other support, need to find the max value
          if (typeof support[browser][letter] === "undefined" || info > support[browser][letter]) {
            support[browser][letter] = info;
          }
        }
      }
    }
  });

  return support;
}

function cleanBrowsersList(browserList) {
  return (0, _lodash2.default)((0, _browserslist2.default)(browserList).map(function (browser) {
    return browser.split(" ")[0];
  }));
}
},{"lodash.uniq":"node_modules/lodash.uniq/index.js","browserslist":"node_modules/browserslist/index.js"}],"node_modules/caniuse-api/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBrowserScope = exports.setBrowserScope = exports.getLatestStableBrowsers = exports.find = exports.isSupported = exports.getSupport = exports.features = undefined;

var _lodash = require("lodash.memoize");

var _lodash2 = _interopRequireDefault(_lodash);

var _browserslist = require("browserslist");

var _browserslist2 = _interopRequireDefault(_browserslist);

var _caniuseLite = require("caniuse-lite");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var featuresList = Object.keys(_caniuseLite.features);

var browsers = void 0;
function setBrowserScope(browserList) {
  browsers = (0, _utils.cleanBrowsersList)(browserList);
}

function getBrowserScope() {
  return browsers;
}

var parse = (0, _lodash2.default)(_utils.parseCaniuseData, function (feat, browsers) {
  return feat.title + browsers;
});

function getSupport(query) {
  var feature = void 0;
  try {
    feature = (0, _caniuseLite.feature)(_caniuseLite.features[query]);
  } catch (e) {
    var res = find(query);
    if (res.length === 1) return getSupport(res[0]);
    throw new ReferenceError("Please provide a proper feature name. Cannot find " + query);
  }
  return parse(feature, browsers);
}

function isSupported(feature, browsers) {
  var data = void 0;
  try {
    data = (0, _caniuseLite.feature)(_caniuseLite.features[feature]);
  } catch (e) {
    var res = find(feature);
    if (res.length === 1) {
      data = _caniuseLite.features[res[0]];
    } else {
      throw new ReferenceError("Please provide a proper feature name. Cannot find " + feature);
    }
  }

  return (0, _browserslist2.default)(browsers, { ignoreUnknownVersions: true }).map(function (browser) {
    return browser.split(" ");
  }).every(function (browser) {
    return data.stats[browser[0]] && data.stats[browser[0]][browser[1]] === "y";
  });
}

function find(query) {
  if (typeof query !== "string") {
    throw new TypeError("The `query` parameter should be a string.");
  }

  if (~featuresList.indexOf(query)) {
    // exact match
    return query;
  }

  return featuresList.filter(function (file) {
    return (0, _utils.contains)(file, query);
  });
}

function getLatestStableBrowsers() {
  return (0, _browserslist2.default)("last 1 version");
}

setBrowserScope();

exports.features = featuresList;
exports.getSupport = getSupport;
exports.isSupported = isSupported;
exports.find = find;
exports.getLatestStableBrowsers = getLatestStableBrowsers;
exports.setBrowserScope = setBrowserScope;
exports.getBrowserScope = getBrowserScope;
},{"lodash.memoize":"node_modules/lodash.memoize/index.js","browserslist":"node_modules/browserslist/index.js","caniuse-lite":"node_modules/caniuse-lite/dist/unpacker/index.js","./utils":"node_modules/caniuse-api/dist/utils.js"}],"node_modules/postcss-reduce-initial/data/fromInitial.json":[function(require,module,exports) {
module.exports = {
  "align-content": "normal",
  "align-items": "normal",
  "align-self": "auto",
  "animation-delay": "0s",
  "animation-direction": "normal",
  "animation-duration": "0s",
  "animation-fill-mode": "none",
  "animation-iteration-count": "1",
  "animation-name": "none",
  "animation-timing-function": "ease",
  "appearance": "auto",
  "azimuth": "center",
  "backdrop-filter": "none",
  "background-attachment": "scroll",
  "background-blend-mode": "normal",
  "background-image": "none",
  "background-position": "0% 0%",
  "background-position-x": "left",
  "background-position-y": "top",
  "background-repeat": "repeat",
  "block-overflow": "clip",
  "block-size": "auto",
  "border-block-style": "none",
  "border-block-width": "medium",
  "border-block-end-style": "none",
  "border-block-end-width": "medium",
  "border-block-start-style": "none",
  "border-block-start-width": "medium",
  "border-bottom-left-radius": "0",
  "border-bottom-right-radius": "0",
  "border-bottom-style": "none",
  "border-bottom-width": "medium",
  "border-end-end-radius": "0",
  "border-end-start-radius": "0",
  "border-image-outset": "0",
  "border-image-slice": "100%",
  "border-image-source": "none",
  "border-image-width": "1",
  "border-inline-style": "none",
  "border-inline-width": "medium",
  "border-inline-end-style": "none",
  "border-inline-end-width": "medium",
  "border-inline-start-style": "none",
  "border-inline-start-width": "medium",
  "border-left-style": "none",
  "border-left-width": "medium",
  "border-right-style": "none",
  "border-right-width": "medium",
  "border-spacing": "0",
  "border-start-end-radius": "0",
  "border-start-start-radius": "0",
  "border-top-left-radius": "0",
  "border-top-right-radius": "0",
  "border-top-style": "none",
  "border-top-width": "medium",
  "bottom": "auto",
  "box-decoration-break": "slice",
  "box-shadow": "none",
  "break-after": "auto",
  "break-before": "auto",
  "break-inside": "auto",
  "caption-side": "top",
  "caret-color": "auto",
  "clear": "none",
  "clip": "auto",
  "clip-path": "none",
  "column-count": "auto",
  "column-gap": "normal",
  "column-rule-style": "none",
  "column-rule-width": "medium",
  "column-span": "none",
  "column-width": "auto",
  "contain": "none",
  "content": "normal",
  "counter-increment": "none",
  "counter-reset": "none",
  "cursor": "auto",
  "direction": "ltr",
  "empty-cells": "show",
  "filter": "none",
  "flex-basis": "auto",
  "flex-direction": "row",
  "flex-grow": "0",
  "flex-shrink": "1",
  "flex-wrap": "nowrap",
  "float": "none",
  "font-feature-settings": "normal",
  "font-kerning": "auto",
  "font-language-override": "normal",
  "font-optical-sizing": "auto",
  "font-variation-settings": "normal",
  "font-size": "medium",
  "font-size-adjust": "none",
  "font-stretch": "normal",
  "font-style": "normal",
  "font-variant": "normal",
  "font-variant-alternates": "normal",
  "font-variant-caps": "normal",
  "font-variant-east-asian": "normal",
  "font-variant-ligatures": "normal",
  "font-variant-numeric": "normal",
  "font-variant-position": "normal",
  "font-weight": "normal",
  "grid-auto-columns": "auto",
  "grid-auto-flow": "row",
  "grid-auto-rows": "auto",
  "grid-column-end": "auto",
  "grid-column-gap": "0",
  "grid-column-start": "auto",
  "grid-row-end": "auto",
  "grid-row-gap": "0",
  "grid-row-start": "auto",
  "grid-template-areas": "none",
  "grid-template-columns": "none",
  "grid-template-rows": "none",
  "hanging-punctuation": "none",
  "height": "auto",
  "hyphens": "manual",
  "image-orientation": "0deg",
  "image-rendering": "auto",
  "image-resolution": "1dppx",
  "ime-mode": "auto",
  "initial-letter": "normal",
  "initial-letter-align": "auto",
  "inline-size": "auto",
  "inset": "auto",
  "inset-block": "auto",
  "inset-block-end": "auto",
  "inset-block-start": "auto",
  "inset-inline": "auto",
  "inset-inline-end": "auto",
  "inset-inline-start": "auto",
  "isolation": "auto",
  "justify-content": "normal",
  "justify-items": "legacy",
  "justify-self": "auto",
  "left": "auto",
  "letter-spacing": "normal",
  "line-break": "auto",
  "line-clamp": "none",
  "line-height": "normal",
  "list-style-image": "none",
  "list-style-type": "disc",
  "margin-block": "0",
  "margin-block-end": "0",
  "margin-block-start": "0",
  "margin-bottom": "0",
  "margin-inline": "0",
  "margin-inline-end": "0",
  "margin-inline-start": "0",
  "margin-left": "0",
  "margin-right": "0",
  "margin-top": "0",
  "mask-border-mode": "alpha",
  "mask-border-outset": "0",
  "mask-border-slice": "0",
  "mask-border-source": "none",
  "mask-border-width": "auto",
  "mask-composite": "add",
  "mask-image": "none",
  "mask-position": "center",
  "mask-size": "auto",
  "max-block-size": "0",
  "max-height": "none",
  "max-inline-size": "0",
  "max-lines": "none",
  "max-width": "none",
  "min-block-size": "0",
  "min-height": "0",
  "min-inline-size": "0",
  "min-width": "0",
  "mix-blend-mode": "normal",
  "object-fit": "fill",
  "offset-anchor": "auto",
  "offset-distance": "0",
  "offset-path": "none",
  "offset-position": "auto",
  "offset-rotate": "auto",
  "opacity": "1.0",
  "order": "0",
  "orphans": "2",
  "outline-offset": "0",
  "outline-style": "none",
  "outline-width": "medium",
  "overflow-anchor": "auto",
  "overflow-block": "auto",
  "overflow-inline": "auto",
  "overflow-wrap": "normal",
  "padding-block": "0",
  "padding-block-end": "0",
  "padding-block-start": "0",
  "padding-bottom": "0",
  "padding-inline": "0",
  "padding-inline-end": "0",
  "padding-inline-start": "0",
  "padding-left": "0",
  "padding-right": "0",
  "padding-top": "0",
  "page-break-after": "auto",
  "page-break-before": "auto",
  "page-break-inside": "auto",
  "paint-order": "normal",
  "perspective": "none",
  "place-content": "normal",
  "pointer-events": "auto",
  "position": "static",
  "resize": "none",
  "right": "auto",
  "rotate": "none",
  "row-gap": "normal",
  "ruby-position": "over",
  "scale": "none",
  "scrollbar-color": "auto",
  "scrollbar-width": "auto",
  "scroll-behavior": "auto",
  "scroll-margin": "0",
  "scroll-margin-block": "0",
  "scroll-margin-block-start": "0",
  "scroll-margin-block-end": "0",
  "scroll-margin-bottom": "0",
  "scroll-margin-inline": "0",
  "scroll-margin-inline-start": "0",
  "scroll-margin-inline-end": "0",
  "scroll-margin-left": "0",
  "scroll-margin-right": "0",
  "scroll-margin-top": "0",
  "scroll-padding": "auto",
  "scroll-padding-block": "auto",
  "scroll-padding-block-start": "auto",
  "scroll-padding-block-end": "auto",
  "scroll-padding-bottom": "auto",
  "scroll-padding-inline": "auto",
  "scroll-padding-inline-start": "auto",
  "scroll-padding-inline-end": "auto",
  "scroll-padding-left": "auto",
  "scroll-padding-right": "auto",
  "scroll-padding-top": "auto",
  "scroll-snap-align": "none",
  "scroll-snap-coordinate": "none",
  "scroll-snap-points-x": "none",
  "scroll-snap-points-y": "none",
  "scroll-snap-stop": "normal",
  "scroll-snap-type": "none",
  "shape-image-threshold": "0.0",
  "shape-margin": "0",
  "shape-outside": "none",
  "tab-size": "8",
  "table-layout": "auto",
  "text-align-last": "auto",
  "text-combine-upright": "none",
  "text-decoration-line": "none",
  "text-decoration-skip-ink": "auto",
  "text-decoration-style": "solid",
  "text-emphasis-style": "none",
  "text-indent": "0",
  "text-justify": "auto",
  "text-orientation": "mixed",
  "text-overflow": "clip",
  "text-rendering": "auto",
  "text-shadow": "none",
  "text-transform": "none",
  "text-underline-position": "auto",
  "top": "auto",
  "touch-action": "auto",
  "transform": "none",
  "transform-style": "flat",
  "transition-delay": "0s",
  "transition-duration": "0s",
  "transition-property": "all",
  "transition-timing-function": "ease",
  "translate": "none",
  "unicode-bidi": "normal",
  "white-space": "normal",
  "widows": "2",
  "width": "auto",
  "will-change": "auto",
  "word-break": "normal",
  "word-spacing": "normal",
  "word-wrap": "normal",
  "z-index": "auto"
};
},{}],"node_modules/postcss-reduce-initial/data/toInitial.json":[function(require,module,exports) {
module.exports = {
  "background-clip": "border-box",
  "background-color": "transparent",
  "background-origin": "padding-box",
  "background-size": "auto auto",
  "border-block-color": "currentcolor",
  "border-block-end-color": "currentcolor",
  "border-block-start-color": "currentcolor",
  "border-bottom-color": "currentcolor",
  "border-collapse": "separate",
  "border-inline-color": "currentcolor",
  "border-inline-end-color": "currentcolor",
  "border-inline-start-color": "currentcolor",
  "border-left-color": "currentcolor",
  "border-right-color": "currentcolor",
  "border-top-color": "currentcolor",
  "box-sizing": "content-box",
  "column-rule-color": "currentcolor",
  "font-synthesis": "weight style",
  "mask-clip": "border-box",
  "mask-mode": "match-source",
  "mask-origin": "border-box",
  "mask-repeat": "repeat",
  "mask-type": "luminance",
  "ruby-align": "space-around",
  "ruby-merge": "separate",
  "text-decoration-color": "currentcolor",
  "text-emphasis-color": "currentcolor",
  "text-emphasis-position": "over right",
  "transform-box": "border-box",
  "transform-origin": "50% 50% 0",
  "vertical-align": "baseline",
  "writing-mode": "horizontal-tb"
};
},{}],"node_modules/postcss-reduce-initial/dist/index.js":[function(require,module,exports) {
var __dirname = "/home/royyan/csspurge/node_modules/postcss-reduce-initial/dist";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _has = require('has');

var _has2 = _interopRequireDefault(_has);

var _browserslist = require('browserslist');

var _browserslist2 = _interopRequireDefault(_browserslist);

var _caniuseApi = require('caniuse-api');

var _fromInitial = require('../data/fromInitial.json');

var _fromInitial2 = _interopRequireDefault(_fromInitial);

var _toInitial = require('../data/toInitial.json');

var _toInitial2 = _interopRequireDefault(_toInitial);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var initial = 'initial';
exports.default = (0, _postcss.plugin)('postcss-reduce-initial', function () {
  return function (css, result) {
    var resultOpts = result.opts || {};
    var browsers = (0, _browserslist2.default)(null, {
      stats: resultOpts.stats,
      path: __dirname,
      env: resultOpts.env
    });
    var initialSupport = (0, _caniuseApi.isSupported)('css-initial-value', browsers);
    css.walkDecls(function (decl) {
      var lowerCasedProp = decl.prop.toLowerCase();

      if (initialSupport && (0, _has2.default)(_toInitial2.default, lowerCasedProp) && decl.value.toLowerCase() === _toInitial2.default[lowerCasedProp]) {
        decl.value = initial;
        return;
      }

      if (decl.value.toLowerCase() !== initial || !_fromInitial2.default[lowerCasedProp]) {
        return;
      }

      decl.value = _fromInitial2.default[lowerCasedProp];
    });
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","has":"node_modules/has/src/index.js","browserslist":"node_modules/browserslist/index.js","caniuse-api":"node_modules/caniuse-api/dist/index.js","../data/fromInitial.json":"node_modules/postcss-reduce-initial/data/fromInitial.json","../data/toInitial.json":"node_modules/postcss-reduce-initial/data/toInitial.json"}],"node_modules/postcss-value-parser/lib/parse.js":[function(require,module,exports) {
var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);

module.exports = function(input) {
  var tokens = [];
  var value = input;

  var next, quote, prev, token, escape, escapePos, whitespacePos;
  var pos = 0;
  var code = value.charCodeAt(pos);
  var max = value.length;
  var stack = [{ nodes: tokens }];
  var balanced = 0;
  var parent;

  var name = "";
  var before = "";
  var after = "";

  while (pos < max) {
    // Whitespaces
    if (code <= 32) {
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = value.slice(pos, next);

      prev = tokens[tokens.length - 1];
      if (code === closeParentheses && balanced) {
        after = token;
      } else if (prev && prev.type === "div") {
        prev.after = token;
      } else if (
        code === comma ||
        code === colon ||
        (code === slash && value.charCodeAt(next + 1) !== star)
      ) {
        before = token;
      } else {
        tokens.push({
          type: "space",
          sourceIndex: pos,
          value: token
        });
      }

      pos = next;

      // Quotes
    } else if (code === singleQuote || code === doubleQuote) {
      next = pos;
      quote = code === singleQuote ? "'" : '"';
      token = {
        type: "string",
        sourceIndex: pos,
        quote: quote
      };
      do {
        escape = false;
        next = value.indexOf(quote, next + 1);
        if (~next) {
          escapePos = next;
          while (value.charCodeAt(escapePos - 1) === backslash) {
            escapePos -= 1;
            escape = !escape;
          }
        } else {
          value += quote;
          next = value.length - 1;
          token.unclosed = true;
        }
      } while (escape);
      token.value = value.slice(pos + 1, next);

      tokens.push(token);
      pos = next + 1;
      code = value.charCodeAt(pos);

      // Comments
    } else if (code === slash && value.charCodeAt(pos + 1) === star) {
      token = {
        type: "comment",
        sourceIndex: pos
      };

      next = value.indexOf("*/", pos);
      if (next === -1) {
        token.unclosed = true;
        next = value.length;
      }

      token.value = value.slice(pos + 2, next);
      tokens.push(token);

      pos = next + 2;
      code = value.charCodeAt(pos);

      // Dividers
    } else if (code === slash || code === comma || code === colon) {
      token = value[pos];

      tokens.push({
        type: "div",
        sourceIndex: pos - before.length,
        value: token,
        before: before,
        after: ""
      });
      before = "";

      pos += 1;
      code = value.charCodeAt(pos);

      // Open parentheses
    } else if (openParentheses === code) {
      // Whitespaces after open parentheses
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = {
        type: "function",
        sourceIndex: pos - name.length,
        value: name,
        before: value.slice(pos + 1, next)
      };
      pos = next;

      if (name === "url" && code !== singleQuote && code !== doubleQuote) {
        next -= 1;
        do {
          escape = false;
          next = value.indexOf(")", next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += ")";
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);
        // Whitespaces before closed
        whitespacePos = next;
        do {
          whitespacePos -= 1;
          code = value.charCodeAt(whitespacePos);
        } while (code <= 32);
        if (pos !== whitespacePos + 1) {
          token.nodes = [
            {
              type: "word",
              sourceIndex: pos,
              value: value.slice(pos, whitespacePos + 1)
            }
          ];
        } else {
          token.nodes = [];
        }
        if (token.unclosed && whitespacePos + 1 !== next) {
          token.after = "";
          token.nodes.push({
            type: "space",
            sourceIndex: whitespacePos + 1,
            value: value.slice(whitespacePos + 1, next)
          });
        } else {
          token.after = value.slice(whitespacePos + 1, next);
        }
        pos = next + 1;
        code = value.charCodeAt(pos);
        tokens.push(token);
      } else {
        balanced += 1;
        token.after = "";
        tokens.push(token);
        stack.push(token);
        tokens = token.nodes = [];
        parent = token;
      }
      name = "";

      // Close parentheses
    } else if (closeParentheses === code && balanced) {
      pos += 1;
      code = value.charCodeAt(pos);

      parent.after = after;
      after = "";
      balanced -= 1;
      stack.pop();
      parent = stack[balanced];
      tokens = parent.nodes;

      // Words
    } else {
      next = pos;
      do {
        if (code === backslash) {
          next += 1;
        }
        next += 1;
        code = value.charCodeAt(next);
      } while (
        next < max &&
        !(
          code <= 32 ||
          code === singleQuote ||
          code === doubleQuote ||
          code === comma ||
          code === colon ||
          code === slash ||
          code === openParentheses ||
          (code === closeParentheses && balanced)
        )
      );
      token = value.slice(pos, next);

      if (openParentheses === code) {
        name = token;
      } else {
        tokens.push({
          type: "word",
          sourceIndex: pos,
          value: token
        });
      }

      pos = next;
    }
  }

  for (pos = stack.length - 1; pos; pos -= 1) {
    stack[pos].unclosed = true;
  }

  return stack[0].nodes;
};

},{}],"node_modules/postcss-value-parser/lib/walk.js":[function(require,module,exports) {
module.exports = function walk(nodes, cb, bubble) {
  var i, max, node, result;

  for (i = 0, max = nodes.length; i < max; i += 1) {
    node = nodes[i];
    if (!bubble) {
      result = cb(node, i, nodes);
    }

    if (
      result !== false &&
      node.type === "function" &&
      Array.isArray(node.nodes)
    ) {
      walk(node.nodes, cb, bubble);
    }

    if (bubble) {
      cb(node, i, nodes);
    }
  }
};

},{}],"node_modules/postcss-value-parser/lib/stringify.js":[function(require,module,exports) {
function stringifyNode(node, custom) {
  var type = node.type;
  var value = node.value;
  var buf;
  var customResult;

  if (custom && (customResult = custom(node)) !== undefined) {
    return customResult;
  } else if (type === "word" || type === "space") {
    return value;
  } else if (type === "string") {
    buf = node.quote || "";
    return buf + value + (node.unclosed ? "" : buf);
  } else if (type === "comment") {
    return "/*" + value + (node.unclosed ? "" : "*/");
  } else if (type === "div") {
    return (node.before || "") + value + (node.after || "");
  } else if (Array.isArray(node.nodes)) {
    buf = stringify(node.nodes);
    if (type !== "function") {
      return buf;
    }
    return (
      value +
      "(" +
      (node.before || "") +
      buf +
      (node.after || "") +
      (node.unclosed ? "" : ")")
    );
  }
  return value;
}

function stringify(nodes, custom) {
  var result, i;

  if (Array.isArray(nodes)) {
    result = "";
    for (i = nodes.length - 1; ~i; i -= 1) {
      result = stringifyNode(nodes[i], custom) + result;
    }
    return result;
  }
  return stringifyNode(nodes, custom);
}

module.exports = stringify;

},{}],"node_modules/postcss-value-parser/lib/unit.js":[function(require,module,exports) {
var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);

module.exports = function(value) {
  var pos = 0;
  var length = value.length;
  var dotted = false;
  var sciPos = -1;
  var containsNumber = false;
  var code;

  while (pos < length) {
    code = value.charCodeAt(pos);

    if (code >= 48 && code <= 57) {
      containsNumber = true;
    } else if (code === exp || code === EXP) {
      if (sciPos > -1) {
        break;
      }
      sciPos = pos;
    } else if (code === dot) {
      if (dotted) {
        break;
      }
      dotted = true;
    } else if (code === plus || code === minus) {
      if (pos !== 0) {
        break;
      }
    } else {
      break;
    }

    pos += 1;
  }

  if (sciPos + 1 === pos) pos--;

  return containsNumber
    ? {
        number: value.slice(0, pos),
        unit: value.slice(pos)
      }
    : false;
};

},{}],"node_modules/postcss-value-parser/lib/index.js":[function(require,module,exports) {
var parse = require("./parse");
var walk = require("./walk");
var stringify = require("./stringify");

function ValueParser(value) {
  if (this instanceof ValueParser) {
    this.nodes = parse(value);
    return this;
  }
  return new ValueParser(value);
}

ValueParser.prototype.toString = function() {
  return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};

ValueParser.prototype.walk = function(cb, bubble) {
  walk(this.nodes, cb, bubble);
  return this;
};

ValueParser.unit = require("./unit");

ValueParser.walk = walk;

ValueParser.stringify = stringify;

module.exports = ValueParser;

},{"./parse":"node_modules/postcss-value-parser/lib/parse.js","./walk":"node_modules/postcss-value-parser/lib/walk.js","./stringify":"node_modules/postcss-value-parser/lib/stringify.js","./unit":"node_modules/postcss-value-parser/lib/unit.js"}],"node_modules/cssnano-util-get-arguments/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getArguments;

function getArguments(node) {
  return node.nodes.reduce(function (list, child) {
    if (child.type !== 'div') {
      list[list.length - 1].push(child);
    } else {
      list.push([]);
    }

    return list;
  }, [[]]);
}

module.exports = exports['default'];
},{}],"node_modules/rgb-regex/index.js":[function(require,module,exports) {
'use strict';

module.exports = function rgbRegex(options) {
  options = options || {};

  return options.exact ?
    /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/ :
    /rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)/ig;
}

},{}],"node_modules/is-color-stop/lib/isRGB.js":[function(require,module,exports) {
'use strict';

const rgbRegex = require('rgb-regex');

function isRGB(str) {
  return rgbRegex({ exact: true }).test(str);
}

module.exports = isRGB;

},{"rgb-regex":"node_modules/rgb-regex/index.js"}],"node_modules/rgba-regex/index.js":[function(require,module,exports) {
'use strict';

module.exports = function rgbaRegex(options) {
  options = options || {};

  return options.exact ?
    /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*(?:\.\d+)?)\)$/ :
    /rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*(?:\.\d+)?)\)/ig;
}

},{}],"node_modules/is-color-stop/lib/isRGBA.js":[function(require,module,exports) {
'use strict';

const rgbaRegex = require('rgba-regex');

function isRgba(str) {
  return rgbaRegex({ exact: true }).test(str);
}

module.exports = isRgba;

},{"rgba-regex":"node_modules/rgba-regex/index.js"}],"node_modules/hsl-regex/index.js":[function(require,module,exports) {
'use strict';

module.exports = function hslRegex(options) {
  options = options || {};

  return options.exact ?
    /^hsl\(\s*(\d+)\s*,\s*(\d*(?:\.\d+)?%)\s*,\s*(\d*(?:\.\d+)?%)\)$/ :
    /hsl\(\s*(\d+)\s*,\s*(\d*(?:\.\d+)?%)\s*,\s*(\d*(?:\.\d+)?%)\)/ig;
}

},{}],"node_modules/is-color-stop/lib/isHSL.js":[function(require,module,exports) {
'use strict';

const hslRegex = require('hsl-regex');

function isHSL(str) {
  return hslRegex({ exact: true }).test(str);
}

module.exports = isHSL;

},{"hsl-regex":"node_modules/hsl-regex/index.js"}],"node_modules/hsla-regex/index.js":[function(require,module,exports) {
'use strict';

module.exports = function hslaRegex(options) {
  options = options || {};

  return options.exact ?
    /^hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*(\d*(?:\.\d+)?)\)$/ :
    /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*(\d*(?:\.\d+)?)\)/ig;
}

},{}],"node_modules/is-color-stop/lib/isHSLA.js":[function(require,module,exports) {
'use strict';

const hslaRegex = require('hsla-regex');

function isHSLA(str) {
  return hslaRegex({ exact: true }).test(str);
}

module.exports = isHSLA;

},{"hsla-regex":"node_modules/hsla-regex/index.js"}],"node_modules/hex-color-regex/index.js":[function(require,module,exports) {
/*!
 * hex-color-regex <https://github.com/regexps/hex-color-regex>
 *
 * Copyright (c) 2015 Charlike Mike Reagent <@tunnckoCore> (http://www.tunnckocore.tk)
 * Released under the MIT license.
 */

'use strict'

module.exports = function hexColorRegex(opts) {
  opts = opts && typeof opts === 'object' ? opts : {}

  return opts.strict
    ? /^#([a-f0-9]{3,4}|[a-f0-9]{4}(?:[a-f0-9]{2}){1,2})\b$/i
    : /#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})\b/gi
}

},{}],"node_modules/is-color-stop/lib/isHex.js":[function(require,module,exports) {
'use strict';

const hexRegex = require('hex-color-regex');

function isHex(str) {
  return hexRegex({ exact: true }).test(str);
}

module.exports = isHex;

},{"hex-color-regex":"node_modules/hex-color-regex/index.js"}],"node_modules/css-color-names/css-color-names.json":[function(require,module,exports) {
module.exports = {
  "aliceblue": "#f0f8ff",
  "antiquewhite": "#faebd7",
  "aqua": "#00ffff",
  "aquamarine": "#7fffd4",
  "azure": "#f0ffff",
  "beige": "#f5f5dc",
  "bisque": "#ffe4c4",
  "black": "#000000",
  "blanchedalmond": "#ffebcd",
  "blue": "#0000ff",
  "blueviolet": "#8a2be2",
  "brown": "#a52a2a",
  "burlywood": "#deb887",
  "cadetblue": "#5f9ea0",
  "chartreuse": "#7fff00",
  "chocolate": "#d2691e",
  "coral": "#ff7f50",
  "cornflowerblue": "#6495ed",
  "cornsilk": "#fff8dc",
  "crimson": "#dc143c",
  "cyan": "#00ffff",
  "darkblue": "#00008b",
  "darkcyan": "#008b8b",
  "darkgoldenrod": "#b8860b",
  "darkgray": "#a9a9a9",
  "darkgreen": "#006400",
  "darkgrey": "#a9a9a9",
  "darkkhaki": "#bdb76b",
  "darkmagenta": "#8b008b",
  "darkolivegreen": "#556b2f",
  "darkorange": "#ff8c00",
  "darkorchid": "#9932cc",
  "darkred": "#8b0000",
  "darksalmon": "#e9967a",
  "darkseagreen": "#8fbc8f",
  "darkslateblue": "#483d8b",
  "darkslategray": "#2f4f4f",
  "darkslategrey": "#2f4f4f",
  "darkturquoise": "#00ced1",
  "darkviolet": "#9400d3",
  "deeppink": "#ff1493",
  "deepskyblue": "#00bfff",
  "dimgray": "#696969",
  "dimgrey": "#696969",
  "dodgerblue": "#1e90ff",
  "firebrick": "#b22222",
  "floralwhite": "#fffaf0",
  "forestgreen": "#228b22",
  "fuchsia": "#ff00ff",
  "gainsboro": "#dcdcdc",
  "ghostwhite": "#f8f8ff",
  "gold": "#ffd700",
  "goldenrod": "#daa520",
  "gray": "#808080",
  "green": "#008000",
  "greenyellow": "#adff2f",
  "grey": "#808080",
  "honeydew": "#f0fff0",
  "hotpink": "#ff69b4",
  "indianred": "#cd5c5c",
  "indigo": "#4b0082",
  "ivory": "#fffff0",
  "khaki": "#f0e68c",
  "lavender": "#e6e6fa",
  "lavenderblush": "#fff0f5",
  "lawngreen": "#7cfc00",
  "lemonchiffon": "#fffacd",
  "lightblue": "#add8e6",
  "lightcoral": "#f08080",
  "lightcyan": "#e0ffff",
  "lightgoldenrodyellow": "#fafad2",
  "lightgray": "#d3d3d3",
  "lightgreen": "#90ee90",
  "lightgrey": "#d3d3d3",
  "lightpink": "#ffb6c1",
  "lightsalmon": "#ffa07a",
  "lightseagreen": "#20b2aa",
  "lightskyblue": "#87cefa",
  "lightslategray": "#778899",
  "lightslategrey": "#778899",
  "lightsteelblue": "#b0c4de",
  "lightyellow": "#ffffe0",
  "lime": "#00ff00",
  "limegreen": "#32cd32",
  "linen": "#faf0e6",
  "magenta": "#ff00ff",
  "maroon": "#800000",
  "mediumaquamarine": "#66cdaa",
  "mediumblue": "#0000cd",
  "mediumorchid": "#ba55d3",
  "mediumpurple": "#9370db",
  "mediumseagreen": "#3cb371",
  "mediumslateblue": "#7b68ee",
  "mediumspringgreen": "#00fa9a",
  "mediumturquoise": "#48d1cc",
  "mediumvioletred": "#c71585",
  "midnightblue": "#191970",
  "mintcream": "#f5fffa",
  "mistyrose": "#ffe4e1",
  "moccasin": "#ffe4b5",
  "navajowhite": "#ffdead",
  "navy": "#000080",
  "oldlace": "#fdf5e6",
  "olive": "#808000",
  "olivedrab": "#6b8e23",
  "orange": "#ffa500",
  "orangered": "#ff4500",
  "orchid": "#da70d6",
  "palegoldenrod": "#eee8aa",
  "palegreen": "#98fb98",
  "paleturquoise": "#afeeee",
  "palevioletred": "#db7093",
  "papayawhip": "#ffefd5",
  "peachpuff": "#ffdab9",
  "peru": "#cd853f",
  "pink": "#ffc0cb",
  "plum": "#dda0dd",
  "powderblue": "#b0e0e6",
  "purple": "#800080",
  "rebeccapurple": "#663399",
  "red": "#ff0000",
  "rosybrown": "#bc8f8f",
  "royalblue": "#4169e1",
  "saddlebrown": "#8b4513",
  "salmon": "#fa8072",
  "sandybrown": "#f4a460",
  "seagreen": "#2e8b57",
  "seashell": "#fff5ee",
  "sienna": "#a0522d",
  "silver": "#c0c0c0",
  "skyblue": "#87ceeb",
  "slateblue": "#6a5acd",
  "slategray": "#708090",
  "slategrey": "#708090",
  "snow": "#fffafa",
  "springgreen": "#00ff7f",
  "steelblue": "#4682b4",
  "tan": "#d2b48c",
  "teal": "#008080",
  "thistle": "#d8bfd8",
  "tomato": "#ff6347",
  "turquoise": "#40e0d0",
  "violet": "#ee82ee",
  "wheat": "#f5deb3",
  "white": "#ffffff",
  "whitesmoke": "#f5f5f5",
  "yellow": "#ffff00",
  "yellowgreen": "#9acd32"
}
;
},{}],"node_modules/is-color-stop/lib/isCSSColorName.js":[function(require,module,exports) {
'use strict';

const colorNames = require('css-color-names');

function isCSSColorName(str) {
  return !!colorNames[str];
}

module.exports = isCSSColorName;

},{"css-color-names":"node_modules/css-color-names/css-color-names.json"}],"node_modules/is-color-stop/lib/isTransparent.js":[function(require,module,exports) {
'use strict';

function isTransparent(str) {
  return str === 'transparent';
}

module.exports = isTransparent;

},{}],"node_modules/is-color-stop/lib/isCSSLengthUnit.js":[function(require,module,exports) {
'use strict';

const lengthArray = [
  'PX',
  'IN',
  'CM',
  'MM',
  'EM',
  'REM',
  'POINTS',
  'PC',
  'EX',
  'CH',
  'VW',
  'VH',
  'VMIN',
  'VMAX',
  '%',
];

function isCSSLengthUnit(unit) {
  return lengthArray.indexOf(unit.toUpperCase()) >= 0;
}

module.exports = isCSSLengthUnit;

},{}],"node_modules/is-color-stop/util/unit.js":[function(require,module,exports) {
'use strict';

/**
 * https://github.com/TrySound/postcss-value-parser/blob/fc679a7e17877841ff9fe455722280b65abd4f28/lib/unit.js
 * parse node -> number and unit
 */

const minus = '-'.charCodeAt(0);
const plus = '+'.charCodeAt(0);
const dot = '.'.charCodeAt(0);

module.exports = function unit(value) {
  let pos = 0;
  const length = value.length;
  let dotted = false;
  let containsNumber = false;
  let code;
  let number = '';

  while (pos < length) {
    code = value.charCodeAt(pos);

    if (code >= 48 && code <= 57) {
      number += value[pos];
      containsNumber = true;
    } else if (code === dot) {
      if (dotted) {
        break;
      }
      dotted = true;
      number += value[pos];
    } else if (code === plus || code === minus) {
      if (pos !== 0) {
        break;
      }
      number += value[pos];
    } else {
      break;
    }

    pos += 1;
  }

  return containsNumber ? {
    number,
    unit: value.slice(pos),
  } : false;
};

},{}],"node_modules/is-color-stop/lib/isStop.js":[function(require,module,exports) {
'use strict';

const isCSSLengthUnit = require('./isCSSLengthUnit');
const unit = require('../util/unit');

function isStop(str) {
  let stop = !str;
  
  if (!stop) {
    const node = unit(str);
    if (node) {
      if (node.number === 0 || (!isNaN(node.number) && isCSSLengthUnit(node.unit))) {
        stop = true;
      }
    } else {
      stop = (/^calc\(\S+\)$/g).test(str);
    }
  }

  return stop;
}

module.exports = isStop;

},{"./isCSSLengthUnit":"node_modules/is-color-stop/lib/isCSSLengthUnit.js","../util/unit":"node_modules/is-color-stop/util/unit.js"}],"node_modules/is-color-stop/index.js":[function(require,module,exports) {
'use strict';

const isRGB = require('./lib/isRGB');
const isRGBA = require('./lib/isRGBA');
const isHSL = require('./lib/isHSL');
const isHSLA = require('./lib/isHSLA');
const isHex = require('./lib/isHex');
const isCSSColorName = require('./lib/isCSSColorName');
const isTransparent = require('./lib/isTransparent');
const isCSSLengthUnit = require('./lib/isCSSLengthUnit');
const isStop = require('./lib/isStop');

function isColor(colorStr) {
  const color =
    isRGB(colorStr) ||
    isRGBA(colorStr) ||
    isHSL(colorStr) ||
    isHSLA(colorStr) ||
    isHex(colorStr) ||
    isCSSColorName(colorStr) ||
    isTransparent(colorStr);

  return color;
}


module.exports = function isColorStop(color, stop) {
  return isColor(color) && isStop(stop);
};
module.exports.isColor = isColor;
module.exports.isRGB = isRGB;
module.exports.isRGBA = isRGBA;
module.exports.isHSL = isHSL;
module.exports.isHSLA = isHSLA;
module.exports.isHex = isHex;
module.exports.isCSSColorName = isCSSColorName;
module.exports.isTransparent = isTransparent;
module.exports.isCSSLengthUnit = isCSSLengthUnit;

},{"./lib/isRGB":"node_modules/is-color-stop/lib/isRGB.js","./lib/isRGBA":"node_modules/is-color-stop/lib/isRGBA.js","./lib/isHSL":"node_modules/is-color-stop/lib/isHSL.js","./lib/isHSLA":"node_modules/is-color-stop/lib/isHSLA.js","./lib/isHex":"node_modules/is-color-stop/lib/isHex.js","./lib/isCSSColorName":"node_modules/is-color-stop/lib/isCSSColorName.js","./lib/isTransparent":"node_modules/is-color-stop/lib/isTransparent.js","./lib/isCSSLengthUnit":"node_modules/is-color-stop/lib/isCSSLengthUnit.js","./lib/isStop":"node_modules/is-color-stop/lib/isStop.js"}],"node_modules/postcss-minify-gradients/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _cssnanoUtilGetArguments = require('cssnano-util-get-arguments');

var _cssnanoUtilGetArguments2 = _interopRequireDefault(_cssnanoUtilGetArguments);

var _isColorStop = require('is-color-stop');

var _isColorStop2 = _interopRequireDefault(_isColorStop);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var angles = {
  top: '0deg',
  right: '90deg',
  bottom: '180deg',
  left: '270deg'
};

function isLessThan(a, b) {
  return a.unit.toLowerCase() === b.unit.toLowerCase() && parseFloat(a.number) >= parseFloat(b.number);
}

function optimise(decl) {
  var value = decl.value;

  if (!~value.toLowerCase().indexOf('gradient')) {
    return;
  }

  decl.value = (0, _postcssValueParser2.default)(value).walk(function (node) {
    if (node.type !== 'function' || !node.nodes.length) {
      return false;
    }

    var lowerCasedValue = node.value.toLowerCase();

    if (lowerCasedValue === 'linear-gradient' || lowerCasedValue === 'repeating-linear-gradient' || lowerCasedValue === '-webkit-linear-gradient' || lowerCasedValue === '-webkit-repeating-linear-gradient') {
      var args = (0, _cssnanoUtilGetArguments2.default)(node);

      if (node.nodes[0].value.toLowerCase() === 'to' && args[0].length === 3) {
        node.nodes = node.nodes.slice(2);
        node.nodes[0].value = angles[node.nodes[0].value.toLowerCase()];
      }

      var lastStop = null;
      args.forEach(function (arg, index) {
        if (!arg[2]) {
          return;
        }

        var isFinalStop = index === args.length - 1;
        var thisStop = (0, _postcssValueParser.unit)(arg[2].value);

        if (lastStop === null) {
          lastStop = thisStop;

          if (!isFinalStop && lastStop && lastStop.number === '0' && lastStop.unit.toLowerCase() !== 'deg') {
            arg[1].value = arg[2].value = '';
          }

          return;
        }

        if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {
          arg[2].value = 0;
        }

        lastStop = thisStop;

        if (isFinalStop && arg[2].value === '100%') {
          arg[1].value = arg[2].value = '';
        }
      });
      return false;
    }

    if (lowerCasedValue === 'radial-gradient' || lowerCasedValue === 'repeating-radial-gradient') {
      var _args = (0, _cssnanoUtilGetArguments2.default)(node);

      var _lastStop;

      var hasAt = _args[0].find(function (n) {
        return n.value.toLowerCase() === 'at';
      });

      _args.forEach(function (arg, index) {
        if (!arg[2] || !index && hasAt) {
          return;
        }

        var thisStop = (0, _postcssValueParser.unit)(arg[2].value);

        if (!_lastStop) {
          _lastStop = thisStop;
          return;
        }

        if (_lastStop && thisStop && isLessThan(_lastStop, thisStop)) {
          arg[2].value = 0;
        }

        _lastStop = thisStop;
      });

      return false;
    }

    if (lowerCasedValue === '-webkit-radial-gradient' || lowerCasedValue === '-webkit-repeating-radial-gradient') {
      var _args2 = (0, _cssnanoUtilGetArguments2.default)(node);

      var _lastStop2;

      _args2.forEach(function (arg) {
        var color;
        var stop;

        if (arg[2] !== undefined) {
          if (arg[0].type === 'function') {
            color = "".concat(arg[0].value, "(").concat((0, _postcssValueParser.stringify)(arg[0].nodes), ")");
          } else {
            color = arg[0].value;
          }

          if (arg[2].type === 'function') {
            stop = "".concat(arg[2].value, "(").concat((0, _postcssValueParser.stringify)(arg[2].nodes), ")");
          } else {
            stop = arg[2].value;
          }
        } else {
          if (arg[0].type === 'function') {
            color = "".concat(arg[0].value, "(").concat((0, _postcssValueParser.stringify)(arg[0].nodes), ")");
          }

          color = arg[0].value;
        }

        color = color.toLowerCase();
        var colorStop = stop || stop === 0 ? (0, _isColorStop2.default)(color, stop.toLowerCase()) : (0, _isColorStop2.default)(color);

        if (!colorStop || !arg[2]) {
          return;
        }

        var thisStop = (0, _postcssValueParser.unit)(arg[2].value);

        if (!_lastStop2) {
          _lastStop2 = thisStop;
          return;
        }

        if (_lastStop2 && thisStop && isLessThan(_lastStop2, thisStop)) {
          arg[2].value = 0;
        }

        _lastStop2 = thisStop;
      });

      return false;
    }
  }).toString();
}

exports.default = _postcss2.default.plugin('postcss-minify-gradients', function () {
  return function (css) {
    return css.walkDecls(optimise);
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","cssnano-util-get-arguments":"node_modules/cssnano-util-get-arguments/dist/index.js","is-color-stop":"node_modules/is-color-stop/index.js"}],"node_modules/js-yaml/lib/js-yaml/common.js":[function(require,module,exports) {
'use strict';


function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],"node_modules/js-yaml/lib/js-yaml/exception.js":[function(require,module,exports) {
// YAML error class. http://stackoverflow.com/questions/8458984
//
'use strict';

function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],"node_modules/js-yaml/lib/js-yaml/mark.js":[function(require,module,exports) {
'use strict';


var common = require('./common');


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{"./common":"node_modules/js-yaml/lib/js-yaml/common.js"}],"node_modules/js-yaml/lib/js-yaml/type.js":[function(require,module,exports) {
'use strict';

var YAMLException = require('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

},{"./exception":"node_modules/js-yaml/lib/js-yaml/exception.js"}],"node_modules/js-yaml/lib/js-yaml/schema.js":[function(require,module,exports) {
'use strict';

/*eslint-disable max-len*/

var common        = require('./common');
var YAMLException = require('./exception');
var Type          = require('./type');


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{"./common":"node_modules/js-yaml/lib/js-yaml/common.js","./exception":"node_modules/js-yaml/lib/js-yaml/exception.js","./type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/type/str.js":[function(require,module,exports) {
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});

},{"../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/type/seq.js":[function(require,module,exports) {
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});

},{"../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/type/map.js":[function(require,module,exports) {
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});

},{"../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/schema/failsafe.js":[function(require,module,exports) {
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  explicit: [
    require('../type/str'),
    require('../type/seq'),
    require('../type/map')
  ]
});

},{"../schema":"node_modules/js-yaml/lib/js-yaml/schema.js","../type/str":"node_modules/js-yaml/lib/js-yaml/type/str.js","../type/seq":"node_modules/js-yaml/lib/js-yaml/type/seq.js","../type/map":"node_modules/js-yaml/lib/js-yaml/type/map.js"}],"node_modules/js-yaml/lib/js-yaml/type/null.js":[function(require,module,exports) {
'use strict';

var Type = require('../type');

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/type/bool.js":[function(require,module,exports) {
'use strict';

var Type = require('../type');

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/type/int.js":[function(require,module,exports) {
'use strict';

var common = require('../common');
var Type   = require('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

},{"../common":"node_modules/js-yaml/lib/js-yaml/common.js","../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/type/float.js":[function(require,module,exports) {
'use strict';

var common = require('../common');
var Type   = require('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

},{"../common":"node_modules/js-yaml/lib/js-yaml/common.js","../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/schema/json.js":[function(require,module,exports) {
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./failsafe')
  ],
  implicit: [
    require('../type/null'),
    require('../type/bool'),
    require('../type/int'),
    require('../type/float')
  ]
});

},{"../schema":"node_modules/js-yaml/lib/js-yaml/schema.js","./failsafe":"node_modules/js-yaml/lib/js-yaml/schema/failsafe.js","../type/null":"node_modules/js-yaml/lib/js-yaml/type/null.js","../type/bool":"node_modules/js-yaml/lib/js-yaml/type/bool.js","../type/int":"node_modules/js-yaml/lib/js-yaml/type/int.js","../type/float":"node_modules/js-yaml/lib/js-yaml/type/float.js"}],"node_modules/js-yaml/lib/js-yaml/schema/core.js":[function(require,module,exports) {
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./json')
  ]
});

},{"../schema":"node_modules/js-yaml/lib/js-yaml/schema.js","./json":"node_modules/js-yaml/lib/js-yaml/schema/json.js"}],"node_modules/js-yaml/lib/js-yaml/type/timestamp.js":[function(require,module,exports) {
'use strict';

var Type = require('../type');

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/type/merge.js":[function(require,module,exports) {
'use strict';

var Type = require('../type');

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

},{"../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/type/binary.js":[function(require,module,exports) {
'use strict';

/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = require;
  NodeBuffer = _require('buffer').Buffer;
} catch (__) {}

var Type       = require('../type');


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{"../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/type/omap.js":[function(require,module,exports) {
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

},{"../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/type/pairs.js":[function(require,module,exports) {
'use strict';

var Type = require('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/type/set.js":[function(require,module,exports) {
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

},{"../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/schema/default_safe.js":[function(require,module,exports) {
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./core')
  ],
  implicit: [
    require('../type/timestamp'),
    require('../type/merge')
  ],
  explicit: [
    require('../type/binary'),
    require('../type/omap'),
    require('../type/pairs'),
    require('../type/set')
  ]
});

},{"../schema":"node_modules/js-yaml/lib/js-yaml/schema.js","./core":"node_modules/js-yaml/lib/js-yaml/schema/core.js","../type/timestamp":"node_modules/js-yaml/lib/js-yaml/type/timestamp.js","../type/merge":"node_modules/js-yaml/lib/js-yaml/type/merge.js","../type/binary":"node_modules/js-yaml/lib/js-yaml/type/binary.js","../type/omap":"node_modules/js-yaml/lib/js-yaml/type/omap.js","../type/pairs":"node_modules/js-yaml/lib/js-yaml/type/pairs.js","../type/set":"node_modules/js-yaml/lib/js-yaml/type/set.js"}],"node_modules/js-yaml/lib/js-yaml/type/js/undefined.js":[function(require,module,exports) {
'use strict';

var Type = require('../../type');

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{"../../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/type/js/regexp.js":[function(require,module,exports) {
'use strict';

var Type = require('../../type');

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{"../../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/type/js/function.js":[function(require,module,exports) {
'use strict';

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = require;
  esprima = _require('esprima');
} catch (_) {
  /* eslint-disable no-redeclare */
  /* global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = require('../../type');

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
        ast.body[0].expression.type !== 'FunctionExpression')) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{"../../type":"node_modules/js-yaml/lib/js-yaml/type.js"}],"node_modules/js-yaml/lib/js-yaml/schema/default_full.js":[function(require,module,exports) {
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.


'use strict';


var Schema = require('../schema');


module.exports = Schema.DEFAULT = new Schema({
  include: [
    require('./default_safe')
  ],
  explicit: [
    require('../type/js/undefined'),
    require('../type/js/regexp'),
    require('../type/js/function')
  ]
});

},{"../schema":"node_modules/js-yaml/lib/js-yaml/schema.js","./default_safe":"node_modules/js-yaml/lib/js-yaml/schema/default_safe.js","../type/js/undefined":"node_modules/js-yaml/lib/js-yaml/type/js/undefined.js","../type/js/regexp":"node_modules/js-yaml/lib/js-yaml/type/js/regexp.js","../type/js/function":"node_modules/js-yaml/lib/js-yaml/type/js/function.js"}],"node_modules/js-yaml/lib/js-yaml/loader.js":[function(require,module,exports) {
'use strict';

/*eslint-disable max-len,no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var Mark                = require('./mark');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      // Implicit resolving is not allowed for non-scalar types, and '?'
      // non-specific tag is only automatically assigned to plain scalars.
      //
      // We only need to check kind conformity in case user explicitly assigns '?'
      // tag, for example like this: "!<?> [0]"
      //
      if (state.result !== null && state.kind !== 'scalar') {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }

      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, iterator, options) {
  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{"./common":"node_modules/js-yaml/lib/js-yaml/common.js","./exception":"node_modules/js-yaml/lib/js-yaml/exception.js","./mark":"node_modules/js-yaml/lib/js-yaml/mark.js","./schema/default_safe":"node_modules/js-yaml/lib/js-yaml/schema/default_safe.js","./schema/default_full":"node_modules/js-yaml/lib/js-yaml/schema/default_full.js"}],"node_modules/js-yaml/lib/js-yaml/dumper.js":[function(require,module,exports) {
'use strict';

/*eslint-disable no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_EQUALS               = 0x3D; /* = */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF
function isNsChar(c) {
  return isPrintable(c) && !isWhitespace(c)
    // byte-order-mark
    && c !== 0xFEFF
    // b-char
    && c !== CHAR_CARRIAGE_RETURN
    && c !== CHAR_LINE_FEED;
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c, prev) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    // /* An ns-char preceding */ "#"
    && c !== CHAR_COLON
    && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_EQUALS
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | “%” | “@” | “`”)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char, prev_char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {

    pairBuffer = '';
    if (index !== 0) pairBuffer += ', ';

    if (state.condenseFlow) pairBuffer += '"';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
      if (block && (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;

},{"./common":"node_modules/js-yaml/lib/js-yaml/common.js","./exception":"node_modules/js-yaml/lib/js-yaml/exception.js","./schema/default_full":"node_modules/js-yaml/lib/js-yaml/schema/default_full.js","./schema/default_safe":"node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"}],"node_modules/js-yaml/lib/js-yaml.js":[function(require,module,exports) {
'use strict';


var loader = require('./js-yaml/loader');
var dumper = require('./js-yaml/dumper');


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = require('./js-yaml/type');
module.exports.Schema              = require('./js-yaml/schema');
module.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');
module.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');
module.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');
module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = require('./js-yaml/exception');

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
module.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

},{"./js-yaml/loader":"node_modules/js-yaml/lib/js-yaml/loader.js","./js-yaml/dumper":"node_modules/js-yaml/lib/js-yaml/dumper.js","./js-yaml/type":"node_modules/js-yaml/lib/js-yaml/type.js","./js-yaml/schema":"node_modules/js-yaml/lib/js-yaml/schema.js","./js-yaml/schema/failsafe":"node_modules/js-yaml/lib/js-yaml/schema/failsafe.js","./js-yaml/schema/json":"node_modules/js-yaml/lib/js-yaml/schema/json.js","./js-yaml/schema/core":"node_modules/js-yaml/lib/js-yaml/schema/core.js","./js-yaml/schema/default_safe":"node_modules/js-yaml/lib/js-yaml/schema/default_safe.js","./js-yaml/schema/default_full":"node_modules/js-yaml/lib/js-yaml/schema/default_full.js","./js-yaml/exception":"node_modules/js-yaml/lib/js-yaml/exception.js"}],"node_modules/js-yaml/index.js":[function(require,module,exports) {
'use strict';


var yaml = require('./lib/js-yaml.js');


module.exports = yaml;

},{"./lib/js-yaml.js":"node_modules/js-yaml/lib/js-yaml.js"}],"node_modules/svgo/lib/svgo/config.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var FS = require('fs');

var PATH = require('path');

var yaml = require('js-yaml');
/**
 * Read and/or extend/replace default config file,
 * prepare and optimize plugins array.
 *
 * @param {Object} [config] input config
 * @return {Object} output config
 */


module.exports = function (config) {
  var defaults;
  config = _typeof(config) == 'object' && config || {};

  if (config.plugins && !Array.isArray(config.plugins)) {
    return {
      error: 'Error: Invalid plugins list. Provided \'plugins\' in config should be an array.'
    };
  }

  if (config.full) {
    defaults = config;

    if (Array.isArray(defaults.plugins)) {
      defaults.plugins = preparePluginsArray(config, defaults.plugins);
    }
  } else {
    defaults = Object.assign({}, yaml.safeLoad("# replace default config\n\n# multipass: true\n# full: true\n\nplugins:\n\n  # - name\n  #\n  # or:\n  # - name: false\n  # - name: true\n  #\n  # or:\n  # - name:\n  #     param1: 1\n  #     param2: 2\n\n  - removeDoctype\n  - removeXMLProcInst\n  - removeComments\n  - removeMetadata\n  - removeXMLNS\n  - removeEditorsNSData\n  - cleanupAttrs\n  - inlineStyles\n  - minifyStyles\n  - convertStyleToAttrs\n  - cleanupIDs\n  - prefixIds\n  - removeRasterImages\n  - removeUselessDefs\n  - cleanupNumericValues\n  - cleanupListOfValues\n  - convertColors\n  - removeUnknownsAndDefaults\n  - removeNonInheritableGroupAttrs\n  - removeUselessStrokeAndFill\n  - removeViewBox\n  - cleanupEnableBackground\n  - removeHiddenElems\n  - removeEmptyText\n  - convertShapeToPath\n  - convertEllipseToCircle\n  - moveElemsAttrsToGroup\n  - moveGroupAttrsToElems\n  - collapseGroups\n  - convertPathData\n  - convertTransform\n  - removeEmptyAttrs\n  - removeEmptyContainers\n  - mergePaths\n  - removeUnusedNS\n  - sortAttrs\n  - sortDefsChildren\n  - removeTitle\n  - removeDesc\n  - removeDimensions\n  - removeAttrs\n  - removeAttributesBySelector\n  - removeElementsByAttr\n  - addClassesToSVGElement\n  - removeStyleElement\n  - removeScriptElement\n  - addAttributesToSVGElement\n  - removeOffCanvasPaths\n  - reusePaths\n\n# configure the indent (default 4 spaces) used by `--pretty` here:\n#\n# @see https://github.com/svg/svgo/blob/master/lib/svgo/js2svg.js#L6 for more config options\n#\n# js2svg:\n#  pretty: true\n#  indent: '  '\n"));
    defaults.plugins = preparePluginsArray(config, defaults.plugins || []);
    defaults = extendConfig(defaults, config);
  }

  if ('floatPrecision' in config && Array.isArray(defaults.plugins)) {
    defaults.plugins.forEach(function (plugin) {
      if (plugin.params && 'floatPrecision' in plugin.params) {
        // Don't touch default plugin params
        plugin.params = Object.assign({}, plugin.params, {
          floatPrecision: config.floatPrecision
        });
      }
    });
  }

  if ('datauri' in config) {
    defaults.datauri = config.datauri;
  }

  if (Array.isArray(defaults.plugins)) {
    defaults.plugins = optimizePluginsArray(defaults.plugins);
  }

  return defaults;
};
/**
 * Require() all plugins in array.
 *
 * @param {Object} config
 * @param {Array} plugins input plugins array
 * @return {Array} input plugins array of arrays
 */


function preparePluginsArray(config, plugins) {
  var plugin, key;
  return plugins.map(function (item) {
    // {}
    if (_typeof(item) === 'object') {
      key = Object.keys(item)[0]; // custom

      if (_typeof(item[key]) === 'object' && item[key].fn && typeof item[key].fn === 'function') {
        plugin = setupCustomPlugin(key, item[key]);
      } else {
        plugin = setPluginActiveState(loadPlugin(config, key, item[key].path), item, key);
        plugin.name = key;
      } // name

    } else {
      plugin = loadPlugin(config, item);
      plugin.name = item;

      if (_typeof(plugin.params) === 'object') {
        plugin.params = Object.assign({}, plugin.params);
      }
    }

    return plugin;
  });
}
/**
 * Extend plugins with the custom config object.
 *
 * @param {Array} plugins input plugins
 * @param {Object} config config
 * @return {Array} output plugins
 */


function extendConfig(defaults, config) {
  var key; // plugins

  if (config.plugins) {
    config.plugins.forEach(function (item) {
      // {}
      if (_typeof(item) === 'object') {
        key = Object.keys(item)[0];

        if (item[key] == null) {
          console.error("Error: '".concat(key, "' plugin is misconfigured! Have you padded its content in YML properly?\n"));
        } // custom


        if (_typeof(item[key]) === 'object' && item[key].fn && typeof item[key].fn === 'function') {
          defaults.plugins.push(setupCustomPlugin(key, item[key])); // plugin defined via path
        } else if (_typeof(item[key]) === 'object' && item[key].path) {
          defaults.plugins.push(setPluginActiveState(loadPlugin(config, undefined, item[key].path), item, key));
        } else {
          defaults.plugins.forEach(function (plugin) {
            if (plugin.name === key) {
              plugin = setPluginActiveState(plugin, item, key);
            }
          });
        }
      }
    });
  }

  defaults.multipass = config.multipass; // svg2js

  if (config.svg2js) {
    defaults.svg2js = config.svg2js;
  } // js2svg


  if (config.js2svg) {
    defaults.js2svg = config.js2svg;
  }

  return defaults;
}
/**
 * Setup and enable a custom plugin
 *
 * @param {String} plugin name
 * @param {Object} custom plugin
 * @return {Array} enabled plugin
 */


function setupCustomPlugin(name, plugin) {
  plugin.active = true;
  plugin.params = Object.assign({}, plugin.params || {});
  plugin.name = name;
  return plugin;
}
/**
 * Try to group sequential elements of plugins array.
 *
 * @param {Object} plugins input plugins
 * @return {Array} output plugins
 */


function optimizePluginsArray(plugins) {
  var prev;
  return plugins.reduce(function (plugins, item) {
    if (prev && item.type == prev[0].type) {
      prev.push(item);
    } else {
      plugins.push(prev = [item]);
    }

    return plugins;
  }, []);
}
/**
 * Sets plugin to active or inactive state.
 *
 * @param {Object} plugin
 * @param {Object} item
 * @param {Object} key
 * @return {Object} plugin
 */


function setPluginActiveState(plugin, item, key) {
  // name: {}
  if (_typeof(item[key]) === 'object') {
    plugin.params = Object.assign({}, plugin.params || {}, item[key]);
    plugin.active = true; // name: false
  } else if (item[key] === false) {
    plugin.active = false; // name: true
  } else if (item[key] === true) {
    plugin.active = true;
  }

  return plugin;
}
/**
 * Loads default plugin using name or custom plugin defined via path in config.
 *
 * @param {Object} config
 * @param {Object} name
 * @param {Object} path
 * @return {Object} plugin
 */


function loadPlugin(config, name, path) {
  var plugin;

  if (!path) {
    plugin = require('../../plugins/' + name);
  } else {
    plugin = require(PATH.resolve(config.__DIR, path));
  }

  return Object.assign({}, plugin);
}
},{"fs":"node_modules/parcel-bundler/src/builtins/_empty.js","path":"node_modules/path-browserify/index.js","js-yaml":"node_modules/js-yaml/index.js"}],"node_modules/events/events.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}
},{}],"node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],"node_modules/process-nextick-args/index.js":[function(require,module,exports) {
var process = require("process");
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


},{"process":"node_modules/process/browser.js"}],"node_modules/readable-stream/lib/internal/streams/stream-browser.js":[function(require,module,exports) {
module.exports = require('events').EventEmitter;

},{"events":"node_modules/events/events.js"}],"node_modules/readable-stream/node_modules/safe-buffer/index.js":[function(require,module,exports) {

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":"node_modules/buffer/index.js"}],"node_modules/core-util-is/lib/util.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"buffer":"node_modules/buffer/index.js"}],"node_modules/readable-stream/lib/internal/streams/BufferList.js":[function(require,module,exports) {

'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":"node_modules/readable-stream/node_modules/safe-buffer/index.js","util":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/readable-stream/lib/internal/streams/destroy.js":[function(require,module,exports) {
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":"node_modules/process-nextick-args/index.js"}],"node_modules/util-deprecate/browser.js":[function(require,module,exports) {
var global = arguments[3];

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

},{}],"node_modules/readable-stream/lib/_stream_writable.js":[function(require,module,exports) {
var process = require("process");

var global = arguments[3];
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';
/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !true && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/


var Buffer = require('safe-buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
},{"process-nextick-args":"node_modules/process-nextick-args/index.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js","util-deprecate":"node_modules/util-deprecate/browser.js","./internal/streams/stream":"node_modules/readable-stream/lib/internal/streams/stream-browser.js","safe-buffer":"node_modules/readable-stream/node_modules/safe-buffer/index.js","./internal/streams/destroy":"node_modules/readable-stream/lib/internal/streams/destroy.js","./_stream_duplex":"node_modules/readable-stream/lib/_stream_duplex.js","process":"node_modules/process/browser.js"}],"node_modules/readable-stream/lib/_stream_duplex.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"process-nextick-args":"node_modules/process-nextick-args/index.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js","./_stream_readable":"node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"node_modules/readable-stream/lib/_stream_writable.js"}],"node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js":[function(require,module,exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":"node_modules/readable-stream/node_modules/safe-buffer/index.js"}],"node_modules/readable-stream/lib/_stream_readable.js":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
},{"process-nextick-args":"node_modules/process-nextick-args/index.js","isarray":"node_modules/isarray/index.js","events":"node_modules/events/events.js","./internal/streams/stream":"node_modules/readable-stream/lib/internal/streams/stream-browser.js","safe-buffer":"node_modules/readable-stream/node_modules/safe-buffer/index.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js","util":"node_modules/parcel-bundler/src/builtins/_empty.js","./internal/streams/BufferList":"node_modules/readable-stream/lib/internal/streams/BufferList.js","./internal/streams/destroy":"node_modules/readable-stream/lib/internal/streams/destroy.js","./_stream_duplex":"node_modules/readable-stream/lib/_stream_duplex.js","string_decoder/":"node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js","process":"node_modules/process/browser.js"}],"node_modules/readable-stream/lib/_stream_transform.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":"node_modules/readable-stream/lib/_stream_duplex.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/readable-stream/lib/_stream_passthrough.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":"node_modules/readable-stream/lib/_stream_transform.js","core-util-is":"node_modules/core-util-is/lib/util.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/readable-stream/readable-browser.js":[function(require,module,exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_readable.js":"node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_writable.js":"node_modules/readable-stream/lib/_stream_writable.js","./lib/_stream_duplex.js":"node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_transform.js":"node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_passthrough.js":"node_modules/readable-stream/lib/_stream_passthrough.js"}],"node_modules/readable-stream/writable-browser.js":[function(require,module,exports) {
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":"node_modules/readable-stream/lib/_stream_writable.js"}],"node_modules/readable-stream/duplex-browser.js":[function(require,module,exports) {
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":"node_modules/readable-stream/lib/_stream_duplex.js"}],"node_modules/readable-stream/transform.js":[function(require,module,exports) {
module.exports = require('./readable').Transform

},{"./readable":"node_modules/readable-stream/readable-browser.js"}],"node_modules/readable-stream/passthrough.js":[function(require,module,exports) {
module.exports = require('./readable').PassThrough

},{"./readable":"node_modules/readable-stream/readable-browser.js"}],"node_modules/stream-browserify/index.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":"node_modules/events/events.js","inherits":"node_modules/inherits/inherits_browser.js","readable-stream/readable.js":"node_modules/readable-stream/readable-browser.js","readable-stream/writable.js":"node_modules/readable-stream/writable-browser.js","readable-stream/duplex.js":"node_modules/readable-stream/duplex-browser.js","readable-stream/transform.js":"node_modules/readable-stream/transform.js","readable-stream/passthrough.js":"node_modules/readable-stream/passthrough.js"}],"node_modules/safe-buffer/index.js":[function(require,module,exports) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":"node_modules/buffer/index.js"}],"node_modules/string_decoder/lib/string_decoder.js":[function(require,module,exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":"node_modules/safe-buffer/index.js"}],"node_modules/sax/lib/sax.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = require('stream').Stream
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = require('string_decoder').StringDecoder
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace (c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote (c) {
    return c === '"' || c === '\''
  }

  function isAttribEnd (c) {
    return c === '>' || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})(typeof exports === 'undefined' ? this.sax = {} : exports)

},{"stream":"node_modules/stream-browserify/index.js","string_decoder":"node_modules/string_decoder/lib/string_decoder.js","buffer":"node_modules/buffer/index.js"}],"node_modules/domelementtype/index.js":[function(require,module,exports) {
//Types of elements found in the DOM
module.exports = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>
	Doctype: "doctype",

	isTag: function(elem){
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};

},{}],"node_modules/dom-serializer/node_modules/domelementtype/lib/index.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
    return (elem.type === "tag" /* Tag */ ||
        elem.type === "script" /* Script */ ||
        elem.type === "style" /* Style */);
}
exports.isTag = isTag;
// Exports for backwards compatibility
exports.Text = "text" /* Text */; //Text
exports.Directive = "directive" /* Directive */; //<? ... ?>
exports.Comment = "comment" /* Comment */; //<!-- ... -->
exports.Script = "script" /* Script */; //<script> tags
exports.Style = "style" /* Style */; //<style> tags
exports.Tag = "tag" /* Tag */; //Any tag
exports.CDATA = "cdata" /* CDATA */; //<![CDATA[ ... ]]>
exports.Doctype = "doctype" /* Doctype */;

},{}],"node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json":[function(require,module,exports) {
module.exports = { "Aacute": "\u00C1", "aacute": "\u00E1", "Abreve": "\u0102", "abreve": "\u0103", "ac": "\u223E", "acd": "\u223F", "acE": "\u223E\u0333", "Acirc": "\u00C2", "acirc": "\u00E2", "acute": "\u00B4", "Acy": "\u0410", "acy": "\u0430", "AElig": "\u00C6", "aelig": "\u00E6", "af": "\u2061", "Afr": "\uD835\uDD04", "afr": "\uD835\uDD1E", "Agrave": "\u00C0", "agrave": "\u00E0", "alefsym": "\u2135", "aleph": "\u2135", "Alpha": "\u0391", "alpha": "\u03B1", "Amacr": "\u0100", "amacr": "\u0101", "amalg": "\u2A3F", "amp": "&", "AMP": "&", "andand": "\u2A55", "And": "\u2A53", "and": "\u2227", "andd": "\u2A5C", "andslope": "\u2A58", "andv": "\u2A5A", "ang": "\u2220", "ange": "\u29A4", "angle": "\u2220", "angmsdaa": "\u29A8", "angmsdab": "\u29A9", "angmsdac": "\u29AA", "angmsdad": "\u29AB", "angmsdae": "\u29AC", "angmsdaf": "\u29AD", "angmsdag": "\u29AE", "angmsdah": "\u29AF", "angmsd": "\u2221", "angrt": "\u221F", "angrtvb": "\u22BE", "angrtvbd": "\u299D", "angsph": "\u2222", "angst": "\u00C5", "angzarr": "\u237C", "Aogon": "\u0104", "aogon": "\u0105", "Aopf": "\uD835\uDD38", "aopf": "\uD835\uDD52", "apacir": "\u2A6F", "ap": "\u2248", "apE": "\u2A70", "ape": "\u224A", "apid": "\u224B", "apos": "'", "ApplyFunction": "\u2061", "approx": "\u2248", "approxeq": "\u224A", "Aring": "\u00C5", "aring": "\u00E5", "Ascr": "\uD835\uDC9C", "ascr": "\uD835\uDCB6", "Assign": "\u2254", "ast": "*", "asymp": "\u2248", "asympeq": "\u224D", "Atilde": "\u00C3", "atilde": "\u00E3", "Auml": "\u00C4", "auml": "\u00E4", "awconint": "\u2233", "awint": "\u2A11", "backcong": "\u224C", "backepsilon": "\u03F6", "backprime": "\u2035", "backsim": "\u223D", "backsimeq": "\u22CD", "Backslash": "\u2216", "Barv": "\u2AE7", "barvee": "\u22BD", "barwed": "\u2305", "Barwed": "\u2306", "barwedge": "\u2305", "bbrk": "\u23B5", "bbrktbrk": "\u23B6", "bcong": "\u224C", "Bcy": "\u0411", "bcy": "\u0431", "bdquo": "\u201E", "becaus": "\u2235", "because": "\u2235", "Because": "\u2235", "bemptyv": "\u29B0", "bepsi": "\u03F6", "bernou": "\u212C", "Bernoullis": "\u212C", "Beta": "\u0392", "beta": "\u03B2", "beth": "\u2136", "between": "\u226C", "Bfr": "\uD835\uDD05", "bfr": "\uD835\uDD1F", "bigcap": "\u22C2", "bigcirc": "\u25EF", "bigcup": "\u22C3", "bigodot": "\u2A00", "bigoplus": "\u2A01", "bigotimes": "\u2A02", "bigsqcup": "\u2A06", "bigstar": "\u2605", "bigtriangledown": "\u25BD", "bigtriangleup": "\u25B3", "biguplus": "\u2A04", "bigvee": "\u22C1", "bigwedge": "\u22C0", "bkarow": "\u290D", "blacklozenge": "\u29EB", "blacksquare": "\u25AA", "blacktriangle": "\u25B4", "blacktriangledown": "\u25BE", "blacktriangleleft": "\u25C2", "blacktriangleright": "\u25B8", "blank": "\u2423", "blk12": "\u2592", "blk14": "\u2591", "blk34": "\u2593", "block": "\u2588", "bne": "=\u20E5", "bnequiv": "\u2261\u20E5", "bNot": "\u2AED", "bnot": "\u2310", "Bopf": "\uD835\uDD39", "bopf": "\uD835\uDD53", "bot": "\u22A5", "bottom": "\u22A5", "bowtie": "\u22C8", "boxbox": "\u29C9", "boxdl": "\u2510", "boxdL": "\u2555", "boxDl": "\u2556", "boxDL": "\u2557", "boxdr": "\u250C", "boxdR": "\u2552", "boxDr": "\u2553", "boxDR": "\u2554", "boxh": "\u2500", "boxH": "\u2550", "boxhd": "\u252C", "boxHd": "\u2564", "boxhD": "\u2565", "boxHD": "\u2566", "boxhu": "\u2534", "boxHu": "\u2567", "boxhU": "\u2568", "boxHU": "\u2569", "boxminus": "\u229F", "boxplus": "\u229E", "boxtimes": "\u22A0", "boxul": "\u2518", "boxuL": "\u255B", "boxUl": "\u255C", "boxUL": "\u255D", "boxur": "\u2514", "boxuR": "\u2558", "boxUr": "\u2559", "boxUR": "\u255A", "boxv": "\u2502", "boxV": "\u2551", "boxvh": "\u253C", "boxvH": "\u256A", "boxVh": "\u256B", "boxVH": "\u256C", "boxvl": "\u2524", "boxvL": "\u2561", "boxVl": "\u2562", "boxVL": "\u2563", "boxvr": "\u251C", "boxvR": "\u255E", "boxVr": "\u255F", "boxVR": "\u2560", "bprime": "\u2035", "breve": "\u02D8", "Breve": "\u02D8", "brvbar": "\u00A6", "bscr": "\uD835\uDCB7", "Bscr": "\u212C", "bsemi": "\u204F", "bsim": "\u223D", "bsime": "\u22CD", "bsolb": "\u29C5", "bsol": "\\", "bsolhsub": "\u27C8", "bull": "\u2022", "bullet": "\u2022", "bump": "\u224E", "bumpE": "\u2AAE", "bumpe": "\u224F", "Bumpeq": "\u224E", "bumpeq": "\u224F", "Cacute": "\u0106", "cacute": "\u0107", "capand": "\u2A44", "capbrcup": "\u2A49", "capcap": "\u2A4B", "cap": "\u2229", "Cap": "\u22D2", "capcup": "\u2A47", "capdot": "\u2A40", "CapitalDifferentialD": "\u2145", "caps": "\u2229\uFE00", "caret": "\u2041", "caron": "\u02C7", "Cayleys": "\u212D", "ccaps": "\u2A4D", "Ccaron": "\u010C", "ccaron": "\u010D", "Ccedil": "\u00C7", "ccedil": "\u00E7", "Ccirc": "\u0108", "ccirc": "\u0109", "Cconint": "\u2230", "ccups": "\u2A4C", "ccupssm": "\u2A50", "Cdot": "\u010A", "cdot": "\u010B", "cedil": "\u00B8", "Cedilla": "\u00B8", "cemptyv": "\u29B2", "cent": "\u00A2", "centerdot": "\u00B7", "CenterDot": "\u00B7", "cfr": "\uD835\uDD20", "Cfr": "\u212D", "CHcy": "\u0427", "chcy": "\u0447", "check": "\u2713", "checkmark": "\u2713", "Chi": "\u03A7", "chi": "\u03C7", "circ": "\u02C6", "circeq": "\u2257", "circlearrowleft": "\u21BA", "circlearrowright": "\u21BB", "circledast": "\u229B", "circledcirc": "\u229A", "circleddash": "\u229D", "CircleDot": "\u2299", "circledR": "\u00AE", "circledS": "\u24C8", "CircleMinus": "\u2296", "CirclePlus": "\u2295", "CircleTimes": "\u2297", "cir": "\u25CB", "cirE": "\u29C3", "cire": "\u2257", "cirfnint": "\u2A10", "cirmid": "\u2AEF", "cirscir": "\u29C2", "ClockwiseContourIntegral": "\u2232", "CloseCurlyDoubleQuote": "\u201D", "CloseCurlyQuote": "\u2019", "clubs": "\u2663", "clubsuit": "\u2663", "colon": ":", "Colon": "\u2237", "Colone": "\u2A74", "colone": "\u2254", "coloneq": "\u2254", "comma": ",", "commat": "@", "comp": "\u2201", "compfn": "\u2218", "complement": "\u2201", "complexes": "\u2102", "cong": "\u2245", "congdot": "\u2A6D", "Congruent": "\u2261", "conint": "\u222E", "Conint": "\u222F", "ContourIntegral": "\u222E", "copf": "\uD835\uDD54", "Copf": "\u2102", "coprod": "\u2210", "Coproduct": "\u2210", "copy": "\u00A9", "COPY": "\u00A9", "copysr": "\u2117", "CounterClockwiseContourIntegral": "\u2233", "crarr": "\u21B5", "cross": "\u2717", "Cross": "\u2A2F", "Cscr": "\uD835\uDC9E", "cscr": "\uD835\uDCB8", "csub": "\u2ACF", "csube": "\u2AD1", "csup": "\u2AD0", "csupe": "\u2AD2", "ctdot": "\u22EF", "cudarrl": "\u2938", "cudarrr": "\u2935", "cuepr": "\u22DE", "cuesc": "\u22DF", "cularr": "\u21B6", "cularrp": "\u293D", "cupbrcap": "\u2A48", "cupcap": "\u2A46", "CupCap": "\u224D", "cup": "\u222A", "Cup": "\u22D3", "cupcup": "\u2A4A", "cupdot": "\u228D", "cupor": "\u2A45", "cups": "\u222A\uFE00", "curarr": "\u21B7", "curarrm": "\u293C", "curlyeqprec": "\u22DE", "curlyeqsucc": "\u22DF", "curlyvee": "\u22CE", "curlywedge": "\u22CF", "curren": "\u00A4", "curvearrowleft": "\u21B6", "curvearrowright": "\u21B7", "cuvee": "\u22CE", "cuwed": "\u22CF", "cwconint": "\u2232", "cwint": "\u2231", "cylcty": "\u232D", "dagger": "\u2020", "Dagger": "\u2021", "daleth": "\u2138", "darr": "\u2193", "Darr": "\u21A1", "dArr": "\u21D3", "dash": "\u2010", "Dashv": "\u2AE4", "dashv": "\u22A3", "dbkarow": "\u290F", "dblac": "\u02DD", "Dcaron": "\u010E", "dcaron": "\u010F", "Dcy": "\u0414", "dcy": "\u0434", "ddagger": "\u2021", "ddarr": "\u21CA", "DD": "\u2145", "dd": "\u2146", "DDotrahd": "\u2911", "ddotseq": "\u2A77", "deg": "\u00B0", "Del": "\u2207", "Delta": "\u0394", "delta": "\u03B4", "demptyv": "\u29B1", "dfisht": "\u297F", "Dfr": "\uD835\uDD07", "dfr": "\uD835\uDD21", "dHar": "\u2965", "dharl": "\u21C3", "dharr": "\u21C2", "DiacriticalAcute": "\u00B4", "DiacriticalDot": "\u02D9", "DiacriticalDoubleAcute": "\u02DD", "DiacriticalGrave": "`", "DiacriticalTilde": "\u02DC", "diam": "\u22C4", "diamond": "\u22C4", "Diamond": "\u22C4", "diamondsuit": "\u2666", "diams": "\u2666", "die": "\u00A8", "DifferentialD": "\u2146", "digamma": "\u03DD", "disin": "\u22F2", "div": "\u00F7", "divide": "\u00F7", "divideontimes": "\u22C7", "divonx": "\u22C7", "DJcy": "\u0402", "djcy": "\u0452", "dlcorn": "\u231E", "dlcrop": "\u230D", "dollar": "$", "Dopf": "\uD835\uDD3B", "dopf": "\uD835\uDD55", "Dot": "\u00A8", "dot": "\u02D9", "DotDot": "\u20DC", "doteq": "\u2250", "doteqdot": "\u2251", "DotEqual": "\u2250", "dotminus": "\u2238", "dotplus": "\u2214", "dotsquare": "\u22A1", "doublebarwedge": "\u2306", "DoubleContourIntegral": "\u222F", "DoubleDot": "\u00A8", "DoubleDownArrow": "\u21D3", "DoubleLeftArrow": "\u21D0", "DoubleLeftRightArrow": "\u21D4", "DoubleLeftTee": "\u2AE4", "DoubleLongLeftArrow": "\u27F8", "DoubleLongLeftRightArrow": "\u27FA", "DoubleLongRightArrow": "\u27F9", "DoubleRightArrow": "\u21D2", "DoubleRightTee": "\u22A8", "DoubleUpArrow": "\u21D1", "DoubleUpDownArrow": "\u21D5", "DoubleVerticalBar": "\u2225", "DownArrowBar": "\u2913", "downarrow": "\u2193", "DownArrow": "\u2193", "Downarrow": "\u21D3", "DownArrowUpArrow": "\u21F5", "DownBreve": "\u0311", "downdownarrows": "\u21CA", "downharpoonleft": "\u21C3", "downharpoonright": "\u21C2", "DownLeftRightVector": "\u2950", "DownLeftTeeVector": "\u295E", "DownLeftVectorBar": "\u2956", "DownLeftVector": "\u21BD", "DownRightTeeVector": "\u295F", "DownRightVectorBar": "\u2957", "DownRightVector": "\u21C1", "DownTeeArrow": "\u21A7", "DownTee": "\u22A4", "drbkarow": "\u2910", "drcorn": "\u231F", "drcrop": "\u230C", "Dscr": "\uD835\uDC9F", "dscr": "\uD835\uDCB9", "DScy": "\u0405", "dscy": "\u0455", "dsol": "\u29F6", "Dstrok": "\u0110", "dstrok": "\u0111", "dtdot": "\u22F1", "dtri": "\u25BF", "dtrif": "\u25BE", "duarr": "\u21F5", "duhar": "\u296F", "dwangle": "\u29A6", "DZcy": "\u040F", "dzcy": "\u045F", "dzigrarr": "\u27FF", "Eacute": "\u00C9", "eacute": "\u00E9", "easter": "\u2A6E", "Ecaron": "\u011A", "ecaron": "\u011B", "Ecirc": "\u00CA", "ecirc": "\u00EA", "ecir": "\u2256", "ecolon": "\u2255", "Ecy": "\u042D", "ecy": "\u044D", "eDDot": "\u2A77", "Edot": "\u0116", "edot": "\u0117", "eDot": "\u2251", "ee": "\u2147", "efDot": "\u2252", "Efr": "\uD835\uDD08", "efr": "\uD835\uDD22", "eg": "\u2A9A", "Egrave": "\u00C8", "egrave": "\u00E8", "egs": "\u2A96", "egsdot": "\u2A98", "el": "\u2A99", "Element": "\u2208", "elinters": "\u23E7", "ell": "\u2113", "els": "\u2A95", "elsdot": "\u2A97", "Emacr": "\u0112", "emacr": "\u0113", "empty": "\u2205", "emptyset": "\u2205", "EmptySmallSquare": "\u25FB", "emptyv": "\u2205", "EmptyVerySmallSquare": "\u25AB", "emsp13": "\u2004", "emsp14": "\u2005", "emsp": "\u2003", "ENG": "\u014A", "eng": "\u014B", "ensp": "\u2002", "Eogon": "\u0118", "eogon": "\u0119", "Eopf": "\uD835\uDD3C", "eopf": "\uD835\uDD56", "epar": "\u22D5", "eparsl": "\u29E3", "eplus": "\u2A71", "epsi": "\u03B5", "Epsilon": "\u0395", "epsilon": "\u03B5", "epsiv": "\u03F5", "eqcirc": "\u2256", "eqcolon": "\u2255", "eqsim": "\u2242", "eqslantgtr": "\u2A96", "eqslantless": "\u2A95", "Equal": "\u2A75", "equals": "=", "EqualTilde": "\u2242", "equest": "\u225F", "Equilibrium": "\u21CC", "equiv": "\u2261", "equivDD": "\u2A78", "eqvparsl": "\u29E5", "erarr": "\u2971", "erDot": "\u2253", "escr": "\u212F", "Escr": "\u2130", "esdot": "\u2250", "Esim": "\u2A73", "esim": "\u2242", "Eta": "\u0397", "eta": "\u03B7", "ETH": "\u00D0", "eth": "\u00F0", "Euml": "\u00CB", "euml": "\u00EB", "euro": "\u20AC", "excl": "!", "exist": "\u2203", "Exists": "\u2203", "expectation": "\u2130", "exponentiale": "\u2147", "ExponentialE": "\u2147", "fallingdotseq": "\u2252", "Fcy": "\u0424", "fcy": "\u0444", "female": "\u2640", "ffilig": "\uFB03", "fflig": "\uFB00", "ffllig": "\uFB04", "Ffr": "\uD835\uDD09", "ffr": "\uD835\uDD23", "filig": "\uFB01", "FilledSmallSquare": "\u25FC", "FilledVerySmallSquare": "\u25AA", "fjlig": "fj", "flat": "\u266D", "fllig": "\uFB02", "fltns": "\u25B1", "fnof": "\u0192", "Fopf": "\uD835\uDD3D", "fopf": "\uD835\uDD57", "forall": "\u2200", "ForAll": "\u2200", "fork": "\u22D4", "forkv": "\u2AD9", "Fouriertrf": "\u2131", "fpartint": "\u2A0D", "frac12": "\u00BD", "frac13": "\u2153", "frac14": "\u00BC", "frac15": "\u2155", "frac16": "\u2159", "frac18": "\u215B", "frac23": "\u2154", "frac25": "\u2156", "frac34": "\u00BE", "frac35": "\u2157", "frac38": "\u215C", "frac45": "\u2158", "frac56": "\u215A", "frac58": "\u215D", "frac78": "\u215E", "frasl": "\u2044", "frown": "\u2322", "fscr": "\uD835\uDCBB", "Fscr": "\u2131", "gacute": "\u01F5", "Gamma": "\u0393", "gamma": "\u03B3", "Gammad": "\u03DC", "gammad": "\u03DD", "gap": "\u2A86", "Gbreve": "\u011E", "gbreve": "\u011F", "Gcedil": "\u0122", "Gcirc": "\u011C", "gcirc": "\u011D", "Gcy": "\u0413", "gcy": "\u0433", "Gdot": "\u0120", "gdot": "\u0121", "ge": "\u2265", "gE": "\u2267", "gEl": "\u2A8C", "gel": "\u22DB", "geq": "\u2265", "geqq": "\u2267", "geqslant": "\u2A7E", "gescc": "\u2AA9", "ges": "\u2A7E", "gesdot": "\u2A80", "gesdoto": "\u2A82", "gesdotol": "\u2A84", "gesl": "\u22DB\uFE00", "gesles": "\u2A94", "Gfr": "\uD835\uDD0A", "gfr": "\uD835\uDD24", "gg": "\u226B", "Gg": "\u22D9", "ggg": "\u22D9", "gimel": "\u2137", "GJcy": "\u0403", "gjcy": "\u0453", "gla": "\u2AA5", "gl": "\u2277", "glE": "\u2A92", "glj": "\u2AA4", "gnap": "\u2A8A", "gnapprox": "\u2A8A", "gne": "\u2A88", "gnE": "\u2269", "gneq": "\u2A88", "gneqq": "\u2269", "gnsim": "\u22E7", "Gopf": "\uD835\uDD3E", "gopf": "\uD835\uDD58", "grave": "`", "GreaterEqual": "\u2265", "GreaterEqualLess": "\u22DB", "GreaterFullEqual": "\u2267", "GreaterGreater": "\u2AA2", "GreaterLess": "\u2277", "GreaterSlantEqual": "\u2A7E", "GreaterTilde": "\u2273", "Gscr": "\uD835\uDCA2", "gscr": "\u210A", "gsim": "\u2273", "gsime": "\u2A8E", "gsiml": "\u2A90", "gtcc": "\u2AA7", "gtcir": "\u2A7A", "gt": ">", "GT": ">", "Gt": "\u226B", "gtdot": "\u22D7", "gtlPar": "\u2995", "gtquest": "\u2A7C", "gtrapprox": "\u2A86", "gtrarr": "\u2978", "gtrdot": "\u22D7", "gtreqless": "\u22DB", "gtreqqless": "\u2A8C", "gtrless": "\u2277", "gtrsim": "\u2273", "gvertneqq": "\u2269\uFE00", "gvnE": "\u2269\uFE00", "Hacek": "\u02C7", "hairsp": "\u200A", "half": "\u00BD", "hamilt": "\u210B", "HARDcy": "\u042A", "hardcy": "\u044A", "harrcir": "\u2948", "harr": "\u2194", "hArr": "\u21D4", "harrw": "\u21AD", "Hat": "^", "hbar": "\u210F", "Hcirc": "\u0124", "hcirc": "\u0125", "hearts": "\u2665", "heartsuit": "\u2665", "hellip": "\u2026", "hercon": "\u22B9", "hfr": "\uD835\uDD25", "Hfr": "\u210C", "HilbertSpace": "\u210B", "hksearow": "\u2925", "hkswarow": "\u2926", "hoarr": "\u21FF", "homtht": "\u223B", "hookleftarrow": "\u21A9", "hookrightarrow": "\u21AA", "hopf": "\uD835\uDD59", "Hopf": "\u210D", "horbar": "\u2015", "HorizontalLine": "\u2500", "hscr": "\uD835\uDCBD", "Hscr": "\u210B", "hslash": "\u210F", "Hstrok": "\u0126", "hstrok": "\u0127", "HumpDownHump": "\u224E", "HumpEqual": "\u224F", "hybull": "\u2043", "hyphen": "\u2010", "Iacute": "\u00CD", "iacute": "\u00ED", "ic": "\u2063", "Icirc": "\u00CE", "icirc": "\u00EE", "Icy": "\u0418", "icy": "\u0438", "Idot": "\u0130", "IEcy": "\u0415", "iecy": "\u0435", "iexcl": "\u00A1", "iff": "\u21D4", "ifr": "\uD835\uDD26", "Ifr": "\u2111", "Igrave": "\u00CC", "igrave": "\u00EC", "ii": "\u2148", "iiiint": "\u2A0C", "iiint": "\u222D", "iinfin": "\u29DC", "iiota": "\u2129", "IJlig": "\u0132", "ijlig": "\u0133", "Imacr": "\u012A", "imacr": "\u012B", "image": "\u2111", "ImaginaryI": "\u2148", "imagline": "\u2110", "imagpart": "\u2111", "imath": "\u0131", "Im": "\u2111", "imof": "\u22B7", "imped": "\u01B5", "Implies": "\u21D2", "incare": "\u2105", "in": "\u2208", "infin": "\u221E", "infintie": "\u29DD", "inodot": "\u0131", "intcal": "\u22BA", "int": "\u222B", "Int": "\u222C", "integers": "\u2124", "Integral": "\u222B", "intercal": "\u22BA", "Intersection": "\u22C2", "intlarhk": "\u2A17", "intprod": "\u2A3C", "InvisibleComma": "\u2063", "InvisibleTimes": "\u2062", "IOcy": "\u0401", "iocy": "\u0451", "Iogon": "\u012E", "iogon": "\u012F", "Iopf": "\uD835\uDD40", "iopf": "\uD835\uDD5A", "Iota": "\u0399", "iota": "\u03B9", "iprod": "\u2A3C", "iquest": "\u00BF", "iscr": "\uD835\uDCBE", "Iscr": "\u2110", "isin": "\u2208", "isindot": "\u22F5", "isinE": "\u22F9", "isins": "\u22F4", "isinsv": "\u22F3", "isinv": "\u2208", "it": "\u2062", "Itilde": "\u0128", "itilde": "\u0129", "Iukcy": "\u0406", "iukcy": "\u0456", "Iuml": "\u00CF", "iuml": "\u00EF", "Jcirc": "\u0134", "jcirc": "\u0135", "Jcy": "\u0419", "jcy": "\u0439", "Jfr": "\uD835\uDD0D", "jfr": "\uD835\uDD27", "jmath": "\u0237", "Jopf": "\uD835\uDD41", "jopf": "\uD835\uDD5B", "Jscr": "\uD835\uDCA5", "jscr": "\uD835\uDCBF", "Jsercy": "\u0408", "jsercy": "\u0458", "Jukcy": "\u0404", "jukcy": "\u0454", "Kappa": "\u039A", "kappa": "\u03BA", "kappav": "\u03F0", "Kcedil": "\u0136", "kcedil": "\u0137", "Kcy": "\u041A", "kcy": "\u043A", "Kfr": "\uD835\uDD0E", "kfr": "\uD835\uDD28", "kgreen": "\u0138", "KHcy": "\u0425", "khcy": "\u0445", "KJcy": "\u040C", "kjcy": "\u045C", "Kopf": "\uD835\uDD42", "kopf": "\uD835\uDD5C", "Kscr": "\uD835\uDCA6", "kscr": "\uD835\uDCC0", "lAarr": "\u21DA", "Lacute": "\u0139", "lacute": "\u013A", "laemptyv": "\u29B4", "lagran": "\u2112", "Lambda": "\u039B", "lambda": "\u03BB", "lang": "\u27E8", "Lang": "\u27EA", "langd": "\u2991", "langle": "\u27E8", "lap": "\u2A85", "Laplacetrf": "\u2112", "laquo": "\u00AB", "larrb": "\u21E4", "larrbfs": "\u291F", "larr": "\u2190", "Larr": "\u219E", "lArr": "\u21D0", "larrfs": "\u291D", "larrhk": "\u21A9", "larrlp": "\u21AB", "larrpl": "\u2939", "larrsim": "\u2973", "larrtl": "\u21A2", "latail": "\u2919", "lAtail": "\u291B", "lat": "\u2AAB", "late": "\u2AAD", "lates": "\u2AAD\uFE00", "lbarr": "\u290C", "lBarr": "\u290E", "lbbrk": "\u2772", "lbrace": "{", "lbrack": "[", "lbrke": "\u298B", "lbrksld": "\u298F", "lbrkslu": "\u298D", "Lcaron": "\u013D", "lcaron": "\u013E", "Lcedil": "\u013B", "lcedil": "\u013C", "lceil": "\u2308", "lcub": "{", "Lcy": "\u041B", "lcy": "\u043B", "ldca": "\u2936", "ldquo": "\u201C", "ldquor": "\u201E", "ldrdhar": "\u2967", "ldrushar": "\u294B", "ldsh": "\u21B2", "le": "\u2264", "lE": "\u2266", "LeftAngleBracket": "\u27E8", "LeftArrowBar": "\u21E4", "leftarrow": "\u2190", "LeftArrow": "\u2190", "Leftarrow": "\u21D0", "LeftArrowRightArrow": "\u21C6", "leftarrowtail": "\u21A2", "LeftCeiling": "\u2308", "LeftDoubleBracket": "\u27E6", "LeftDownTeeVector": "\u2961", "LeftDownVectorBar": "\u2959", "LeftDownVector": "\u21C3", "LeftFloor": "\u230A", "leftharpoondown": "\u21BD", "leftharpoonup": "\u21BC", "leftleftarrows": "\u21C7", "leftrightarrow": "\u2194", "LeftRightArrow": "\u2194", "Leftrightarrow": "\u21D4", "leftrightarrows": "\u21C6", "leftrightharpoons": "\u21CB", "leftrightsquigarrow": "\u21AD", "LeftRightVector": "\u294E", "LeftTeeArrow": "\u21A4", "LeftTee": "\u22A3", "LeftTeeVector": "\u295A", "leftthreetimes": "\u22CB", "LeftTriangleBar": "\u29CF", "LeftTriangle": "\u22B2", "LeftTriangleEqual": "\u22B4", "LeftUpDownVector": "\u2951", "LeftUpTeeVector": "\u2960", "LeftUpVectorBar": "\u2958", "LeftUpVector": "\u21BF", "LeftVectorBar": "\u2952", "LeftVector": "\u21BC", "lEg": "\u2A8B", "leg": "\u22DA", "leq": "\u2264", "leqq": "\u2266", "leqslant": "\u2A7D", "lescc": "\u2AA8", "les": "\u2A7D", "lesdot": "\u2A7F", "lesdoto": "\u2A81", "lesdotor": "\u2A83", "lesg": "\u22DA\uFE00", "lesges": "\u2A93", "lessapprox": "\u2A85", "lessdot": "\u22D6", "lesseqgtr": "\u22DA", "lesseqqgtr": "\u2A8B", "LessEqualGreater": "\u22DA", "LessFullEqual": "\u2266", "LessGreater": "\u2276", "lessgtr": "\u2276", "LessLess": "\u2AA1", "lesssim": "\u2272", "LessSlantEqual": "\u2A7D", "LessTilde": "\u2272", "lfisht": "\u297C", "lfloor": "\u230A", "Lfr": "\uD835\uDD0F", "lfr": "\uD835\uDD29", "lg": "\u2276", "lgE": "\u2A91", "lHar": "\u2962", "lhard": "\u21BD", "lharu": "\u21BC", "lharul": "\u296A", "lhblk": "\u2584", "LJcy": "\u0409", "ljcy": "\u0459", "llarr": "\u21C7", "ll": "\u226A", "Ll": "\u22D8", "llcorner": "\u231E", "Lleftarrow": "\u21DA", "llhard": "\u296B", "lltri": "\u25FA", "Lmidot": "\u013F", "lmidot": "\u0140", "lmoustache": "\u23B0", "lmoust": "\u23B0", "lnap": "\u2A89", "lnapprox": "\u2A89", "lne": "\u2A87", "lnE": "\u2268", "lneq": "\u2A87", "lneqq": "\u2268", "lnsim": "\u22E6", "loang": "\u27EC", "loarr": "\u21FD", "lobrk": "\u27E6", "longleftarrow": "\u27F5", "LongLeftArrow": "\u27F5", "Longleftarrow": "\u27F8", "longleftrightarrow": "\u27F7", "LongLeftRightArrow": "\u27F7", "Longleftrightarrow": "\u27FA", "longmapsto": "\u27FC", "longrightarrow": "\u27F6", "LongRightArrow": "\u27F6", "Longrightarrow": "\u27F9", "looparrowleft": "\u21AB", "looparrowright": "\u21AC", "lopar": "\u2985", "Lopf": "\uD835\uDD43", "lopf": "\uD835\uDD5D", "loplus": "\u2A2D", "lotimes": "\u2A34", "lowast": "\u2217", "lowbar": "_", "LowerLeftArrow": "\u2199", "LowerRightArrow": "\u2198", "loz": "\u25CA", "lozenge": "\u25CA", "lozf": "\u29EB", "lpar": "(", "lparlt": "\u2993", "lrarr": "\u21C6", "lrcorner": "\u231F", "lrhar": "\u21CB", "lrhard": "\u296D", "lrm": "\u200E", "lrtri": "\u22BF", "lsaquo": "\u2039", "lscr": "\uD835\uDCC1", "Lscr": "\u2112", "lsh": "\u21B0", "Lsh": "\u21B0", "lsim": "\u2272", "lsime": "\u2A8D", "lsimg": "\u2A8F", "lsqb": "[", "lsquo": "\u2018", "lsquor": "\u201A", "Lstrok": "\u0141", "lstrok": "\u0142", "ltcc": "\u2AA6", "ltcir": "\u2A79", "lt": "<", "LT": "<", "Lt": "\u226A", "ltdot": "\u22D6", "lthree": "\u22CB", "ltimes": "\u22C9", "ltlarr": "\u2976", "ltquest": "\u2A7B", "ltri": "\u25C3", "ltrie": "\u22B4", "ltrif": "\u25C2", "ltrPar": "\u2996", "lurdshar": "\u294A", "luruhar": "\u2966", "lvertneqq": "\u2268\uFE00", "lvnE": "\u2268\uFE00", "macr": "\u00AF", "male": "\u2642", "malt": "\u2720", "maltese": "\u2720", "Map": "\u2905", "map": "\u21A6", "mapsto": "\u21A6", "mapstodown": "\u21A7", "mapstoleft": "\u21A4", "mapstoup": "\u21A5", "marker": "\u25AE", "mcomma": "\u2A29", "Mcy": "\u041C", "mcy": "\u043C", "mdash": "\u2014", "mDDot": "\u223A", "measuredangle": "\u2221", "MediumSpace": "\u205F", "Mellintrf": "\u2133", "Mfr": "\uD835\uDD10", "mfr": "\uD835\uDD2A", "mho": "\u2127", "micro": "\u00B5", "midast": "*", "midcir": "\u2AF0", "mid": "\u2223", "middot": "\u00B7", "minusb": "\u229F", "minus": "\u2212", "minusd": "\u2238", "minusdu": "\u2A2A", "MinusPlus": "\u2213", "mlcp": "\u2ADB", "mldr": "\u2026", "mnplus": "\u2213", "models": "\u22A7", "Mopf": "\uD835\uDD44", "mopf": "\uD835\uDD5E", "mp": "\u2213", "mscr": "\uD835\uDCC2", "Mscr": "\u2133", "mstpos": "\u223E", "Mu": "\u039C", "mu": "\u03BC", "multimap": "\u22B8", "mumap": "\u22B8", "nabla": "\u2207", "Nacute": "\u0143", "nacute": "\u0144", "nang": "\u2220\u20D2", "nap": "\u2249", "napE": "\u2A70\u0338", "napid": "\u224B\u0338", "napos": "\u0149", "napprox": "\u2249", "natural": "\u266E", "naturals": "\u2115", "natur": "\u266E", "nbsp": "\u00A0", "nbump": "\u224E\u0338", "nbumpe": "\u224F\u0338", "ncap": "\u2A43", "Ncaron": "\u0147", "ncaron": "\u0148", "Ncedil": "\u0145", "ncedil": "\u0146", "ncong": "\u2247", "ncongdot": "\u2A6D\u0338", "ncup": "\u2A42", "Ncy": "\u041D", "ncy": "\u043D", "ndash": "\u2013", "nearhk": "\u2924", "nearr": "\u2197", "neArr": "\u21D7", "nearrow": "\u2197", "ne": "\u2260", "nedot": "\u2250\u0338", "NegativeMediumSpace": "\u200B", "NegativeThickSpace": "\u200B", "NegativeThinSpace": "\u200B", "NegativeVeryThinSpace": "\u200B", "nequiv": "\u2262", "nesear": "\u2928", "nesim": "\u2242\u0338", "NestedGreaterGreater": "\u226B", "NestedLessLess": "\u226A", "NewLine": "\n", "nexist": "\u2204", "nexists": "\u2204", "Nfr": "\uD835\uDD11", "nfr": "\uD835\uDD2B", "ngE": "\u2267\u0338", "nge": "\u2271", "ngeq": "\u2271", "ngeqq": "\u2267\u0338", "ngeqslant": "\u2A7E\u0338", "nges": "\u2A7E\u0338", "nGg": "\u22D9\u0338", "ngsim": "\u2275", "nGt": "\u226B\u20D2", "ngt": "\u226F", "ngtr": "\u226F", "nGtv": "\u226B\u0338", "nharr": "\u21AE", "nhArr": "\u21CE", "nhpar": "\u2AF2", "ni": "\u220B", "nis": "\u22FC", "nisd": "\u22FA", "niv": "\u220B", "NJcy": "\u040A", "njcy": "\u045A", "nlarr": "\u219A", "nlArr": "\u21CD", "nldr": "\u2025", "nlE": "\u2266\u0338", "nle": "\u2270", "nleftarrow": "\u219A", "nLeftarrow": "\u21CD", "nleftrightarrow": "\u21AE", "nLeftrightarrow": "\u21CE", "nleq": "\u2270", "nleqq": "\u2266\u0338", "nleqslant": "\u2A7D\u0338", "nles": "\u2A7D\u0338", "nless": "\u226E", "nLl": "\u22D8\u0338", "nlsim": "\u2274", "nLt": "\u226A\u20D2", "nlt": "\u226E", "nltri": "\u22EA", "nltrie": "\u22EC", "nLtv": "\u226A\u0338", "nmid": "\u2224", "NoBreak": "\u2060", "NonBreakingSpace": "\u00A0", "nopf": "\uD835\uDD5F", "Nopf": "\u2115", "Not": "\u2AEC", "not": "\u00AC", "NotCongruent": "\u2262", "NotCupCap": "\u226D", "NotDoubleVerticalBar": "\u2226", "NotElement": "\u2209", "NotEqual": "\u2260", "NotEqualTilde": "\u2242\u0338", "NotExists": "\u2204", "NotGreater": "\u226F", "NotGreaterEqual": "\u2271", "NotGreaterFullEqual": "\u2267\u0338", "NotGreaterGreater": "\u226B\u0338", "NotGreaterLess": "\u2279", "NotGreaterSlantEqual": "\u2A7E\u0338", "NotGreaterTilde": "\u2275", "NotHumpDownHump": "\u224E\u0338", "NotHumpEqual": "\u224F\u0338", "notin": "\u2209", "notindot": "\u22F5\u0338", "notinE": "\u22F9\u0338", "notinva": "\u2209", "notinvb": "\u22F7", "notinvc": "\u22F6", "NotLeftTriangleBar": "\u29CF\u0338", "NotLeftTriangle": "\u22EA", "NotLeftTriangleEqual": "\u22EC", "NotLess": "\u226E", "NotLessEqual": "\u2270", "NotLessGreater": "\u2278", "NotLessLess": "\u226A\u0338", "NotLessSlantEqual": "\u2A7D\u0338", "NotLessTilde": "\u2274", "NotNestedGreaterGreater": "\u2AA2\u0338", "NotNestedLessLess": "\u2AA1\u0338", "notni": "\u220C", "notniva": "\u220C", "notnivb": "\u22FE", "notnivc": "\u22FD", "NotPrecedes": "\u2280", "NotPrecedesEqual": "\u2AAF\u0338", "NotPrecedesSlantEqual": "\u22E0", "NotReverseElement": "\u220C", "NotRightTriangleBar": "\u29D0\u0338", "NotRightTriangle": "\u22EB", "NotRightTriangleEqual": "\u22ED", "NotSquareSubset": "\u228F\u0338", "NotSquareSubsetEqual": "\u22E2", "NotSquareSuperset": "\u2290\u0338", "NotSquareSupersetEqual": "\u22E3", "NotSubset": "\u2282\u20D2", "NotSubsetEqual": "\u2288", "NotSucceeds": "\u2281", "NotSucceedsEqual": "\u2AB0\u0338", "NotSucceedsSlantEqual": "\u22E1", "NotSucceedsTilde": "\u227F\u0338", "NotSuperset": "\u2283\u20D2", "NotSupersetEqual": "\u2289", "NotTilde": "\u2241", "NotTildeEqual": "\u2244", "NotTildeFullEqual": "\u2247", "NotTildeTilde": "\u2249", "NotVerticalBar": "\u2224", "nparallel": "\u2226", "npar": "\u2226", "nparsl": "\u2AFD\u20E5", "npart": "\u2202\u0338", "npolint": "\u2A14", "npr": "\u2280", "nprcue": "\u22E0", "nprec": "\u2280", "npreceq": "\u2AAF\u0338", "npre": "\u2AAF\u0338", "nrarrc": "\u2933\u0338", "nrarr": "\u219B", "nrArr": "\u21CF", "nrarrw": "\u219D\u0338", "nrightarrow": "\u219B", "nRightarrow": "\u21CF", "nrtri": "\u22EB", "nrtrie": "\u22ED", "nsc": "\u2281", "nsccue": "\u22E1", "nsce": "\u2AB0\u0338", "Nscr": "\uD835\uDCA9", "nscr": "\uD835\uDCC3", "nshortmid": "\u2224", "nshortparallel": "\u2226", "nsim": "\u2241", "nsime": "\u2244", "nsimeq": "\u2244", "nsmid": "\u2224", "nspar": "\u2226", "nsqsube": "\u22E2", "nsqsupe": "\u22E3", "nsub": "\u2284", "nsubE": "\u2AC5\u0338", "nsube": "\u2288", "nsubset": "\u2282\u20D2", "nsubseteq": "\u2288", "nsubseteqq": "\u2AC5\u0338", "nsucc": "\u2281", "nsucceq": "\u2AB0\u0338", "nsup": "\u2285", "nsupE": "\u2AC6\u0338", "nsupe": "\u2289", "nsupset": "\u2283\u20D2", "nsupseteq": "\u2289", "nsupseteqq": "\u2AC6\u0338", "ntgl": "\u2279", "Ntilde": "\u00D1", "ntilde": "\u00F1", "ntlg": "\u2278", "ntriangleleft": "\u22EA", "ntrianglelefteq": "\u22EC", "ntriangleright": "\u22EB", "ntrianglerighteq": "\u22ED", "Nu": "\u039D", "nu": "\u03BD", "num": "#", "numero": "\u2116", "numsp": "\u2007", "nvap": "\u224D\u20D2", "nvdash": "\u22AC", "nvDash": "\u22AD", "nVdash": "\u22AE", "nVDash": "\u22AF", "nvge": "\u2265\u20D2", "nvgt": ">\u20D2", "nvHarr": "\u2904", "nvinfin": "\u29DE", "nvlArr": "\u2902", "nvle": "\u2264\u20D2", "nvlt": "<\u20D2", "nvltrie": "\u22B4\u20D2", "nvrArr": "\u2903", "nvrtrie": "\u22B5\u20D2", "nvsim": "\u223C\u20D2", "nwarhk": "\u2923", "nwarr": "\u2196", "nwArr": "\u21D6", "nwarrow": "\u2196", "nwnear": "\u2927", "Oacute": "\u00D3", "oacute": "\u00F3", "oast": "\u229B", "Ocirc": "\u00D4", "ocirc": "\u00F4", "ocir": "\u229A", "Ocy": "\u041E", "ocy": "\u043E", "odash": "\u229D", "Odblac": "\u0150", "odblac": "\u0151", "odiv": "\u2A38", "odot": "\u2299", "odsold": "\u29BC", "OElig": "\u0152", "oelig": "\u0153", "ofcir": "\u29BF", "Ofr": "\uD835\uDD12", "ofr": "\uD835\uDD2C", "ogon": "\u02DB", "Ograve": "\u00D2", "ograve": "\u00F2", "ogt": "\u29C1", "ohbar": "\u29B5", "ohm": "\u03A9", "oint": "\u222E", "olarr": "\u21BA", "olcir": "\u29BE", "olcross": "\u29BB", "oline": "\u203E", "olt": "\u29C0", "Omacr": "\u014C", "omacr": "\u014D", "Omega": "\u03A9", "omega": "\u03C9", "Omicron": "\u039F", "omicron": "\u03BF", "omid": "\u29B6", "ominus": "\u2296", "Oopf": "\uD835\uDD46", "oopf": "\uD835\uDD60", "opar": "\u29B7", "OpenCurlyDoubleQuote": "\u201C", "OpenCurlyQuote": "\u2018", "operp": "\u29B9", "oplus": "\u2295", "orarr": "\u21BB", "Or": "\u2A54", "or": "\u2228", "ord": "\u2A5D", "order": "\u2134", "orderof": "\u2134", "ordf": "\u00AA", "ordm": "\u00BA", "origof": "\u22B6", "oror": "\u2A56", "orslope": "\u2A57", "orv": "\u2A5B", "oS": "\u24C8", "Oscr": "\uD835\uDCAA", "oscr": "\u2134", "Oslash": "\u00D8", "oslash": "\u00F8", "osol": "\u2298", "Otilde": "\u00D5", "otilde": "\u00F5", "otimesas": "\u2A36", "Otimes": "\u2A37", "otimes": "\u2297", "Ouml": "\u00D6", "ouml": "\u00F6", "ovbar": "\u233D", "OverBar": "\u203E", "OverBrace": "\u23DE", "OverBracket": "\u23B4", "OverParenthesis": "\u23DC", "para": "\u00B6", "parallel": "\u2225", "par": "\u2225", "parsim": "\u2AF3", "parsl": "\u2AFD", "part": "\u2202", "PartialD": "\u2202", "Pcy": "\u041F", "pcy": "\u043F", "percnt": "%", "period": ".", "permil": "\u2030", "perp": "\u22A5", "pertenk": "\u2031", "Pfr": "\uD835\uDD13", "pfr": "\uD835\uDD2D", "Phi": "\u03A6", "phi": "\u03C6", "phiv": "\u03D5", "phmmat": "\u2133", "phone": "\u260E", "Pi": "\u03A0", "pi": "\u03C0", "pitchfork": "\u22D4", "piv": "\u03D6", "planck": "\u210F", "planckh": "\u210E", "plankv": "\u210F", "plusacir": "\u2A23", "plusb": "\u229E", "pluscir": "\u2A22", "plus": "+", "plusdo": "\u2214", "plusdu": "\u2A25", "pluse": "\u2A72", "PlusMinus": "\u00B1", "plusmn": "\u00B1", "plussim": "\u2A26", "plustwo": "\u2A27", "pm": "\u00B1", "Poincareplane": "\u210C", "pointint": "\u2A15", "popf": "\uD835\uDD61", "Popf": "\u2119", "pound": "\u00A3", "prap": "\u2AB7", "Pr": "\u2ABB", "pr": "\u227A", "prcue": "\u227C", "precapprox": "\u2AB7", "prec": "\u227A", "preccurlyeq": "\u227C", "Precedes": "\u227A", "PrecedesEqual": "\u2AAF", "PrecedesSlantEqual": "\u227C", "PrecedesTilde": "\u227E", "preceq": "\u2AAF", "precnapprox": "\u2AB9", "precneqq": "\u2AB5", "precnsim": "\u22E8", "pre": "\u2AAF", "prE": "\u2AB3", "precsim": "\u227E", "prime": "\u2032", "Prime": "\u2033", "primes": "\u2119", "prnap": "\u2AB9", "prnE": "\u2AB5", "prnsim": "\u22E8", "prod": "\u220F", "Product": "\u220F", "profalar": "\u232E", "profline": "\u2312", "profsurf": "\u2313", "prop": "\u221D", "Proportional": "\u221D", "Proportion": "\u2237", "propto": "\u221D", "prsim": "\u227E", "prurel": "\u22B0", "Pscr": "\uD835\uDCAB", "pscr": "\uD835\uDCC5", "Psi": "\u03A8", "psi": "\u03C8", "puncsp": "\u2008", "Qfr": "\uD835\uDD14", "qfr": "\uD835\uDD2E", "qint": "\u2A0C", "qopf": "\uD835\uDD62", "Qopf": "\u211A", "qprime": "\u2057", "Qscr": "\uD835\uDCAC", "qscr": "\uD835\uDCC6", "quaternions": "\u210D", "quatint": "\u2A16", "quest": "?", "questeq": "\u225F", "quot": "\"", "QUOT": "\"", "rAarr": "\u21DB", "race": "\u223D\u0331", "Racute": "\u0154", "racute": "\u0155", "radic": "\u221A", "raemptyv": "\u29B3", "rang": "\u27E9", "Rang": "\u27EB", "rangd": "\u2992", "range": "\u29A5", "rangle": "\u27E9", "raquo": "\u00BB", "rarrap": "\u2975", "rarrb": "\u21E5", "rarrbfs": "\u2920", "rarrc": "\u2933", "rarr": "\u2192", "Rarr": "\u21A0", "rArr": "\u21D2", "rarrfs": "\u291E", "rarrhk": "\u21AA", "rarrlp": "\u21AC", "rarrpl": "\u2945", "rarrsim": "\u2974", "Rarrtl": "\u2916", "rarrtl": "\u21A3", "rarrw": "\u219D", "ratail": "\u291A", "rAtail": "\u291C", "ratio": "\u2236", "rationals": "\u211A", "rbarr": "\u290D", "rBarr": "\u290F", "RBarr": "\u2910", "rbbrk": "\u2773", "rbrace": "}", "rbrack": "]", "rbrke": "\u298C", "rbrksld": "\u298E", "rbrkslu": "\u2990", "Rcaron": "\u0158", "rcaron": "\u0159", "Rcedil": "\u0156", "rcedil": "\u0157", "rceil": "\u2309", "rcub": "}", "Rcy": "\u0420", "rcy": "\u0440", "rdca": "\u2937", "rdldhar": "\u2969", "rdquo": "\u201D", "rdquor": "\u201D", "rdsh": "\u21B3", "real": "\u211C", "realine": "\u211B", "realpart": "\u211C", "reals": "\u211D", "Re": "\u211C", "rect": "\u25AD", "reg": "\u00AE", "REG": "\u00AE", "ReverseElement": "\u220B", "ReverseEquilibrium": "\u21CB", "ReverseUpEquilibrium": "\u296F", "rfisht": "\u297D", "rfloor": "\u230B", "rfr": "\uD835\uDD2F", "Rfr": "\u211C", "rHar": "\u2964", "rhard": "\u21C1", "rharu": "\u21C0", "rharul": "\u296C", "Rho": "\u03A1", "rho": "\u03C1", "rhov": "\u03F1", "RightAngleBracket": "\u27E9", "RightArrowBar": "\u21E5", "rightarrow": "\u2192", "RightArrow": "\u2192", "Rightarrow": "\u21D2", "RightArrowLeftArrow": "\u21C4", "rightarrowtail": "\u21A3", "RightCeiling": "\u2309", "RightDoubleBracket": "\u27E7", "RightDownTeeVector": "\u295D", "RightDownVectorBar": "\u2955", "RightDownVector": "\u21C2", "RightFloor": "\u230B", "rightharpoondown": "\u21C1", "rightharpoonup": "\u21C0", "rightleftarrows": "\u21C4", "rightleftharpoons": "\u21CC", "rightrightarrows": "\u21C9", "rightsquigarrow": "\u219D", "RightTeeArrow": "\u21A6", "RightTee": "\u22A2", "RightTeeVector": "\u295B", "rightthreetimes": "\u22CC", "RightTriangleBar": "\u29D0", "RightTriangle": "\u22B3", "RightTriangleEqual": "\u22B5", "RightUpDownVector": "\u294F", "RightUpTeeVector": "\u295C", "RightUpVectorBar": "\u2954", "RightUpVector": "\u21BE", "RightVectorBar": "\u2953", "RightVector": "\u21C0", "ring": "\u02DA", "risingdotseq": "\u2253", "rlarr": "\u21C4", "rlhar": "\u21CC", "rlm": "\u200F", "rmoustache": "\u23B1", "rmoust": "\u23B1", "rnmid": "\u2AEE", "roang": "\u27ED", "roarr": "\u21FE", "robrk": "\u27E7", "ropar": "\u2986", "ropf": "\uD835\uDD63", "Ropf": "\u211D", "roplus": "\u2A2E", "rotimes": "\u2A35", "RoundImplies": "\u2970", "rpar": ")", "rpargt": "\u2994", "rppolint": "\u2A12", "rrarr": "\u21C9", "Rrightarrow": "\u21DB", "rsaquo": "\u203A", "rscr": "\uD835\uDCC7", "Rscr": "\u211B", "rsh": "\u21B1", "Rsh": "\u21B1", "rsqb": "]", "rsquo": "\u2019", "rsquor": "\u2019", "rthree": "\u22CC", "rtimes": "\u22CA", "rtri": "\u25B9", "rtrie": "\u22B5", "rtrif": "\u25B8", "rtriltri": "\u29CE", "RuleDelayed": "\u29F4", "ruluhar": "\u2968", "rx": "\u211E", "Sacute": "\u015A", "sacute": "\u015B", "sbquo": "\u201A", "scap": "\u2AB8", "Scaron": "\u0160", "scaron": "\u0161", "Sc": "\u2ABC", "sc": "\u227B", "sccue": "\u227D", "sce": "\u2AB0", "scE": "\u2AB4", "Scedil": "\u015E", "scedil": "\u015F", "Scirc": "\u015C", "scirc": "\u015D", "scnap": "\u2ABA", "scnE": "\u2AB6", "scnsim": "\u22E9", "scpolint": "\u2A13", "scsim": "\u227F", "Scy": "\u0421", "scy": "\u0441", "sdotb": "\u22A1", "sdot": "\u22C5", "sdote": "\u2A66", "searhk": "\u2925", "searr": "\u2198", "seArr": "\u21D8", "searrow": "\u2198", "sect": "\u00A7", "semi": ";", "seswar": "\u2929", "setminus": "\u2216", "setmn": "\u2216", "sext": "\u2736", "Sfr": "\uD835\uDD16", "sfr": "\uD835\uDD30", "sfrown": "\u2322", "sharp": "\u266F", "SHCHcy": "\u0429", "shchcy": "\u0449", "SHcy": "\u0428", "shcy": "\u0448", "ShortDownArrow": "\u2193", "ShortLeftArrow": "\u2190", "shortmid": "\u2223", "shortparallel": "\u2225", "ShortRightArrow": "\u2192", "ShortUpArrow": "\u2191", "shy": "\u00AD", "Sigma": "\u03A3", "sigma": "\u03C3", "sigmaf": "\u03C2", "sigmav": "\u03C2", "sim": "\u223C", "simdot": "\u2A6A", "sime": "\u2243", "simeq": "\u2243", "simg": "\u2A9E", "simgE": "\u2AA0", "siml": "\u2A9D", "simlE": "\u2A9F", "simne": "\u2246", "simplus": "\u2A24", "simrarr": "\u2972", "slarr": "\u2190", "SmallCircle": "\u2218", "smallsetminus": "\u2216", "smashp": "\u2A33", "smeparsl": "\u29E4", "smid": "\u2223", "smile": "\u2323", "smt": "\u2AAA", "smte": "\u2AAC", "smtes": "\u2AAC\uFE00", "SOFTcy": "\u042C", "softcy": "\u044C", "solbar": "\u233F", "solb": "\u29C4", "sol": "/", "Sopf": "\uD835\uDD4A", "sopf": "\uD835\uDD64", "spades": "\u2660", "spadesuit": "\u2660", "spar": "\u2225", "sqcap": "\u2293", "sqcaps": "\u2293\uFE00", "sqcup": "\u2294", "sqcups": "\u2294\uFE00", "Sqrt": "\u221A", "sqsub": "\u228F", "sqsube": "\u2291", "sqsubset": "\u228F", "sqsubseteq": "\u2291", "sqsup": "\u2290", "sqsupe": "\u2292", "sqsupset": "\u2290", "sqsupseteq": "\u2292", "square": "\u25A1", "Square": "\u25A1", "SquareIntersection": "\u2293", "SquareSubset": "\u228F", "SquareSubsetEqual": "\u2291", "SquareSuperset": "\u2290", "SquareSupersetEqual": "\u2292", "SquareUnion": "\u2294", "squarf": "\u25AA", "squ": "\u25A1", "squf": "\u25AA", "srarr": "\u2192", "Sscr": "\uD835\uDCAE", "sscr": "\uD835\uDCC8", "ssetmn": "\u2216", "ssmile": "\u2323", "sstarf": "\u22C6", "Star": "\u22C6", "star": "\u2606", "starf": "\u2605", "straightepsilon": "\u03F5", "straightphi": "\u03D5", "strns": "\u00AF", "sub": "\u2282", "Sub": "\u22D0", "subdot": "\u2ABD", "subE": "\u2AC5", "sube": "\u2286", "subedot": "\u2AC3", "submult": "\u2AC1", "subnE": "\u2ACB", "subne": "\u228A", "subplus": "\u2ABF", "subrarr": "\u2979", "subset": "\u2282", "Subset": "\u22D0", "subseteq": "\u2286", "subseteqq": "\u2AC5", "SubsetEqual": "\u2286", "subsetneq": "\u228A", "subsetneqq": "\u2ACB", "subsim": "\u2AC7", "subsub": "\u2AD5", "subsup": "\u2AD3", "succapprox": "\u2AB8", "succ": "\u227B", "succcurlyeq": "\u227D", "Succeeds": "\u227B", "SucceedsEqual": "\u2AB0", "SucceedsSlantEqual": "\u227D", "SucceedsTilde": "\u227F", "succeq": "\u2AB0", "succnapprox": "\u2ABA", "succneqq": "\u2AB6", "succnsim": "\u22E9", "succsim": "\u227F", "SuchThat": "\u220B", "sum": "\u2211", "Sum": "\u2211", "sung": "\u266A", "sup1": "\u00B9", "sup2": "\u00B2", "sup3": "\u00B3", "sup": "\u2283", "Sup": "\u22D1", "supdot": "\u2ABE", "supdsub": "\u2AD8", "supE": "\u2AC6", "supe": "\u2287", "supedot": "\u2AC4", "Superset": "\u2283", "SupersetEqual": "\u2287", "suphsol": "\u27C9", "suphsub": "\u2AD7", "suplarr": "\u297B", "supmult": "\u2AC2", "supnE": "\u2ACC", "supne": "\u228B", "supplus": "\u2AC0", "supset": "\u2283", "Supset": "\u22D1", "supseteq": "\u2287", "supseteqq": "\u2AC6", "supsetneq": "\u228B", "supsetneqq": "\u2ACC", "supsim": "\u2AC8", "supsub": "\u2AD4", "supsup": "\u2AD6", "swarhk": "\u2926", "swarr": "\u2199", "swArr": "\u21D9", "swarrow": "\u2199", "swnwar": "\u292A", "szlig": "\u00DF", "Tab": "\t", "target": "\u2316", "Tau": "\u03A4", "tau": "\u03C4", "tbrk": "\u23B4", "Tcaron": "\u0164", "tcaron": "\u0165", "Tcedil": "\u0162", "tcedil": "\u0163", "Tcy": "\u0422", "tcy": "\u0442", "tdot": "\u20DB", "telrec": "\u2315", "Tfr": "\uD835\uDD17", "tfr": "\uD835\uDD31", "there4": "\u2234", "therefore": "\u2234", "Therefore": "\u2234", "Theta": "\u0398", "theta": "\u03B8", "thetasym": "\u03D1", "thetav": "\u03D1", "thickapprox": "\u2248", "thicksim": "\u223C", "ThickSpace": "\u205F\u200A", "ThinSpace": "\u2009", "thinsp": "\u2009", "thkap": "\u2248", "thksim": "\u223C", "THORN": "\u00DE", "thorn": "\u00FE", "tilde": "\u02DC", "Tilde": "\u223C", "TildeEqual": "\u2243", "TildeFullEqual": "\u2245", "TildeTilde": "\u2248", "timesbar": "\u2A31", "timesb": "\u22A0", "times": "\u00D7", "timesd": "\u2A30", "tint": "\u222D", "toea": "\u2928", "topbot": "\u2336", "topcir": "\u2AF1", "top": "\u22A4", "Topf": "\uD835\uDD4B", "topf": "\uD835\uDD65", "topfork": "\u2ADA", "tosa": "\u2929", "tprime": "\u2034", "trade": "\u2122", "TRADE": "\u2122", "triangle": "\u25B5", "triangledown": "\u25BF", "triangleleft": "\u25C3", "trianglelefteq": "\u22B4", "triangleq": "\u225C", "triangleright": "\u25B9", "trianglerighteq": "\u22B5", "tridot": "\u25EC", "trie": "\u225C", "triminus": "\u2A3A", "TripleDot": "\u20DB", "triplus": "\u2A39", "trisb": "\u29CD", "tritime": "\u2A3B", "trpezium": "\u23E2", "Tscr": "\uD835\uDCAF", "tscr": "\uD835\uDCC9", "TScy": "\u0426", "tscy": "\u0446", "TSHcy": "\u040B", "tshcy": "\u045B", "Tstrok": "\u0166", "tstrok": "\u0167", "twixt": "\u226C", "twoheadleftarrow": "\u219E", "twoheadrightarrow": "\u21A0", "Uacute": "\u00DA", "uacute": "\u00FA", "uarr": "\u2191", "Uarr": "\u219F", "uArr": "\u21D1", "Uarrocir": "\u2949", "Ubrcy": "\u040E", "ubrcy": "\u045E", "Ubreve": "\u016C", "ubreve": "\u016D", "Ucirc": "\u00DB", "ucirc": "\u00FB", "Ucy": "\u0423", "ucy": "\u0443", "udarr": "\u21C5", "Udblac": "\u0170", "udblac": "\u0171", "udhar": "\u296E", "ufisht": "\u297E", "Ufr": "\uD835\uDD18", "ufr": "\uD835\uDD32", "Ugrave": "\u00D9", "ugrave": "\u00F9", "uHar": "\u2963", "uharl": "\u21BF", "uharr": "\u21BE", "uhblk": "\u2580", "ulcorn": "\u231C", "ulcorner": "\u231C", "ulcrop": "\u230F", "ultri": "\u25F8", "Umacr": "\u016A", "umacr": "\u016B", "uml": "\u00A8", "UnderBar": "_", "UnderBrace": "\u23DF", "UnderBracket": "\u23B5", "UnderParenthesis": "\u23DD", "Union": "\u22C3", "UnionPlus": "\u228E", "Uogon": "\u0172", "uogon": "\u0173", "Uopf": "\uD835\uDD4C", "uopf": "\uD835\uDD66", "UpArrowBar": "\u2912", "uparrow": "\u2191", "UpArrow": "\u2191", "Uparrow": "\u21D1", "UpArrowDownArrow": "\u21C5", "updownarrow": "\u2195", "UpDownArrow": "\u2195", "Updownarrow": "\u21D5", "UpEquilibrium": "\u296E", "upharpoonleft": "\u21BF", "upharpoonright": "\u21BE", "uplus": "\u228E", "UpperLeftArrow": "\u2196", "UpperRightArrow": "\u2197", "upsi": "\u03C5", "Upsi": "\u03D2", "upsih": "\u03D2", "Upsilon": "\u03A5", "upsilon": "\u03C5", "UpTeeArrow": "\u21A5", "UpTee": "\u22A5", "upuparrows": "\u21C8", "urcorn": "\u231D", "urcorner": "\u231D", "urcrop": "\u230E", "Uring": "\u016E", "uring": "\u016F", "urtri": "\u25F9", "Uscr": "\uD835\uDCB0", "uscr": "\uD835\uDCCA", "utdot": "\u22F0", "Utilde": "\u0168", "utilde": "\u0169", "utri": "\u25B5", "utrif": "\u25B4", "uuarr": "\u21C8", "Uuml": "\u00DC", "uuml": "\u00FC", "uwangle": "\u29A7", "vangrt": "\u299C", "varepsilon": "\u03F5", "varkappa": "\u03F0", "varnothing": "\u2205", "varphi": "\u03D5", "varpi": "\u03D6", "varpropto": "\u221D", "varr": "\u2195", "vArr": "\u21D5", "varrho": "\u03F1", "varsigma": "\u03C2", "varsubsetneq": "\u228A\uFE00", "varsubsetneqq": "\u2ACB\uFE00", "varsupsetneq": "\u228B\uFE00", "varsupsetneqq": "\u2ACC\uFE00", "vartheta": "\u03D1", "vartriangleleft": "\u22B2", "vartriangleright": "\u22B3", "vBar": "\u2AE8", "Vbar": "\u2AEB", "vBarv": "\u2AE9", "Vcy": "\u0412", "vcy": "\u0432", "vdash": "\u22A2", "vDash": "\u22A8", "Vdash": "\u22A9", "VDash": "\u22AB", "Vdashl": "\u2AE6", "veebar": "\u22BB", "vee": "\u2228", "Vee": "\u22C1", "veeeq": "\u225A", "vellip": "\u22EE", "verbar": "|", "Verbar": "\u2016", "vert": "|", "Vert": "\u2016", "VerticalBar": "\u2223", "VerticalLine": "|", "VerticalSeparator": "\u2758", "VerticalTilde": "\u2240", "VeryThinSpace": "\u200A", "Vfr": "\uD835\uDD19", "vfr": "\uD835\uDD33", "vltri": "\u22B2", "vnsub": "\u2282\u20D2", "vnsup": "\u2283\u20D2", "Vopf": "\uD835\uDD4D", "vopf": "\uD835\uDD67", "vprop": "\u221D", "vrtri": "\u22B3", "Vscr": "\uD835\uDCB1", "vscr": "\uD835\uDCCB", "vsubnE": "\u2ACB\uFE00", "vsubne": "\u228A\uFE00", "vsupnE": "\u2ACC\uFE00", "vsupne": "\u228B\uFE00", "Vvdash": "\u22AA", "vzigzag": "\u299A", "Wcirc": "\u0174", "wcirc": "\u0175", "wedbar": "\u2A5F", "wedge": "\u2227", "Wedge": "\u22C0", "wedgeq": "\u2259", "weierp": "\u2118", "Wfr": "\uD835\uDD1A", "wfr": "\uD835\uDD34", "Wopf": "\uD835\uDD4E", "wopf": "\uD835\uDD68", "wp": "\u2118", "wr": "\u2240", "wreath": "\u2240", "Wscr": "\uD835\uDCB2", "wscr": "\uD835\uDCCC", "xcap": "\u22C2", "xcirc": "\u25EF", "xcup": "\u22C3", "xdtri": "\u25BD", "Xfr": "\uD835\uDD1B", "xfr": "\uD835\uDD35", "xharr": "\u27F7", "xhArr": "\u27FA", "Xi": "\u039E", "xi": "\u03BE", "xlarr": "\u27F5", "xlArr": "\u27F8", "xmap": "\u27FC", "xnis": "\u22FB", "xodot": "\u2A00", "Xopf": "\uD835\uDD4F", "xopf": "\uD835\uDD69", "xoplus": "\u2A01", "xotime": "\u2A02", "xrarr": "\u27F6", "xrArr": "\u27F9", "Xscr": "\uD835\uDCB3", "xscr": "\uD835\uDCCD", "xsqcup": "\u2A06", "xuplus": "\u2A04", "xutri": "\u25B3", "xvee": "\u22C1", "xwedge": "\u22C0", "Yacute": "\u00DD", "yacute": "\u00FD", "YAcy": "\u042F", "yacy": "\u044F", "Ycirc": "\u0176", "ycirc": "\u0177", "Ycy": "\u042B", "ycy": "\u044B", "yen": "\u00A5", "Yfr": "\uD835\uDD1C", "yfr": "\uD835\uDD36", "YIcy": "\u0407", "yicy": "\u0457", "Yopf": "\uD835\uDD50", "yopf": "\uD835\uDD6A", "Yscr": "\uD835\uDCB4", "yscr": "\uD835\uDCCE", "YUcy": "\u042E", "yucy": "\u044E", "yuml": "\u00FF", "Yuml": "\u0178", "Zacute": "\u0179", "zacute": "\u017A", "Zcaron": "\u017D", "zcaron": "\u017E", "Zcy": "\u0417", "zcy": "\u0437", "Zdot": "\u017B", "zdot": "\u017C", "zeetrf": "\u2128", "ZeroWidthSpace": "\u200B", "Zeta": "\u0396", "zeta": "\u03B6", "zfr": "\uD835\uDD37", "Zfr": "\u2128", "ZHcy": "\u0416", "zhcy": "\u0436", "zigrarr": "\u21DD", "zopf": "\uD835\uDD6B", "Zopf": "\u2124", "Zscr": "\uD835\uDCB5", "zscr": "\uD835\uDCCF", "zwj": "\u200D", "zwnj": "\u200C" }
;
},{}],"node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json":[function(require,module,exports) {
module.exports = { "Aacute": "\u00C1", "aacute": "\u00E1", "Acirc": "\u00C2", "acirc": "\u00E2", "acute": "\u00B4", "AElig": "\u00C6", "aelig": "\u00E6", "Agrave": "\u00C0", "agrave": "\u00E0", "amp": "&", "AMP": "&", "Aring": "\u00C5", "aring": "\u00E5", "Atilde": "\u00C3", "atilde": "\u00E3", "Auml": "\u00C4", "auml": "\u00E4", "brvbar": "\u00A6", "Ccedil": "\u00C7", "ccedil": "\u00E7", "cedil": "\u00B8", "cent": "\u00A2", "copy": "\u00A9", "COPY": "\u00A9", "curren": "\u00A4", "deg": "\u00B0", "divide": "\u00F7", "Eacute": "\u00C9", "eacute": "\u00E9", "Ecirc": "\u00CA", "ecirc": "\u00EA", "Egrave": "\u00C8", "egrave": "\u00E8", "ETH": "\u00D0", "eth": "\u00F0", "Euml": "\u00CB", "euml": "\u00EB", "frac12": "\u00BD", "frac14": "\u00BC", "frac34": "\u00BE", "gt": ">", "GT": ">", "Iacute": "\u00CD", "iacute": "\u00ED", "Icirc": "\u00CE", "icirc": "\u00EE", "iexcl": "\u00A1", "Igrave": "\u00CC", "igrave": "\u00EC", "iquest": "\u00BF", "Iuml": "\u00CF", "iuml": "\u00EF", "laquo": "\u00AB", "lt": "<", "LT": "<", "macr": "\u00AF", "micro": "\u00B5", "middot": "\u00B7", "nbsp": "\u00A0", "not": "\u00AC", "Ntilde": "\u00D1", "ntilde": "\u00F1", "Oacute": "\u00D3", "oacute": "\u00F3", "Ocirc": "\u00D4", "ocirc": "\u00F4", "Ograve": "\u00D2", "ograve": "\u00F2", "ordf": "\u00AA", "ordm": "\u00BA", "Oslash": "\u00D8", "oslash": "\u00F8", "Otilde": "\u00D5", "otilde": "\u00F5", "Ouml": "\u00D6", "ouml": "\u00F6", "para": "\u00B6", "plusmn": "\u00B1", "pound": "\u00A3", "quot": "\"", "QUOT": "\"", "raquo": "\u00BB", "reg": "\u00AE", "REG": "\u00AE", "sect": "\u00A7", "shy": "\u00AD", "sup1": "\u00B9", "sup2": "\u00B2", "sup3": "\u00B3", "szlig": "\u00DF", "THORN": "\u00DE", "thorn": "\u00FE", "times": "\u00D7", "Uacute": "\u00DA", "uacute": "\u00FA", "Ucirc": "\u00DB", "ucirc": "\u00FB", "Ugrave": "\u00D9", "ugrave": "\u00F9", "uml": "\u00A8", "Uuml": "\u00DC", "uuml": "\u00FC", "Yacute": "\u00DD", "yacute": "\u00FD", "yen": "\u00A5", "yuml": "\u00FF" }
;
},{}],"node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json":[function(require,module,exports) {
module.exports = { "amp": "&", "apos": "'", "gt": ">", "lt": "<", "quot": "\"" }
;
},{}],"node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json":[function(require,module,exports) {
module.exports = {
    "0": 65533,
    "128": 8364,
    "130": 8218,
    "131": 402,
    "132": 8222,
    "133": 8230,
    "134": 8224,
    "135": 8225,
    "136": 710,
    "137": 8240,
    "138": 352,
    "139": 8249,
    "140": 338,
    "142": 381,
    "145": 8216,
    "146": 8217,
    "147": 8220,
    "148": 8221,
    "149": 8226,
    "150": 8211,
    "151": 8212,
    "152": 732,
    "153": 8482,
    "154": 353,
    "155": 8250,
    "156": 339,
    "158": 382,
    "159": 376
}
;
},{}],"node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js":[function(require,module,exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var decode_json_1 = __importDefault(require("./maps/decode.json"));
// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }
    if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
    }
    var output = "";
    if (codePoint > 0xffff) {
        codePoint -= 0x10000;
        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
        codePoint = 0xdc00 | (codePoint & 0x3ff);
    }
    output += String.fromCharCode(codePoint);
    return output;
}
exports.default = decodeCodePoint;

},{"./maps/decode.json":"node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json"}],"node_modules/dom-serializer/node_modules/entities/lib/decode.js":[function(require,module,exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var entities_json_1 = __importDefault(require("./maps/entities.json"));
var legacy_json_1 = __importDefault(require("./maps/legacy.json"));
var xml_json_1 = __importDefault(require("./maps/xml.json"));
var decode_codepoint_1 = __importDefault(require("./decode_codepoint"));
exports.decodeXML = getStrictDecoder(xml_json_1.default);
exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
function getStrictDecoder(map) {
    var keys = Object.keys(map).join("|");
    var replace = getReplacer(map);
    keys += "|#[xX][\\da-fA-F]+|#\\d+";
    var re = new RegExp("&(?:" + keys + ");", "g");
    return function (str) { return String(str).replace(re, replace); };
}
var sorter = function (a, b) { return (a < b ? 1 : -1); };
exports.decodeHTML = (function () {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
        }
        else {
            keys[i] += ";";
        }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1.default);
    function replacer(str) {
        if (str.substr(-1) !== ";")
            str += ";";
        return replace(str);
    }
    //TODO consider creating a merged map
    return function (str) { return String(str).replace(re, replacer); };
})();
function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            if (secondChar === "X" || secondChar === "x") {
                return decode_codepoint_1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        return map[str.slice(1, -1)];
    };
}

},{"./maps/entities.json":"node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json","./maps/legacy.json":"node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json","./maps/xml.json":"node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json","./decode_codepoint":"node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js"}],"node_modules/dom-serializer/node_modules/entities/lib/encode.js":[function(require,module,exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var xml_json_1 = __importDefault(require("./maps/xml.json"));
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
exports.encodeXML = getInverse(inverseXML, xmlReplacer);
var entities_json_1 = __importDefault(require("./maps/entities.json"));
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
function getInverseObj(obj) {
    return Object.keys(obj)
        .sort()
        .reduce(function (inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
    }, {});
}
function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
            // Add value to single array
            single.push("\\" + k);
        }
        else {
            // Add value to multiple array
            multiple.push(k);
        }
    }
    // Add ranges to single characters.
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
        // Find the end of a run of characters
        var end = start;
        while (end < single.length - 1 &&
            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
            end += 1;
        }
        var count = 1 + end - start;
        // We want to replace at least three characters
        if (count < 3)
            continue;
        single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
}
var reNonASCII = /[^\0-\x7F]/gu;
function singleCharReplacer(c) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return "&#x" + c.codePointAt(0).toString(16).toUpperCase() + ";";
}
function getInverse(inverse, re) {
    return function (data) {
        return data
            .replace(re, function (name) { return inverse[name]; })
            .replace(reNonASCII, singleCharReplacer);
    };
}
var reXmlChars = getInverseReplacer(inverseXML);
function escape(data) {
    return data
        .replace(reXmlChars, singleCharReplacer)
        .replace(reNonASCII, singleCharReplacer);
}
exports.escape = escape;

},{"./maps/xml.json":"node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json","./maps/entities.json":"node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json"}],"node_modules/dom-serializer/node_modules/entities/lib/index.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var decode_1 = require("./decode");
var encode_1 = require("./encode");
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 */
function decode(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}
exports.decode = decode;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 */
function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
 */
function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}
exports.encode = encode;
var encode_2 = require("./encode");
exports.encodeXML = encode_2.encodeXML;
exports.encodeHTML = encode_2.encodeHTML;
exports.escape = encode_2.escape;
// Legacy aliases
exports.encodeHTML4 = encode_2.encodeHTML;
exports.encodeHTML5 = encode_2.encodeHTML;
var decode_2 = require("./decode");
exports.decodeXML = decode_2.decodeXML;
exports.decodeHTML = decode_2.decodeHTML;
exports.decodeHTMLStrict = decode_2.decodeHTMLStrict;
// Legacy aliases
exports.decodeHTML4 = decode_2.decodeHTML;
exports.decodeHTML5 = decode_2.decodeHTML;
exports.decodeHTML4Strict = decode_2.decodeHTMLStrict;
exports.decodeHTML5Strict = decode_2.decodeHTMLStrict;
exports.decodeXMLStrict = decode_2.decodeXML;

},{"./decode":"node_modules/dom-serializer/node_modules/entities/lib/decode.js","./encode":"node_modules/dom-serializer/node_modules/entities/lib/encode.js"}],"node_modules/dom-serializer/foreignNames.json":[function(require,module,exports) {
module.exports = {
  "elementNames" : {
"altglyph" : "altGlyph",
"altglyphdef" : "altGlyphDef",
"altglyphitem" : "altGlyphItem",
"animatecolor" : "animateColor",
"animatemotion" : "animateMotion",
"animatetransform" : "animateTransform",
"clippath" : "clipPath",
"feblend" : "feBlend",
"fecolormatrix" : "feColorMatrix",
"fecomponenttransfer" : "feComponentTransfer",
"fecomposite" : "feComposite",
"feconvolvematrix" : "feConvolveMatrix",
"fediffuselighting" : "feDiffuseLighting",
"fedisplacementmap" : "feDisplacementMap",
"fedistantlight" : "feDistantLight",
"fedropshadow" : "feDropShadow",
"feflood" : "feFlood",
"fefunca" : "feFuncA",
"fefuncb" : "feFuncB",
"fefuncg" : "feFuncG",
"fefuncr" : "feFuncR",
"fegaussianblur" : "feGaussianBlur",
"feimage" : "feImage",
"femerge" : "feMerge",
"femergenode" : "feMergeNode",
"femorphology" : "feMorphology",
"feoffset" : "feOffset",
"fepointlight" : "fePointLight",
"fespecularlighting" : "feSpecularLighting",
"fespotlight" : "feSpotLight",
"fetile" : "feTile",
"feturbulence" : "feTurbulence",
"foreignobject" : "foreignObject",
"glyphref" : "glyphRef",
"lineargradient" : "linearGradient",
"radialgradient" : "radialGradient",
"textpath" : "textPath"
  },
  "attributeNames" : {
"definitionurl" : "definitionURL",
"attributename" : "attributeName",
"attributetype" : "attributeType",
"basefrequency" : "baseFrequency",
"baseprofile" : "baseProfile",
"calcmode" : "calcMode",
"clippathunits" : "clipPathUnits",
"diffuseconstant" : "diffuseConstant",
"edgemode" : "edgeMode",
"filterunits" : "filterUnits",
"glyphref" : "glyphRef",
"gradienttransform" : "gradientTransform",
"gradientunits" : "gradientUnits",
"kernelmatrix" : "kernelMatrix",
"kernelunitlength" : "kernelUnitLength",
"keypoints" : "keyPoints",
"keysplines" : "keySplines",
"keytimes" : "keyTimes",
"lengthadjust" : "lengthAdjust",
"limitingconeangle" : "limitingConeAngle",
"markerheight" : "markerHeight",
"markerunits" : "markerUnits",
"markerwidth" : "markerWidth",
"maskcontentunits" : "maskContentUnits",
"maskunits" : "maskUnits",
"numoctaves" : "numOctaves",
"pathlength" : "pathLength",
"patterncontentunits" : "patternContentUnits",
"patterntransform" : "patternTransform",
"patternunits" : "patternUnits",
"pointsatx" : "pointsAtX",
"pointsaty" : "pointsAtY",
"pointsatz" : "pointsAtZ",
"preservealpha" : "preserveAlpha",
"preserveaspectratio" : "preserveAspectRatio",
"primitiveunits" : "primitiveUnits",
"refx" : "refX",
"refy" : "refY",
"repeatcount" : "repeatCount",
"repeatdur" : "repeatDur",
"requiredextensions" : "requiredExtensions",
"requiredfeatures" : "requiredFeatures",
"specularconstant" : "specularConstant",
"specularexponent" : "specularExponent",
"spreadmethod" : "spreadMethod",
"startoffset" : "startOffset",
"stddeviation" : "stdDeviation",
"stitchtiles" : "stitchTiles",
"surfacescale" : "surfaceScale",
"systemlanguage" : "systemLanguage",
"tablevalues" : "tableValues",
"targetx" : "targetX",
"targety" : "targetY",
"textlength" : "textLength",
"viewbox" : "viewBox",
"viewtarget" : "viewTarget",
"xchannelselector" : "xChannelSelector",
"ychannelselector" : "yChannelSelector",
"zoomandpan" : "zoomAndPan"
  }
}
;
},{}],"node_modules/dom-serializer/index.js":[function(require,module,exports) {
/*
  Module dependencies
*/
var ElementType = require('domelementtype');
var entities = require('entities');

/* mixed-case SVG and MathML tags & attributes
   recognized by the HTML parser, see
   https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
*/
var foreignNames = require('./foreignNames.json');
foreignNames.elementNames.__proto__ = null; /* use as a simple dictionary */
foreignNames.attributeNames.__proto__ = null;

var unencodedElements = {
  __proto__: null,
  style: true,
  script: true,
  xmp: true,
  iframe: true,
  noembed: true,
  noframes: true,
  plaintext: true,
  noscript: true
};

/*
  Format attributes
*/
function formatAttrs(attributes, opts) {
  if (!attributes) return;

  var output = '';
  var value;

  // Loop through the attributes
  for (var key in attributes) {
    value = attributes[key];
    if (output) {
      output += ' ';
    }

    if (opts.xmlMode === 'foreign') {
      /* fix up mixed-case attribute names */
      key = foreignNames.attributeNames[key] || key;
    }
    output += key;
    if ((value !== null && value !== '') || opts.xmlMode) {
      output +=
        '="' +
        (opts.decodeEntities
          ? entities.encodeXML(value)
          : value.replace(/\"/g, '&quot;')) +
        '"';
    }
  }

  return output;
}

/*
  Self-enclosing tags (stolen from node-htmlparser)
*/
var singleTag = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

var render = (module.exports = function(dom, opts) {
  if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
  opts = opts || {};

  var output = '';

  for (var i = 0; i < dom.length; i++) {
    var elem = dom[i];

    if (elem.type === 'root') output += render(elem.children, opts);
    else if (ElementType.isTag(elem)) output += renderTag(elem, opts);
    else if (elem.type === ElementType.Directive)
      output += renderDirective(elem);
    else if (elem.type === ElementType.Comment) output += renderComment(elem);
    else if (elem.type === ElementType.CDATA) output += renderCdata(elem);
    else output += renderText(elem, opts);
  }

  return output;
});

var foreignModeIntegrationPoints = [
  'mi',
  'mo',
  'mn',
  'ms',
  'mtext',
  'annotation-xml',
  'foreignObject',
  'desc',
  'title'
];

function renderTag(elem, opts) {
  // Handle SVG / MathML in HTML
  if (opts.xmlMode === 'foreign') {
    /* fix up mixed-case element names */
    elem.name = foreignNames.elementNames[elem.name] || elem.name;
    /* exit foreign mode at integration points */
    if (
      elem.parent &&
      foreignModeIntegrationPoints.indexOf(elem.parent.name) >= 0
    )
      opts = Object.assign({}, opts, { xmlMode: false });
  }
  if (!opts.xmlMode && ['svg', 'math'].indexOf(elem.name) >= 0) {
    opts = Object.assign({}, opts, { xmlMode: 'foreign' });
  }

  var tag = '<' + elem.name;
  var attribs = formatAttrs(elem.attribs, opts);

  if (attribs) {
    tag += ' ' + attribs;
  }

  if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
    tag += '/>';
  } else {
    tag += '>';
    if (elem.children) {
      tag += render(elem.children, opts);
    }

    if (!singleTag[elem.name] || opts.xmlMode) {
      tag += '</' + elem.name + '>';
    }
  }

  return tag;
}

function renderDirective(elem) {
  return '<' + elem.data + '>';
}

function renderText(elem, opts) {
  var data = elem.data || '';

  // if entities weren't decoded, no need to encode them back
  if (
    opts.decodeEntities &&
    !(elem.parent && elem.parent.name in unencodedElements)
  ) {
    data = entities.encodeXML(data);
  }

  return data;
}

function renderCdata(elem) {
  return '<![CDATA[' + elem.children[0].data + ']]>';
}

function renderComment(elem) {
  return '<!--' + elem.data + '-->';
}

},{"domelementtype":"node_modules/dom-serializer/node_modules/domelementtype/lib/index.js","entities":"node_modules/dom-serializer/node_modules/entities/lib/index.js","./foreignNames.json":"node_modules/dom-serializer/foreignNames.json"}],"node_modules/domutils/lib/stringify.js":[function(require,module,exports) {
var ElementType = require("domelementtype"),
    getOuterHTML = require("dom-serializer"),
    isTag = ElementType.isTag;

module.exports = {
	getInnerHTML: getInnerHTML,
	getOuterHTML: getOuterHTML,
	getText: getText
};

function getInnerHTML(elem, opts){
	return elem.children ? elem.children.map(function(elem){
		return getOuterHTML(elem, opts);
	}).join("") : "";
}

function getText(elem){
	if(Array.isArray(elem)) return elem.map(getText).join("");
	if(isTag(elem)) return elem.name === "br" ? "\n" : getText(elem.children);
	if(elem.type === ElementType.CDATA) return getText(elem.children);
	if(elem.type === ElementType.Text) return elem.data;
	return "";
}

},{"domelementtype":"node_modules/domelementtype/index.js","dom-serializer":"node_modules/dom-serializer/index.js"}],"node_modules/domutils/lib/traversal.js":[function(require,module,exports) {
var getChildren = exports.getChildren = function(elem){
	return elem.children;
};

var getParent = exports.getParent = function(elem){
	return elem.parent;
};

exports.getSiblings = function(elem){
	var parent = getParent(elem);
	return parent ? getChildren(parent) : [elem];
};

exports.getAttributeValue = function(elem, name){
	return elem.attribs && elem.attribs[name];
};

exports.hasAttrib = function(elem, name){
	return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
};

exports.getName = function(elem){
	return elem.name;
};

},{}],"node_modules/domutils/lib/manipulation.js":[function(require,module,exports) {
exports.removeElement = function(elem){
	if(elem.prev) elem.prev.next = elem.next;
	if(elem.next) elem.next.prev = elem.prev;

	if(elem.parent){
		var childs = elem.parent.children;
		childs.splice(childs.lastIndexOf(elem), 1);
	}
};

exports.replaceElement = function(elem, replacement){
	var prev = replacement.prev = elem.prev;
	if(prev){
		prev.next = replacement;
	}

	var next = replacement.next = elem.next;
	if(next){
		next.prev = replacement;
	}

	var parent = replacement.parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs[childs.lastIndexOf(elem)] = replacement;
	}
};

exports.appendChild = function(elem, child){
	child.parent = elem;

	if(elem.children.push(child) !== 1){
		var sibling = elem.children[elem.children.length - 2];
		sibling.next = child;
		child.prev = sibling;
		child.next = null;
	}
};

exports.append = function(elem, next){
	var parent = elem.parent,
		currNext = elem.next;

	next.next = currNext;
	next.prev = elem;
	elem.next = next;
	next.parent = parent;

	if(currNext){
		currNext.prev = next;
		if(parent){
			var childs = parent.children;
			childs.splice(childs.lastIndexOf(currNext), 0, next);
		}
	} else if(parent){
		parent.children.push(next);
	}
};

exports.prepend = function(elem, prev){
	var parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs.splice(childs.lastIndexOf(elem), 0, prev);
	}

	if(elem.prev){
		elem.prev.next = prev;
	}
	
	prev.parent = parent;
	prev.prev = elem.prev;
	prev.next = elem;
	elem.prev = prev;
};



},{}],"node_modules/domutils/lib/querying.js":[function(require,module,exports) {
var isTag = require("domelementtype").isTag;

module.exports = {
	filter: filter,
	find: find,
	findOneChild: findOneChild,
	findOne: findOne,
	existsOne: existsOne,
	findAll: findAll
};

function filter(test, element, recurse, limit){
	if(!Array.isArray(element)) element = [element];

	if(typeof limit !== "number" || !isFinite(limit)){
		limit = Infinity;
	}
	return find(test, element, recurse !== false, limit);
}

function find(test, elems, recurse, limit){
	var result = [], childs;

	for(var i = 0, j = elems.length; i < j; i++){
		if(test(elems[i])){
			result.push(elems[i]);
			if(--limit <= 0) break;
		}

		childs = elems[i].children;
		if(recurse && childs && childs.length > 0){
			childs = find(test, childs, recurse, limit);
			result = result.concat(childs);
			limit -= childs.length;
			if(limit <= 0) break;
		}
	}

	return result;
}

function findOneChild(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(test(elems[i])) return elems[i];
	}

	return null;
}

function findOne(test, elems){
	var elem = null;

	for(var i = 0, l = elems.length; i < l && !elem; i++){
		if(!isTag(elems[i])){
			continue;
		} else if(test(elems[i])){
			elem = elems[i];
		} else if(elems[i].children.length > 0){
			elem = findOne(test, elems[i].children);
		}
	}

	return elem;
}

function existsOne(test, elems){
	for(var i = 0, l = elems.length; i < l; i++){
		if(
			isTag(elems[i]) && (
				test(elems[i]) || (
					elems[i].children.length > 0 &&
					existsOne(test, elems[i].children)
				)
			)
		){
			return true;
		}
	}

	return false;
}

function findAll(test, rootElems){
	var result = [];
	var stack = rootElems.slice();
	while(stack.length){
		var elem = stack.shift();
		if(!isTag(elem)) continue;
		if (elem.children && elem.children.length > 0) {
			stack.unshift.apply(stack, elem.children);
		}
		if(test(elem)) result.push(elem);
	}
	return result;
}

},{"domelementtype":"node_modules/domelementtype/index.js"}],"node_modules/domutils/lib/legacy.js":[function(require,module,exports) {
var ElementType = require("domelementtype");
var isTag = exports.isTag = ElementType.isTag;

exports.testElement = function(options, element){
	for(var key in options){
		if(!options.hasOwnProperty(key));
		else if(key === "tag_name"){
			if(!isTag(element) || !options.tag_name(element.name)){
				return false;
			}
		} else if(key === "tag_type"){
			if(!options.tag_type(element.type)) return false;
		} else if(key === "tag_contains"){
			if(isTag(element) || !options.tag_contains(element.data)){
				return false;
			}
		} else if(!element.attribs || !options[key](element.attribs[key])){
			return false;
		}
	}
	return true;
};

var Checks = {
	tag_name: function(name){
		if(typeof name === "function"){
			return function(elem){ return isTag(elem) && name(elem.name); };
		} else if(name === "*"){
			return isTag;
		} else {
			return function(elem){ return isTag(elem) && elem.name === name; };
		}
	},
	tag_type: function(type){
		if(typeof type === "function"){
			return function(elem){ return type(elem.type); };
		} else {
			return function(elem){ return elem.type === type; };
		}
	},
	tag_contains: function(data){
		if(typeof data === "function"){
			return function(elem){ return !isTag(elem) && data(elem.data); };
		} else {
			return function(elem){ return !isTag(elem) && elem.data === data; };
		}
	}
};

function getAttribCheck(attrib, value){
	if(typeof value === "function"){
		return function(elem){ return elem.attribs && value(elem.attribs[attrib]); };
	} else {
		return function(elem){ return elem.attribs && elem.attribs[attrib] === value; };
	}
}

function combineFuncs(a, b){
	return function(elem){
		return a(elem) || b(elem);
	};
}

exports.getElements = function(options, element, recurse, limit){
	var funcs = Object.keys(options).map(function(key){
		var value = options[key];
		return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
	});

	return funcs.length === 0 ? [] : this.filter(
		funcs.reduce(combineFuncs),
		element, recurse, limit
	);
};

exports.getElementById = function(id, element, recurse){
	if(!Array.isArray(element)) element = [element];
	return this.findOne(getAttribCheck("id", id), element, recurse !== false);
};

exports.getElementsByTagName = function(name, element, recurse, limit){
	return this.filter(Checks.tag_name(name), element, recurse, limit);
};

exports.getElementsByTagType = function(type, element, recurse, limit){
	return this.filter(Checks.tag_type(type), element, recurse, limit);
};

},{"domelementtype":"node_modules/domelementtype/index.js"}],"node_modules/domutils/lib/helpers.js":[function(require,module,exports) {
// removeSubsets
// Given an array of nodes, remove any member that is contained by another.
exports.removeSubsets = function(nodes) {
	var idx = nodes.length, node, ancestor, replace;

	// Check if each node (or one of its ancestors) is already contained in the
	// array.
	while (--idx > -1) {
		node = ancestor = nodes[idx];

		// Temporarily remove the node under consideration
		nodes[idx] = null;
		replace = true;

		while (ancestor) {
			if (nodes.indexOf(ancestor) > -1) {
				replace = false;
				nodes.splice(idx, 1);
				break;
			}
			ancestor = ancestor.parent;
		}

		// If the node has been found to be unique, re-insert it.
		if (replace) {
			nodes[idx] = node;
		}
	}

	return nodes;
};

// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
var POSITION = {
	DISCONNECTED: 1,
	PRECEDING: 2,
	FOLLOWING: 4,
	CONTAINS: 8,
	CONTAINED_BY: 16
};

// Compare the position of one node against another node in any other document.
// The return value is a bitmask with the following values:
//
// document order:
// > There is an ordering, document order, defined on all the nodes in the
// > document corresponding to the order in which the first character of the
// > XML representation of each node occurs in the XML representation of the
// > document after expansion of general entities. Thus, the document element
// > node will be the first node. Element nodes occur before their children.
// > Thus, document order orders element nodes in order of the occurrence of
// > their start-tag in the XML (after expansion of entities). The attribute
// > nodes of an element occur after the element and before its children. The
// > relative order of attribute nodes is implementation-dependent./
// Source:
// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
//
// @argument {Node} nodaA The first node to use in the comparison
// @argument {Node} nodeB The second node to use in the comparison
//
// @return {Number} A bitmask describing the input nodes' relative position.
//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
//         a description of these values.
var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
	var aParents = [];
	var bParents = [];
	var current, sharedParent, siblings, aSibling, bSibling, idx;

	if (nodeA === nodeB) {
		return 0;
	}

	current = nodeA;
	while (current) {
		aParents.unshift(current);
		current = current.parent;
	}
	current = nodeB;
	while (current) {
		bParents.unshift(current);
		current = current.parent;
	}

	idx = 0;
	while (aParents[idx] === bParents[idx]) {
		idx++;
	}

	if (idx === 0) {
		return POSITION.DISCONNECTED;
	}

	sharedParent = aParents[idx - 1];
	siblings = sharedParent.children;
	aSibling = aParents[idx];
	bSibling = bParents[idx];

	if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
		if (sharedParent === nodeB) {
			return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
		}
		return POSITION.FOLLOWING;
	} else {
		if (sharedParent === nodeA) {
			return POSITION.PRECEDING | POSITION.CONTAINS;
		}
		return POSITION.PRECEDING;
	}
};

// Sort an array of nodes based on their relative position in the document and
// remove any duplicate nodes. If the array contains nodes that do not belong
// to the same document, sort order is unspecified.
//
// @argument {Array} nodes Array of DOM nodes
//
// @returns {Array} collection of unique nodes, sorted in document order
exports.uniqueSort = function(nodes) {
	var idx = nodes.length, node, position;

	nodes = nodes.slice();

	while (--idx > -1) {
		node = nodes[idx];
		position = nodes.indexOf(node);
		if (position > -1 && position < idx) {
			nodes.splice(idx, 1);
		}
	}
	nodes.sort(function(a, b) {
		var relative = comparePos(a, b);
		if (relative & POSITION.PRECEDING) {
			return -1;
		} else if (relative & POSITION.FOLLOWING) {
			return 1;
		}
		return 0;
	});

	return nodes;
};

},{}],"node_modules/domutils/index.js":[function(require,module,exports) {
var DomUtils = module.exports;

[
	require("./lib/stringify"),
	require("./lib/traversal"),
	require("./lib/manipulation"),
	require("./lib/querying"),
	require("./lib/legacy"),
	require("./lib/helpers")
].forEach(function(ext){
	Object.keys(ext).forEach(function(key){
		DomUtils[key] = ext[key].bind(DomUtils);
	});
});

},{"./lib/stringify":"node_modules/domutils/lib/stringify.js","./lib/traversal":"node_modules/domutils/lib/traversal.js","./lib/manipulation":"node_modules/domutils/lib/manipulation.js","./lib/querying":"node_modules/domutils/lib/querying.js","./lib/legacy":"node_modules/domutils/lib/legacy.js","./lib/helpers":"node_modules/domutils/lib/helpers.js"}],"node_modules/boolbase/index.js":[function(require,module,exports) {
module.exports = {
	trueFunc: function trueFunc(){
		return true;
	},
	falseFunc: function falseFunc(){
		return false;
	}
};
},{}],"node_modules/css-what/lib/parse.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parse;
var reName = /^(?:\\([\da-f]{1,6}\s?|(\s)|.)|[\w\-\u00b0-\uFFFF])+/,
    reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi,
    //modified version of https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L87
reAttr = /^\s*((?:\\.|[\w\u00b0-\uFFFF-])+)\s*(?:(\S?)=\s*(?:(['"])([^]*?)\3|(#?(?:\\.|[\w\u00b0-\uFFFF-])*)|)|)\s*(i)?\]/;
var actionTypes = {
  undefined: "exists",
  "": "equals",
  "~": "element",
  "^": "start",
  $: "end",
  "*": "any",
  "!": "not",
  "|": "hyphen"
};
var Traversals = {
  ">": "child",
  "<": "parent",
  "~": "sibling",
  "+": "adjacent"
};
var attribSelectors = {
  "#": ["id", "equals"],
  ".": ["class", "element"]
}; //pseudos, whose data-property is parsed as well

var unpackPseudos = new Set(["has", "not", "matches"]);
var stripQuotesFromPseudos = new Set(["contains", "icontains"]);
var quotes = new Set(['"', "'"]); //unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152

function funescape(_, escaped, escapedWhitespace) {
  var high = parseInt(escaped, 16) - 0x10000; // NaN means non-codepoint

  return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint
  String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)
  String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);
}

function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}

function isWhitespace(c) {
  return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function parse(selector, options) {
  var subselects = [];
  selector = parseSelector(subselects, selector + "", options);

  if (selector !== "") {
    throw new Error("Unmatched selector: " + selector);
  }

  return subselects;
}

function parseSelector(subselects, selector, options) {
  var tokens = [],
      sawWS = false;

  function getName() {
    var match = selector.match(reName);

    if (!match) {
      throw new Error("Expected name, found " + selector);
    }

    var sub = match[0];
    selector = selector.substr(sub.length);
    return unescapeCSS(sub);
  }

  function stripWhitespace(start) {
    while (isWhitespace(selector.charAt(start))) {
      start++;
    }

    selector = selector.substr(start);
  }

  function isEscaped(pos) {
    var slashCount = 0;

    while (selector.charAt(--pos) === "\\") {
      slashCount++;
    }

    return (slashCount & 1) === 1;
  }

  stripWhitespace(0);

  while (selector !== "") {
    var firstChar = selector.charAt(0);

    if (isWhitespace(firstChar)) {
      sawWS = true;
      stripWhitespace(1);
    } else if (firstChar in Traversals) {
      tokens.push({
        type: Traversals[firstChar]
      });
      sawWS = false;
      stripWhitespace(1);
    } else if (firstChar === ",") {
      if (tokens.length === 0) {
        throw new Error("Empty sub-selector");
      }

      subselects.push(tokens);
      tokens = [];
      sawWS = false;
      stripWhitespace(1);
    } else {
      if (sawWS) {
        if (tokens.length > 0) {
          tokens.push({
            type: "descendant"
          });
        }

        sawWS = false;
      }

      if (firstChar === "*") {
        selector = selector.substr(1);
        tokens.push({
          type: "universal"
        });
      } else if (firstChar in attribSelectors) {
        var _a = attribSelectors[firstChar],
            name_1 = _a[0],
            action = _a[1];
        selector = selector.substr(1);
        tokens.push({
          type: "attribute",
          name: name_1,
          action: action,
          value: getName(),
          ignoreCase: false
        });
      } else if (firstChar === "[") {
        selector = selector.substr(1);
        var data = selector.match(reAttr);

        if (!data) {
          throw new Error("Malformed attribute selector: " + selector);
        }

        selector = selector.substr(data[0].length);
        var name_2 = unescapeCSS(data[1]);

        if (!options || ("lowerCaseAttributeNames" in options ? options.lowerCaseAttributeNames : !options.xmlMode)) {
          name_2 = name_2.toLowerCase();
        }

        tokens.push({
          type: "attribute",
          name: name_2,
          action: actionTypes[data[2]],
          value: unescapeCSS(data[4] || data[5] || ""),
          ignoreCase: !!data[6]
        });
      } else if (firstChar === ":") {
        if (selector.charAt(1) === ":") {
          selector = selector.substr(2);
          tokens.push({
            type: "pseudo-element",
            name: getName().toLowerCase()
          });
          continue;
        }

        selector = selector.substr(1);
        var name_3 = getName().toLowerCase();
        var data = null;

        if (selector.charAt(0) === "(") {
          if (unpackPseudos.has(name_3)) {
            var quot = selector.charAt(1);
            var quoted = quotes.has(quot);
            selector = selector.substr(quoted ? 2 : 1);
            data = [];
            selector = parseSelector(data, selector, options);

            if (quoted) {
              if (selector.charAt(0) !== quot) {
                throw new Error("Unmatched quotes in :" + name_3);
              } else {
                selector = selector.substr(1);
              }
            }

            if (selector.charAt(0) !== ")") {
              throw new Error("Missing closing parenthesis in :" + name_3 + " (" + selector + ")");
            }

            selector = selector.substr(1);
          } else {
            var pos = 1,
                counter = 1;

            for (; counter > 0 && pos < selector.length; pos++) {
              if (selector.charAt(pos) === "(" && !isEscaped(pos)) counter++;else if (selector.charAt(pos) === ")" && !isEscaped(pos)) counter--;
            }

            if (counter) {
              throw new Error("Parenthesis not matched");
            }

            data = selector.substr(1, pos - 2);
            selector = selector.substr(pos);

            if (stripQuotesFromPseudos.has(name_3)) {
              var quot = data.charAt(0);

              if (quot === data.slice(-1) && quotes.has(quot)) {
                data = data.slice(1, -1);
              }

              data = unescapeCSS(data);
            }
          }
        }

        tokens.push({
          type: "pseudo",
          name: name_3,
          data: data
        });
      } else if (reName.test(selector)) {
        var name_4 = getName();

        if (!options || ("lowerCaseTags" in options ? options.lowerCaseTags : !options.xmlMode)) {
          name_4 = name_4.toLowerCase();
        }

        tokens.push({
          type: "tag",
          name: name_4
        });
      } else {
        if (tokens.length && tokens[tokens.length - 1].type === "descendant") {
          tokens.pop();
        }

        addToken(subselects, tokens);
        return selector;
      }
    }
  }

  addToken(subselects, tokens);
  return selector;
}

function addToken(subselects, tokens) {
  if (subselects.length > 0 && tokens.length === 0) {
    throw new Error("Empty sub-selector");
  }

  subselects.push(tokens);
}
},{}],"node_modules/css-what/lib/stringify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var actionTypes = {
  equals: "",
  element: "~",
  start: "^",
  end: "$",
  any: "*",
  not: "!",
  hyphen: "|"
};
var simpleSelectors = {
  child: " > ",
  parent: " < ",
  sibling: " ~ ",
  adjacent: " + ",
  descendant: " ",
  universal: "*"
};

function stringify(token) {
  return token.map(stringifySubselector).join(", ");
}

exports.default = stringify;

function stringifySubselector(token) {
  return token.map(stringifyToken).join("");
}

function stringifyToken(token) {
  if (token.type in simpleSelectors) return simpleSelectors[token.type];
  if (token.type === "tag") return escapeName(token.name);
  if (token.type === "pseudo-element") return "::" + escapeName(token.name);

  if (token.type === "attribute") {
    if (token.action === "exists") {
      return "[" + escapeName(token.name) + "]";
    }

    if (token.name === "id" && token.action === "equals" && !token.ignoreCase) {
      return "#" + escapeName(token.value);
    }

    if (token.name === "class" && token.action === "element" && !token.ignoreCase) {
      return "." + escapeName(token.value);
    }

    var atributeName = escapeName(token.name);
    var action = actionTypes[token.action];
    var value = escapeName(token.value);
    var ignoreCase = token.ignoreCase ? "i" : "";
    return "[" + atributeName + action + "='" + value + "'" + ignoreCase + "]";
  }

  if (token.type === "pseudo") {
    if (token.data === null) return ":" + escapeName(token.name);

    if (typeof token.data === "string") {
      return ":" + escapeName(token.name) + "(" + token.data + ")";
    }

    return ":" + escapeName(token.name) + "(" + stringify(token.data) + ")";
  }

  throw new Error("Unknown type");
}

function escapeName(str) {
  //TODO
  return str;
}
},{}],"node_modules/css-what/lib/index.js":[function(require,module,exports) {
"use strict";

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

__export(require("./parse"));

var parse_1 = require("./parse");

exports.parse = parse_1.default;

var stringify_1 = require("./stringify");

exports.stringify = stringify_1.default;
},{"./parse":"node_modules/css-what/lib/parse.js","./stringify":"node_modules/css-what/lib/stringify.js"}],"node_modules/css-select/lib/procedure.json":[function(require,module,exports) {
module.exports = {
	"universal": 50,
	"tag": 30,
	"attribute": 1,
	"pseudo": 0,
	"descendant": -1,
	"child": -1,
	"parent": -1,
	"sibling": -1,
	"adjacent": -1
}
;
},{}],"node_modules/css-select/lib/sort.js":[function(require,module,exports) {
module.exports = sortByProcedure;

/*
	sort the parts of the passed selector,
	as there is potential for optimization
	(some types of selectors are faster than others)
*/

var procedure = require("./procedure.json");

var attributes = {
    __proto__: null,
    exists: 10,
    equals: 8,
    not: 7,
    start: 6,
    end: 6,
    any: 5,
    hyphen: 4,
    element: 4
};

function sortByProcedure(arr) {
    var procs = arr.map(getProcedure);
    for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];

        if (procNew < 0) continue;

        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
            var token = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = token;
            procs[j + 1] = procs[j];
            procs[j] = procNew;
        }
    }
}

function getProcedure(token) {
    var proc = procedure[token.type];

    if (proc === procedure.attribute) {
        proc = attributes[token.action];

        if (proc === attributes.equals && token.name === "id") {
            //prefer ID selectors (eg. #ID)
            proc = 9;
        }

        if (token.ignoreCase) {
            //ignoreCase adds some overhead, prefer "normal" token
            //this is a binary operation, to ensure it's still an int
            proc >>= 1;
        }
    } else if (proc === procedure.pseudo) {
        if (!token.data) {
            proc = 3;
        } else if (token.name === "has" || token.name === "contains") {
            proc = 0; //expensive in any case
        } else if (token.name === "matches" || token.name === "not") {
            proc = 0;
            for (var i = 0; i < token.data.length; i++) {
                //TODO better handling of complex selectors
                if (token.data[i].length !== 1) continue;
                var cur = getProcedure(token.data[i][0]);
                //avoid executing :has or :contains
                if (cur === 0) {
                    proc = 0;
                    break;
                }
                if (cur > proc) proc = cur;
            }
            if (token.data.length > 1 && proc > 0) proc -= 1;
        } else {
            proc = 1;
        }
    }
    return proc;
}

},{"./procedure.json":"node_modules/css-select/lib/procedure.json"}],"node_modules/css-select/lib/attributes.js":[function(require,module,exports) {
var falseFunc = require("boolbase").falseFunc;

//https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js#L469
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;

/*
	attribute selectors
*/
var attributeRules = {
    __proto__: null,
    equals: function(next, data, options) {
        var name = data.name;
        var value = data.value;
        var adapter = options.adapter;

        if (data.ignoreCase) {
            value = value.toLowerCase();

            return function equalsIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return attr != null && attr.toLowerCase() === value && next(elem);
            };
        }

        return function equals(elem) {
            return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
    },
    hyphen: function(next, data, options) {
        var name = data.name;
        var value = data.value;
        var len = value.length;
        var adapter = options.adapter;

        if (data.ignoreCase) {
            value = value.toLowerCase();

            return function hyphenIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (
                    attr != null &&
                    (attr.length === len || attr.charAt(len) === "-") &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem)
                );
            };
        }

        return function hyphen(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (
                attr != null &&
                attr.substr(0, len) === value &&
                (attr.length === len || attr.charAt(len) === "-") &&
                next(elem)
            );
        };
    },
    element: function(next, data, options) {
        var name = data.name;
        var value = data.value;
        var adapter = options.adapter;

        if (/\s/.test(value)) {
            return falseFunc;
        }

        value = value.replace(reChars, "\\$&");

        var pattern = "(?:^|\\s)" + value + "(?:$|\\s)",
            flags = data.ignoreCase ? "i" : "",
            regex = new RegExp(pattern, flags);

        return function element(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && regex.test(attr) && next(elem);
        };
    },
    exists: function(next, data, options) {
        var name = data.name;
        var adapter = options.adapter;

        return function exists(elem) {
            return adapter.hasAttrib(elem, name) && next(elem);
        };
    },
    start: function(next, data, options) {
        var name = data.name;
        var value = data.value;
        var len = value.length;
        var adapter = options.adapter;

        if (len === 0) {
            return falseFunc;
        }

        if (data.ignoreCase) {
            value = value.toLowerCase();

            return function startIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return attr != null && attr.substr(0, len).toLowerCase() === value && next(elem);
            };
        }

        return function start(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.substr(0, len) === value && next(elem);
        };
    },
    end: function(next, data, options) {
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        var adapter = options.adapter;

        if (len === 0) {
            return falseFunc;
        }

        if (data.ignoreCase) {
            value = value.toLowerCase();

            return function endIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return attr != null && attr.substr(len).toLowerCase() === value && next(elem);
            };
        }

        return function end(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.substr(len) === value && next(elem);
        };
    },
    any: function(next, data, options) {
        var name = data.name;
        var value = data.value;
        var adapter = options.adapter;

        if (value === "") {
            return falseFunc;
        }

        if (data.ignoreCase) {
            var regex = new RegExp(value.replace(reChars, "\\$&"), "i");

            return function anyIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return attr != null && regex.test(attr) && next(elem);
            };
        }

        return function any(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.indexOf(value) >= 0 && next(elem);
        };
    },
    not: function(next, data, options) {
        var name = data.name;
        var value = data.value;
        var adapter = options.adapter;

        if (value === "") {
            return function notEmpty(elem) {
                return !!adapter.getAttributeValue(elem, name) && next(elem);
            };
        } else if (data.ignoreCase) {
            value = value.toLowerCase();

            return function notIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return attr != null && attr.toLowerCase() !== value && next(elem);
            };
        }

        return function not(elem) {
            return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
    }
};

module.exports = {
    compile: function(next, data, options) {
        if (options && options.strict && (data.ignoreCase || data.action === "not")) {
            throw new Error("Unsupported attribute selector");
        }
        return attributeRules[data.action](next, data, options);
    },
    rules: attributeRules
};

},{"boolbase":"node_modules/boolbase/index.js"}],"node_modules/nth-check/parse.js":[function(require,module,exports) {
module.exports = parse;

//following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo

//[ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
var re_nthElement = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;

/*
	parses a nth-check formula, returns an array of two numbers
*/
function parse(formula){
	formula = formula.trim().toLowerCase();

	if(formula === "even"){
		return [2, 0];
	} else if(formula === "odd"){
		return [2, 1];
	} else {
		var parsed = formula.match(re_nthElement);

		if(!parsed){
			throw new SyntaxError("n-th rule couldn't be parsed ('" + formula + "')");
		}

		var a;

		if(parsed[1]){
			a = parseInt(parsed[1], 10);
			if(isNaN(a)){
				if(parsed[1].charAt(0) === "-") a = -1;
				else a = 1;
			}
		} else a = 0;

		return [
			a,
			parsed[3] ? parseInt((parsed[2] || "") + parsed[3], 10) : 0
		];
	}
}

},{}],"node_modules/nth-check/compile.js":[function(require,module,exports) {
module.exports = compile;

var BaseFuncs = require("boolbase"),
    trueFunc  = BaseFuncs.trueFunc,
    falseFunc = BaseFuncs.falseFunc;

/*
	returns a function that checks if an elements index matches the given rule
	highly optimized to return the fastest solution
*/
function compile(parsed){
	var a = parsed[0],
	    b = parsed[1] - 1;

	//when b <= 0, a*n won't be possible for any matches when a < 0
	//besides, the specification says that no element is matched when a and b are 0
	if(b < 0 && a <= 0) return falseFunc;

	//when a is in the range -1..1, it matches any element (so only b is checked)
	if(a ===-1) return function(pos){ return pos <= b; };
	if(a === 0) return function(pos){ return pos === b; };
	//when b <= 0 and a === 1, they match any element
	if(a === 1) return b < 0 ? trueFunc : function(pos){ return pos >= b; };

	//when a > 0, modulo can be used to check if there is a match
	var bMod = b % a;
	if(bMod < 0) bMod += a;

	if(a > 1){
		return function(pos){
			return pos >= b && pos % a === bMod;
		};
	}

	a *= -1; //make `a` positive

	return function(pos){
		return pos <= b && pos % a === bMod;
	};
}
},{"boolbase":"node_modules/boolbase/index.js"}],"node_modules/nth-check/index.js":[function(require,module,exports) {
var parse = require("./parse.js"),
    compile = require("./compile.js");

module.exports = function nthCheck(formula){
	return compile(parse(formula));
};

module.exports.parse = parse;
module.exports.compile = compile;
},{"./parse.js":"node_modules/nth-check/parse.js","./compile.js":"node_modules/nth-check/compile.js"}],"node_modules/css-select/lib/pseudos.js":[function(require,module,exports) {
/*
	pseudo selectors

	---

	they are available in two forms:
	* filters called when the selector
	  is compiled and return a function
	  that needs to return next()
	* pseudos get called on execution
	  they need to return a boolean
*/

var getNCheck = require("nth-check");
var BaseFuncs = require("boolbase");
var attributes = require("./attributes.js");
var trueFunc = BaseFuncs.trueFunc;
var falseFunc = BaseFuncs.falseFunc;

var checkAttrib = attributes.rules.equals;

function getAttribFunc(name, value) {
    var data = { name: name, value: value };
    return function attribFunc(next, rule, options) {
        return checkAttrib(next, data, options);
    };
}

function getChildFunc(next, adapter) {
    return function(elem) {
        return !!adapter.getParent(elem) && next(elem);
    };
}

var filters = {
    contains: function(next, text, options) {
        var adapter = options.adapter;

        return function contains(elem) {
            return next(elem) && adapter.getText(elem).indexOf(text) >= 0;
        };
    },
    icontains: function(next, text, options) {
        var itext = text.toLowerCase();
        var adapter = options.adapter;

        return function icontains(elem) {
            return (
                next(elem) &&
                adapter
                    .getText(elem)
                    .toLowerCase()
                    .indexOf(itext) >= 0
            );
        };
    },

    //location specific methods
    "nth-child": function(next, rule, options) {
        var func = getNCheck(rule);
        var adapter = options.adapter;

        if (func === falseFunc) return func;
        if (func === trueFunc) return getChildFunc(next, adapter);

        return function nthChild(elem) {
            var siblings = adapter.getSiblings(elem);

            for (var i = 0, pos = 0; i < siblings.length; i++) {
                if (adapter.isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    else pos++;
                }
            }

            return func(pos) && next(elem);
        };
    },
    "nth-last-child": function(next, rule, options) {
        var func = getNCheck(rule);
        var adapter = options.adapter;

        if (func === falseFunc) return func;
        if (func === trueFunc) return getChildFunc(next, adapter);

        return function nthLastChild(elem) {
            var siblings = adapter.getSiblings(elem);

            for (var pos = 0, i = siblings.length - 1; i >= 0; i--) {
                if (adapter.isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    else pos++;
                }
            }

            return func(pos) && next(elem);
        };
    },
    "nth-of-type": function(next, rule, options) {
        var func = getNCheck(rule);
        var adapter = options.adapter;

        if (func === falseFunc) return func;
        if (func === trueFunc) return getChildFunc(next, adapter);

        return function nthOfType(elem) {
            var siblings = adapter.getSiblings(elem);

            for (var pos = 0, i = 0; i < siblings.length; i++) {
                if (adapter.isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    if (adapter.getName(siblings[i]) === adapter.getName(elem)) pos++;
                }
            }

            return func(pos) && next(elem);
        };
    },
    "nth-last-of-type": function(next, rule, options) {
        var func = getNCheck(rule);
        var adapter = options.adapter;

        if (func === falseFunc) return func;
        if (func === trueFunc) return getChildFunc(next, adapter);

        return function nthLastOfType(elem) {
            var siblings = adapter.getSiblings(elem);

            for (var pos = 0, i = siblings.length - 1; i >= 0; i--) {
                if (adapter.isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    if (adapter.getName(siblings[i]) === adapter.getName(elem)) pos++;
                }
            }

            return func(pos) && next(elem);
        };
    },

    //TODO determine the actual root element
    root: function(next, rule, options) {
        var adapter = options.adapter;

        return function(elem) {
            return !adapter.getParent(elem) && next(elem);
        };
    },

    scope: function(next, rule, options, context) {
        var adapter = options.adapter;

        if (!context || context.length === 0) {
            //equivalent to :root
            return filters.root(next, rule, options);
        }

        function equals(a, b) {
            if (typeof adapter.equals === "function") return adapter.equals(a, b);

            return a === b;
        }

        if (context.length === 1) {
            //NOTE: can't be unpacked, as :has uses this for side-effects
            return function(elem) {
                return equals(context[0], elem) && next(elem);
            };
        }

        return function(elem) {
            return context.indexOf(elem) >= 0 && next(elem);
        };
    },

    //jQuery extensions (others follow as pseudos)
    checkbox: getAttribFunc("type", "checkbox"),
    file: getAttribFunc("type", "file"),
    password: getAttribFunc("type", "password"),
    radio: getAttribFunc("type", "radio"),
    reset: getAttribFunc("type", "reset"),
    image: getAttribFunc("type", "image"),
    submit: getAttribFunc("type", "submit"),

    //dynamic state pseudos. These depend on optional Adapter methods.
    hover: function(next, rule, options) {
        var adapter = options.adapter;

        if (typeof adapter.isHovered === 'function') {
            return function hover(elem) {
                return next(elem) && adapter.isHovered(elem);
            };
        }

        return falseFunc;
    },
    visited: function(next, rule, options) {
        var adapter = options.adapter;

        if (typeof adapter.isVisited === 'function') {
            return function visited(elem) {
                return next(elem) && adapter.isVisited(elem);
            };
        }

        return falseFunc;
    },
    active: function(next, rule, options) {
        var adapter = options.adapter;

        if (typeof adapter.isActive === 'function') {
            return function active(elem) {
                return next(elem) && adapter.isActive(elem);
            };
        }

        return falseFunc;
    }
};

//helper methods
function getFirstElement(elems, adapter) {
    for (var i = 0; elems && i < elems.length; i++) {
        if (adapter.isTag(elems[i])) return elems[i];
    }
}

//while filters are precompiled, pseudos get called when they are needed
var pseudos = {
    empty: function(elem, adapter) {
        return !adapter.getChildren(elem).some(function(elem) {
            return adapter.isTag(elem) || elem.type === "text";
        });
    },

    "first-child": function(elem, adapter) {
        return getFirstElement(adapter.getSiblings(elem), adapter) === elem;
    },
    "last-child": function(elem, adapter) {
        var siblings = adapter.getSiblings(elem);

        for (var i = siblings.length - 1; i >= 0; i--) {
            if (siblings[i] === elem) return true;
            if (adapter.isTag(siblings[i])) break;
        }

        return false;
    },
    "first-of-type": function(elem, adapter) {
        var siblings = adapter.getSiblings(elem);

        for (var i = 0; i < siblings.length; i++) {
            if (adapter.isTag(siblings[i])) {
                if (siblings[i] === elem) return true;
                if (adapter.getName(siblings[i]) === adapter.getName(elem)) break;
            }
        }

        return false;
    },
    "last-of-type": function(elem, adapter) {
        var siblings = adapter.getSiblings(elem);

        for (var i = siblings.length - 1; i >= 0; i--) {
            if (adapter.isTag(siblings[i])) {
                if (siblings[i] === elem) return true;
                if (adapter.getName(siblings[i]) === adapter.getName(elem)) break;
            }
        }

        return false;
    },
    "only-of-type": function(elem, adapter) {
        var siblings = adapter.getSiblings(elem);

        for (var i = 0, j = siblings.length; i < j; i++) {
            if (adapter.isTag(siblings[i])) {
                if (siblings[i] === elem) continue;
                if (adapter.getName(siblings[i]) === adapter.getName(elem)) {
                    return false;
                }
            }
        }

        return true;
    },
    "only-child": function(elem, adapter) {
        var siblings = adapter.getSiblings(elem);

        for (var i = 0; i < siblings.length; i++) {
            if (adapter.isTag(siblings[i]) && siblings[i] !== elem) return false;
        }

        return true;
    },

    //:matches(a, area, link)[href]
    link: function(elem, adapter) {
        return adapter.hasAttrib(elem, "href");
    },
    //TODO: :any-link once the name is finalized (as an alias of :link)

    //forms
    //to consider: :target

    //:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
    selected: function(elem, adapter) {
        if (adapter.hasAttrib(elem, "selected")) return true;
        else if (adapter.getName(elem) !== "option") return false;

        //the first <option> in a <select> is also selected
        var parent = adapter.getParent(elem);

        if (!parent || adapter.getName(parent) !== "select" || adapter.hasAttrib(parent, "multiple")) {
            return false;
        }

        var siblings = adapter.getChildren(parent);
        var sawElem = false;

        for (var i = 0; i < siblings.length; i++) {
            if (adapter.isTag(siblings[i])) {
                if (siblings[i] === elem) {
                    sawElem = true;
                } else if (!sawElem) {
                    return false;
                } else if (adapter.hasAttrib(siblings[i], "selected")) {
                    return false;
                }
            }
        }

        return sawElem;
    },
    //https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
    //:matches(
    //  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
    //  optgroup[disabled] > option),
    // fieldset[disabled] * //TODO not child of first <legend>
    //)
    disabled: function(elem, adapter) {
        return adapter.hasAttrib(elem, "disabled");
    },
    enabled: function(elem, adapter) {
        return !adapter.hasAttrib(elem, "disabled");
    },
    //:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
    checked: function(elem, adapter) {
        return adapter.hasAttrib(elem, "checked") || pseudos.selected(elem, adapter);
    },
    //:matches(input, select, textarea)[required]
    required: function(elem, adapter) {
        return adapter.hasAttrib(elem, "required");
    },
    //:matches(input, select, textarea):not([required])
    optional: function(elem, adapter) {
        return !adapter.hasAttrib(elem, "required");
    },

    //jQuery extensions

    //:not(:empty)
    parent: function(elem, adapter) {
        return !pseudos.empty(elem, adapter);
    },
    //:matches(h1, h2, h3, h4, h5, h6)
    header: namePseudo(["h1", "h2", "h3", "h4", "h5", "h6"]),

    //:matches(button, input[type=button])
    button: function(elem, adapter) {
        var name = adapter.getName(elem);
        return (
            name === "button" || (name === "input" && adapter.getAttributeValue(elem, "type") === "button")
        );
    },
    //:matches(input, textarea, select, button)
    input: namePseudo(["input", "textarea", "select", "button"]),
    //input:matches(:not([type!='']), [type='text' i])
    text: function(elem, adapter) {
        var attr;
        return (
            adapter.getName(elem) === "input" &&
            (!(attr = adapter.getAttributeValue(elem, "type")) || attr.toLowerCase() === "text")
        );
    }
};

function namePseudo(names) {
    if (typeof Set !== "undefined") {
        // eslint-disable-next-line no-undef
        var nameSet = new Set(names);

        return function(elem, adapter) {
            return nameSet.has(adapter.getName(elem));
        };
    }

    return function(elem, adapter) {
        return names.indexOf(adapter.getName(elem)) >= 0;
    };
}

function verifyArgs(func, name, subselect) {
    if (subselect === null) {
        if (func.length > 2 && name !== "scope") {
            throw new Error("pseudo-selector :" + name + " requires an argument");
        }
    } else {
        if (func.length === 2) {
            throw new Error("pseudo-selector :" + name + " doesn't have any arguments");
        }
    }
}

//FIXME this feels hacky
var re_CSS3 = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;

module.exports = {
    compile: function(next, data, options, context) {
        var name = data.name;
        var subselect = data.data;
        var adapter = options.adapter;

        if (options && options.strict && !re_CSS3.test(name)) {
            throw new Error(":" + name + " isn't part of CSS3");
        }

        if (typeof filters[name] === "function") {
            return filters[name](next, subselect, options, context);
        } else if (typeof pseudos[name] === "function") {
            var func = pseudos[name];

            verifyArgs(func, name, subselect);

            if (func === falseFunc) {
                return func;
            }

            if (next === trueFunc) {
                return function pseudoRoot(elem) {
                    return func(elem, adapter, subselect);
                };
            }

            return function pseudoArgs(elem) {
                return func(elem, adapter, subselect) && next(elem);
            };
        } else {
            throw new Error("unmatched pseudo-class :" + name);
        }
    },
    filters: filters,
    pseudos: pseudos
};

},{"nth-check":"node_modules/nth-check/index.js","boolbase":"node_modules/boolbase/index.js","./attributes.js":"node_modules/css-select/lib/attributes.js"}],"node_modules/css-select/lib/general.js":[function(require,module,exports) {
var attributes = require("./attributes.js");
var Pseudos = require("./pseudos");

/*
	all available rules
*/
module.exports = {
    __proto__: null,

    attribute: attributes.compile,
    pseudo: Pseudos.compile,

    //tags
    tag: function(next, data, options) {
        var name = data.name;
        var adapter = options.adapter;

        return function tag(elem) {
            return adapter.getName(elem) === name && next(elem);
        };
    },

    //traversal
    descendant: function(next, data, options) {
        // eslint-disable-next-line no-undef
        var isFalseCache = typeof WeakSet !== "undefined" ? new WeakSet() : null;
        var adapter = options.adapter;

        return function descendant(elem) {
            var found = false;

            while (!found && (elem = adapter.getParent(elem))) {
                if (!isFalseCache || !isFalseCache.has(elem)) {
                    found = next(elem);
                    if (!found && isFalseCache) {
                        isFalseCache.add(elem);
                    }
                }
            }

            return found;
        };
    },
    _flexibleDescendant: function(next, data, options) {
        var adapter = options.adapter;

        // Include element itself, only used while querying an array
        return function descendant(elem) {
            var found = next(elem);

            while (!found && (elem = adapter.getParent(elem))) {
                found = next(elem);
            }

            return found;
        };
    },
    parent: function(next, data, options) {
        if (options && options.strict) {
            throw new Error("Parent selector isn't part of CSS3");
        }

        var adapter = options.adapter;

        return function parent(elem) {
            return adapter.getChildren(elem).some(test);
        };

        function test(elem) {
            return adapter.isTag(elem) && next(elem);
        }
    },
    child: function(next, data, options) {
        var adapter = options.adapter;

        return function child(elem) {
            var parent = adapter.getParent(elem);
            return !!parent && next(parent);
        };
    },
    sibling: function(next, data, options) {
        var adapter = options.adapter;

        return function sibling(elem) {
            var siblings = adapter.getSiblings(elem);

            for (var i = 0; i < siblings.length; i++) {
                if (adapter.isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    if (next(siblings[i])) return true;
                }
            }

            return false;
        };
    },
    adjacent: function(next, data, options) {
        var adapter = options.adapter;

        return function adjacent(elem) {
            var siblings = adapter.getSiblings(elem),
                lastElement;

            for (var i = 0; i < siblings.length; i++) {
                if (adapter.isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    lastElement = siblings[i];
                }
            }

            return !!lastElement && next(lastElement);
        };
    },
    universal: function(next) {
        return next;
    }
};

},{"./attributes.js":"node_modules/css-select/lib/attributes.js","./pseudos":"node_modules/css-select/lib/pseudos.js"}],"node_modules/css-select/lib/compile.js":[function(require,module,exports) {
/*
	compiles a selector to an executable function
*/

module.exports = compile;

var parse = require("css-what").parse;
var BaseFuncs = require("boolbase");
var sortRules = require("./sort.js");
var procedure = require("./procedure.json");
var Rules = require("./general.js");
var Pseudos = require("./pseudos.js");
var trueFunc = BaseFuncs.trueFunc;
var falseFunc = BaseFuncs.falseFunc;

var filters = Pseudos.filters;

function compile(selector, options, context) {
    var next = compileUnsafe(selector, options, context);
    return wrap(next, options);
}

function wrap(next, options) {
    var adapter = options.adapter;

    return function base(elem) {
        return adapter.isTag(elem) && next(elem);
    };
}

function compileUnsafe(selector, options, context) {
    var token = parse(selector, options);
    return compileToken(token, options, context);
}

function includesScopePseudo(t) {
    return (
        t.type === "pseudo" &&
        (t.name === "scope" ||
            (Array.isArray(t.data) &&
                t.data.some(function(data) {
                    return data.some(includesScopePseudo);
                })))
    );
}

var DESCENDANT_TOKEN = { type: "descendant" };
var FLEXIBLE_DESCENDANT_TOKEN = { type: "_flexibleDescendant" };
var SCOPE_TOKEN = { type: "pseudo", name: "scope" };
var PLACEHOLDER_ELEMENT = {};

//CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
//http://www.w3.org/TR/selectors4/#absolutizing
function absolutize(token, options, context) {
    var adapter = options.adapter;

    //TODO better check if context is document
    var hasContext =
        !!context &&
        !!context.length &&
        context.every(function(e) {
            return e === PLACEHOLDER_ELEMENT || !!adapter.getParent(e);
        });

    token.forEach(function(t) {
        if (t.length > 0 && isTraversal(t[0]) && t[0].type !== "descendant") {
            //don't return in else branch
        } else if (hasContext && !(Array.isArray(t) ? t.some(includesScopePseudo) : includesScopePseudo(t))) {
            t.unshift(DESCENDANT_TOKEN);
        } else {
            return;
        }

        t.unshift(SCOPE_TOKEN);
    });
}

function compileToken(token, options, context) {
    token = token.filter(function(t) {
        return t.length > 0;
    });

    token.forEach(sortRules);

    var isArrayContext = Array.isArray(context);

    context = (options && options.context) || context;

    if (context && !isArrayContext) context = [context];

    absolutize(token, options, context);

    var shouldTestNextSiblings = false;

    var query = token
        .map(function(rules) {
            if (rules[0] && rules[1] && rules[0].name === "scope") {
                var ruleType = rules[1].type;
                if (isArrayContext && ruleType === "descendant") {
                    rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
                } else if (ruleType === "adjacent" || ruleType === "sibling") {
                    shouldTestNextSiblings = true;
                }
            }
            return compileRules(rules, options, context);
        })
        .reduce(reduceRules, falseFunc);

    query.shouldTestNextSiblings = shouldTestNextSiblings;

    return query;
}

function isTraversal(t) {
    return procedure[t.type] < 0;
}

function compileRules(rules, options, context) {
    return rules.reduce(function(func, rule) {
        if (func === falseFunc) return func;

        if (!(rule.type in Rules)) {
            throw new Error("Rule type " + rule.type + " is not supported by css-select");
        }

        return Rules[rule.type](func, rule, options, context);
    }, (options && options.rootFunc) || trueFunc);
}

function reduceRules(a, b) {
    if (b === falseFunc || a === trueFunc) {
        return a;
    }
    if (a === falseFunc || b === trueFunc) {
        return b;
    }

    return function combine(elem) {
        return a(elem) || b(elem);
    };
}

function containsTraversal(t) {
    return t.some(isTraversal);
}

//:not, :has and :matches have to compile selectors
//doing this in lib/pseudos.js would lead to circular dependencies,
//so we add them here
filters.not = function(next, token, options, context) {
    var opts = {
        xmlMode: !!(options && options.xmlMode),
        strict: !!(options && options.strict),
        adapter: options.adapter
    };

    if (opts.strict) {
        if (token.length > 1 || token.some(containsTraversal)) {
            throw new Error("complex selectors in :not aren't allowed in strict mode");
        }
    }

    var func = compileToken(token, opts, context);

    if (func === falseFunc) return next;
    if (func === trueFunc) return falseFunc;

    return function not(elem) {
        return !func(elem) && next(elem);
    };
};

filters.has = function(next, token, options) {
    var adapter = options.adapter;
    var opts = {
        xmlMode: !!(options && options.xmlMode),
        strict: !!(options && options.strict),
        adapter: adapter
    };

    //FIXME: Uses an array as a pointer to the current element (side effects)
    var context = token.some(containsTraversal) ? [PLACEHOLDER_ELEMENT] : null;

    var func = compileToken(token, opts, context);

    if (func === falseFunc) return falseFunc;
    if (func === trueFunc) {
        return function hasChild(elem) {
            return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
        };
    }

    func = wrap(func, options);

    if (context) {
        return function has(elem) {
            return next(elem) && ((context[0] = elem), adapter.existsOne(func, adapter.getChildren(elem)));
        };
    }

    return function has(elem) {
        return next(elem) && adapter.existsOne(func, adapter.getChildren(elem));
    };
};

filters.matches = function(next, token, options, context) {
    var opts = {
        xmlMode: !!(options && options.xmlMode),
        strict: !!(options && options.strict),
        rootFunc: next,
        adapter: options.adapter
    };

    return compileToken(token, opts, context);
};

compile.compileToken = compileToken;
compile.compileUnsafe = compileUnsafe;
compile.Pseudos = Pseudos;

},{"css-what":"node_modules/css-what/lib/index.js","boolbase":"node_modules/boolbase/index.js","./sort.js":"node_modules/css-select/lib/sort.js","./procedure.json":"node_modules/css-select/lib/procedure.json","./general.js":"node_modules/css-select/lib/general.js","./pseudos.js":"node_modules/css-select/lib/pseudos.js"}],"node_modules/css-select/index.js":[function(require,module,exports) {
"use strict";

module.exports = CSSselect;

var DomUtils = require("domutils");
var falseFunc = require("boolbase").falseFunc;
var compileRaw = require("./lib/compile.js");

function wrapCompile(func) {
    return function addAdapter(selector, options, context) {
        options = options || {};
        options.adapter = options.adapter || DomUtils;

        return func(selector, options, context);
    };
}

var compile = wrapCompile(compileRaw);
var compileUnsafe = wrapCompile(compileRaw.compileUnsafe);

function getSelectorFunc(searchFunc) {
    return function select(query, elems, options) {
        options = options || {};
        options.adapter = options.adapter || DomUtils;

        if (typeof query !== "function") {
            query = compileUnsafe(query, options, elems);
        }
        if (query.shouldTestNextSiblings) {
            elems = appendNextSiblings((options && options.context) || elems, options.adapter);
        }
        if (!Array.isArray(elems)) elems = options.adapter.getChildren(elems);
        else elems = options.adapter.removeSubsets(elems);
        return searchFunc(query, elems, options);
    };
}

function getNextSiblings(elem, adapter) {
    var siblings = adapter.getSiblings(elem);
    if (!Array.isArray(siblings)) return [];
    siblings = siblings.slice(0);
    while (siblings.shift() !== elem);
    return siblings;
}

function appendNextSiblings(elems, adapter) {
    // Order matters because jQuery seems to check the children before the siblings
    if (!Array.isArray(elems)) elems = [elems];
    var newElems = elems.slice(0);

    for (var i = 0, len = elems.length; i < len; i++) {
        var nextSiblings = getNextSiblings(newElems[i], adapter);
        newElems.push.apply(newElems, nextSiblings);
    }
    return newElems;
}

var selectAll = getSelectorFunc(function selectAll(query, elems, options) {
    return query === falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
});

var selectOne = getSelectorFunc(function selectOne(query, elems, options) {
    return query === falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
});

function is(elem, query, options) {
    options = options || {};
    options.adapter = options.adapter || DomUtils;
    return (typeof query === "function" ? query : compile(query, options))(elem);
}

/*
	the exported interface
*/
function CSSselect(query, elems, options) {
    return selectAll(query, elems, options);
}

CSSselect.compile = compile;
CSSselect.filters = compileRaw.Pseudos.filters;
CSSselect.pseudos = compileRaw.Pseudos.pseudos;

CSSselect.selectAll = selectAll;
CSSselect.selectOne = selectOne;

CSSselect.is = is;

//legacy methods (might be removed)
CSSselect.parse = compile;
CSSselect.iterate = selectAll;

//hooks
CSSselect._compileUnsafe = compileUnsafe;
CSSselect._compileToken = compileRaw.compileToken;

},{"domutils":"node_modules/domutils/index.js","boolbase":"node_modules/boolbase/index.js","./lib/compile.js":"node_modules/css-select/lib/compile.js"}],"node_modules/css-select-base-adapter/index.js":[function(require,module,exports) {
'use strict'

module.exports = adapterFactory;

function adapterFactory(implementation){
	ensureImplementation(implementation);

	var adapter = {}

	var baseAdapter = {
		removeSubsets: function (nodes){
			return removeSubsets(adapter, nodes);
		},
		existsOne: function(test, elems){
			return existsOne(adapter, test, elems);
		},
		getSiblings: function(elem){
			return getSiblings(adapter, elem);
		},
		hasAttrib: function(elem, name){
			return hasAttrib(adapter, elem, name);
		},
		findOne: function(test, arr){
			return findOne(adapter, test, arr);
		},
		findAll: function(test, elems){
			return findAll(adapter, test, elems)
		}
	};

	Object.assign(adapter, baseAdapter, implementation);

	return adapter;
}

var expectImplemented = [
	"isTag", "getAttributeValue", "getChildren", "getName", "getParent",
	"getText"
];

function ensureImplementation(implementation){
	if(!implementation)	throw new TypeError("Expected implementation")

	var notImplemented = expectImplemented.filter(function(fname){
		return typeof implementation[fname] !== "function";
	});

	if(notImplemented.length){
		var notList = "(" + notImplemented.join(", ") + ")";
		var message = "Expected functions " + notList + " to be implemented";
		throw new Error(message);
	}
}

function removeSubsets(adapter, nodes){
	var idx = nodes.length, node, ancestor, replace;

	// Check if each node (or one of its ancestors) is already contained in the
	// array.
	while(--idx > -1){
		node = ancestor = nodes[idx];

		// Temporarily remove the node under consideration
		nodes[idx] = null;
		replace = true;

		while(ancestor){
			if(nodes.indexOf(ancestor) > -1){
				replace = false;
				nodes.splice(idx, 1);
				break;
			}
			ancestor = adapter.getParent(ancestor)
		}

		// If the node has been found to be unique, re-insert it.
		if(replace){
			nodes[idx] = node;
		}
	}

	return nodes;
}

function existsOne(adapter, test, elems){
	return elems.some(function(elem){
		return adapter.isTag(elem) ?
			test(elem) || adapter.existsOne(test, adapter.getChildren(elem)) :
			false;
	});
}

function getSiblings(adapter, elem){
	var parent = adapter.getParent(elem);
	return parent && adapter.getChildren(parent);
}


function hasAttrib(adapter, elem, name){
	return adapter.getAttributeValue(elem,name) !== undefined
}

function findOne(adapter, test, arr){
	var elem = null;

	for(var i = 0, l = arr.length; i < l && !elem; i++){
		if(test(arr[i])){
			elem = arr[i];
		} else {
			var childs = adapter.getChildren(arr[i]);
			if(childs && childs.length > 0){
				elem = adapter.findOne(test, childs);
			}
		}
	}

	return elem;
}

function findAll(adapter, test, elems){
	var result = [];

	for(var i = 0, j = elems.length; i < j; i++){
		if(!adapter.isTag(elems[i])) continue;
		if(test(elems[i])) result.push(elems[i]);
		var childs = adapter.getChildren(elems[i]);
		if(childs) result = result.concat(adapter.findAll(test, childs));
	}

	return result;
}

},{}],"node_modules/svgo/lib/svgo/css-select-adapter.js":[function(require,module,exports) {
'use strict';

var baseCssAdapter = require('css-select-base-adapter');
/**
 * DOMUtils API for SVGO AST (used by css-select)
 */


var svgoCssSelectAdapterMin = {
  // is the node a tag?
  // isTag: ( node:Node ) => isTag:Boolean
  isTag: function (node) {
    return node.isElem();
  },
  // get the parent of the node
  // getParent: ( node:Node ) => parentNode:Node
  // returns null when no parent exists
  getParent: function (node) {
    return node.parentNode || null;
  },
  // get the node's children
  // getChildren: ( node:Node ) => children:[Node]
  getChildren: function (node) {
    return node.content || [];
  },
  // get the name of the tag
  // getName: ( elem:ElementNode ) => tagName:String
  getName: function (elemAst) {
    return elemAst.elem;
  },
  // get the text content of the node, and its children if it has any
  // getText: ( node:Node ) => text:String
  // returns empty string when there is no text
  getText: function (node) {
    return node.content[0].text || node.content[0].cdata || '';
  },
  // get the attribute value
  // getAttributeValue: ( elem:ElementNode, name:String ) => value:String
  // returns null when attribute doesn't exist
  getAttributeValue: function (elem, name) {
    return elem.hasAttr(name) ? elem.attr(name).value : null;
  }
}; // use base adapter for default implementation

var svgoCssSelectAdapter = baseCssAdapter(svgoCssSelectAdapterMin);
module.exports = svgoCssSelectAdapter;
},{"css-select-base-adapter":"node_modules/css-select-base-adapter/index.js"}],"node_modules/svgo/lib/svgo/jsAPI.js":[function(require,module,exports) {
'use strict';

var cssSelect = require('css-select');

var svgoCssSelectAdapter = require('./css-select-adapter');

var cssSelectOpts = {
  xmlMode: true,
  adapter: svgoCssSelectAdapter
};

var JSAPI = module.exports = function (data, parentNode) {
  Object.assign(this, data);

  if (parentNode) {
    Object.defineProperty(this, 'parentNode', {
      writable: true,
      value: parentNode
    });
  }
};
/**
 * Perform a deep clone of this node.
 *
 * @return {Object} element
 */


JSAPI.prototype.clone = function () {
  var node = this;
  var nodeData = {};
  Object.keys(node).forEach(function (key) {
    if (key !== 'class' && key !== 'style' && key !== 'content') {
      nodeData[key] = node[key];
    }
  }); // Deep-clone node data.

  nodeData = JSON.parse(JSON.stringify(nodeData)); // parentNode gets set to a proper object by the parent clone,
  // but it needs to be true/false now to do the right thing
  // in the constructor.

  var clonedNode = new JSAPI(nodeData, !!node.parentNode);

  if (node.class) {
    clonedNode.class = node.class.clone(clonedNode);
  }

  if (node.style) {
    clonedNode.style = node.style.clone(clonedNode);
  }

  if (node.content) {
    clonedNode.content = node.content.map(function (childNode) {
      var clonedChild = childNode.clone();
      clonedChild.parentNode = clonedNode;
      return clonedChild;
    });
  }

  return clonedNode;
};
/**
 * Determine if item is an element
 * (any, with a specific name or in a names array).
 *
 * @param {String|Array} [param] element name or names arrays
 * @return {Boolean}
 */


JSAPI.prototype.isElem = function (param) {
  if (!param) return !!this.elem;
  if (Array.isArray(param)) return !!this.elem && param.indexOf(this.elem) > -1;
  return !!this.elem && this.elem === param;
};
/**
 * Renames an element
 *
 * @param {String} name new element name
 * @return {Object} element
 */


JSAPI.prototype.renameElem = function (name) {
  if (name && typeof name === 'string') this.elem = this.local = name;
  return this;
};
/**
 * Determine if element is empty.
 *
 * @return {Boolean}
 */


JSAPI.prototype.isEmpty = function () {
  return !this.content || !this.content.length;
};
/**
 * Find the closest ancestor of the current element.
 * @param elemName
 *
 * @return {?Object}
 */


JSAPI.prototype.closestElem = function (elemName) {
  var elem = this;

  while ((elem = elem.parentNode) && !elem.isElem(elemName));

  return elem;
};
/**
 * Changes content by removing elements and/or adding new elements.
 *
 * @param {Number} start Index at which to start changing the content.
 * @param {Number} n Number of elements to remove.
 * @param {Array|Object} [insertion] Elements to add to the content.
 * @return {Array} Removed elements.
 */


JSAPI.prototype.spliceContent = function (start, n, insertion) {
  if (arguments.length < 2) return [];
  if (!Array.isArray(insertion)) insertion = Array.apply(null, arguments).slice(2);
  insertion.forEach(function (inner) {
    inner.parentNode = this;
  }, this);
  return this.content.splice.apply(this.content, [start, n].concat(insertion));
};
/**
 * Determine if element has an attribute
 * (any, or by name or by name + value).
 *
 * @param {String} [name] attribute name
 * @param {String} [val] attribute value (will be toString()'ed)
 * @return {Boolean}
 */


JSAPI.prototype.hasAttr = function (name, val) {
  if (!this.attrs || !Object.keys(this.attrs).length) return false;
  if (!arguments.length) return !!this.attrs;
  if (val !== undefined) return !!this.attrs[name] && this.attrs[name].value === val.toString();
  return !!this.attrs[name];
};
/**
 * Determine if element has an attribute by local name
 * (any, or by name or by name + value).
 *
 * @param {String} [localName] local attribute name
 * @param {Number|String|RegExp|Function} [val] attribute value (will be toString()'ed or executed, otherwise ignored)
 * @return {Boolean}
 */


JSAPI.prototype.hasAttrLocal = function (localName, val) {
  if (!this.attrs || !Object.keys(this.attrs).length) return false;
  if (!arguments.length) return !!this.attrs;
  var callback;

  switch (val != null && val.constructor && val.constructor.name) {
    case 'Number': // same as String

    case 'String':
      callback = stringValueTest;
      break;

    case 'RegExp':
      callback = regexpValueTest;
      break;

    case 'Function':
      callback = funcValueTest;
      break;

    default:
      callback = nameTest;
  }

  return this.someAttr(callback);

  function nameTest(attr) {
    return attr.local === localName;
  }

  function stringValueTest(attr) {
    return attr.local === localName && val == attr.value;
  }

  function regexpValueTest(attr) {
    return attr.local === localName && val.test(attr.value);
  }

  function funcValueTest(attr) {
    return attr.local === localName && val(attr.value);
  }
};
/**
 * Get a specific attribute from an element
 * (by name or name + value).
 *
 * @param {String} name attribute name
 * @param {String} [val] attribute value (will be toString()'ed)
 * @return {Object|Undefined}
 */


JSAPI.prototype.attr = function (name, val) {
  if (!this.hasAttr() || !arguments.length) return undefined;
  if (val !== undefined) return this.hasAttr(name, val) ? this.attrs[name] : undefined;
  return this.attrs[name];
};
/**
 * Get computed attribute value from an element
 *
 * @param {String} name attribute name
 * @return {Object|Undefined}
 */


JSAPI.prototype.computedAttr = function (name, val) {
  /* jshint eqnull: true */
  if (!arguments.length) return;

  for (var elem = this; elem && (!elem.hasAttr(name) || !elem.attr(name).value); elem = elem.parentNode);

  if (val != null) {
    return elem ? elem.hasAttr(name, val) : false;
  } else if (elem && elem.hasAttr(name)) {
    return elem.attrs[name].value;
  }
};
/**
 * Remove a specific attribute.
 *
 * @param {String|Array} name attribute name
 * @param {String} [val] attribute value
 * @return {Boolean}
 */


JSAPI.prototype.removeAttr = function (name, val, recursive) {
  if (!arguments.length) return false;

  if (Array.isArray(name)) {
    name.forEach(this.removeAttr, this);
    return false;
  }

  if (!this.hasAttr(name)) return false;
  if (!recursive && val && this.attrs[name].value !== val) return false;
  delete this.attrs[name];
  if (!Object.keys(this.attrs).length) delete this.attrs;
  return true;
};
/**
 * Add attribute.
 *
 * @param {Object} [attr={}] attribute object
 * @return {Object|Boolean} created attribute or false if no attr was passed in
 */


JSAPI.prototype.addAttr = function (attr) {
  attr = attr || {};
  if (attr.name === undefined || attr.prefix === undefined || attr.local === undefined) return false;
  this.attrs = this.attrs || {};
  this.attrs[attr.name] = attr;

  if (attr.name === 'class') {
    // newly added class attribute
    this.class.hasClass();
  }

  if (attr.name === 'style') {
    // newly added style attribute
    this.style.hasStyle();
  }

  return this.attrs[attr.name];
};
/**
 * Iterates over all attributes.
 *
 * @param {Function} callback callback
 * @param {Object} [context] callback context
 * @return {Boolean} false if there are no any attributes
 */


JSAPI.prototype.eachAttr = function (callback, context) {
  if (!this.hasAttr()) return false;

  for (var name in this.attrs) {
    callback.call(context, this.attrs[name]);
  }

  return true;
};
/**
 * Tests whether some attribute passes the test.
 *
 * @param {Function} callback callback
 * @param {Object} [context] callback context
 * @return {Boolean} false if there are no any attributes
 */


JSAPI.prototype.someAttr = function (callback, context) {
  if (!this.hasAttr()) return false;

  for (var name in this.attrs) {
    if (callback.call(context, this.attrs[name])) return true;
  }

  return false;
};
/**
 * Evaluate a string of CSS selectors against the element and returns matched elements.
 *
 * @param {String} selectors CSS selector(s) string
 * @return {Array} null if no elements matched
 */


JSAPI.prototype.querySelectorAll = function (selectors) {
  var matchedEls = cssSelect(selectors, this, cssSelectOpts);
  return matchedEls.length > 0 ? matchedEls : null;
};
/**
 * Evaluate a string of CSS selectors against the element and returns only the first matched element.
 *
 * @param {String} selectors CSS selector(s) string
 * @return {Array} null if no element matched
 */


JSAPI.prototype.querySelector = function (selectors) {
  return cssSelect.selectOne(selectors, this, cssSelectOpts);
};
/**
 * Test if a selector matches a given element.
 *
 * @param {String} selector CSS selector string
 * @return {Boolean} true if element would be selected by selector string, false if it does not
 */


JSAPI.prototype.matches = function (selector) {
  return cssSelect.is(this, selector, cssSelectOpts);
};
},{"css-select":"node_modules/css-select/index.js","./css-select-adapter":"node_modules/svgo/lib/svgo/css-select-adapter.js"}],"node_modules/object-keys/isArguments.js":[function(require,module,exports) {
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
  var str = toStr.call(value);
  var isArgs = str === '[object Arguments]';

  if (!isArgs) {
    isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
  }

  return isArgs;
};
},{}],"node_modules/object-keys/implementation.js":[function(require,module,exports) {
'use strict';

var keysShim;

if (!Object.keys) {
  // modified from https://github.com/es-shims/es5-shim
  var has = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;

  var isArgs = require('./isArguments'); // eslint-disable-line global-require


  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var hasDontEnumBug = !isEnumerable.call({
    toString: null
  }, 'toString');
  var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
  var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];

  var equalsConstructorPrototype = function (o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };

  var excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };

  var hasAutomationEqualityBug = function () {
    /* global window */
    if (typeof window === 'undefined') {
      return false;
    }

    for (var k in window) {
      try {
        if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
          try {
            equalsConstructorPrototype(window[k]);
          } catch (e) {
            return true;
          }
        }
      } catch (e) {
        return true;
      }
    }

    return false;
  }();

  var equalsConstructorPrototypeIfNotBuggy = function (o) {
    /* global window */
    if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o);
    }

    try {
      return equalsConstructorPrototype(o);
    } catch (e) {
      return false;
    }
  };

  keysShim = function keys(object) {
    var isObject = object !== null && typeof object === 'object';
    var isFunction = toStr.call(object) === '[object Function]';
    var isArguments = isArgs(object);
    var isString = isObject && toStr.call(object) === '[object String]';
    var theKeys = [];

    if (!isObject && !isFunction && !isArguments) {
      throw new TypeError('Object.keys called on a non-object');
    }

    var skipProto = hasProtoEnumBug && isFunction;

    if (isString && object.length > 0 && !has.call(object, 0)) {
      for (var i = 0; i < object.length; ++i) {
        theKeys.push(String(i));
      }
    }

    if (isArguments && object.length > 0) {
      for (var j = 0; j < object.length; ++j) {
        theKeys.push(String(j));
      }
    } else {
      for (var name in object) {
        if (!(skipProto && name === 'prototype') && has.call(object, name)) {
          theKeys.push(String(name));
        }
      }
    }

    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

      for (var k = 0; k < dontEnums.length; ++k) {
        if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
          theKeys.push(dontEnums[k]);
        }
      }
    }

    return theKeys;
  };
}

module.exports = keysShim;
},{"./isArguments":"node_modules/object-keys/isArguments.js"}],"node_modules/object-keys/index.js":[function(require,module,exports) {
'use strict';

var slice = Array.prototype.slice;

var isArgs = require('./isArguments');

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : require('./implementation');
var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function () {
      // Safari 5.0 bug
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);

    if (!keysWorksWithArguments) {
      Object.keys = function keys(object) {
        // eslint-disable-line func-name-matching
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }

        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }

  return Object.keys || keysShim;
};

module.exports = keysShim;
},{"./isArguments":"node_modules/object-keys/isArguments.js","./implementation":"node_modules/object-keys/implementation.js"}],"node_modules/define-properties/index.js":[function(require,module,exports) {
'use strict';

var keys = require('object-keys');

var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
  return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
  var obj = {};

  try {
    origDefineProperty(obj, 'x', {
      enumerable: false,
      value: obj
    }); // eslint-disable-next-line no-unused-vars, no-restricted-syntax

    for (var _ in obj) {
      // jscs:ignore disallowUnusedVariables
      return false;
    }

    return obj.x === obj;
  } catch (e) {
    /* this is IE 8. */
    return false;
  }
};

var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
  if (name in object && (!isFunction(predicate) || !predicate())) {
    return;
  }

  if (supportsDescriptors) {
    origDefineProperty(object, name, {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    });
  } else {
    object[name] = value;
  }
};

var defineProperties = function (object, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys(map);

  if (hasSymbols) {
    props = concat.call(props, Object.getOwnPropertySymbols(map));
  }

  for (var i = 0; i < props.length; i += 1) {
    defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
  }
};

defineProperties.supportsDescriptors = !!supportsDescriptors;
module.exports = defineProperties;
},{"object-keys":"node_modules/object-keys/index.js"}],"node_modules/has-symbols/shams.js":[function(require,module,exports) {
'use strict';
/* eslint complexity: [2, 18], max-statements: [2, 33] */

module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }

  if (typeof Symbol.iterator === 'symbol') {
    return true;
  }

  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);

  if (typeof sym === 'string') {
    return false;
  }

  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }

  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  } // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }
  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }


  var symVal = 42;
  obj[sym] = symVal;

  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax


  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }

  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }

  var syms = Object.getOwnPropertySymbols(obj);

  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }

  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }

  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);

    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }

  return true;
};
},{}],"node_modules/has-symbols/index.js":[function(require,module,exports) {
var global = arguments[3];
'use strict';

var origSymbol = global.Symbol;

var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }

  if (typeof Symbol !== 'function') {
    return false;
  }

  if (typeof origSymbol('foo') !== 'symbol') {
    return false;
  }

  if (typeof Symbol('bar') !== 'symbol') {
    return false;
  }

  return hasSymbolSham();
};
},{"./shams":"node_modules/has-symbols/shams.js"}],"node_modules/es-abstract/GetIntrinsic.js":[function(require,module,exports) {
'use strict';
/* globals
	Atomics,
	SharedArrayBuffer,
*/

var undefined;
var $TypeError = TypeError;
var $gOPD = Object.getOwnPropertyDescriptor;

if ($gOPD) {
  try {
    $gOPD({}, '');
  } catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
  }
}

var throwTypeError = function () {
  throw new $TypeError();
};

var ThrowTypeError = $gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here

    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) {
  return x.__proto__;
}; // eslint-disable-line no-proto


var generator; // = function * () {};

var generatorFunction = generator ? getProto(generator) : undefined;
var asyncFn; // async function() {};

var asyncFunction = asyncFn ? asyncFn.constructor : undefined;
var asyncGen; // async function * () {};

var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined;
var asyncGenIterator = asyncGen ? asyncGen() : undefined;
var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);
var INTRINSICS = {
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
  '%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer.prototype,
  '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
  '%ArrayPrototype%': Array.prototype,
  '%ArrayProto_entries%': Array.prototype.entries,
  '%ArrayProto_forEach%': Array.prototype.forEach,
  '%ArrayProto_keys%': Array.prototype.keys,
  '%ArrayProto_values%': Array.prototype.values,
  '%AsyncFromSyncIteratorPrototype%': undefined,
  '%AsyncFunction%': asyncFunction,
  '%AsyncFunctionPrototype%': asyncFunction ? asyncFunction.prototype : undefined,
  '%AsyncGenerator%': asyncGen ? getProto(asyncGenIterator) : undefined,
  '%AsyncGeneratorFunction%': asyncGenFunction,
  '%AsyncGeneratorPrototype%': asyncGenFunction ? asyncGenFunction.prototype : undefined,
  '%AsyncIteratorPrototype%': asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
  '%Boolean%': Boolean,
  '%BooleanPrototype%': Boolean.prototype,
  '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
  '%DataViewPrototype%': typeof DataView === 'undefined' ? undefined : DataView.prototype,
  '%Date%': Date,
  '%DatePrototype%': Date.prototype,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': Error,
  '%ErrorPrototype%': Error.prototype,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': EvalError,
  '%EvalErrorPrototype%': EvalError.prototype,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
  '%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined : Float32Array.prototype,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
  '%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined : Float64Array.prototype,
  '%Function%': Function,
  '%FunctionPrototype%': Function.prototype,
  '%Generator%': generator ? getProto(generator()) : undefined,
  '%GeneratorFunction%': generatorFunction,
  '%GeneratorPrototype%': generatorFunction ? generatorFunction.prototype : undefined,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
  '%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined : Int8Array.prototype,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
  '%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined : Int8Array.prototype,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
  '%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined : Int32Array.prototype,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
  '%JSON%': typeof JSON === 'object' ? JSON : undefined,
  '%JSONParse%': typeof JSON === 'object' ? JSON.parse : undefined,
  '%Map%': typeof Map === 'undefined' ? undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
  '%MapPrototype%': typeof Map === 'undefined' ? undefined : Map.prototype,
  '%Math%': Math,
  '%Number%': Number,
  '%NumberPrototype%': Number.prototype,
  '%Object%': Object,
  '%ObjectPrototype%': Object.prototype,
  '%ObjProto_toString%': Object.prototype.toString,
  '%ObjProto_valueOf%': Object.prototype.valueOf,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
  '%PromisePrototype%': typeof Promise === 'undefined' ? undefined : Promise.prototype,
  '%PromiseProto_then%': typeof Promise === 'undefined' ? undefined : Promise.prototype.then,
  '%Promise_all%': typeof Promise === 'undefined' ? undefined : Promise.all,
  '%Promise_reject%': typeof Promise === 'undefined' ? undefined : Promise.reject,
  '%Promise_resolve%': typeof Promise === 'undefined' ? undefined : Promise.resolve,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
  '%RangeError%': RangeError,
  '%RangeErrorPrototype%': RangeError.prototype,
  '%ReferenceError%': ReferenceError,
  '%ReferenceErrorPrototype%': ReferenceError.prototype,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
  '%RegExp%': RegExp,
  '%RegExpPrototype%': RegExp.prototype,
  '%Set%': typeof Set === 'undefined' ? undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
  '%SetPrototype%': typeof Set === 'undefined' ? undefined : Set.prototype,
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
  '%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer.prototype,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
  '%StringPrototype%': String.prototype,
  '%Symbol%': hasSymbols ? Symbol : undefined,
  '%SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined,
  '%SyntaxError%': SyntaxError,
  '%SyntaxErrorPrototype%': SyntaxError.prototype,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined,
  '%TypeError%': $TypeError,
  '%TypeErrorPrototype%': $TypeError.prototype,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
  '%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array.prototype,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
  '%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray.prototype,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
  '%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array.prototype,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
  '%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array.prototype,
  '%URIError%': URIError,
  '%URIErrorPrototype%': URIError.prototype,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
  '%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined : WeakMap.prototype,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
  '%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined : WeakSet.prototype
};

var bind = require('function-bind');

var $replace = bind.call(Function.call, String.prototype.replace);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */

var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
/** Used to match backslashes in property paths. */

var stringToPath = function stringToPath(string) {
  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */


var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  if (!(name in INTRINSICS)) {
    throw new SyntaxError('intrinsic ' + name + ' does not exist!');
  } // istanbul ignore if // hopefully this is impossible to test :-)


  if (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {
    throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
  }

  return INTRINSICS[name];
};

module.exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new TypeError('intrinsic name must be a non-empty string');
  }

  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new TypeError('"allowMissing" argument must be a boolean');
  }

  var parts = stringToPath(name);
  var value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);

  for (var i = 1; i < parts.length; i += 1) {
    if (value != null) {
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, parts[i]);

        if (!allowMissing && !(parts[i] in value)) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }

        value = desc ? desc.get || desc.value : value[parts[i]];
      } else {
        value = value[parts[i]];
      }
    }
  }

  return value;
};
},{"has-symbols":"node_modules/has-symbols/index.js","function-bind":"node_modules/function-bind/index.js"}],"node_modules/es-abstract/5/CheckObjectCoercible.js":[function(require,module,exports) {
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $TypeError = GetIntrinsic('%TypeError%'); // http://www.ecma-international.org/ecma-262/5.1/#sec-9.10

module.exports = function CheckObjectCoercible(value, optMessage) {
  if (value == null) {
    throw new $TypeError(optMessage || 'Cannot call method on ' + value);
  }

  return value;
};
},{"../GetIntrinsic":"node_modules/es-abstract/GetIntrinsic.js"}],"node_modules/es-abstract/2019/RequireObjectCoercible.js":[function(require,module,exports) {
'use strict';

module.exports = require('../5/CheckObjectCoercible');
},{"../5/CheckObjectCoercible":"node_modules/es-abstract/5/CheckObjectCoercible.js"}],"node_modules/es-abstract/helpers/callBind.js":[function(require,module,exports) {
'use strict';

var bind = require('function-bind');

var GetIntrinsic = require('../GetIntrinsic');

var $Function = GetIntrinsic('%Function%');
var $apply = $Function.apply;
var $call = $Function.call;

module.exports = function callBind() {
  return bind.apply($call, arguments);
};

module.exports.apply = function applyBind() {
  return bind.apply($apply, arguments);
};
},{"function-bind":"node_modules/function-bind/index.js","../GetIntrinsic":"node_modules/es-abstract/GetIntrinsic.js"}],"node_modules/es-abstract/helpers/callBound.js":[function(require,module,exports) {
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var callBind = require('./callBind');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic(name, !!allowMissing);

  if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.')) {
    return callBind(intrinsic);
  }

  return intrinsic;
};
},{"../GetIntrinsic":"node_modules/es-abstract/GetIntrinsic.js","./callBind":"node_modules/es-abstract/helpers/callBind.js"}],"node_modules/object.values/implementation.js":[function(require,module,exports) {
'use strict';

var has = require('has');

var RequireObjectCoercible = require('es-abstract/2019/RequireObjectCoercible');

var callBound = require('es-abstract/helpers/callBound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

module.exports = function values(O) {
  var obj = RequireObjectCoercible(O);
  var vals = [];

  for (var key in obj) {
    if (has(obj, key) && $isEnumerable(obj, key)) {
      vals.push(obj[key]);
    }
  }

  return vals;
};
},{"has":"node_modules/has/src/index.js","es-abstract/2019/RequireObjectCoercible":"node_modules/es-abstract/2019/RequireObjectCoercible.js","es-abstract/helpers/callBound":"node_modules/es-abstract/helpers/callBound.js"}],"node_modules/object.values/polyfill.js":[function(require,module,exports) {
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
  return typeof Object.values === 'function' ? Object.values : implementation;
};
},{"./implementation":"node_modules/object.values/implementation.js"}],"node_modules/object.values/shim.js":[function(require,module,exports) {

'use strict';

var getPolyfill = require('./polyfill');

var define = require('define-properties');

module.exports = function shimValues() {
  var polyfill = getPolyfill();
  define(Object, {
    values: polyfill
  }, {
    values: function testValues() {
      return Object.values !== polyfill;
    }
  });
  return polyfill;
};
},{"./polyfill":"node_modules/object.values/polyfill.js","define-properties":"node_modules/define-properties/index.js"}],"node_modules/object.values/index.js":[function(require,module,exports) {

'use strict';

var define = require('define-properties');

var implementation = require('./implementation');

var getPolyfill = require('./polyfill');

var shim = require('./shim');

var polyfill = getPolyfill();
define(polyfill, {
  getPolyfill: getPolyfill,
  implementation: implementation,
  shim: shim
});
module.exports = polyfill;
},{"define-properties":"node_modules/define-properties/index.js","./implementation":"node_modules/object.values/implementation.js","./polyfill":"node_modules/object.values/polyfill.js","./shim":"node_modules/object.values/shim.js"}],"node_modules/svgo/lib/svgo/css-class-list.js":[function(require,module,exports) {
'use strict';

var values = require('object.values');

if (!Object.values) {
  values.shim();
}

var CSSClassList = function (node) {
  this.parentNode = node;
  this.classNames = new Set();
  this.classAttr = null; //this.classValue = null;
};
/**
 * Performs a deep clone of this object.
 *
 * @param parentNode the parentNode to assign to the cloned result
 */


CSSClassList.prototype.clone = function (parentNode) {
  var node = this;
  var nodeData = {};
  Object.keys(node).forEach(function (key) {
    if (key !== 'parentNode') {
      nodeData[key] = node[key];
    }
  }); // Deep-clone node data.

  nodeData = JSON.parse(JSON.stringify(nodeData));
  var clone = new CSSClassList(parentNode);
  Object.assign(clone, nodeData);
  return clone;
};

CSSClassList.prototype.hasClass = function () {
  this.classAttr = {
    // empty class attr
    'name': 'class',
    'value': null
  };
  this.addClassHandler();
}; // attr.class


CSSClassList.prototype.addClassHandler = function () {
  Object.defineProperty(this.parentNode.attrs, 'class', {
    get: this.getClassAttr.bind(this),
    set: this.setClassAttr.bind(this),
    enumerable: true,
    configurable: true
  });
  this.addClassValueHandler();
}; // attr.class.value


CSSClassList.prototype.addClassValueHandler = function () {
  Object.defineProperty(this.classAttr, 'value', {
    get: this.getClassValue.bind(this),
    set: this.setClassValue.bind(this),
    enumerable: true,
    configurable: true
  });
};

CSSClassList.prototype.getClassAttr = function () {
  return this.classAttr;
};

CSSClassList.prototype.setClassAttr = function (newClassAttr) {
  this.setClassValue(newClassAttr.value); // must before applying value handler!

  this.classAttr = newClassAttr;
  this.addClassValueHandler();
};

CSSClassList.prototype.getClassValue = function () {
  var arrClassNames = Array.from(this.classNames);
  return arrClassNames.join(' ');
};

CSSClassList.prototype.setClassValue = function (newValue) {
  if (typeof newValue === 'undefined') {
    this.classNames.clear();
    return;
  }

  var arrClassNames = newValue.split(' ');
  this.classNames = new Set(arrClassNames);
};

CSSClassList.prototype.add = function ()
/* variadic */
{
  this.hasClass();
  Object.values(arguments).forEach(this._addSingle.bind(this));
};

CSSClassList.prototype._addSingle = function (className) {
  this.classNames.add(className);
};

CSSClassList.prototype.remove = function ()
/* variadic */
{
  this.hasClass();
  Object.values(arguments).forEach(this._removeSingle.bind(this));
};

CSSClassList.prototype._removeSingle = function (className) {
  this.classNames.delete(className);
};

CSSClassList.prototype.item = function (index) {
  var arrClassNames = Array.from(this.classNames);
  return arrClassNames[index];
};

CSSClassList.prototype.toggle = function (className, force) {
  if (this.contains(className) || force === false) {
    this.classNames.delete(className);
  }

  this.classNames.add(className);
};

CSSClassList.prototype.contains = function (className) {
  return this.classNames.has(className);
};

module.exports = CSSClassList;
},{"object.values":"node_modules/object.values/index.js"}],"node_modules/css-tree/lib/common/List.js":[function(require,module,exports) {
//
//                              list
//                            ┌──────┐
//             ┌──────────────┼─head │
//             │              │ tail─┼──────────────┐
//             │              └──────┘              │
//             ▼                                    ▼
//            item        item        item        item
//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
//          │ data │    │ data │    │ data │    │ data │
//          └──────┘    └──────┘    └──────┘    └──────┘
//
function createItem(data) {
  return {
    prev: null,
    next: null,
    data: data
  };
}

function allocateCursor(node, prev, next) {
  var cursor;

  if (cursors !== null) {
    cursor = cursors;
    cursors = cursors.cursor;
    cursor.prev = prev;
    cursor.next = next;
    cursor.cursor = node.cursor;
  } else {
    cursor = {
      prev: prev,
      next: next,
      cursor: node.cursor
    };
  }

  node.cursor = cursor;
  return cursor;
}

function releaseCursor(node) {
  var cursor = node.cursor;
  node.cursor = cursor.cursor;
  cursor.prev = null;
  cursor.next = null;
  cursor.cursor = cursors;
  cursors = cursor;
}

var cursors = null;

var List = function List() {
  this.cursor = null;
  this.head = null;
  this.tail = null;
};

List.createItem = createItem;
List.prototype.createItem = createItem;

List.prototype.updateCursors = function (prevOld, prevNew, nextOld, nextNew) {
  var cursor = this.cursor;

  while (cursor !== null) {
    if (cursor.prev === prevOld) {
      cursor.prev = prevNew;
    }

    if (cursor.next === nextOld) {
      cursor.next = nextNew;
    }

    cursor = cursor.cursor;
  }
};

List.prototype.getSize = function () {
  var size = 0;
  var cursor = this.head;

  while (cursor) {
    size++;
    cursor = cursor.next;
  }

  return size;
};

List.prototype.fromArray = function (array) {
  var cursor = null;
  this.head = null;

  for (var i = 0; i < array.length; i++) {
    var item = createItem(array[i]);

    if (cursor !== null) {
      cursor.next = item;
    } else {
      this.head = item;
    }

    item.prev = cursor;
    cursor = item;
  }

  this.tail = cursor;
  return this;
};

List.prototype.toArray = function () {
  var cursor = this.head;
  var result = [];

  while (cursor) {
    result.push(cursor.data);
    cursor = cursor.next;
  }

  return result;
};

List.prototype.toJSON = List.prototype.toArray;

List.prototype.isEmpty = function () {
  return this.head === null;
};

List.prototype.first = function () {
  return this.head && this.head.data;
};

List.prototype.last = function () {
  return this.tail && this.tail.data;
};

List.prototype.each = function (fn, context) {
  var item;

  if (context === undefined) {
    context = this;
  } // push cursor


  var cursor = allocateCursor(this, null, this.head);

  while (cursor.next !== null) {
    item = cursor.next;
    cursor.next = item.next;
    fn.call(context, item.data, item, this);
  } // pop cursor


  releaseCursor(this);
};

List.prototype.forEach = List.prototype.each;

List.prototype.eachRight = function (fn, context) {
  var item;

  if (context === undefined) {
    context = this;
  } // push cursor


  var cursor = allocateCursor(this, this.tail, null);

  while (cursor.prev !== null) {
    item = cursor.prev;
    cursor.prev = item.prev;
    fn.call(context, item.data, item, this);
  } // pop cursor


  releaseCursor(this);
};

List.prototype.forEachRight = List.prototype.eachRight;

List.prototype.nextUntil = function (start, fn, context) {
  if (start === null) {
    return;
  }

  var item;

  if (context === undefined) {
    context = this;
  } // push cursor


  var cursor = allocateCursor(this, null, start);

  while (cursor.next !== null) {
    item = cursor.next;
    cursor.next = item.next;

    if (fn.call(context, item.data, item, this)) {
      break;
    }
  } // pop cursor


  releaseCursor(this);
};

List.prototype.prevUntil = function (start, fn, context) {
  if (start === null) {
    return;
  }

  var item;

  if (context === undefined) {
    context = this;
  } // push cursor


  var cursor = allocateCursor(this, start, null);

  while (cursor.prev !== null) {
    item = cursor.prev;
    cursor.prev = item.prev;

    if (fn.call(context, item.data, item, this)) {
      break;
    }
  } // pop cursor


  releaseCursor(this);
};

List.prototype.some = function (fn, context) {
  var cursor = this.head;

  if (context === undefined) {
    context = this;
  }

  while (cursor !== null) {
    if (fn.call(context, cursor.data, cursor, this)) {
      return true;
    }

    cursor = cursor.next;
  }

  return false;
};

List.prototype.map = function (fn, context) {
  var result = new List();
  var cursor = this.head;

  if (context === undefined) {
    context = this;
  }

  while (cursor !== null) {
    result.appendData(fn.call(context, cursor.data, cursor, this));
    cursor = cursor.next;
  }

  return result;
};

List.prototype.filter = function (fn, context) {
  var result = new List();
  var cursor = this.head;

  if (context === undefined) {
    context = this;
  }

  while (cursor !== null) {
    if (fn.call(context, cursor.data, cursor, this)) {
      result.appendData(cursor.data);
    }

    cursor = cursor.next;
  }

  return result;
};

List.prototype.clear = function () {
  this.head = null;
  this.tail = null;
};

List.prototype.copy = function () {
  var result = new List();
  var cursor = this.head;

  while (cursor !== null) {
    result.insert(createItem(cursor.data));
    cursor = cursor.next;
  }

  return result;
};

List.prototype.prepend = function (item) {
  //      head
  //    ^
  // item
  this.updateCursors(null, item, this.head, item); // insert to the beginning of the list

  if (this.head !== null) {
    // new item <- first item
    this.head.prev = item; // new item -> first item

    item.next = this.head;
  } else {
    // if list has no head, then it also has no tail
    // in this case tail points to the new item
    this.tail = item;
  } // head always points to new item


  this.head = item;
  return this;
};

List.prototype.prependData = function (data) {
  return this.prepend(createItem(data));
};

List.prototype.append = function (item) {
  return this.insert(item);
};

List.prototype.appendData = function (data) {
  return this.insert(createItem(data));
};

List.prototype.insert = function (item, before) {
  if (before !== undefined && before !== null) {
    // prev   before
    //      ^
    //     item
    this.updateCursors(before.prev, item, before, item);

    if (before.prev === null) {
      // insert to the beginning of list
      if (this.head !== before) {
        throw new Error('before doesn\'t belong to list');
      } // since head points to before therefore list doesn't empty
      // no need to check tail


      this.head = item;
      before.prev = item;
      item.next = before;
      this.updateCursors(null, item);
    } else {
      // insert between two items
      before.prev.next = item;
      item.prev = before.prev;
      before.prev = item;
      item.next = before;
    }
  } else {
    // tail
    //      ^
    //      item
    this.updateCursors(this.tail, item, null, item); // insert to the ending of the list

    if (this.tail !== null) {
      // last item -> new item
      this.tail.next = item; // last item <- new item

      item.prev = this.tail;
    } else {
      // if list has no tail, then it also has no head
      // in this case head points to new item
      this.head = item;
    } // tail always points to new item


    this.tail = item;
  }

  return this;
};

List.prototype.insertData = function (data, before) {
  return this.insert(createItem(data), before);
};

List.prototype.remove = function (item) {
  //      item
  //       ^
  // prev     next
  this.updateCursors(item, item.prev, item, item.next);

  if (item.prev !== null) {
    item.prev.next = item.next;
  } else {
    if (this.head !== item) {
      throw new Error('item doesn\'t belong to list');
    }

    this.head = item.next;
  }

  if (item.next !== null) {
    item.next.prev = item.prev;
  } else {
    if (this.tail !== item) {
      throw new Error('item doesn\'t belong to list');
    }

    this.tail = item.prev;
  }

  item.prev = null;
  item.next = null;
  return item;
};

List.prototype.push = function (data) {
  this.insert(createItem(data));
};

List.prototype.pop = function () {
  if (this.tail !== null) {
    return this.remove(this.tail);
  }
};

List.prototype.unshift = function (data) {
  this.prepend(createItem(data));
};

List.prototype.shift = function () {
  if (this.head !== null) {
    return this.remove(this.head);
  }
};

List.prototype.prependList = function (list) {
  return this.insertList(list, this.head);
};

List.prototype.appendList = function (list) {
  return this.insertList(list);
};

List.prototype.insertList = function (list, before) {
  // ignore empty lists
  if (list.head === null) {
    return this;
  }

  if (before !== undefined && before !== null) {
    this.updateCursors(before.prev, list.tail, before, list.head); // insert in the middle of dist list

    if (before.prev !== null) {
      // before.prev <-> list.head
      before.prev.next = list.head;
      list.head.prev = before.prev;
    } else {
      this.head = list.head;
    }

    before.prev = list.tail;
    list.tail.next = before;
  } else {
    this.updateCursors(this.tail, list.tail, null, list.head); // insert to end of the list

    if (this.tail !== null) {
      // if destination list has a tail, then it also has a head,
      // but head doesn't change
      // dest tail -> source head
      this.tail.next = list.head; // dest tail <- source head

      list.head.prev = this.tail;
    } else {
      // if list has no a tail, then it also has no a head
      // in this case points head to new item
      this.head = list.head;
    } // tail always start point to new item


    this.tail = list.tail;
  }

  list.head = null;
  list.tail = null;
  return this;
};

List.prototype.replace = function (oldItem, newItemOrList) {
  if ('head' in newItemOrList) {
    this.insertList(newItemOrList, oldItem);
  } else {
    this.insert(newItemOrList, oldItem);
  }

  this.remove(oldItem);
};

module.exports = List;
},{}],"node_modules/css-tree/lib/utils/createCustomError.js":[function(require,module,exports) {
module.exports = function createCustomError(name, message) {
  // use Object.create(), because some VMs prevent setting line/column otherwise
  // (iOS Safari 10 even throws an exception)
  var error = Object.create(SyntaxError.prototype);
  var errorStack = new Error();
  error.name = name;
  error.message = message;
  Object.defineProperty(error, 'stack', {
    get: function get() {
      return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
    }
  });
  return error;
};
},{}],"node_modules/css-tree/lib/common/SyntaxError.js":[function(require,module,exports) {
var createCustomError = require('../utils/createCustomError');

var MAX_LINE_LENGTH = 100;
var OFFSET_CORRECTION = 60;
var TAB_REPLACEMENT = '    ';

function sourceFragment(error, extraLines) {
  function processLines(start, end) {
    return lines.slice(start, end).map(function (line, idx) {
      var num = String(start + idx + 1);

      while (num.length < maxNumLength) {
        num = ' ' + num;
      }

      return num + ' |' + line;
    }).join('\n');
  }

  var lines = error.source.split(/\r\n?|\n|\f/);
  var line = error.line;
  var column = error.column;
  var startLine = Math.max(1, line - extraLines) - 1;
  var endLine = Math.min(line + extraLines, lines.length + 1);
  var maxNumLength = Math.max(4, String(endLine).length) + 1;
  var cutLeft = 0; // column correction according to replaced tab before column

  column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

  if (column > MAX_LINE_LENGTH) {
    cutLeft = column - OFFSET_CORRECTION + 3;
    column = OFFSET_CORRECTION - 2;
  }

  for (var i = startLine; i <= endLine; i++) {
    if (i >= 0 && i < lines.length) {
      lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
      lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "\u2026" : '') + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : '');
    }
  }

  return [processLines(startLine, line), new Array(column + maxNumLength + 2).join('-') + '^', processLines(line, endLine)].filter(Boolean).join('\n');
}

var SyntaxError = function SyntaxError(message, source, offset, line, column) {
  var error = createCustomError('SyntaxError', message);
  error.source = source;
  error.offset = offset;
  error.line = line;
  error.column = column;

  error.sourceFragment = function (extraLines) {
    return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
  };

  Object.defineProperty(error, 'formattedMessage', {
    get: function get() {
      return 'Parse error: ' + error.message + '\n' + sourceFragment(error, 2);
    }
  }); // for backward capability

  error.parseError = {
    offset: offset,
    line: line,
    column: column
  };
  return error;
};

module.exports = SyntaxError;
},{"../utils/createCustomError":"node_modules/css-tree/lib/utils/createCustomError.js"}],"node_modules/css-tree/lib/tokenizer/const.js":[function(require,module,exports) {
// CSS Syntax Module Level 3
// https://www.w3.org/TR/css-syntax-3/
var TYPE = {
  EOF: 0,
  // <EOF-token>
  Ident: 1,
  // <ident-token>
  Function: 2,
  // <function-token>
  AtKeyword: 3,
  // <at-keyword-token>
  Hash: 4,
  // <hash-token>
  String: 5,
  // <string-token>
  BadString: 6,
  // <bad-string-token>
  Url: 7,
  // <url-token>
  BadUrl: 8,
  // <bad-url-token>
  Delim: 9,
  // <delim-token>
  Number: 10,
  // <number-token>
  Percentage: 11,
  // <percentage-token>
  Dimension: 12,
  // <dimension-token>
  WhiteSpace: 13,
  // <whitespace-token>
  CDO: 14,
  // <CDO-token>
  CDC: 15,
  // <CDC-token>
  Colon: 16,
  // <colon-token>     :
  Semicolon: 17,
  // <semicolon-token> ;
  Comma: 18,
  // <comma-token>     ,
  LeftSquareBracket: 19,
  // <[-token>
  RightSquareBracket: 20,
  // <]-token>
  LeftParenthesis: 21,
  // <(-token>
  RightParenthesis: 22,
  // <)-token>
  LeftCurlyBracket: 23,
  // <{-token>
  RightCurlyBracket: 24,
  // <}-token>
  Comment: 25
};
var NAME = Object.keys(TYPE).reduce(function (result, key) {
  result[TYPE[key]] = key;
  return result;
}, {});
module.exports = {
  TYPE: TYPE,
  NAME: NAME
};
},{}],"node_modules/css-tree/lib/tokenizer/char-code-definitions.js":[function(require,module,exports) {
var EOF = 0; // https://drafts.csswg.org/css-syntax-3/
// § 4.2. Definitions
// digit
// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).

function isDigit(code) {
  return code >= 0x0030 && code <= 0x0039;
} // hex digit
// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).


function isHexDigit(code) {
  return isDigit(code) || // 0 .. 9
  code >= 0x0041 && code <= 0x0046 || // A .. F
  code >= 0x0061 && code <= 0x0066 // a .. f
  ;
} // uppercase letter
// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).


function isUppercaseLetter(code) {
  return code >= 0x0041 && code <= 0x005A;
} // lowercase letter
// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).


function isLowercaseLetter(code) {
  return code >= 0x0061 && code <= 0x007A;
} // letter
// An uppercase letter or a lowercase letter.


function isLetter(code) {
  return isUppercaseLetter(code) || isLowercaseLetter(code);
} // non-ASCII code point
// A code point with a value equal to or greater than U+0080 <control>.


function isNonAscii(code) {
  return code >= 0x0080;
} // name-start code point
// A letter, a non-ASCII code point, or U+005F LOW LINE (_).


function isNameStart(code) {
  return isLetter(code) || isNonAscii(code) || code === 0x005F;
} // name code point
// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).


function isName(code) {
  return isNameStart(code) || isDigit(code) || code === 0x002D;
} // non-printable code point
// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.


function isNonPrintable(code) {
  return code >= 0x0000 && code <= 0x0008 || code === 0x000B || code >= 0x000E && code <= 0x001F || code === 0x007F;
} // newline
// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
// as they are converted to U+000A LINE FEED during preprocessing.
// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED


function isNewline(code) {
  return code === 0x000A || code === 0x000D || code === 0x000C;
} // whitespace
// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.


function isWhiteSpace(code) {
  return isNewline(code) || code === 0x0020 || code === 0x0009;
} // § 4.3.8. Check if two code points are a valid escape


function isValidEscape(first, second) {
  // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
  if (first !== 0x005C) {
    return false;
  } // Otherwise, if the second code point is a newline or EOF, return false.


  if (isNewline(second) || second === EOF) {
    return false;
  } // Otherwise, return true.


  return true;
} // § 4.3.9. Check if three code points would start an identifier


function isIdentifierStart(first, second, third) {
  // Look at the first code point:
  // U+002D HYPHEN-MINUS
  if (first === 0x002D) {
    // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
    // or the second and third code points are a valid escape, return true. Otherwise, return false.
    return isNameStart(second) || second === 0x002D || isValidEscape(second, third);
  } // name-start code point


  if (isNameStart(first)) {
    // Return true.
    return true;
  } // U+005C REVERSE SOLIDUS (\)


  if (first === 0x005C) {
    // If the first and second code points are a valid escape, return true. Otherwise, return false.
    return isValidEscape(first, second);
  } // anything else
  // Return false.


  return false;
} // § 4.3.10. Check if three code points would start a number


function isNumberStart(first, second, third) {
  // Look at the first code point:
  // U+002B PLUS SIGN (+)
  // U+002D HYPHEN-MINUS (-)
  if (first === 0x002B || first === 0x002D) {
    // If the second code point is a digit, return true.
    if (isDigit(second)) {
      return 2;
    } // Otherwise, if the second code point is a U+002E FULL STOP (.)
    // and the third code point is a digit, return true.
    // Otherwise, return false.


    return second === 0x002E && isDigit(third) ? 3 : 0;
  } // U+002E FULL STOP (.)


  if (first === 0x002E) {
    // If the second code point is a digit, return true. Otherwise, return false.
    return isDigit(second) ? 2 : 0;
  } // digit


  if (isDigit(first)) {
    // Return true.
    return 1;
  } // anything else
  // Return false.


  return 0;
} //
// Misc
//
// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)


function isBOM(code) {
  // UTF-16BE
  if (code === 0xFEFF) {
    return 1;
  } // UTF-16LE


  if (code === 0xFFFE) {
    return 1;
  }

  return 0;
} // Fast code category
//
// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
// > non-ASCII code point
// >   A code point with a value equal to or greater than U+0080 <control>
// > name-start code point
// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
// > name code point
// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only


var CATEGORY = new Array(0x80);
charCodeCategory.Eof = 0x80;
charCodeCategory.WhiteSpace = 0x82;
charCodeCategory.Digit = 0x83;
charCodeCategory.NameStart = 0x84;
charCodeCategory.NonPrintable = 0x85;

for (var i = 0; i < CATEGORY.length; i++) {
  switch (true) {
    case isWhiteSpace(i):
      CATEGORY[i] = charCodeCategory.WhiteSpace;
      break;

    case isDigit(i):
      CATEGORY[i] = charCodeCategory.Digit;
      break;

    case isNameStart(i):
      CATEGORY[i] = charCodeCategory.NameStart;
      break;

    case isNonPrintable(i):
      CATEGORY[i] = charCodeCategory.NonPrintable;
      break;

    default:
      CATEGORY[i] = i || charCodeCategory.Eof;
  }
}

function charCodeCategory(code) {
  return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
}

;
module.exports = {
  isDigit: isDigit,
  isHexDigit: isHexDigit,
  isUppercaseLetter: isUppercaseLetter,
  isLowercaseLetter: isLowercaseLetter,
  isLetter: isLetter,
  isNonAscii: isNonAscii,
  isNameStart: isNameStart,
  isName: isName,
  isNonPrintable: isNonPrintable,
  isNewline: isNewline,
  isWhiteSpace: isWhiteSpace,
  isValidEscape: isValidEscape,
  isIdentifierStart: isIdentifierStart,
  isNumberStart: isNumberStart,
  isBOM: isBOM,
  charCodeCategory: charCodeCategory
};
},{}],"node_modules/css-tree/lib/tokenizer/utils.js":[function(require,module,exports) {
var charCodeDef = require('./char-code-definitions');

var isDigit = charCodeDef.isDigit;
var isHexDigit = charCodeDef.isHexDigit;
var isUppercaseLetter = charCodeDef.isUppercaseLetter;
var isName = charCodeDef.isName;
var isWhiteSpace = charCodeDef.isWhiteSpace;
var isValidEscape = charCodeDef.isValidEscape;

function getCharCode(source, offset) {
  return offset < source.length ? source.charCodeAt(offset) : 0;
}

function getNewlineLength(source, offset, code) {
  if (code === 13
  /* \r */
  && getCharCode(source, offset + 1) === 10
  /* \n */
  ) {
      return 2;
    }

  return 1;
}

function cmpChar(testStr, offset, referenceCode) {
  var code = testStr.charCodeAt(offset); // code.toLowerCase() for A..Z

  if (isUppercaseLetter(code)) {
    code = code | 32;
  }

  return code === referenceCode;
}

function cmpStr(testStr, start, end, referenceStr) {
  if (end - start !== referenceStr.length) {
    return false;
  }

  if (start < 0 || end > testStr.length) {
    return false;
  }

  for (var i = start; i < end; i++) {
    var testCode = testStr.charCodeAt(i);
    var referenceCode = referenceStr.charCodeAt(i - start); // testCode.toLowerCase() for A..Z

    if (isUppercaseLetter(testCode)) {
      testCode = testCode | 32;
    }

    if (testCode !== referenceCode) {
      return false;
    }
  }

  return true;
}

function findWhiteSpaceStart(source, offset) {
  for (; offset >= 0; offset--) {
    if (!isWhiteSpace(source.charCodeAt(offset))) {
      break;
    }
  }

  return offset + 1;
}

function findWhiteSpaceEnd(source, offset) {
  for (; offset < source.length; offset++) {
    if (!isWhiteSpace(source.charCodeAt(offset))) {
      break;
    }
  }

  return offset;
}

function findDecimalNumberEnd(source, offset) {
  for (; offset < source.length; offset++) {
    if (!isDigit(source.charCodeAt(offset))) {
      break;
    }
  }

  return offset;
} // § 4.3.7. Consume an escaped code point


function consumeEscaped(source, offset) {
  // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
  // that the next input code point has already been verified to be part of a valid escape.
  offset += 2; // hex digit

  if (isHexDigit(getCharCode(source, offset - 1))) {
    // Consume as many hex digits as possible, but no more than 5.
    // Note that this means 1-6 hex digits have been consumed in total.
    for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
      if (!isHexDigit(getCharCode(source, offset))) {
        break;
      }
    } // If the next input code point is whitespace, consume it as well.


    var code = getCharCode(source, offset);

    if (isWhiteSpace(code)) {
      offset += getNewlineLength(source, offset, code);
    }
  }

  return offset;
} // §4.3.11. Consume a name
// Note: This algorithm does not do the verification of the first few code points that are necessary
// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
// ensure that the stream starts with an identifier before calling this algorithm.


function consumeName(source, offset) {
  // Let result initially be an empty string.
  // Repeatedly consume the next input code point from the stream:
  for (; offset < source.length; offset++) {
    var code = source.charCodeAt(offset); // name code point

    if (isName(code)) {
      // Append the code point to result.
      continue;
    } // the stream starts with a valid escape


    if (isValidEscape(code, getCharCode(source, offset + 1))) {
      // Consume an escaped code point. Append the returned code point to result.
      offset = consumeEscaped(source, offset) - 1;
      continue;
    } // anything else
    // Reconsume the current input code point. Return result.


    break;
  }

  return offset;
} // §4.3.12. Consume a number


function consumeNumber(source, offset) {
  var code = source.charCodeAt(offset); // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
  // consume it and append it to repr.

  if (code === 0x002B || code === 0x002D) {
    code = source.charCodeAt(offset += 1);
  } // 3. While the next input code point is a digit, consume it and append it to repr.


  if (isDigit(code)) {
    offset = findDecimalNumberEnd(source, offset + 1);
    code = source.charCodeAt(offset);
  } // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:


  if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {
    // 4.1 Consume them.
    // 4.2 Append them to repr.
    code = source.charCodeAt(offset += 2); // 4.3 Set type to "number".
    // TODO
    // 4.4 While the next input code point is a digit, consume it and append it to repr.

    offset = findDecimalNumberEnd(source, offset);
  } // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
  // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:


  if (cmpChar(source, offset, 101
  /* e */
  )) {
    var sign = 0;
    code = source.charCodeAt(offset + 1); // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...

    if (code === 0x002D || code === 0x002B) {
      sign = 1;
      code = source.charCodeAt(offset + 2);
    } // ... followed by a digit


    if (isDigit(code)) {
      // 5.1 Consume them.
      // 5.2 Append them to repr.
      // 5.3 Set type to "number".
      // TODO
      // 5.4 While the next input code point is a digit, consume it and append it to repr.
      offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
    }
  }

  return offset;
} // § 4.3.14. Consume the remnants of a bad url
// ... its sole use is to consume enough of the input stream to reach a recovery point
// where normal tokenizing can resume.


function consumeBadUrlRemnants(source, offset) {
  // Repeatedly consume the next input code point from the stream:
  for (; offset < source.length; offset++) {
    var code = source.charCodeAt(offset); // U+0029 RIGHT PARENTHESIS ())
    // EOF

    if (code === 0x0029) {
      // Return.
      offset++;
      break;
    }

    if (isValidEscape(code, getCharCode(source, offset + 1))) {
      // Consume an escaped code point.
      // Note: This allows an escaped right parenthesis ("\)") to be encountered
      // without ending the <bad-url-token>. This is otherwise identical to
      // the "anything else" clause.
      offset = consumeEscaped(source, offset);
    }
  }

  return offset;
}

module.exports = {
  consumeEscaped: consumeEscaped,
  consumeName: consumeName,
  consumeNumber: consumeNumber,
  consumeBadUrlRemnants: consumeBadUrlRemnants,
  cmpChar: cmpChar,
  cmpStr: cmpStr,
  getNewlineLength: getNewlineLength,
  findWhiteSpaceStart: findWhiteSpaceStart,
  findWhiteSpaceEnd: findWhiteSpaceEnd
};
},{"./char-code-definitions":"node_modules/css-tree/lib/tokenizer/char-code-definitions.js"}],"node_modules/css-tree/lib/common/TokenStream.js":[function(require,module,exports) {
var constants = require('../tokenizer/const');

var TYPE = constants.TYPE;
var NAME = constants.NAME;

var utils = require('../tokenizer/utils');

var cmpStr = utils.cmpStr;
var EOF = TYPE.EOF;
var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var OFFSET_MASK = 0x00FFFFFF;
var TYPE_SHIFT = 24;

var TokenStream = function TokenStream() {
  this.offsetAndType = null;
  this.balance = null;
  this.reset();
};

TokenStream.prototype = {
  reset: function reset() {
    this.eof = false;
    this.tokenIndex = -1;
    this.tokenType = 0;
    this.tokenStart = this.firstCharOffset;
    this.tokenEnd = this.firstCharOffset;
  },
  lookupType: function lookupType(offset) {
    offset += this.tokenIndex;

    if (offset < this.tokenCount) {
      return this.offsetAndType[offset] >> TYPE_SHIFT;
    }

    return EOF;
  },
  lookupOffset: function lookupOffset(offset) {
    offset += this.tokenIndex;

    if (offset < this.tokenCount) {
      return this.offsetAndType[offset - 1] & OFFSET_MASK;
    }

    return this.source.length;
  },
  lookupValue: function lookupValue(offset, referenceStr) {
    offset += this.tokenIndex;

    if (offset < this.tokenCount) {
      return cmpStr(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);
    }

    return false;
  },
  getTokenStart: function getTokenStart(tokenIndex) {
    if (tokenIndex === this.tokenIndex) {
      return this.tokenStart;
    }

    if (tokenIndex > 0) {
      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
    }

    return this.firstCharOffset;
  },
  // TODO: -> skipUntilBalanced
  getRawLength: function getRawLength(startToken, mode) {
    var cursor = startToken;
    var balanceEnd;
    var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
    var type;

    loop: for (; cursor < this.tokenCount; cursor++) {
      balanceEnd = this.balance[cursor]; // stop scanning on balance edge that points to offset before start token

      if (balanceEnd < startToken) {
        break loop;
      }

      type = this.offsetAndType[cursor] >> TYPE_SHIFT; // check token is stop type

      switch (mode(type, this.source, offset)) {
        case 1:
          break loop;

        case 2:
          cursor++;
          break loop;

        default:
          offset = this.offsetAndType[cursor] & OFFSET_MASK; // fast forward to the end of balanced block

          if (this.balance[balanceEnd] === cursor) {
            cursor = balanceEnd;
          }

      }
    }

    return cursor - this.tokenIndex;
  },
  isBalanceEdge: function isBalanceEdge(pos) {
    return this.balance[this.tokenIndex] < pos;
  },
  isDelim: function isDelim(code, offset) {
    if (offset) {
      return this.lookupType(offset) === TYPE.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;
    }

    return this.tokenType === TYPE.Delim && this.source.charCodeAt(this.tokenStart) === code;
  },
  getTokenValue: function getTokenValue() {
    return this.source.substring(this.tokenStart, this.tokenEnd);
  },
  getTokenLength: function getTokenLength() {
    return this.tokenEnd - this.tokenStart;
  },
  substrToCursor: function substrToCursor(start) {
    return this.source.substring(start, this.tokenStart);
  },
  skipWS: function skipWS() {
    for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
      if (this.offsetAndType[i] >> TYPE_SHIFT !== WHITESPACE) {
        break;
      }
    }

    if (skipTokenCount > 0) {
      this.skip(skipTokenCount);
    }
  },
  skipSC: function skipSC() {
    while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
      this.next();
    }
  },
  skip: function skip(tokenCount) {
    var next = this.tokenIndex + tokenCount;

    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.tokenIndex = this.tokenCount;
      this.next();
    }
  },
  next: function next() {
    var next = this.tokenIndex + 1;

    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.tokenEnd;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.tokenIndex = this.tokenCount;
      this.eof = true;
      this.tokenType = EOF;
      this.tokenStart = this.tokenEnd = this.source.length;
    }
  },
  dump: function dump() {
    var offset = this.firstCharOffset;
    return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function (item, idx) {
      var start = offset;
      var end = item & OFFSET_MASK;
      offset = end;
      return {
        idx: idx,
        type: NAME[item >> TYPE_SHIFT],
        chunk: this.source.substring(start, end),
        balance: this.balance[idx]
      };
    }, this);
  }
};
module.exports = TokenStream;
},{"../tokenizer/const":"node_modules/css-tree/lib/tokenizer/const.js","../tokenizer/utils":"node_modules/css-tree/lib/tokenizer/utils.js"}],"node_modules/css-tree/lib/definition-syntax/generate.js":[function(require,module,exports) {
function noop(value) {
  return value;
}

function generateMultiplier(multiplier) {
  if (multiplier.min === 0 && multiplier.max === 0) {
    return '*';
  }

  if (multiplier.min === 0 && multiplier.max === 1) {
    return '?';
  }

  if (multiplier.min === 1 && multiplier.max === 0) {
    return multiplier.comma ? '#' : '+';
  }

  if (multiplier.min === 1 && multiplier.max === 1) {
    return '';
  }

  return (multiplier.comma ? '#' : '') + (multiplier.min === multiplier.max ? '{' + multiplier.min + '}' : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}');
}

function generateTypeOpts(node) {
  switch (node.type) {
    case 'Range':
      return ' [' + (node.min === null ? '-∞' : node.min) + ',' + (node.max === null ? '∞' : node.max) + ']';

    default:
      throw new Error('Unknown node type `' + node.type + '`');
  }
}

function generateSequence(node, decorate, forceBraces, compact) {
  var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
  var result = node.terms.map(function (term) {
    return generate(term, decorate, forceBraces, compact);
  }).join(combinator);

  if (node.explicit || forceBraces) {
    result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
  }

  return result;
}

function generate(node, decorate, forceBraces, compact) {
  var result;

  switch (node.type) {
    case 'Group':
      result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? '!' : '');
      break;

    case 'Multiplier':
      // return since node is a composition
      return generate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);

    case 'Type':
      result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
      break;

    case 'Property':
      result = '<\'' + node.name + '\'>';
      break;

    case 'Keyword':
      result = node.name;
      break;

    case 'AtKeyword':
      result = '@' + node.name;
      break;

    case 'Function':
      result = node.name + '(';
      break;

    case 'String':
    case 'Token':
      result = node.value;
      break;

    case 'Comma':
      result = ',';
      break;

    default:
      throw new Error('Unknown node type `' + node.type + '`');
  }

  return decorate(result, node);
}

module.exports = function (node, options) {
  var decorate = noop;
  var forceBraces = false;
  var compact = false;

  if (typeof options === 'function') {
    decorate = options;
  } else if (options) {
    forceBraces = Boolean(options.forceBraces);
    compact = Boolean(options.compact);

    if (typeof options.decorate === 'function') {
      decorate = options.decorate;
    }
  }

  return generate(node, decorate, forceBraces, compact);
};
},{}],"node_modules/css-tree/lib/lexer/error.js":[function(require,module,exports) {
var createCustomError = require('../utils/createCustomError');

var generate = require('../definition-syntax/generate');

function fromMatchResult(matchResult) {
  var tokens = matchResult.tokens;
  var longestMatch = matchResult.longestMatch;
  var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
  var mismatchOffset = -1;
  var entries = 0;
  var css = '';

  for (var i = 0; i < tokens.length; i++) {
    if (i === longestMatch) {
      mismatchOffset = css.length;
    }

    if (node !== null && tokens[i].node === node) {
      if (i <= longestMatch) {
        entries++;
      } else {
        entries = 0;
      }
    }

    css += tokens[i].value;
  }

  return {
    node: node,
    css: css,
    mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
    last: node === null || entries > 1
  };
}

function getLocation(node, point) {
  var loc = node && node.loc && node.loc[point];

  if (loc) {
    return {
      offset: loc.offset,
      line: loc.line,
      column: loc.column
    };
  }

  return null;
}

var SyntaxReferenceError = function SyntaxReferenceError(type, referenceName) {
  var error = createCustomError('SyntaxReferenceError', type + (referenceName ? ' `' + referenceName + '`' : ''));
  error.reference = referenceName;
  return error;
};

var MatchError = function MatchError(message, syntax, node, matchResult) {
  var error = createCustomError('SyntaxMatchError', message);
  var details = fromMatchResult(matchResult);
  var mismatchOffset = details.mismatchOffset || 0;
  var badNode = details.node || node;
  var end = getLocation(badNode, 'end');
  var start = details.last ? end : getLocation(badNode, 'start');
  var css = details.css;
  error.rawMessage = message;
  error.syntax = syntax ? generate(syntax) : '<generic>';
  error.css = css;
  error.mismatchOffset = mismatchOffset;
  error.loc = {
    source: badNode && badNode.loc && badNode.loc.source || '<unknown>',
    start: start,
    end: end
  };
  error.line = start ? start.line : undefined;
  error.column = start ? start.column : undefined;
  error.offset = start ? start.offset : undefined;
  error.message = message + '\n' + '  syntax: ' + error.syntax + '\n' + '   value: ' + (error.css || '<empty string>') + '\n' + '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';
  return error;
};

module.exports = {
  SyntaxReferenceError: SyntaxReferenceError,
  MatchError: MatchError
};
},{"../utils/createCustomError":"node_modules/css-tree/lib/utils/createCustomError.js","../definition-syntax/generate":"node_modules/css-tree/lib/definition-syntax/generate.js"}],"node_modules/css-tree/lib/utils/names.js":[function(require,module,exports) {
var hasOwnProperty = Object.prototype.hasOwnProperty;
var keywords = Object.create(null);
var properties = Object.create(null);
var HYPHENMINUS = 45; // '-'.charCodeAt()

function isCustomProperty(str, offset) {
  offset = offset || 0;
  return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) === HYPHENMINUS;
}

function getVendorPrefix(str, offset) {
  offset = offset || 0; // verdor prefix should be at least 3 chars length

  if (str.length - offset >= 3) {
    // vendor prefix starts with hyper minus following non-hyper minus
    if (str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) !== HYPHENMINUS) {
      // vendor prefix should contain a hyper minus at the ending
      var secondDashIndex = str.indexOf('-', offset + 2);

      if (secondDashIndex !== -1) {
        return str.substring(offset, secondDashIndex + 1);
      }
    }
  }

  return '';
}

function getKeywordDescriptor(keyword) {
  if (hasOwnProperty.call(keywords, keyword)) {
    return keywords[keyword];
  }

  var name = keyword.toLowerCase();

  if (hasOwnProperty.call(keywords, name)) {
    return keywords[keyword] = keywords[name];
  }

  var custom = isCustomProperty(name, 0);
  var vendor = !custom ? getVendorPrefix(name, 0) : '';
  return keywords[keyword] = Object.freeze({
    basename: name.substr(vendor.length),
    name: name,
    vendor: vendor,
    prefix: vendor,
    custom: custom
  });
}

function getPropertyDescriptor(property) {
  if (hasOwnProperty.call(properties, property)) {
    return properties[property];
  }

  var name = property;
  var hack = property[0];

  if (hack === '/') {
    hack = property[1] === '/' ? '//' : '/';
  } else if (hack !== '_' && hack !== '*' && hack !== '$' && hack !== '#' && hack !== '+' && hack !== '&') {
    hack = '';
  }

  var custom = isCustomProperty(name, hack.length); // re-use result when possible (the same as for lower case)

  if (!custom) {
    name = name.toLowerCase();

    if (hasOwnProperty.call(properties, name)) {
      return properties[property] = properties[name];
    }
  }

  var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
  var prefix = name.substr(0, hack.length + vendor.length);
  return properties[property] = Object.freeze({
    basename: name.substr(prefix.length),
    name: name.substr(hack.length),
    hack: hack,
    vendor: vendor,
    prefix: prefix,
    custom: custom
  });
}

module.exports = {
  keyword: getKeywordDescriptor,
  property: getPropertyDescriptor,
  isCustomProperty: isCustomProperty,
  vendorPrefix: getVendorPrefix
};
},{}],"node_modules/css-tree/lib/common/adopt-buffer.js":[function(require,module,exports) {
var MIN_SIZE = 16 * 1024;
var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

module.exports = function adoptBuffer(buffer, size) {
  if (buffer === null || buffer.length < size) {
    return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
  }

  return buffer;
};
},{}],"node_modules/css-tree/lib/tokenizer/index.js":[function(require,module,exports) {
var TokenStream = require('../common/TokenStream');

var adoptBuffer = require('../common/adopt-buffer');

var constants = require('./const');

var TYPE = constants.TYPE;

var charCodeDefinitions = require('./char-code-definitions');

var isNewline = charCodeDefinitions.isNewline;
var isName = charCodeDefinitions.isName;
var isValidEscape = charCodeDefinitions.isValidEscape;
var isNumberStart = charCodeDefinitions.isNumberStart;
var isIdentifierStart = charCodeDefinitions.isIdentifierStart;
var charCodeCategory = charCodeDefinitions.charCodeCategory;
var isBOM = charCodeDefinitions.isBOM;

var utils = require('./utils');

var cmpStr = utils.cmpStr;
var getNewlineLength = utils.getNewlineLength;
var findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
var consumeEscaped = utils.consumeEscaped;
var consumeName = utils.consumeName;
var consumeNumber = utils.consumeNumber;
var consumeBadUrlRemnants = utils.consumeBadUrlRemnants;
var OFFSET_MASK = 0x00FFFFFF;
var TYPE_SHIFT = 24;

function tokenize(source, stream) {
  function getCharCode(offset) {
    return offset < sourceLength ? source.charCodeAt(offset) : 0;
  } // § 4.3.3. Consume a numeric token


  function consumeNumericToken() {
    // Consume a number and let number be the result.
    offset = consumeNumber(source, offset); // If the next 3 input code points would start an identifier, then:

    if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
      // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
      // Consume a name. Set the <dimension-token>’s unit to the returned value.
      // Return the <dimension-token>.
      type = TYPE.Dimension;
      offset = consumeName(source, offset);
      return;
    } // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.


    if (getCharCode(offset) === 0x0025) {
      // Create a <percentage-token> with the same value as number, and return it.
      type = TYPE.Percentage;
      offset++;
      return;
    } // Otherwise, create a <number-token> with the same value and type flag as number, and return it.


    type = TYPE.Number;
  } // § 4.3.4. Consume an ident-like token


  function consumeIdentLikeToken() {
    var nameStartOffset = offset; // Consume a name, and let string be the result.

    offset = consumeName(source, offset); // If string’s value is an ASCII case-insensitive match for "url",
    // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.

    if (cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
      // While the next two input code points are whitespace, consume the next input code point.
      offset = findWhiteSpaceEnd(source, offset + 1); // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
      // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
      // then create a <function-token> with its value set to string and return it.

      if (getCharCode(offset) === 0x0022 || getCharCode(offset) === 0x0027) {
        type = TYPE.Function;
        offset = nameStartOffset + 4;
        return;
      } // Otherwise, consume a url token, and return it.


      consumeUrlToken();
      return;
    } // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
    // Create a <function-token> with its value set to string and return it.


    if (getCharCode(offset) === 0x0028) {
      type = TYPE.Function;
      offset++;
      return;
    } // Otherwise, create an <ident-token> with its value set to string and return it.


    type = TYPE.Ident;
  } // § 4.3.5. Consume a string token


  function consumeStringToken(endingCodePoint) {
    // This algorithm may be called with an ending code point, which denotes the code point
    // that ends the string. If an ending code point is not specified,
    // the current input code point is used.
    if (!endingCodePoint) {
      endingCodePoint = getCharCode(offset++);
    } // Initially create a <string-token> with its value set to the empty string.


    type = TYPE.String; // Repeatedly consume the next input code point from the stream:

    for (; offset < source.length; offset++) {
      var code = source.charCodeAt(offset);

      switch (charCodeCategory(code)) {
        // ending code point
        case endingCodePoint:
          // Return the <string-token>.
          offset++;
          return;
        // EOF

        case charCodeCategory.Eof:
          // This is a parse error. Return the <string-token>.
          return;
        // newline

        case charCodeCategory.WhiteSpace:
          if (isNewline(code)) {
            // This is a parse error. Reconsume the current input code point,
            // create a <bad-string-token>, and return it.
            offset += getNewlineLength(source, offset, code);
            type = TYPE.BadString;
            return;
          }

          break;
        // U+005C REVERSE SOLIDUS (\)

        case 0x005C:
          // If the next input code point is EOF, do nothing.
          if (offset === source.length - 1) {
            break;
          }

          var nextCode = getCharCode(offset + 1); // Otherwise, if the next input code point is a newline, consume it.

          if (isNewline(nextCode)) {
            offset += getNewlineLength(source, offset + 1, nextCode);
          } else if (isValidEscape(code, nextCode)) {
            // Otherwise, (the stream starts with a valid escape) consume
            // an escaped code point and append the returned code point to
            // the <string-token>’s value.
            offset = consumeEscaped(source, offset) - 1;
          }

          break;
        // anything else
        // Append the current input code point to the <string-token>’s value.
      }
    }
  } // § 4.3.6. Consume a url token
  // Note: This algorithm assumes that the initial "url(" has already been consumed.
  // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
  // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
  // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.


  function consumeUrlToken() {
    // Initially create a <url-token> with its value set to the empty string.
    type = TYPE.Url; // Consume as much whitespace as possible.

    offset = findWhiteSpaceEnd(source, offset); // Repeatedly consume the next input code point from the stream:

    for (; offset < source.length; offset++) {
      var code = source.charCodeAt(offset);

      switch (charCodeCategory(code)) {
        // U+0029 RIGHT PARENTHESIS ())
        case 0x0029:
          // Return the <url-token>.
          offset++;
          return;
        // EOF

        case charCodeCategory.Eof:
          // This is a parse error. Return the <url-token>.
          return;
        // whitespace

        case charCodeCategory.WhiteSpace:
          // Consume as much whitespace as possible.
          offset = findWhiteSpaceEnd(source, offset); // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
          // consume it and return the <url-token>
          // (if EOF was encountered, this is a parse error);

          if (getCharCode(offset) === 0x0029 || offset >= source.length) {
            if (offset < source.length) {
              offset++;
            }

            return;
          } // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
          // and return it.


          offset = consumeBadUrlRemnants(source, offset);
          type = TYPE.BadUrl;
          return;
        // U+0022 QUOTATION MARK (")
        // U+0027 APOSTROPHE (')
        // U+0028 LEFT PARENTHESIS (()
        // non-printable code point

        case 0x0022:
        case 0x0027:
        case 0x0028:
        case charCodeCategory.NonPrintable:
          // This is a parse error. Consume the remnants of a bad url,
          // create a <bad-url-token>, and return it.
          offset = consumeBadUrlRemnants(source, offset);
          type = TYPE.BadUrl;
          return;
        // U+005C REVERSE SOLIDUS (\)

        case 0x005C:
          // If the stream starts with a valid escape, consume an escaped code point and
          // append the returned code point to the <url-token>’s value.
          if (isValidEscape(code, getCharCode(offset + 1))) {
            offset = consumeEscaped(source, offset) - 1;
            break;
          } // Otherwise, this is a parse error. Consume the remnants of a bad url,
          // create a <bad-url-token>, and return it.


          offset = consumeBadUrlRemnants(source, offset);
          type = TYPE.BadUrl;
          return;
        // anything else
        // Append the current input code point to the <url-token>’s value.
      }
    }
  }

  if (!stream) {
    stream = new TokenStream();
  } // ensure source is a string


  source = String(source || '');
  var sourceLength = source.length;
  var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token

  var balance = adoptBuffer(stream.balance, sourceLength + 1);
  var tokenCount = 0;
  var start = isBOM(getCharCode(0));
  var offset = start;
  var balanceCloseType = 0;
  var balanceStart = 0;
  var balancePrev = 0; // https://drafts.csswg.org/css-syntax-3/#consume-token
  // § 4.3.1. Consume a token

  while (offset < sourceLength) {
    var code = source.charCodeAt(offset);
    var type = 0;
    balance[tokenCount] = sourceLength;

    switch (charCodeCategory(code)) {
      // whitespace
      case charCodeCategory.WhiteSpace:
        // Consume as much whitespace as possible. Return a <whitespace-token>.
        type = TYPE.WhiteSpace;
        offset = findWhiteSpaceEnd(source, offset + 1);
        break;
      // U+0022 QUOTATION MARK (")

      case 0x0022:
        // Consume a string token and return it.
        consumeStringToken();
        break;
      // U+0023 NUMBER SIGN (#)

      case 0x0023:
        // If the next input code point is a name code point or the next two input code points are a valid escape, then:
        if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
          // Create a <hash-token>.
          type = TYPE.Hash; // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
          // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
          //     // TODO: set id flag
          // }
          // Consume a name, and set the <hash-token>’s value to the returned string.

          offset = consumeName(source, offset + 1); // Return the <hash-token>.
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = TYPE.Delim;
          offset++;
        }

        break;
      // U+0027 APOSTROPHE (')

      case 0x0027:
        // Consume a string token and return it.
        consumeStringToken();
        break;
      // U+0028 LEFT PARENTHESIS (()

      case 0x0028:
        // Return a <(-token>.
        type = TYPE.LeftParenthesis;
        offset++;
        break;
      // U+0029 RIGHT PARENTHESIS ())

      case 0x0029:
        // Return a <)-token>.
        type = TYPE.RightParenthesis;
        offset++;
        break;
      // U+002B PLUS SIGN (+)

      case 0x002B:
        // If the input stream starts with a number, ...
        if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
          // ... reconsume the current input code point, consume a numeric token, and return it.
          consumeNumericToken();
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = TYPE.Delim;
          offset++;
        }

        break;
      // U+002C COMMA (,)

      case 0x002C:
        // Return a <comma-token>.
        type = TYPE.Comma;
        offset++;
        break;
      // U+002D HYPHEN-MINUS (-)

      case 0x002D:
        // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
        if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
          consumeNumericToken();
        } else {
          // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
          if (getCharCode(offset + 1) === 0x002D && getCharCode(offset + 2) === 0x003E) {
            type = TYPE.CDC;
            offset = offset + 3;
          } else {
            // Otherwise, if the input stream starts with an identifier, ...
            if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              // ... reconsume the current input code point, consume an ident-like token, and return it.
              consumeIdentLikeToken();
            } else {
              // Otherwise, return a <delim-token> with its value set to the current input code point.
              type = TYPE.Delim;
              offset++;
            }
          }
        }

        break;
      // U+002E FULL STOP (.)

      case 0x002E:
        // If the input stream starts with a number, ...
        if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
          // ... reconsume the current input code point, consume a numeric token, and return it.
          consumeNumericToken();
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = TYPE.Delim;
          offset++;
        }

        break;
      // U+002F SOLIDUS (/)

      case 0x002F:
        // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
        if (getCharCode(offset + 1) === 0x002A) {
          // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
          // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
          type = TYPE.Comment;
          offset = source.indexOf('*/', offset + 2) + 2;

          if (offset === 1) {
            offset = source.length;
          }
        } else {
          type = TYPE.Delim;
          offset++;
        }

        break;
      // U+003A COLON (:)

      case 0x003A:
        // Return a <colon-token>.
        type = TYPE.Colon;
        offset++;
        break;
      // U+003B SEMICOLON (;)

      case 0x003B:
        // Return a <semicolon-token>.
        type = TYPE.Semicolon;
        offset++;
        break;
      // U+003C LESS-THAN SIGN (<)

      case 0x003C:
        // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
        if (getCharCode(offset + 1) === 0x0021 && getCharCode(offset + 2) === 0x002D && getCharCode(offset + 3) === 0x002D) {
          // ... consume them and return a <CDO-token>.
          type = TYPE.CDO;
          offset = offset + 4;
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = TYPE.Delim;
          offset++;
        }

        break;
      // U+0040 COMMERCIAL AT (@)

      case 0x0040:
        // If the next 3 input code points would start an identifier, ...
        if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
          // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
          type = TYPE.AtKeyword;
          offset = consumeName(source, offset + 1);
        } else {
          // Otherwise, return a <delim-token> with its value set to the current input code point.
          type = TYPE.Delim;
          offset++;
        }

        break;
      // U+005B LEFT SQUARE BRACKET ([)

      case 0x005B:
        // Return a <[-token>.
        type = TYPE.LeftSquareBracket;
        offset++;
        break;
      // U+005C REVERSE SOLIDUS (\)

      case 0x005C:
        // If the input stream starts with a valid escape, ...
        if (isValidEscape(code, getCharCode(offset + 1))) {
          // ... reconsume the current input code point, consume an ident-like token, and return it.
          consumeIdentLikeToken();
        } else {
          // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
          type = TYPE.Delim;
          offset++;
        }

        break;
      // U+005D RIGHT SQUARE BRACKET (])

      case 0x005D:
        // Return a <]-token>.
        type = TYPE.RightSquareBracket;
        offset++;
        break;
      // U+007B LEFT CURLY BRACKET ({)

      case 0x007B:
        // Return a <{-token>.
        type = TYPE.LeftCurlyBracket;
        offset++;
        break;
      // U+007D RIGHT CURLY BRACKET (})

      case 0x007D:
        // Return a <}-token>.
        type = TYPE.RightCurlyBracket;
        offset++;
        break;
      // digit

      case charCodeCategory.Digit:
        // Reconsume the current input code point, consume a numeric token, and return it.
        consumeNumericToken();
        break;
      // name-start code point

      case charCodeCategory.NameStart:
        // Reconsume the current input code point, consume an ident-like token, and return it.
        consumeIdentLikeToken();
        break;
      // EOF

      case charCodeCategory.Eof:
        // Return an <EOF-token>.
        break;
      // anything else

      default:
        // Return a <delim-token> with its value set to the current input code point.
        type = TYPE.Delim;
        offset++;
    }

    switch (type) {
      case balanceCloseType:
        balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balanceCloseType = balanceStart >> TYPE_SHIFT;
        balance[tokenCount] = balancePrev;
        balance[balancePrev++] = tokenCount;

        for (; balancePrev < tokenCount; balancePrev++) {
          if (balance[balancePrev] === sourceLength) {
            balance[balancePrev] = tokenCount;
          }
        }

        break;

      case TYPE.LeftParenthesis:
      case TYPE.Function:
        balance[tokenCount] = balanceStart;
        balanceCloseType = TYPE.RightParenthesis;
        balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
        break;

      case TYPE.LeftSquareBracket:
        balance[tokenCount] = balanceStart;
        balanceCloseType = TYPE.RightSquareBracket;
        balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
        break;

      case TYPE.LeftCurlyBracket:
        balance[tokenCount] = balanceStart;
        balanceCloseType = TYPE.RightCurlyBracket;
        balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
        break;
    }

    offsetAndType[tokenCount++] = type << TYPE_SHIFT | offset;
  } // finalize buffers


  offsetAndType[tokenCount] = TYPE.EOF << TYPE_SHIFT | offset; // <EOF-token>

  balance[tokenCount] = sourceLength;
  balance[sourceLength] = sourceLength; // prevents false positive balance match with any token

  while (balanceStart !== 0) {
    balancePrev = balanceStart & OFFSET_MASK;
    balanceStart = balance[balancePrev];
    balance[balancePrev] = sourceLength;
  } // update stream


  stream.source = source;
  stream.firstCharOffset = start;
  stream.offsetAndType = offsetAndType;
  stream.tokenCount = tokenCount;
  stream.balance = balance;
  stream.reset();
  stream.next();
  return stream;
} // extend tokenizer with constants


Object.keys(constants).forEach(function (key) {
  tokenize[key] = constants[key];
}); // extend tokenizer with static methods from utils

Object.keys(charCodeDefinitions).forEach(function (key) {
  tokenize[key] = charCodeDefinitions[key];
});
Object.keys(utils).forEach(function (key) {
  tokenize[key] = utils[key];
});
module.exports = tokenize;
},{"../common/TokenStream":"node_modules/css-tree/lib/common/TokenStream.js","../common/adopt-buffer":"node_modules/css-tree/lib/common/adopt-buffer.js","./const":"node_modules/css-tree/lib/tokenizer/const.js","./char-code-definitions":"node_modules/css-tree/lib/tokenizer/char-code-definitions.js","./utils":"node_modules/css-tree/lib/tokenizer/utils.js"}],"node_modules/css-tree/lib/lexer/generic-an-plus-b.js":[function(require,module,exports) {
var isDigit = require('../tokenizer').isDigit;

var cmpChar = require('../tokenizer').cmpChar;

var TYPE = require('../tokenizer').TYPE;

var DELIM = TYPE.Delim;
var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var PLUSSIGN = 0x002B; // U+002B PLUS SIGN (+)

var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)

var N = 0x006E; // U+006E LATIN SMALL LETTER N (n)

var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;

function isDelim(token, code) {
  return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
}

function skipSC(token, offset, getNextToken) {
  while (token !== null && (token.type === WHITESPACE || token.type === COMMENT)) {
    token = getNextToken(++offset);
  }

  return offset;
}

function checkInteger(token, valueOffset, disallowSign, offset) {
  if (!token) {
    return 0;
  }

  var code = token.value.charCodeAt(valueOffset);

  if (code === PLUSSIGN || code === HYPHENMINUS) {
    if (disallowSign) {
      // Number sign is not allowed
      return 0;
    }

    valueOffset++;
  }

  for (; valueOffset < token.value.length; valueOffset++) {
    if (!isDigit(token.value.charCodeAt(valueOffset))) {
      // Integer is expected
      return 0;
    }
  }

  return offset + 1;
} // ... <signed-integer>
// ... ['+' | '-'] <signless-integer>


function consumeB(token, offset_, getNextToken) {
  var sign = false;
  var offset = skipSC(token, offset_, getNextToken);
  token = getNextToken(offset);

  if (token === null) {
    return offset_;
  }

  if (token.type !== NUMBER) {
    if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
      sign = true;
      offset = skipSC(getNextToken(++offset), offset, getNextToken);
      token = getNextToken(offset);

      if (token === null && token.type !== NUMBER) {
        return 0;
      }
    } else {
      return offset_;
    }
  }

  if (!sign) {
    var code = token.value.charCodeAt(0);

    if (code !== PLUSSIGN && code !== HYPHENMINUS) {
      // Number sign is expected
      return 0;
    }
  }

  return checkInteger(token, sign ? 0 : 1, sign, offset);
} // An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb


module.exports = function anPlusB(token, getNextToken) {
  /* eslint-disable brace-style*/
  var offset = 0;

  if (!token) {
    return 0;
  } // <integer>


  if (token.type === NUMBER) {
    return checkInteger(token, 0, ALLOW_SIGN, offset); // b
  } // -n
  // -n <signed-integer>
  // -n ['+' | '-'] <signless-integer>
  // -n- <signless-integer>
  // <dashndashdigit-ident>
  else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS) {
      // expect 1st char is N
      if (!cmpChar(token.value, 1, N)) {
        return 0;
      }

      switch (token.value.length) {
        // -n
        // -n <signed-integer>
        // -n ['+' | '-'] <signless-integer>
        case 2:
          return consumeB(getNextToken(++offset), offset, getNextToken);
        // -n- <signless-integer>

        case 3:
          if (token.value.charCodeAt(2) !== HYPHENMINUS) {
            return 0;
          }

          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger(token, 0, DISALLOW_SIGN, offset);
        // <dashndashdigit-ident>

        default:
          if (token.value.charCodeAt(2) !== HYPHENMINUS) {
            return 0;
          }

          return checkInteger(token, 3, DISALLOW_SIGN, offset);
      }
    } // '+'? n
    // '+'? n <signed-integer>
    // '+'? n ['+' | '-'] <signless-integer>
    // '+'? n- <signless-integer>
    // '+'? <ndashdigit-ident>
    else if (token.type === IDENT || isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT) {
        // just ignore a plus
        if (token.type !== IDENT) {
          token = getNextToken(++offset);
        }

        if (token === null || !cmpChar(token.value, 0, N)) {
          return 0;
        }

        switch (token.value.length) {
          // '+'? n
          // '+'? n <signed-integer>
          // '+'? n ['+' | '-'] <signless-integer>
          case 1:
            return consumeB(getNextToken(++offset), offset, getNextToken);
          // '+'? n- <signless-integer>

          case 2:
            if (token.value.charCodeAt(1) !== HYPHENMINUS) {
              return 0;
            }

            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          // '+'? <ndashdigit-ident>

          default:
            if (token.value.charCodeAt(1) !== HYPHENMINUS) {
              return 0;
            }

            return checkInteger(token, 2, DISALLOW_SIGN, offset);
        }
      } // <ndashdigit-dimension>
      // <ndash-dimension> <signless-integer>
      // <n-dimension>
      // <n-dimension> <signed-integer>
      // <n-dimension> ['+' | '-'] <signless-integer>
      else if (token.type === DIMENSION) {
          var code = token.value.charCodeAt(0);
          var sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;

          for (var i = sign; i < token.value.length; i++) {
            if (!isDigit(token.value.charCodeAt(i))) {
              break;
            }
          }

          if (i === sign) {
            // Integer is expected
            return 0;
          }

          if (!cmpChar(token.value, i, N)) {
            return 0;
          } // <n-dimension>
          // <n-dimension> <signed-integer>
          // <n-dimension> ['+' | '-'] <signless-integer>


          if (i + 1 === token.value.length) {
            return consumeB(getNextToken(++offset), offset, getNextToken);
          } else {
            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
              return 0;
            } // <ndash-dimension> <signless-integer>


            if (i + 2 === token.value.length) {
              offset = skipSC(getNextToken(++offset), offset, getNextToken);
              token = getNextToken(offset);
              return checkInteger(token, 0, DISALLOW_SIGN, offset);
            } // <ndashdigit-dimension>
            else {
                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
              }
          }
        }

  return 0;
};
},{"../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/lexer/generic-urange.js":[function(require,module,exports) {
var isHexDigit = require('../tokenizer').isHexDigit;

var cmpChar = require('../tokenizer').cmpChar;

var TYPE = require('../tokenizer').TYPE;

var IDENT = TYPE.Ident;
var DELIM = TYPE.Delim;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var PLUSSIGN = 0x002B; // U+002B PLUS SIGN (+)

var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)

var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)

var U = 0x0075; // U+0075 LATIN SMALL LETTER U (u)

function isDelim(token, code) {
  return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
}

function startsWith(token, code) {
  return token.value.charCodeAt(0) === code;
}

function hexSequence(token, offset, allowDash) {
  for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
    var code = token.value.charCodeAt(pos);

    if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
      if (hexSequence(token, offset + hexlen + 1, false) > 0) {
        return 6; // dissallow following question marks
      }

      return 0; // dash at the ending of a hex sequence is not allowed
    }

    if (!isHexDigit(code)) {
      return 0; // not a hex digit
    }

    if (++hexlen > 6) {
      return 0; // too many hex digits
    }

    ;
  }

  return hexlen;
}

function withQuestionMarkSequence(consumed, length, getNextToken) {
  if (!consumed) {
    return 0; // nothing consumed
  }

  while (isDelim(getNextToken(length), QUESTIONMARK)) {
    if (++consumed > 6) {
      return 0; // too many question marks
    }

    length++;
  }

  return length;
} // https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+


module.exports = function urange(token, getNextToken) {
  var length = 0; // should start with `u` or `U`

  if (token === null || token.type !== IDENT || !cmpChar(token.value, 0, U)) {
    return 0;
  }

  token = getNextToken(++length);

  if (token === null) {
    return 0;
  } // u '+' <ident-token> '?'*
  // u '+' '?'+


  if (isDelim(token, PLUSSIGN)) {
    token = getNextToken(++length);

    if (token === null) {
      return 0;
    }

    if (token.type === IDENT) {
      // u '+' <ident-token> '?'*
      return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
    }

    if (isDelim(token, QUESTIONMARK)) {
      // u '+' '?'+
      return withQuestionMarkSequence(1, ++length, getNextToken);
    } // Hex digit or question mark is expected


    return 0;
  } // u <number-token> '?'*
  // u <number-token> <dimension-token>
  // u <number-token> <number-token>


  if (token.type === NUMBER) {
    if (!startsWith(token, PLUSSIGN)) {
      return 0;
    }

    var consumedHexLength = hexSequence(token, 1, true);

    if (consumedHexLength === 0) {
      return 0;
    }

    token = getNextToken(++length);

    if (token === null) {
      // u <number-token> <eof>
      return length;
    }

    if (token.type === DIMENSION || token.type === NUMBER) {
      // u <number-token> <dimension-token>
      // u <number-token> <number-token>
      if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {
        return 0;
      }

      return length + 1;
    } // u <number-token> '?'*


    return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
  } // u <dimension-token> '?'*


  if (token.type === DIMENSION) {
    if (!startsWith(token, PLUSSIGN)) {
      return 0;
    }

    return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
  }

  return 0;
};
},{"../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/lexer/generic.js":[function(require,module,exports) {
var tokenizer = require('../tokenizer');

var isIdentifierStart = tokenizer.isIdentifierStart;
var isHexDigit = tokenizer.isHexDigit;
var isDigit = tokenizer.isDigit;
var cmpStr = tokenizer.cmpStr;
var consumeNumber = tokenizer.consumeNumber;
var TYPE = tokenizer.TYPE;

var anPlusB = require('./generic-an-plus-b');

var urange = require('./generic-urange');

var cssWideKeywords = ['unset', 'initial', 'inherit'];
var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc(']; // https://www.w3.org/TR/css-values-3/#lengths

var LENGTH = {
  // absolute length units
  'px': true,
  'mm': true,
  'cm': true,
  'in': true,
  'pt': true,
  'pc': true,
  'q': true,
  // relative length units
  'em': true,
  'ex': true,
  'ch': true,
  'rem': true,
  // viewport-percentage lengths
  'vh': true,
  'vw': true,
  'vmin': true,
  'vmax': true,
  'vm': true
};
var ANGLE = {
  'deg': true,
  'grad': true,
  'rad': true,
  'turn': true
};
var TIME = {
  's': true,
  'ms': true
};
var FREQUENCY = {
  'hz': true,
  'khz': true
}; // https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)

var RESOLUTION = {
  'dpi': true,
  'dpcm': true,
  'dppx': true,
  'x': true // https://github.com/w3c/csswg-drafts/issues/461

}; // https://drafts.csswg.org/css-grid/#fr-unit

var FLEX = {
  'fr': true
}; // https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume

var DECIBEL = {
  'db': true
}; // https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch

var SEMITONES = {
  'st': true
}; // safe char code getter

function charCode(str, index) {
  return index < str.length ? str.charCodeAt(index) : 0;
}

function eqStr(actual, expected) {
  return cmpStr(actual, 0, actual.length, expected);
}

function eqStrAny(actual, expected) {
  for (var i = 0; i < expected.length; i++) {
    if (eqStr(actual, expected[i])) {
      return true;
    }
  }

  return false;
} // IE postfix hack, i.e. 123\0 or 123px\9


function isPostfixIeHack(str, offset) {
  if (offset !== str.length - 2) {
    return false;
  }

  return str.charCodeAt(offset) === 0x005C && // U+005C REVERSE SOLIDUS (\)
  isDigit(str.charCodeAt(offset + 1));
}

function outOfRange(opts, value, numEnd) {
  if (opts && opts.type === 'Range') {
    var num = Number(numEnd !== undefined && numEnd !== value.length ? value.substr(0, numEnd) : value);

    if (isNaN(num)) {
      return true;
    }

    if (opts.min !== null && num < opts.min) {
      return true;
    }

    if (opts.max !== null && num > opts.max) {
      return true;
    }
  }

  return false;
}

function consumeFunction(token, getNextToken) {
  var startIdx = token.index;
  var length = 0; // balanced token consuming

  do {
    length++;

    if (token.balance <= startIdx) {
      break;
    }
  } while (token = getNextToken(length));

  return length;
} // TODO: implement
// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
// https://drafts.csswg.org/css-values/#calc-notation


function calc(next) {
  return function (token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }

    if (token.type === TYPE.Function && eqStrAny(token.value, calcFunctionNames)) {
      return consumeFunction(token, getNextToken);
    }

    return next(token, getNextToken, opts);
  };
}

function tokenType(expectedTokenType) {
  return function (token) {
    if (token === null || token.type !== expectedTokenType) {
      return 0;
    }

    return 1;
  };
}

function func(name) {
  name = name + '(';
  return function (token, getNextToken) {
    if (token !== null && eqStr(token.value, name)) {
      return consumeFunction(token, getNextToken);
    }

    return 0;
  };
} // =========================
// Complex types
//
// https://drafts.csswg.org/css-values-4/#custom-idents
// 4.2. Author-defined Identifiers: the <custom-ident> type
// Some properties accept arbitrary author-defined identifiers as a component value.
// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
//
// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident


function customIdent(token) {
  if (token === null || token.type !== TYPE.Ident) {
    return 0;
  }

  var name = token.value.toLowerCase(); // The CSS-wide keywords are not valid <custom-ident>s

  if (eqStrAny(name, cssWideKeywords)) {
    return 0;
  } // The default keyword is reserved and is also not a valid <custom-ident>


  if (eqStr(name, 'default')) {
    return 0;
  } // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
  // Specifications using <custom-ident> must specify clearly what other keywords
  // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
  // in that property’s value definition are excluded. Excluded keywords are excluded
  // in all ASCII case permutations.


  return 1;
} // https://drafts.csswg.org/css-variables/#typedef-custom-property-name
// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.


function customPropertyName(token) {
  // ... defined as any valid identifier
  if (token === null || token.type !== TYPE.Ident) {
    return 0;
  } // ... that starts with two dashes (U+002D HYPHEN-MINUS)


  if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
    return 0;
  }

  return 1;
} // https://drafts.csswg.org/css-color-4/#hex-notation
// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).


function hexColor(token) {
  if (token === null || token.type !== TYPE.Hash) {
    return 0;
  }

  var length = token.value.length; // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)

  if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
    return 0;
  }

  for (var i = 1; i < length; i++) {
    if (!isHexDigit(token.value.charCodeAt(i))) {
      return 0;
    }
  }

  return 1;
}

function idSelector(token) {
  if (token === null || token.type !== TYPE.Hash) {
    return 0;
  }

  if (!isIdentifierStart(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
    return 0;
  }

  return 1;
} // https://drafts.csswg.org/css-syntax/#any-value
// It represents the entirety of what a valid declaration can have as its value.


function declarationValue(token, getNextToken) {
  if (!token) {
    return 0;
  }

  var length = 0;
  var level = 0;
  var startIdx = token.index; // The <declaration-value> production matches any sequence of one or more tokens,
  // so long as the sequence ...

  scan: do {
    switch (token.type) {
      // ... does not contain <bad-string-token>, <bad-url-token>,
      case TYPE.BadString:
      case TYPE.BadUrl:
        break scan;
      // ... unmatched <)-token>, <]-token>, or <}-token>,

      case TYPE.RightCurlyBracket:
      case TYPE.RightParenthesis:
      case TYPE.RightSquareBracket:
        if (token.balance > token.index || token.balance < startIdx) {
          break scan;
        }

        level--;
        break;
      // ... or top-level <semicolon-token> tokens

      case TYPE.Semicolon:
        if (level === 0) {
          break scan;
        }

        break;
      // ... or <delim-token> tokens with a value of "!"

      case TYPE.Delim:
        if (token.value === '!' && level === 0) {
          break scan;
        }

        break;

      case TYPE.Function:
      case TYPE.LeftParenthesis:
      case TYPE.LeftSquareBracket:
      case TYPE.LeftCurlyBracket:
        level++;
        break;
    }

    length++; // until balance closing

    if (token.balance <= startIdx) {
      break;
    }
  } while (token = getNextToken(length));

  return length;
} // https://drafts.csswg.org/css-syntax/#any-value
// The <any-value> production is identical to <declaration-value>, but also
// allows top-level <semicolon-token> tokens and <delim-token> tokens
// with a value of "!". It represents the entirety of what valid CSS can be in any context.


function anyValue(token, getNextToken) {
  if (!token) {
    return 0;
  }

  var startIdx = token.index;
  var length = 0; // The <any-value> production matches any sequence of one or more tokens,
  // so long as the sequence ...

  scan: do {
    switch (token.type) {
      // ... does not contain <bad-string-token>, <bad-url-token>,
      case TYPE.BadString:
      case TYPE.BadUrl:
        break scan;
      // ... unmatched <)-token>, <]-token>, or <}-token>,

      case TYPE.RightCurlyBracket:
      case TYPE.RightParenthesis:
      case TYPE.RightSquareBracket:
        if (token.balance > token.index || token.balance < startIdx) {
          break scan;
        }

        break;
    }

    length++; // until balance closing

    if (token.balance <= startIdx) {
      break;
    }
  } while (token = getNextToken(length));

  return length;
} // =========================
// Dimensions
//


function dimension(type) {
  return function (token, getNextToken, opts) {
    if (token === null || token.type !== TYPE.Dimension) {
      return 0;
    }

    var numberEnd = consumeNumber(token.value, 0); // check unit

    if (type !== null) {
      // check for IE postfix hack, i.e. 123px\0 or 123px\9
      var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
      var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);

      if (type.hasOwnProperty(unit.toLowerCase()) === false) {
        return 0;
      }
    } // check range if specified


    if (outOfRange(opts, token.value, numberEnd)) {
      return 0;
    }

    return 1;
  };
} // =========================
// Percentage
//
// §5.5. Percentages: the <percentage> type
// https://drafts.csswg.org/css-values-4/#percentages


function percentage(token, getNextToken, opts) {
  // ... corresponds to the <percentage-token> production
  if (token === null || token.type !== TYPE.Percentage) {
    return 0;
  } // check range if specified


  if (outOfRange(opts, token.value, token.value.length - 1)) {
    return 0;
  }

  return 1;
} // =========================
// Numeric
//
// https://drafts.csswg.org/css-values-4/#numbers
// The value <zero> represents a literal number with the value 0. Expressions that merely
// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
// only literal <number-token>s do.


function zero(next) {
  if (typeof next !== 'function') {
    next = function next() {
      return 0;
    };
  }

  return function (token, getNextToken, opts) {
    if (token !== null && token.type === TYPE.Number) {
      if (Number(token.value) === 0) {
        return 1;
      }
    }

    return next(token, getNextToken, opts);
  };
} // § 5.3. Real Numbers: the <number> type
// https://drafts.csswg.org/css-values-4/#numbers
// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
// ... It corresponds to the <number-token> production


function number(token, getNextToken, opts) {
  if (token === null) {
    return 0;
  }

  var numberEnd = consumeNumber(token.value, 0);
  var isNumber = numberEnd === token.value.length;

  if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
    return 0;
  } // check range if specified


  if (outOfRange(opts, token.value, numberEnd)) {
    return 0;
  }

  return 1;
} // §5.2. Integers: the <integer> type
// https://drafts.csswg.org/css-values-4/#integers


function integer(token, getNextToken, opts) {
  // ... corresponds to a subset of the <number-token> production
  if (token === null || token.type !== TYPE.Number) {
    return 0;
  } // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.


  var i = token.value.charCodeAt(0) === 0x002B || // U+002B PLUS SIGN (+)
  token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)
  // When written literally, an integer is one or more decimal digits 0 through 9 ...

  for (; i < token.value.length; i++) {
    if (!isDigit(token.value.charCodeAt(i))) {
      return 0;
    }
  } // check range if specified


  if (outOfRange(opts, token.value, i)) {
    return 0;
  }

  return 1;
}

module.exports = {
  // token types
  'ident-token': tokenType(TYPE.Ident),
  'function-token': tokenType(TYPE.Function),
  'at-keyword-token': tokenType(TYPE.AtKeyword),
  'hash-token': tokenType(TYPE.Hash),
  'string-token': tokenType(TYPE.String),
  'bad-string-token': tokenType(TYPE.BadString),
  'url-token': tokenType(TYPE.Url),
  'bad-url-token': tokenType(TYPE.BadUrl),
  'delim-token': tokenType(TYPE.Delim),
  'number-token': tokenType(TYPE.Number),
  'percentage-token': tokenType(TYPE.Percentage),
  'dimension-token': tokenType(TYPE.Dimension),
  'whitespace-token': tokenType(TYPE.WhiteSpace),
  'CDO-token': tokenType(TYPE.CDO),
  'CDC-token': tokenType(TYPE.CDC),
  'colon-token': tokenType(TYPE.Colon),
  'semicolon-token': tokenType(TYPE.Semicolon),
  'comma-token': tokenType(TYPE.Comma),
  '[-token': tokenType(TYPE.LeftSquareBracket),
  ']-token': tokenType(TYPE.RightSquareBracket),
  '(-token': tokenType(TYPE.LeftParenthesis),
  ')-token': tokenType(TYPE.RightParenthesis),
  '{-token': tokenType(TYPE.LeftCurlyBracket),
  '}-token': tokenType(TYPE.RightCurlyBracket),
  // token type aliases
  'string': tokenType(TYPE.String),
  'ident': tokenType(TYPE.Ident),
  // complex types
  'custom-ident': customIdent,
  'custom-property-name': customPropertyName,
  'hex-color': hexColor,
  'id-selector': idSelector,
  // element( <id-selector> )
  'an-plus-b': anPlusB,
  'urange': urange,
  'declaration-value': declarationValue,
  'any-value': anyValue,
  // dimensions
  'dimension': calc(dimension(null)),
  'angle': calc(dimension(ANGLE)),
  'decibel': calc(dimension(DECIBEL)),
  'frequency': calc(dimension(FREQUENCY)),
  'flex': calc(dimension(FLEX)),
  'length': calc(zero(dimension(LENGTH))),
  'resolution': calc(dimension(RESOLUTION)),
  'semitones': calc(dimension(SEMITONES)),
  'time': calc(dimension(TIME)),
  // percentage
  'percentage': calc(percentage),
  // numeric
  'zero': zero(),
  'number': calc(number),
  'integer': calc(integer),
  // old IE stuff
  '-ms-legacy-expression': func('expression')
};
},{"../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js","./generic-an-plus-b":"node_modules/css-tree/lib/lexer/generic-an-plus-b.js","./generic-urange":"node_modules/css-tree/lib/lexer/generic-urange.js"}],"node_modules/css-tree/lib/definition-syntax/SyntaxError.js":[function(require,module,exports) {
var createCustomError = require('../utils/createCustomError');

module.exports = function SyntaxError(message, input, offset) {
  var error = createCustomError('SyntaxError', message);
  error.input = input;
  error.offset = offset;
  error.rawMessage = message;
  error.message = error.rawMessage + '\n' + '  ' + error.input + '\n' + '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';
  return error;
};
},{"../utils/createCustomError":"node_modules/css-tree/lib/utils/createCustomError.js"}],"node_modules/css-tree/lib/definition-syntax/tokenizer.js":[function(require,module,exports) {
var SyntaxError = require('./SyntaxError');

var TAB = 9;
var N = 10;
var F = 12;
var R = 13;
var SPACE = 32;

var Tokenizer = function Tokenizer(str) {
  this.str = str;
  this.pos = 0;
};

Tokenizer.prototype = {
  charCodeAt: function charCodeAt(pos) {
    return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
  },
  charCode: function charCode() {
    return this.charCodeAt(this.pos);
  },
  nextCharCode: function nextCharCode() {
    return this.charCodeAt(this.pos + 1);
  },
  nextNonWsCode: function nextNonWsCode(pos) {
    return this.charCodeAt(this.findWsEnd(pos));
  },
  findWsEnd: function findWsEnd(pos) {
    for (; pos < this.str.length; pos++) {
      var code = this.str.charCodeAt(pos);

      if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
        break;
      }
    }

    return pos;
  },
  substringToPos: function substringToPos(end) {
    return this.str.substring(this.pos, this.pos = end);
  },
  eat: function eat(code) {
    if (this.charCode() !== code) {
      this.error('Expect `' + String.fromCharCode(code) + '`');
    }

    this.pos++;
  },
  peek: function peek() {
    return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
  },
  error: function error(message) {
    throw new SyntaxError(message, this.str, this.pos);
  }
};
module.exports = Tokenizer;
},{"./SyntaxError":"node_modules/css-tree/lib/definition-syntax/SyntaxError.js"}],"node_modules/css-tree/lib/definition-syntax/parse.js":[function(require,module,exports) {
var Tokenizer = require('./tokenizer');

var TAB = 9;
var N = 10;
var F = 12;
var R = 13;
var SPACE = 32;
var EXCLAMATIONMARK = 33; // !

var NUMBERSIGN = 35; // #

var AMPERSAND = 38; // &

var APOSTROPHE = 39; // '

var LEFTPARENTHESIS = 40; // (

var RIGHTPARENTHESIS = 41; // )

var ASTERISK = 42; // *

var PLUSSIGN = 43; // +

var COMMA = 44; // ,

var HYPERMINUS = 45; // -

var LESSTHANSIGN = 60; // <

var GREATERTHANSIGN = 62; // >

var QUESTIONMARK = 63; // ?

var COMMERCIALAT = 64; // @

var LEFTSQUAREBRACKET = 91; // [

var RIGHTSQUAREBRACKET = 93; // ]

var LEFTCURLYBRACKET = 123; // {

var VERTICALLINE = 124; // |

var RIGHTCURLYBRACKET = 125; // }

var INFINITY = 8734; // ∞

var NAME_CHAR = createCharMap(function (ch) {
  return /[a-zA-Z0-9\-]/.test(ch);
});
var COMBINATOR_PRECEDENCE = {
  ' ': 1,
  '&&': 2,
  '||': 3,
  '|': 4
};

function createCharMap(fn) {
  var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);

  for (var i = 0; i < 128; i++) {
    array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
  }

  return array;
}

function scanSpaces(tokenizer) {
  return tokenizer.substringToPos(tokenizer.findWsEnd(tokenizer.pos));
}

function scanWord(tokenizer) {
  var end = tokenizer.pos;

  for (; end < tokenizer.str.length; end++) {
    var code = tokenizer.str.charCodeAt(end);

    if (code >= 128 || NAME_CHAR[code] === 0) {
      break;
    }
  }

  if (tokenizer.pos === end) {
    tokenizer.error('Expect a keyword');
  }

  return tokenizer.substringToPos(end);
}

function scanNumber(tokenizer) {
  var end = tokenizer.pos;

  for (; end < tokenizer.str.length; end++) {
    var code = tokenizer.str.charCodeAt(end);

    if (code < 48 || code > 57) {
      break;
    }
  }

  if (tokenizer.pos === end) {
    tokenizer.error('Expect a number');
  }

  return tokenizer.substringToPos(end);
}

function scanString(tokenizer) {
  var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

  if (end === -1) {
    tokenizer.pos = tokenizer.str.length;
    tokenizer.error('Expect an apostrophe');
  }

  return tokenizer.substringToPos(end + 1);
}

function readMultiplierRange(tokenizer) {
  var min = null;
  var max = null;
  tokenizer.eat(LEFTCURLYBRACKET);
  min = scanNumber(tokenizer);

  if (tokenizer.charCode() === COMMA) {
    tokenizer.pos++;

    if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
      max = scanNumber(tokenizer);
    }
  } else {
    max = min;
  }

  tokenizer.eat(RIGHTCURLYBRACKET);
  return {
    min: Number(min),
    max: max ? Number(max) : 0
  };
}

function readMultiplier(tokenizer) {
  var range = null;
  var comma = false;

  switch (tokenizer.charCode()) {
    case ASTERISK:
      tokenizer.pos++;
      range = {
        min: 0,
        max: 0
      };
      break;

    case PLUSSIGN:
      tokenizer.pos++;
      range = {
        min: 1,
        max: 0
      };
      break;

    case QUESTIONMARK:
      tokenizer.pos++;
      range = {
        min: 0,
        max: 1
      };
      break;

    case NUMBERSIGN:
      tokenizer.pos++;
      comma = true;

      if (tokenizer.charCode() === LEFTCURLYBRACKET) {
        range = readMultiplierRange(tokenizer);
      } else {
        range = {
          min: 1,
          max: 0
        };
      }

      break;

    case LEFTCURLYBRACKET:
      range = readMultiplierRange(tokenizer);
      break;

    default:
      return null;
  }

  return {
    type: 'Multiplier',
    comma: comma,
    min: range.min,
    max: range.max,
    term: null
  };
}

function maybeMultiplied(tokenizer, node) {
  var multiplier = readMultiplier(tokenizer);

  if (multiplier !== null) {
    multiplier.term = node;
    return multiplier;
  }

  return node;
}

function maybeToken(tokenizer) {
  var ch = tokenizer.peek();

  if (ch === '') {
    return null;
  }

  return {
    type: 'Token',
    value: ch
  };
}

function readProperty(tokenizer) {
  var name;
  tokenizer.eat(LESSTHANSIGN);
  tokenizer.eat(APOSTROPHE);
  name = scanWord(tokenizer);
  tokenizer.eat(APOSTROPHE);
  tokenizer.eat(GREATERTHANSIGN);
  return maybeMultiplied(tokenizer, {
    type: 'Property',
    name: name
  });
} // https://drafts.csswg.org/css-values-3/#numeric-ranges
// 4.1. Range Restrictions and Range Definition Notation
//
// Range restrictions can be annotated in the numeric type notation using CSS bracketed
// range notation—[min,max]—within the angle brackets, after the identifying keyword,
// indicating a closed range between (and including) min and max.
// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.


function readTypeRange(tokenizer) {
  // use null for Infinity to make AST format JSON serializable/deserializable
  var min = null; // -Infinity

  var max = null; // Infinity

  var sign = 1;
  tokenizer.eat(LEFTSQUAREBRACKET);

  if (tokenizer.charCode() === HYPERMINUS) {
    tokenizer.peek();
    sign = -1;
  }

  if (sign == -1 && tokenizer.charCode() === INFINITY) {
    tokenizer.peek();
  } else {
    min = sign * Number(scanNumber(tokenizer));
  }

  scanSpaces(tokenizer);
  tokenizer.eat(COMMA);
  scanSpaces(tokenizer);

  if (tokenizer.charCode() === INFINITY) {
    tokenizer.peek();
  } else {
    sign = 1;

    if (tokenizer.charCode() === HYPERMINUS) {
      tokenizer.peek();
      sign = -1;
    }

    max = sign * Number(scanNumber(tokenizer));
  }

  tokenizer.eat(RIGHTSQUAREBRACKET); // If no range is indicated, either by using the bracketed range notation
  // or in the property description, then [−∞,∞] is assumed.

  if (min === null && max === null) {
    return null;
  }

  return {
    type: 'Range',
    min: min,
    max: max
  };
}

function readType(tokenizer) {
  var name;
  var opts = null;
  tokenizer.eat(LESSTHANSIGN);
  name = scanWord(tokenizer);

  if (tokenizer.charCode() === LEFTPARENTHESIS && tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
    tokenizer.pos += 2;
    name += '()';
  }

  if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
    scanSpaces(tokenizer);
    opts = readTypeRange(tokenizer);
  }

  tokenizer.eat(GREATERTHANSIGN);
  return maybeMultiplied(tokenizer, {
    type: 'Type',
    name: name,
    opts: opts
  });
}

function readKeywordOrFunction(tokenizer) {
  var name;
  name = scanWord(tokenizer);

  if (tokenizer.charCode() === LEFTPARENTHESIS) {
    tokenizer.pos++;
    return {
      type: 'Function',
      name: name
    };
  }

  return maybeMultiplied(tokenizer, {
    type: 'Keyword',
    name: name
  });
}

function regroupTerms(terms, combinators) {
  function createGroup(terms, combinator) {
    return {
      type: 'Group',
      terms: terms,
      combinator: combinator,
      disallowEmpty: false,
      explicit: false
    };
  }

  combinators = Object.keys(combinators).sort(function (a, b) {
    return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
  });

  while (combinators.length > 0) {
    var combinator = combinators.shift();

    for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
      var term = terms[i];

      if (term.type === 'Combinator') {
        if (term.value === combinator) {
          if (subgroupStart === -1) {
            subgroupStart = i - 1;
          }

          terms.splice(i, 1);
          i--;
        } else {
          if (subgroupStart !== -1 && i - subgroupStart > 1) {
            terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));
            i = subgroupStart + 1;
          }

          subgroupStart = -1;
        }
      }
    }

    if (subgroupStart !== -1 && combinators.length) {
      terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));
    }
  }

  return combinator;
}

function readImplicitGroup(tokenizer) {
  var terms = [];
  var combinators = {};
  var token;
  var prevToken = null;
  var prevTokenPos = tokenizer.pos;

  while (token = peek(tokenizer)) {
    if (token.type !== 'Spaces') {
      if (token.type === 'Combinator') {
        // check for combinator in group beginning and double combinator sequence
        if (prevToken === null || prevToken.type === 'Combinator') {
          tokenizer.pos = prevTokenPos;
          tokenizer.error('Unexpected combinator');
        }

        combinators[token.value] = true;
      } else if (prevToken !== null && prevToken.type !== 'Combinator') {
        combinators[' '] = true; // a b

        terms.push({
          type: 'Combinator',
          value: ' '
        });
      }

      terms.push(token);
      prevToken = token;
      prevTokenPos = tokenizer.pos;
    }
  } // check for combinator in group ending


  if (prevToken !== null && prevToken.type === 'Combinator') {
    tokenizer.pos -= prevTokenPos;
    tokenizer.error('Unexpected combinator');
  }

  return {
    type: 'Group',
    terms: terms,
    combinator: regroupTerms(terms, combinators) || ' ',
    disallowEmpty: false,
    explicit: false
  };
}

function readGroup(tokenizer) {
  var result;
  tokenizer.eat(LEFTSQUAREBRACKET);
  result = readImplicitGroup(tokenizer);
  tokenizer.eat(RIGHTSQUAREBRACKET);
  result.explicit = true;

  if (tokenizer.charCode() === EXCLAMATIONMARK) {
    tokenizer.pos++;
    result.disallowEmpty = true;
  }

  return result;
}

function peek(tokenizer) {
  var code = tokenizer.charCode();

  if (code < 128 && NAME_CHAR[code] === 1) {
    return readKeywordOrFunction(tokenizer);
  }

  switch (code) {
    case RIGHTSQUAREBRACKET:
      // don't eat, stop scan a group
      break;

    case LEFTSQUAREBRACKET:
      return maybeMultiplied(tokenizer, readGroup(tokenizer));

    case LESSTHANSIGN:
      return tokenizer.nextCharCode() === APOSTROPHE ? readProperty(tokenizer) : readType(tokenizer);

    case VERTICALLINE:
      return {
        type: 'Combinator',
        value: tokenizer.substringToPos(tokenizer.nextCharCode() === VERTICALLINE ? tokenizer.pos + 2 : tokenizer.pos + 1)
      };

    case AMPERSAND:
      tokenizer.pos++;
      tokenizer.eat(AMPERSAND);
      return {
        type: 'Combinator',
        value: '&&'
      };

    case COMMA:
      tokenizer.pos++;
      return {
        type: 'Comma'
      };

    case APOSTROPHE:
      return maybeMultiplied(tokenizer, {
        type: 'String',
        value: scanString(tokenizer)
      });

    case SPACE:
    case TAB:
    case N:
    case R:
    case F:
      return {
        type: 'Spaces',
        value: scanSpaces(tokenizer)
      };

    case COMMERCIALAT:
      code = tokenizer.nextCharCode();

      if (code < 128 && NAME_CHAR[code] === 1) {
        tokenizer.pos++;
        return {
          type: 'AtKeyword',
          name: scanWord(tokenizer)
        };
      }

      return maybeToken(tokenizer);

    case ASTERISK:
    case PLUSSIGN:
    case QUESTIONMARK:
    case NUMBERSIGN:
    case EXCLAMATIONMARK:
      // prohibited tokens (used as a multiplier start)
      break;

    case LEFTCURLYBRACKET:
      // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
      // check next char isn't a number, because it's likely a disjoined multiplier
      code = tokenizer.nextCharCode();

      if (code < 48 || code > 57) {
        return maybeToken(tokenizer);
      }

      break;

    default:
      return maybeToken(tokenizer);
  }
}

function parse(source) {
  var tokenizer = new Tokenizer(source);
  var result = readImplicitGroup(tokenizer);

  if (tokenizer.pos !== source.length) {
    tokenizer.error('Unexpected input');
  } // reduce redundant groups with single group term


  if (result.terms.length === 1 && result.terms[0].type === 'Group') {
    result = result.terms[0];
  }

  return result;
} // warm up parse to elimitate code branches that never execute
// fix soft deoptimizations (insufficient type feedback)


parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');
module.exports = parse;
},{"./tokenizer":"node_modules/css-tree/lib/definition-syntax/tokenizer.js"}],"node_modules/css-tree/lib/definition-syntax/walk.js":[function(require,module,exports) {
var noop = function noop() {};

function ensureFunction(value) {
  return typeof value === 'function' ? value : noop;
}

module.exports = function (node, options, context) {
  function walk(node) {
    enter.call(context, node);

    switch (node.type) {
      case 'Group':
        node.terms.forEach(walk);
        break;

      case 'Multiplier':
        walk(node.term);
        break;

      case 'Type':
      case 'Property':
      case 'Keyword':
      case 'AtKeyword':
      case 'Function':
      case 'String':
      case 'Token':
      case 'Comma':
        break;

      default:
        throw new Error('Unknown type: ' + node.type);
    }

    leave.call(context, node);
  }

  var enter = noop;
  var leave = noop;

  if (typeof options === 'function') {
    enter = options;
  } else if (options) {
    enter = ensureFunction(options.enter);
    leave = ensureFunction(options.leave);
  }

  if (enter === noop && leave === noop) {
    throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
  }

  walk(node, context);
};
},{}],"node_modules/css-tree/lib/lexer/prepare-tokens.js":[function(require,module,exports) {
var tokenize = require('../tokenizer');

var TokenStream = require('../common/TokenStream');

var tokenStream = new TokenStream();
var astToTokens = {
  decorator: function decorator(handlers) {
    var curNode = null;
    var prev = {
      len: 0,
      node: null
    };
    var nodes = [prev];
    var buffer = '';
    return {
      children: handlers.children,
      node: function node(_node) {
        var tmp = curNode;
        curNode = _node;
        handlers.node.call(this, _node);
        curNode = tmp;
      },
      chunk: function chunk(_chunk) {
        buffer += _chunk;

        if (prev.node !== curNode) {
          nodes.push({
            len: _chunk.length,
            node: curNode
          });
        } else {
          prev.len += _chunk.length;
        }
      },
      result: function result() {
        return prepareTokens(buffer, nodes);
      }
    };
  }
};

function prepareTokens(str, nodes) {
  var tokens = [];
  var nodesOffset = 0;
  var nodesIndex = 0;
  var currentNode = nodes ? nodes[nodesIndex].node : null;
  tokenize(str, tokenStream);

  while (!tokenStream.eof) {
    if (nodes) {
      while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
        nodesOffset += nodes[nodesIndex++].len;
        currentNode = nodes[nodesIndex].node;
      }
    }

    tokens.push({
      type: tokenStream.tokenType,
      value: tokenStream.getTokenValue(),
      index: tokenStream.tokenIndex,
      // TODO: remove it, temporary solution
      balance: tokenStream.balance[tokenStream.tokenIndex],
      // TODO: remove it, temporary solution
      node: currentNode
    });
    tokenStream.next(); // console.log({ ...tokens[tokens.length - 1], node: undefined });
  }

  return tokens;
}

module.exports = function (value, syntax) {
  if (typeof value === 'string') {
    return prepareTokens(value, null);
  }

  return syntax.generate(value, astToTokens);
};
},{"../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js","../common/TokenStream":"node_modules/css-tree/lib/common/TokenStream.js"}],"node_modules/css-tree/lib/lexer/match-graph.js":[function(require,module,exports) {
var parse = require('../definition-syntax/parse');

var MATCH = {
  type: 'Match'
};
var MISMATCH = {
  type: 'Mismatch'
};
var DISALLOW_EMPTY = {
  type: 'DisallowEmpty'
};
var LEFTPARENTHESIS = 40; // (

var RIGHTPARENTHESIS = 41; // )

function createCondition(match, thenBranch, elseBranch) {
  // reduce node count
  if (thenBranch === MATCH && elseBranch === MISMATCH) {
    return match;
  }

  if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
    return match;
  }

  if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
    thenBranch = match.then;
    match = match.match;
  }

  return {
    type: 'If',
    match: match,
    then: thenBranch,
    else: elseBranch
  };
}

function isFunctionType(name) {
  return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS;
}

function isEnumCapatible(term) {
  return term.type === 'Keyword' || term.type === 'AtKeyword' || term.type === 'Function' || term.type === 'Type' && isFunctionType(term.name);
}

function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
  switch (combinator) {
    case ' ':
      // Juxtaposing components means that all of them must occur, in the given order.
      //
      // a b c
      // =
      // match a
      //   then match b
      //     then match c
      //       then MATCH
      //       else MISMATCH
      //     else MISMATCH
      //   else MISMATCH
      var result = MATCH;

      for (var i = terms.length - 1; i >= 0; i--) {
        var term = terms[i];
        result = createCondition(term, result, MISMATCH);
      }

      ;
      return result;

    case '|':
      // A bar (|) separates two or more alternatives: exactly one of them must occur.
      //
      // a | b | c
      // =
      // match a
      //   then MATCH
      //   else match b
      //     then MATCH
      //     else match c
      //       then MATCH
      //       else MISMATCH
      var result = MISMATCH;
      var map = null;

      for (var i = terms.length - 1; i >= 0; i--) {
        var term = terms[i]; // reduce sequence of keywords into a Enum

        if (isEnumCapatible(term)) {
          if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
            map = Object.create(null);
            result = createCondition({
              type: 'Enum',
              map: map
            }, MATCH, result);
          }

          if (map !== null) {
            var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();

            if (key in map === false) {
              map[key] = term;
              continue;
            }
          }
        }

        map = null; // create a new conditonal node

        result = createCondition(term, MATCH, result);
      }

      ;
      return result;

    case '&&':
      // A double ampersand (&&) separates two or more components,
      // all of which must occur, in any order.
      // Use MatchOnce for groups with a large number of terms,
      // since &&-groups produces at least N!-node trees
      if (terms.length > 5) {
        return {
          type: 'MatchOnce',
          terms: terms,
          all: true
        };
      } // Use a combination tree for groups with small number of terms
      //
      // a && b && c
      // =
      // match a
      //   then [b && c]
      //   else match b
      //     then [a && c]
      //     else match c
      //       then [a && b]
      //       else MISMATCH
      //
      // a && b
      // =
      // match a
      //   then match b
      //     then MATCH
      //     else MISMATCH
      //   else match b
      //     then match a
      //       then MATCH
      //       else MISMATCH
      //     else MISMATCH


      var result = MISMATCH;

      for (var i = terms.length - 1; i >= 0; i--) {
        var term = terms[i];
        var thenClause;

        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {
            return newGroupTerm !== term;
          }), false);
        } else {
          thenClause = MATCH;
        }

        result = createCondition(term, thenClause, result);
      }

      ;
      return result;

    case '||':
      // A double bar (||) separates two or more options:
      // one or more of them must occur, in any order.
      // Use MatchOnce for groups with a large number of terms,
      // since ||-groups produces at least N!-node trees
      if (terms.length > 5) {
        return {
          type: 'MatchOnce',
          terms: terms,
          all: false
        };
      } // Use a combination tree for groups with small number of terms
      //
      // a || b || c
      // =
      // match a
      //   then [b || c]
      //   else match b
      //     then [a || c]
      //     else match c
      //       then [a || b]
      //       else MISMATCH
      //
      // a || b
      // =
      // match a
      //   then match b
      //     then MATCH
      //     else MATCH
      //   else match b
      //     then match a
      //       then MATCH
      //       else MATCH
      //     else MISMATCH


      var result = atLeastOneTermMatched ? MATCH : MISMATCH;

      for (var i = terms.length - 1; i >= 0; i--) {
        var term = terms[i];
        var thenClause;

        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(combinator, terms.filter(function (newGroupTerm) {
            return newGroupTerm !== term;
          }), true);
        } else {
          thenClause = MATCH;
        }

        result = createCondition(term, thenClause, result);
      }

      ;
      return result;
  }
}

function buildMultiplierMatchGraph(node) {
  var result = MATCH;

  var matchTerm = _buildMatchGraph(node.term);

  if (node.max === 0) {
    // disable repeating of empty match to prevent infinite loop
    matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH); // an occurrence count is not limited, make a cycle;
    // to collect more terms on each following matching mismatch

    result = createCondition(matchTerm, null, // will be a loop
    MISMATCH);
    result.then = createCondition(MATCH, MATCH, result // make a loop
    );

    if (node.comma) {
      result.then.else = createCondition({
        type: 'Comma',
        syntax: node
      }, result, MISMATCH);
    }
  } else {
    // create a match node chain for [min .. max] interval with optional matches
    for (var i = node.min || 1; i <= node.max; i++) {
      if (node.comma && result !== MATCH) {
        result = createCondition({
          type: 'Comma',
          syntax: node
        }, result, MISMATCH);
      }

      result = createCondition(matchTerm, createCondition(MATCH, MATCH, result), MISMATCH);
    }
  }

  if (node.min === 0) {
    // allow zero match
    result = createCondition(MATCH, MATCH, result);
  } else {
    // create a match node chain to collect [0 ... min - 1] required matches
    for (var i = 0; i < node.min - 1; i++) {
      if (node.comma && result !== MATCH) {
        result = createCondition({
          type: 'Comma',
          syntax: node
        }, result, MISMATCH);
      }

      result = createCondition(matchTerm, result, MISMATCH);
    }
  }

  return result;
}

function _buildMatchGraph(node) {
  if (typeof node === 'function') {
    return {
      type: 'Generic',
      fn: node
    };
  }

  switch (node.type) {
    case 'Group':
      var result = buildGroupMatchGraph(node.combinator, node.terms.map(_buildMatchGraph), false);

      if (node.disallowEmpty) {
        result = createCondition(result, DISALLOW_EMPTY, MISMATCH);
      }

      return result;

    case 'Multiplier':
      return buildMultiplierMatchGraph(node);

    case 'Type':
    case 'Property':
      return {
        type: node.type,
        name: node.name,
        syntax: node
      };

    case 'Keyword':
      return {
        type: node.type,
        name: node.name.toLowerCase(),
        syntax: node
      };

    case 'AtKeyword':
      return {
        type: node.type,
        name: '@' + node.name.toLowerCase(),
        syntax: node
      };

    case 'Function':
      return {
        type: node.type,
        name: node.name.toLowerCase() + '(',
        syntax: node
      };

    case 'String':
      // convert a one char length String to a Token
      if (node.value.length === 3) {
        return {
          type: 'Token',
          value: node.value.charAt(1),
          syntax: node
        };
      } // otherwise use it as is


      return {
        type: node.type,
        value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
        syntax: node
      };

    case 'Token':
      return {
        type: node.type,
        value: node.value,
        syntax: node
      };

    case 'Comma':
      return {
        type: node.type,
        syntax: node
      };

    default:
      throw new Error('Unknown node type:', node.type);
  }
}

module.exports = {
  MATCH: MATCH,
  MISMATCH: MISMATCH,
  DISALLOW_EMPTY: DISALLOW_EMPTY,
  buildMatchGraph: function buildMatchGraph(syntaxTree, ref) {
    if (typeof syntaxTree === 'string') {
      syntaxTree = parse(syntaxTree);
    }

    return {
      type: 'MatchGraph',
      match: _buildMatchGraph(syntaxTree),
      syntax: ref || null,
      source: syntaxTree
    };
  }
};
},{"../definition-syntax/parse":"node_modules/css-tree/lib/definition-syntax/parse.js"}],"node_modules/css-tree/lib/lexer/match.js":[function(require,module,exports) {
var hasOwnProperty = Object.prototype.hasOwnProperty;

var matchGraph = require('./match-graph');

var MATCH = matchGraph.MATCH;
var MISMATCH = matchGraph.MISMATCH;
var DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;

var TYPE = require('../tokenizer/const').TYPE;

var STUB = 0;
var TOKEN = 1;
var OPEN_SYNTAX = 2;
var CLOSE_SYNTAX = 3;
var EXIT_REASON_MATCH = 'Match';
var EXIT_REASON_MISMATCH = 'Mismatch';
var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';
var ITERATION_LIMIT = 15000;
var totalIterationCount = 0;

function reverseList(list) {
  var prev = null;
  var next = null;
  var item = list;

  while (item !== null) {
    next = item.prev;
    item.prev = prev;
    prev = item;
    item = next;
  }

  return prev;
}

function areStringsEqualCaseInsensitive(testStr, referenceStr) {
  if (testStr.length !== referenceStr.length) {
    return false;
  }

  for (var i = 0; i < testStr.length; i++) {
    var testCode = testStr.charCodeAt(i);
    var referenceCode = referenceStr.charCodeAt(i); // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).

    if (testCode >= 0x0041 && testCode <= 0x005A) {
      testCode = testCode | 32;
    }

    if (testCode !== referenceCode) {
      return false;
    }
  }

  return true;
}

function isCommaContextStart(token) {
  if (token === null) {
    return true;
  }

  return token.type === TYPE.Comma || token.type === TYPE.Function || token.type === TYPE.LeftParenthesis || token.type === TYPE.LeftSquareBracket || token.type === TYPE.LeftCurlyBracket || token.type === TYPE.Delim;
}

function isCommaContextEnd(token) {
  if (token === null) {
    return true;
  }

  return token.type === TYPE.RightParenthesis || token.type === TYPE.RightSquareBracket || token.type === TYPE.RightCurlyBracket || token.type === TYPE.Delim;
}

function internalMatch(tokens, state, syntaxes) {
  function moveToNextToken() {
    do {
      tokenIndex++;
      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
    } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));
  }

  function getNextToken(offset) {
    var nextIndex = tokenIndex + offset;
    return nextIndex < tokens.length ? tokens[nextIndex] : null;
  }

  function stateSnapshotFromSyntax(nextState, prev) {
    return {
      nextState: nextState,
      matchStack: matchStack,
      syntaxStack: syntaxStack,
      thenStack: thenStack,
      tokenIndex: tokenIndex,
      prev: prev
    };
  }

  function pushThenStack(nextState) {
    thenStack = {
      nextState: nextState,
      matchStack: matchStack,
      syntaxStack: syntaxStack,
      prev: thenStack
    };
  }

  function pushElseStack(nextState) {
    elseStack = stateSnapshotFromSyntax(nextState, elseStack);
  }

  function addTokenToMatch() {
    matchStack = {
      type: TOKEN,
      syntax: state.syntax,
      token: token,
      prev: matchStack
    };
    moveToNextToken();
    syntaxStash = null;

    if (tokenIndex > longestMatch) {
      longestMatch = tokenIndex;
    }
  }

  function openSyntax() {
    syntaxStack = {
      syntax: state.syntax,
      opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
      prev: syntaxStack
    };
    matchStack = {
      type: OPEN_SYNTAX,
      syntax: state.syntax,
      token: matchStack.token,
      prev: matchStack
    };
  }

  function closeSyntax() {
    if (matchStack.type === OPEN_SYNTAX) {
      matchStack = matchStack.prev;
    } else {
      matchStack = {
        type: CLOSE_SYNTAX,
        syntax: syntaxStack.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }

    syntaxStack = syntaxStack.prev;
  }

  var syntaxStack = null;
  var thenStack = null;
  var elseStack = null; // null – stashing allowed, nothing stashed
  // false – stashing disabled, nothing stashed
  // anithing else – fail stashable syntaxes, some syntax stashed

  var syntaxStash = null;
  var iterationCount = 0; // count iterations and prevent infinite loop

  var exitReason = null;
  var token = null;
  var tokenIndex = -1;
  var longestMatch = 0;
  var matchStack = {
    type: STUB,
    syntax: null,
    token: null,
    prev: null
  };
  moveToNextToken();

  while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
    // function mapList(list, fn) {
    //     var result = [];
    //     while (list) {
    //         result.unshift(fn(list));
    //         list = list.prev;
    //     }
    //     return result;
    // }
    // console.log('--\n',
    //     '#' + iterationCount,
    //     require('util').inspect({
    //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
    //         token: token && token.value,
    //         tokenIndex,
    //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
    //     }, { depth: null })
    // );
    switch (state.type) {
      case 'Match':
        if (thenStack === null) {
          // turn to MISMATCH when some tokens left unmatched
          if (token !== null) {
            // doesn't mismatch if just one token left and it's an IE hack
            if (tokenIndex !== tokens.length - 1 || token.value !== '\\0' && token.value !== '\\9') {
              state = MISMATCH;
              break;
            }
          } // break the main loop, return a result - MATCH


          exitReason = EXIT_REASON_MATCH;
          break;
        } // go to next syntax (`then` branch)


        state = thenStack.nextState; // check match is not empty

        if (state === DISALLOW_EMPTY) {
          if (thenStack.matchStack === matchStack) {
            state = MISMATCH;
            break;
          } else {
            state = MATCH;
          }
        } // close syntax if needed


        while (thenStack.syntaxStack !== syntaxStack) {
          closeSyntax();
        } // pop stack


        thenStack = thenStack.prev;
        break;

      case 'Mismatch':
        // when some syntax is stashed
        if (syntaxStash !== null && syntaxStash !== false) {
          // there is no else branches or a branch reduce match stack
          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
            // restore state from the stash
            elseStack = syntaxStash;
            syntaxStash = false; // disable stashing
          }
        } else if (elseStack === null) {
          // no else branches -> break the main loop
          // return a result - MISMATCH
          exitReason = EXIT_REASON_MISMATCH;
          break;
        } // go to next syntax (`else` branch)


        state = elseStack.nextState; // restore all the rest stack states

        thenStack = elseStack.thenStack;
        syntaxStack = elseStack.syntaxStack;
        matchStack = elseStack.matchStack;
        tokenIndex = elseStack.tokenIndex;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null; // pop stack

        elseStack = elseStack.prev;
        break;

      case 'MatchGraph':
        state = state.match;
        break;

      case 'If':
        // IMPORTANT: else stack push must go first,
        // since it stores the state of thenStack before changes
        if (state.else !== MISMATCH) {
          pushElseStack(state.else);
        }

        if (state.then !== MATCH) {
          pushThenStack(state.then);
        }

        state = state.match;
        break;

      case 'MatchOnce':
        state = {
          type: 'MatchOnceBuffer',
          syntax: state,
          index: 0,
          mask: 0
        };
        break;

      case 'MatchOnceBuffer':
        var terms = state.syntax.terms;

        if (state.index === terms.length) {
          // no matches at all or it's required all terms to be matched
          if (state.mask === 0 || state.syntax.all) {
            state = MISMATCH;
            break;
          } // a partial match is ok


          state = MATCH;
          break;
        } // all terms are matched


        if (state.mask === (1 << terms.length) - 1) {
          state = MATCH;
          break;
        }

        for (; state.index < terms.length; state.index++) {
          var matchFlag = 1 << state.index;

          if ((state.mask & matchFlag) === 0) {
            // IMPORTANT: else stack push must go first,
            // since it stores the state of thenStack before changes
            pushElseStack(state);
            pushThenStack({
              type: 'AddMatchOnce',
              syntax: state.syntax,
              mask: state.mask | matchFlag
            }); // match

            state = terms[state.index++];
            break;
          }
        }

        break;

      case 'AddMatchOnce':
        state = {
          type: 'MatchOnceBuffer',
          syntax: state.syntax,
          index: 0,
          mask: state.mask
        };
        break;

      case 'Enum':
        if (token !== null) {
          var name = token.value.toLowerCase(); // drop \0 and \9 hack from keyword name

          if (name.indexOf('\\') !== -1) {
            name = name.replace(/\\[09].*$/, '');
          }

          if (hasOwnProperty.call(state.map, name)) {
            state = state.map[name];
            break;
          }
        }

        state = MISMATCH;
        break;

      case 'Generic':
        var opts = syntaxStack !== null ? syntaxStack.opts : null;
        var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

        if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
          while (tokenIndex < lastTokenIndex) {
            addTokenToMatch();
          }

          state = MATCH;
        } else {
          state = MISMATCH;
        }

        break;

      case 'Type':
      case 'Property':
        var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
        var dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

        if (!dictSyntax || !dictSyntax.match) {
          throw new Error('Bad syntax reference: ' + (state.type === 'Type' ? '<' + state.name + '>' : '<\'' + state.name + '\'>'));
        } // stash a syntax for types with low priority


        if (syntaxStash !== false && token !== null && state.type === 'Type') {
          var lowPriorityMatching = // https://drafts.csswg.org/css-values-4/#custom-idents
          // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
          // can only claim the keyword if no other unfulfilled production can claim it.
          state.name === 'custom-ident' && token.type === TYPE.Ident || // https://drafts.csswg.org/css-values-4/#lengths
          // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
          // it must parse as a <number>
          state.name === 'length' && token.value === '0';

          if (lowPriorityMatching) {
            if (syntaxStash === null) {
              syntaxStash = stateSnapshotFromSyntax(state, elseStack);
            }

            state = MISMATCH;
            break;
          }
        }

        openSyntax();
        state = dictSyntax.match;
        break;

      case 'Keyword':
        var name = state.name;

        if (token !== null) {
          var keywordName = token.value; // drop \0 and \9 hack from keyword name

          if (keywordName.indexOf('\\') !== -1) {
            keywordName = keywordName.replace(/\\[09].*$/, '');
          }

          if (areStringsEqualCaseInsensitive(keywordName, name)) {
            addTokenToMatch();
            state = MATCH;
            break;
          }
        }

        state = MISMATCH;
        break;

      case 'AtKeyword':
      case 'Function':
        if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
          addTokenToMatch();
          state = MATCH;
          break;
        }

        state = MISMATCH;
        break;

      case 'Token':
        if (token !== null && token.value === state.value) {
          addTokenToMatch();
          state = MATCH;
          break;
        }

        state = MISMATCH;
        break;

      case 'Comma':
        if (token !== null && token.type === TYPE.Comma) {
          if (isCommaContextStart(matchStack.token)) {
            state = MISMATCH;
          } else {
            addTokenToMatch();
            state = isCommaContextEnd(token) ? MISMATCH : MATCH;
          }
        } else {
          state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
        }

        break;

      case 'String':
        var string = '';

        for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
          string += tokens[lastTokenIndex].value;
        }

        if (areStringsEqualCaseInsensitive(string, state.value)) {
          while (tokenIndex < lastTokenIndex) {
            addTokenToMatch();
          }

          state = MATCH;
        } else {
          state = MISMATCH;
        }

        break;

      default:
        throw new Error('Unknown node type: ' + state.type);
    }
  }

  totalIterationCount += iterationCount;

  switch (exitReason) {
    case null:
      console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
      exitReason = EXIT_REASON_ITERATION_LIMIT;
      matchStack = null;
      break;

    case EXIT_REASON_MATCH:
      while (syntaxStack !== null) {
        closeSyntax();
      }

      break;

    default:
      matchStack = null;
  }

  return {
    tokens: tokens,
    reason: exitReason,
    iterations: iterationCount,
    match: matchStack,
    longestMatch: longestMatch
  };
}

function matchAsList(tokens, matchGraph, syntaxes) {
  var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

  if (matchResult.match !== null) {
    var item = reverseList(matchResult.match).prev;
    matchResult.match = [];

    while (item !== null) {
      switch (item.type) {
        case STUB:
          break;

        case OPEN_SYNTAX:
        case CLOSE_SYNTAX:
          matchResult.match.push({
            type: item.type,
            syntax: item.syntax
          });
          break;

        default:
          matchResult.match.push({
            token: item.token.value,
            node: item.token.node
          });
          break;
      }

      item = item.prev;
    }
  }

  return matchResult;
}

function matchAsTree(tokens, matchGraph, syntaxes) {
  var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

  if (matchResult.match === null) {
    return matchResult;
  }

  var item = matchResult.match;
  var host = matchResult.match = {
    syntax: matchGraph.syntax || null,
    match: []
  };
  var hostStack = [host]; // revert a list and start with 2nd item since 1st is a stub item

  item = reverseList(item).prev; // build a tree

  while (item !== null) {
    switch (item.type) {
      case OPEN_SYNTAX:
        host.match.push(host = {
          syntax: item.syntax,
          match: []
        });
        hostStack.push(host);
        break;

      case CLOSE_SYNTAX:
        hostStack.pop();
        host = hostStack[hostStack.length - 1];
        break;

      default:
        host.match.push({
          syntax: item.syntax || null,
          token: item.token.value,
          node: item.token.node
        });
    }

    item = item.prev;
  }

  return matchResult;
}

module.exports = {
  matchAsList: matchAsList,
  matchAsTree: matchAsTree,
  getTotalIterationCount: function getTotalIterationCount() {
    return totalIterationCount;
  }
};
},{"./match-graph":"node_modules/css-tree/lib/lexer/match-graph.js","../tokenizer/const":"node_modules/css-tree/lib/tokenizer/const.js"}],"node_modules/css-tree/lib/lexer/trace.js":[function(require,module,exports) {
function getTrace(node) {
  function shouldPutToTrace(syntax) {
    if (syntax === null) {
      return false;
    }

    return syntax.type === 'Type' || syntax.type === 'Property' || syntax.type === 'Keyword';
  }

  function hasMatch(matchNode) {
    if (Array.isArray(matchNode.match)) {
      // use for-loop for better perfomance
      for (var i = 0; i < matchNode.match.length; i++) {
        if (hasMatch(matchNode.match[i])) {
          if (shouldPutToTrace(matchNode.syntax)) {
            result.unshift(matchNode.syntax);
          }

          return true;
        }
      }
    } else if (matchNode.node === node) {
      result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
      return true;
    }

    return false;
  }

  var result = null;

  if (this.matched !== null) {
    hasMatch(this.matched);
  }

  return result;
}

function testNode(match, node, fn) {
  var trace = getTrace.call(match, node);

  if (trace === null) {
    return false;
  }

  return trace.some(fn);
}

function isType(node, type) {
  return testNode(this, node, function (matchNode) {
    return matchNode.type === 'Type' && matchNode.name === type;
  });
}

function isProperty(node, property) {
  return testNode(this, node, function (matchNode) {
    return matchNode.type === 'Property' && matchNode.name === property;
  });
}

function isKeyword(node) {
  return testNode(this, node, function (matchNode) {
    return matchNode.type === 'Keyword';
  });
}

module.exports = {
  getTrace: getTrace,
  isType: isType,
  isProperty: isProperty,
  isKeyword: isKeyword
};
},{}],"node_modules/css-tree/lib/lexer/search.js":[function(require,module,exports) {
var List = require('../common/List');

function getFirstMatchNode(matchNode) {
  if ('node' in matchNode) {
    return matchNode.node;
  }

  return getFirstMatchNode(matchNode.match[0]);
}

function getLastMatchNode(matchNode) {
  if ('node' in matchNode) {
    return matchNode.node;
  }

  return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}

function matchFragments(lexer, ast, match, type, name) {
  function findFragments(matchNode) {
    if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name) {
      var start = getFirstMatchNode(matchNode);
      var end = getLastMatchNode(matchNode);
      lexer.syntax.walk(ast, function (node, item, list) {
        if (node === start) {
          var nodes = new List();

          do {
            nodes.appendData(item.data);

            if (item.data === end) {
              break;
            }

            item = item.next;
          } while (item !== null);

          fragments.push({
            parent: list,
            nodes: nodes
          });
        }
      });
    }

    if (Array.isArray(matchNode.match)) {
      matchNode.match.forEach(findFragments);
    }
  }

  var fragments = [];

  if (match.matched !== null) {
    findFragments(match.matched);
  }

  return fragments;
}

module.exports = {
  matchFragments: matchFragments
};
},{"../common/List":"node_modules/css-tree/lib/common/List.js"}],"node_modules/css-tree/lib/lexer/structure.js":[function(require,module,exports) {
var List = require('../common/List');

var hasOwnProperty = Object.prototype.hasOwnProperty;

function isValidNumber(value) {
  // Number.isInteger(value) && value >= 0
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value && value >= 0;
}

function isValidLocation(loc) {
  return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
}

function createNodeStructureChecker(type, fields) {
  return function checkNode(node, warn) {
    if (!node || node.constructor !== Object) {
      return warn(node, 'Type of node should be an Object');
    }

    for (var key in node) {
      var valid = true;

      if (hasOwnProperty.call(node, key) === false) {
        continue;
      }

      if (key === 'type') {
        if (node.type !== type) {
          warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
        }
      } else if (key === 'loc') {
        if (node.loc === null) {
          continue;
        } else if (node.loc && node.loc.constructor === Object) {
          if (typeof node.loc.source !== 'string') {
            key += '.source';
          } else if (!isValidLocation(node.loc.start)) {
            key += '.start';
          } else if (!isValidLocation(node.loc.end)) {
            key += '.end';
          } else {
            continue;
          }
        }

        valid = false;
      } else if (fields.hasOwnProperty(key)) {
        for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
          var fieldType = fields[key][i];

          switch (fieldType) {
            case String:
              valid = typeof node[key] === 'string';
              break;

            case Boolean:
              valid = typeof node[key] === 'boolean';
              break;

            case null:
              valid = node[key] === null;
              break;

            default:
              if (typeof fieldType === 'string') {
                valid = node[key] && node[key].type === fieldType;
              } else if (Array.isArray(fieldType)) {
                valid = node[key] instanceof List;
              }

          }
        }
      } else {
        warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
      }

      if (!valid) {
        warn(node, 'Bad value for `' + type + '.' + key + '`');
      }
    }

    for (var key in fields) {
      if (hasOwnProperty.call(fields, key) && hasOwnProperty.call(node, key) === false) {
        warn(node, 'Field `' + type + '.' + key + '` is missed');
      }
    }
  };
}

function processStructure(name, nodeType) {
  var structure = nodeType.structure;
  var fields = {
    type: String,
    loc: true
  };
  var docs = {
    type: '"' + name + '"'
  };

  for (var key in structure) {
    if (hasOwnProperty.call(structure, key) === false) {
      continue;
    }

    var docsTypes = [];
    var fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];

    for (var i = 0; i < fieldTypes.length; i++) {
      var fieldType = fieldTypes[i];

      if (fieldType === String || fieldType === Boolean) {
        docsTypes.push(fieldType.name);
      } else if (fieldType === null) {
        docsTypes.push('null');
      } else if (typeof fieldType === 'string') {
        docsTypes.push('<' + fieldType + '>');
      } else if (Array.isArray(fieldType)) {
        docsTypes.push('List'); // TODO: use type enum
      } else {
        throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
      }
    }

    docs[key] = docsTypes.join(' | ');
  }

  return {
    docs: docs,
    check: createNodeStructureChecker(name, fields)
  };
}

module.exports = {
  getStructureFromConfig: function getStructureFromConfig(config) {
    var structure = {};

    if (config.node) {
      for (var name in config.node) {
        if (hasOwnProperty.call(config.node, name)) {
          var nodeType = config.node[name];

          if (nodeType.structure) {
            structure[name] = processStructure(name, nodeType);
          } else {
            throw new Error('Missed `structure` field in `' + name + '` node type definition');
          }
        }
      }
    }

    return structure;
  }
};
},{"../common/List":"node_modules/css-tree/lib/common/List.js"}],"node_modules/css-tree/lib/lexer/Lexer.js":[function(require,module,exports) {
var SyntaxReferenceError = require('./error').SyntaxReferenceError;

var MatchError = require('./error').MatchError;

var names = require('../utils/names');

var generic = require('./generic');

var parse = require('../definition-syntax/parse');

var generate = require('../definition-syntax/generate');

var walk = require('../definition-syntax/walk');

var prepareTokens = require('./prepare-tokens');

var buildMatchGraph = require('./match-graph').buildMatchGraph;

var matchAsTree = require('./match').matchAsTree;

var trace = require('./trace');

var search = require('./search');

var getStructureFromConfig = require('./structure').getStructureFromConfig;

var cssWideKeywords = buildMatchGraph('inherit | initial | unset');
var cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');

function dumpMapSyntax(map, compact, syntaxAsAst) {
  var result = {};

  for (var name in map) {
    if (map[name].syntax) {
      result[name] = syntaxAsAst ? map[name].syntax : generate(map[name].syntax, {
        compact: compact
      });
    }
  }

  return result;
}

function valueHasVar(tokens) {
  for (var i = 0; i < tokens.length; i++) {
    if (tokens[i].value.toLowerCase() === 'var(') {
      return true;
    }
  }

  return false;
}

function buildMatchResult(match, error, iterations) {
  return {
    matched: match,
    iterations: iterations,
    error: error,
    getTrace: trace.getTrace,
    isType: trace.isType,
    isProperty: trace.isProperty,
    isKeyword: trace.isKeyword
  };
}

function matchSyntax(lexer, syntax, value, useCommon) {
  var tokens = prepareTokens(value, lexer.syntax);
  var result;

  if (valueHasVar(tokens)) {
    return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
  }

  if (useCommon) {
    result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);
  }

  if (!useCommon || !result.match) {
    result = matchAsTree(tokens, syntax.match, lexer);

    if (!result.match) {
      return buildMatchResult(null, new MatchError(result.reason, syntax.syntax, value, result), result.iterations);
    }
  }

  return buildMatchResult(result.match, null, result.iterations);
}

var Lexer = function Lexer(config, syntax, structure) {
  this.valueCommonSyntax = cssWideKeywords;
  this.syntax = syntax;
  this.generic = false;
  this.properties = {};
  this.types = {};
  this.structure = structure || getStructureFromConfig(config);

  if (config) {
    if (config.types) {
      for (var name in config.types) {
        this.addType_(name, config.types[name]);
      }
    }

    if (config.generic) {
      this.generic = true;

      for (var name in generic) {
        this.addType_(name, generic[name]);
      }
    }

    if (config.properties) {
      for (var name in config.properties) {
        this.addProperty_(name, config.properties[name]);
      }
    }
  }
};

Lexer.prototype = {
  structure: {},
  checkStructure: function checkStructure(ast) {
    function collectWarning(node, message) {
      warns.push({
        node: node,
        message: message
      });
    }

    var structure = this.structure;
    var warns = [];
    this.syntax.walk(ast, function (node) {
      if (structure.hasOwnProperty(node.type)) {
        structure[node.type].check(node, collectWarning);
      } else {
        collectWarning(node, 'Unknown node type `' + node.type + '`');
      }
    });
    return warns.length ? warns : false;
  },
  createDescriptor: function createDescriptor(syntax, type, name) {
    var ref = {
      type: type,
      name: name
    };
    var descriptor = {
      type: type,
      name: name,
      syntax: null,
      match: null
    };

    if (typeof syntax === 'function') {
      descriptor.match = buildMatchGraph(syntax, ref);
    } else {
      if (typeof syntax === 'string') {
        // lazy parsing on first access
        Object.defineProperty(descriptor, 'syntax', {
          get: function get() {
            Object.defineProperty(descriptor, 'syntax', {
              value: parse(syntax)
            });
            return descriptor.syntax;
          }
        });
      } else {
        descriptor.syntax = syntax;
      } // lazy graph build on first access


      Object.defineProperty(descriptor, 'match', {
        get: function get() {
          Object.defineProperty(descriptor, 'match', {
            value: buildMatchGraph(descriptor.syntax, ref)
          });
          return descriptor.match;
        }
      });
    }

    return descriptor;
  },
  addProperty_: function addProperty_(name, syntax) {
    this.properties[name] = this.createDescriptor(syntax, 'Property', name);
  },
  addType_: function addType_(name, syntax) {
    this.types[name] = this.createDescriptor(syntax, 'Type', name);

    if (syntax === generic['-ms-legacy-expression']) {
      this.valueCommonSyntax = cssWideKeywordsWithExpression;
    }
  },
  matchDeclaration: function matchDeclaration(node) {
    if (node.type !== 'Declaration') {
      return buildMatchResult(null, new Error('Not a Declaration node'));
    }

    return this.matchProperty(node.property, node.value);
  },
  matchProperty: function matchProperty(propertyName, value) {
    var property = names.property(propertyName); // don't match syntax for a custom property

    if (property.custom) {
      return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
    }

    var propertySyntax = property.vendor ? this.getProperty(property.name) || this.getProperty(property.basename) : this.getProperty(property.name);

    if (!propertySyntax) {
      return buildMatchResult(null, new SyntaxReferenceError('Unknown property', propertyName));
    }

    return matchSyntax(this, propertySyntax, value, true);
  },
  matchType: function matchType(typeName, value) {
    var typeSyntax = this.getType(typeName);

    if (!typeSyntax) {
      return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));
    }

    return matchSyntax(this, typeSyntax, value, false);
  },
  match: function match(syntax, value) {
    if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
      return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));
    }

    if (typeof syntax === 'string' || !syntax.match) {
      syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
    }

    return matchSyntax(this, syntax, value, false);
  },
  findValueFragments: function findValueFragments(propertyName, value, type, name) {
    return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
  },
  findDeclarationValueFragments: function findDeclarationValueFragments(declaration, type, name) {
    return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
  },
  findAllFragments: function findAllFragments(ast, type, name) {
    var result = [];
    this.syntax.walk(ast, {
      visit: 'Declaration',
      enter: function (declaration) {
        result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
      }.bind(this)
    });
    return result;
  },
  getProperty: function getProperty(name) {
    return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
  },
  getType: function getType(name) {
    return this.types.hasOwnProperty(name) ? this.types[name] : null;
  },
  validate: function validate() {
    function validate(syntax, name, broken, descriptor) {
      if (broken.hasOwnProperty(name)) {
        return broken[name];
      }

      broken[name] = false;

      if (descriptor.syntax !== null) {
        walk(descriptor.syntax, function (node) {
          if (node.type !== 'Type' && node.type !== 'Property') {
            return;
          }

          var map = node.type === 'Type' ? syntax.types : syntax.properties;
          var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

          if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
            broken[name] = true;
          }
        }, this);
      }
    }

    var brokenTypes = {};
    var brokenProperties = {};

    for (var key in this.types) {
      validate(this, key, brokenTypes, this.types[key]);
    }

    for (var key in this.properties) {
      validate(this, key, brokenProperties, this.properties[key]);
    }

    brokenTypes = Object.keys(brokenTypes).filter(function (name) {
      return brokenTypes[name];
    });
    brokenProperties = Object.keys(brokenProperties).filter(function (name) {
      return brokenProperties[name];
    });

    if (brokenTypes.length || brokenProperties.length) {
      return {
        types: brokenTypes,
        properties: brokenProperties
      };
    }

    return null;
  },
  dump: function dump(syntaxAsAst, pretty) {
    return {
      generic: this.generic,
      types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
      properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
    };
  },
  toString: function toString() {
    return JSON.stringify(this.dump());
  }
};
module.exports = Lexer;
},{"./error":"node_modules/css-tree/lib/lexer/error.js","../utils/names":"node_modules/css-tree/lib/utils/names.js","./generic":"node_modules/css-tree/lib/lexer/generic.js","../definition-syntax/parse":"node_modules/css-tree/lib/definition-syntax/parse.js","../definition-syntax/generate":"node_modules/css-tree/lib/definition-syntax/generate.js","../definition-syntax/walk":"node_modules/css-tree/lib/definition-syntax/walk.js","./prepare-tokens":"node_modules/css-tree/lib/lexer/prepare-tokens.js","./match-graph":"node_modules/css-tree/lib/lexer/match-graph.js","./match":"node_modules/css-tree/lib/lexer/match.js","./trace":"node_modules/css-tree/lib/lexer/trace.js","./search":"node_modules/css-tree/lib/lexer/search.js","./structure":"node_modules/css-tree/lib/lexer/structure.js"}],"node_modules/css-tree/lib/definition-syntax/index.js":[function(require,module,exports) {
module.exports = {
  SyntaxError: require('./SyntaxError'),
  parse: require('./parse'),
  generate: require('./generate'),
  walk: require('./walk')
};
},{"./SyntaxError":"node_modules/css-tree/lib/definition-syntax/SyntaxError.js","./parse":"node_modules/css-tree/lib/definition-syntax/parse.js","./generate":"node_modules/css-tree/lib/definition-syntax/generate.js","./walk":"node_modules/css-tree/lib/definition-syntax/walk.js"}],"node_modules/css-tree/lib/common/OffsetToLocation.js":[function(require,module,exports) {
var adoptBuffer = require('./adopt-buffer');

var isBOM = require('../tokenizer').isBOM;

var N = 10;
var F = 12;
var R = 13;

function computeLinesAndColumns(host, source) {
  var sourceLength = source.length;
  var lines = adoptBuffer(host.lines, sourceLength); // +1

  var line = host.startLine;
  var columns = adoptBuffer(host.columns, sourceLength);
  var column = host.startColumn;
  var startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;

  for (var i = startOffset; i < sourceLength; i++) {
    // -1
    var code = source.charCodeAt(i);
    lines[i] = line;
    columns[i] = column++;

    if (code === N || code === R || code === F) {
      if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
        i++;
        lines[i] = line;
        columns[i] = column;
      }

      line++;
      column = 1;
    }
  }

  lines[i] = line;
  columns[i] = column;
  host.lines = lines;
  host.columns = columns;
}

var OffsetToLocation = function OffsetToLocation() {
  this.lines = null;
  this.columns = null;
  this.linesAndColumnsComputed = false;
};

OffsetToLocation.prototype = {
  setSource: function setSource(source, startOffset, startLine, startColumn) {
    this.source = source;
    this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
    this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
    this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
    this.linesAndColumnsComputed = false;
  },
  ensureLinesAndColumnsComputed: function ensureLinesAndColumnsComputed() {
    if (!this.linesAndColumnsComputed) {
      computeLinesAndColumns(this, this.source);
      this.linesAndColumnsComputed = true;
    }
  },
  getLocation: function getLocation(offset, filename) {
    this.ensureLinesAndColumnsComputed();
    return {
      source: filename,
      offset: this.startOffset + offset,
      line: this.lines[offset],
      column: this.columns[offset]
    };
  },
  getLocationRange: function getLocationRange(start, end, filename) {
    this.ensureLinesAndColumnsComputed();
    return {
      source: filename,
      start: {
        offset: this.startOffset + start,
        line: this.lines[start],
        column: this.columns[start]
      },
      end: {
        offset: this.startOffset + end,
        line: this.lines[end],
        column: this.columns[end]
      }
    };
  }
};
module.exports = OffsetToLocation;
},{"./adopt-buffer":"node_modules/css-tree/lib/common/adopt-buffer.js","../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/parser/sequence.js":[function(require,module,exports) {
var TYPE = require('../tokenizer').TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;

module.exports = function readSequence(recognizer) {
  var children = this.createList();
  var child = null;
  var context = {
    recognizer: recognizer,
    space: null,
    ignoreWS: false,
    ignoreWSAfter: false
  };
  this.scanner.skipSC();

  while (!this.scanner.eof) {
    switch (this.scanner.tokenType) {
      case COMMENT:
        this.scanner.next();
        continue;

      case WHITESPACE:
        if (context.ignoreWS) {
          this.scanner.next();
        } else {
          context.space = this.WhiteSpace();
        }

        continue;
    }

    child = recognizer.getNode.call(this, context);

    if (child === undefined) {
      break;
    }

    if (context.space !== null) {
      children.push(context.space);
      context.space = null;
    }

    children.push(child);

    if (context.ignoreWSAfter) {
      context.ignoreWSAfter = false;
      context.ignoreWS = true;
    } else {
      context.ignoreWS = false;
    }
  }

  return children;
};
},{"../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/parser/create.js":[function(require,module,exports) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var OffsetToLocation = require('../common/OffsetToLocation');

var SyntaxError = require('../common/SyntaxError');

var TokenStream = require('../common/TokenStream');

var List = require('../common/List');

var tokenize = require('../tokenizer');

var constants = require('../tokenizer/const');

var findWhiteSpaceStart = require('../tokenizer/utils').findWhiteSpaceStart;

var sequence = require('./sequence');

var noop = function noop() {};

var TYPE = constants.TYPE;
var NAME = constants.NAME;
var WHITESPACE = TYPE.WhiteSpace;
var IDENT = TYPE.Ident;
var FUNCTION = TYPE.Function;
var URL = TYPE.Url;
var HASH = TYPE.Hash;
var PERCENTAGE = TYPE.Percentage;
var NUMBER = TYPE.Number;
var NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)

var NULL = 0;

function createParseContext(name) {
  return function () {
    return this[name]();
  };
}

function processConfig(config) {
  var parserConfig = {
    context: {},
    scope: {},
    atrule: {},
    pseudo: {}
  };

  if (config.parseContext) {
    for (var name in config.parseContext) {
      switch (_typeof(config.parseContext[name])) {
        case 'function':
          parserConfig.context[name] = config.parseContext[name];
          break;

        case 'string':
          parserConfig.context[name] = createParseContext(config.parseContext[name]);
          break;
      }
    }
  }

  if (config.scope) {
    for (var name in config.scope) {
      parserConfig.scope[name] = config.scope[name];
    }
  }

  if (config.atrule) {
    for (var name in config.atrule) {
      var atrule = config.atrule[name];

      if (atrule.parse) {
        parserConfig.atrule[name] = atrule.parse;
      }
    }
  }

  if (config.pseudo) {
    for (var name in config.pseudo) {
      var pseudo = config.pseudo[name];

      if (pseudo.parse) {
        parserConfig.pseudo[name] = pseudo.parse;
      }
    }
  }

  if (config.node) {
    for (var name in config.node) {
      parserConfig[name] = config.node[name].parse;
    }
  }

  return parserConfig;
}

module.exports = function createParser(config) {
  var parser = {
    scanner: new TokenStream(),
    locationMap: new OffsetToLocation(),
    filename: '<unknown>',
    needPositions: false,
    onParseError: noop,
    onParseErrorThrow: false,
    parseAtrulePrelude: true,
    parseRulePrelude: true,
    parseValue: true,
    parseCustomProperty: false,
    readSequence: sequence,
    createList: function createList() {
      return new List();
    },
    createSingleNodeList: function createSingleNodeList(node) {
      return new List().appendData(node);
    },
    getFirstListNode: function getFirstListNode(list) {
      return list && list.first();
    },
    getLastListNode: function getLastListNode(list) {
      return list.last();
    },
    parseWithFallback: function parseWithFallback(consumer, fallback) {
      var startToken = this.scanner.tokenIndex;

      try {
        return consumer.call(this);
      } catch (e) {
        if (this.onParseErrorThrow) {
          throw e;
        }

        var fallbackNode = fallback.call(this, startToken);
        this.onParseErrorThrow = true;
        this.onParseError(e, fallbackNode);
        this.onParseErrorThrow = false;
        return fallbackNode;
      }
    },
    lookupNonWSType: function lookupNonWSType(offset) {
      do {
        var type = this.scanner.lookupType(offset++);

        if (type !== WHITESPACE) {
          return type;
        }
      } while (type !== NULL);

      return NULL;
    },
    eat: function eat(tokenType) {
      if (this.scanner.tokenType !== tokenType) {
        var offset = this.scanner.tokenStart;
        var message = NAME[tokenType] + ' is expected'; // tweak message and offset

        switch (tokenType) {
          case IDENT:
            // when identifier is expected but there is a function or url
            if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {
              offset = this.scanner.tokenEnd - 1;
              message = 'Identifier is expected but function found';
            } else {
              message = 'Identifier is expected';
            }

            break;

          case HASH:
            if (this.scanner.isDelim(NUMBERSIGN)) {
              this.scanner.next();
              offset++;
              message = 'Name is expected';
            }

            break;

          case PERCENTAGE:
            if (this.scanner.tokenType === NUMBER) {
              offset = this.scanner.tokenEnd;
              message = 'Percent sign is expected';
            }

            break;

          default:
            // when test type is part of another token show error for current position + 1
            // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
              offset = offset + 1;
            }

        }

        this.error(message, offset);
      }

      this.scanner.next();
    },
    consume: function consume(tokenType) {
      var value = this.scanner.getTokenValue();
      this.eat(tokenType);
      return value;
    },
    consumeFunctionName: function consumeFunctionName() {
      var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);
      this.eat(FUNCTION);
      return name;
    },
    getLocation: function getLocation(start, end) {
      if (this.needPositions) {
        return this.locationMap.getLocationRange(start, end, this.filename);
      }

      return null;
    },
    getLocationFromList: function getLocationFromList(list) {
      if (this.needPositions) {
        var head = this.getFirstListNode(list);
        var tail = this.getLastListNode(list);
        return this.locationMap.getLocationRange(head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart, tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart, this.filename);
      }

      return null;
    },
    error: function error(message, offset) {
      var location = typeof offset !== 'undefined' && offset < this.scanner.source.length ? this.locationMap.getLocation(offset) : this.scanner.eof ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1)) : this.locationMap.getLocation(this.scanner.tokenStart);
      throw new SyntaxError(message || 'Unexpected input', this.scanner.source, location.offset, location.line, location.column);
    }
  };
  config = processConfig(config || {});

  for (var key in config) {
    parser[key] = config[key];
  }

  return function (source, options) {
    options = options || {};
    var context = options.context || 'default';
    var ast;
    tokenize(source, parser.scanner);
    parser.locationMap.setSource(source, options.offset, options.line, options.column);
    parser.filename = options.filename || '<unknown>';
    parser.needPositions = Boolean(options.positions);
    parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;
    parser.onParseErrorThrow = false;
    parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
    parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
    parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
    parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

    if (!parser.context.hasOwnProperty(context)) {
      throw new Error('Unknown context `' + context + '`');
    }

    ast = parser.context[context].call(parser, options);

    if (!parser.scanner.eof) {
      parser.error();
    }

    return ast;
  };
};
},{"../common/OffsetToLocation":"node_modules/css-tree/lib/common/OffsetToLocation.js","../common/SyntaxError":"node_modules/css-tree/lib/common/SyntaxError.js","../common/TokenStream":"node_modules/css-tree/lib/common/TokenStream.js","../common/List":"node_modules/css-tree/lib/common/List.js","../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js","../tokenizer/const":"node_modules/css-tree/lib/tokenizer/const.js","../tokenizer/utils":"node_modules/css-tree/lib/tokenizer/utils.js","./sequence":"node_modules/css-tree/lib/parser/sequence.js"}],"node_modules/css-tree/lib/generator/sourceMap.js":[function(require,module,exports) {
var SourceMapGenerator = require('source-map/lib/source-map-generator').SourceMapGenerator;

var trackNodes = {
  Atrule: true,
  Selector: true,
  Declaration: true
};

module.exports = function generateSourceMap(handlers) {
  var map = new SourceMapGenerator();
  var line = 1;
  var column = 0;
  var generated = {
    line: 1,
    column: 0
  };
  var original = {
    line: 0,
    // should be zero to add first mapping
    column: 0
  };
  var sourceMappingActive = false;
  var activatedGenerated = {
    line: 1,
    column: 0
  };
  var activatedMapping = {
    generated: activatedGenerated
  };
  var handlersNode = handlers.node;

  handlers.node = function (node) {
    if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
      var nodeLine = node.loc.start.line;
      var nodeColumn = node.loc.start.column - 1;

      if (original.line !== nodeLine || original.column !== nodeColumn) {
        original.line = nodeLine;
        original.column = nodeColumn;
        generated.line = line;
        generated.column = column;

        if (sourceMappingActive) {
          sourceMappingActive = false;

          if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
            map.addMapping(activatedMapping);
          }
        }

        sourceMappingActive = true;
        map.addMapping({
          source: node.loc.source,
          original: original,
          generated: generated
        });
      }
    }

    handlersNode.call(this, node);

    if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
      activatedGenerated.line = line;
      activatedGenerated.column = column;
    }
  };

  var handlersChunk = handlers.chunk;

  handlers.chunk = function (chunk) {
    for (var i = 0; i < chunk.length; i++) {
      if (chunk.charCodeAt(i) === 10) {
        // \n
        line++;
        column = 0;
      } else {
        column++;
      }
    }

    handlersChunk(chunk);
  };

  var handlersResult = handlers.result;

  handlers.result = function () {
    if (sourceMappingActive) {
      map.addMapping(activatedMapping);
    }

    return {
      css: handlersResult(),
      map: map
    };
  };

  return handlers;
};
},{"source-map/lib/source-map-generator":"node_modules/source-map/lib/source-map-generator.js"}],"node_modules/css-tree/lib/generator/create.js":[function(require,module,exports) {
var sourceMap = require('./sourceMap');

var hasOwnProperty = Object.prototype.hasOwnProperty;

function processChildren(node, delimeter) {
  var list = node.children;
  var prev = null;

  if (typeof delimeter !== 'function') {
    list.forEach(this.node, this);
  } else {
    list.forEach(function (node) {
      if (prev !== null) {
        delimeter.call(this, prev);
      }

      this.node(node);
      prev = node;
    }, this);
  }
}

module.exports = function createGenerator(config) {
  function processNode(node) {
    if (hasOwnProperty.call(types, node.type)) {
      types[node.type].call(this, node);
    } else {
      throw new Error('Unknown node type: ' + node.type);
    }
  }

  var types = {};

  if (config.node) {
    for (var name in config.node) {
      types[name] = config.node[name].generate;
    }
  }

  return function (node, options) {
    var buffer = '';
    var handlers = {
      children: processChildren,
      node: processNode,
      chunk: function chunk(_chunk) {
        buffer += _chunk;
      },
      result: function result() {
        return buffer;
      }
    };

    if (options) {
      if (typeof options.decorator === 'function') {
        handlers = options.decorator(handlers);
      }

      if (options.sourceMap) {
        handlers = sourceMap(handlers);
      }
    }

    handlers.node(node);
    return handlers.result();
  };
};
},{"./sourceMap":"node_modules/css-tree/lib/generator/sourceMap.js"}],"node_modules/css-tree/lib/convertor/create.js":[function(require,module,exports) {
var List = require('../common/List');

module.exports = function createConvertors(walk) {
  return {
    fromPlainObject: function fromPlainObject(ast) {
      walk(ast, {
        enter: function enter(node) {
          if (node.children && node.children instanceof List === false) {
            node.children = new List().fromArray(node.children);
          }
        }
      });
      return ast;
    },
    toPlainObject: function toPlainObject(ast) {
      walk(ast, {
        leave: function leave(node) {
          if (node.children && node.children instanceof List) {
            node.children = node.children.toArray();
          }
        }
      });
      return ast;
    }
  };
};
},{"../common/List":"node_modules/css-tree/lib/common/List.js"}],"node_modules/css-tree/lib/walker/create.js":[function(require,module,exports) {
var hasOwnProperty = Object.prototype.hasOwnProperty;

var noop = function noop() {};

function ensureFunction(value) {
  return typeof value === 'function' ? value : noop;
}

function invokeForType(fn, type) {
  return function (node, item, list) {
    if (node.type === type) {
      fn.call(this, node, item, list);
    }
  };
}

function getWalkersFromStructure(name, nodeType) {
  var structure = nodeType.structure;
  var walkers = [];

  for (var key in structure) {
    if (hasOwnProperty.call(structure, key) === false) {
      continue;
    }

    var fieldTypes = structure[key];
    var walker = {
      name: key,
      type: false,
      nullable: false
    };

    if (!Array.isArray(structure[key])) {
      fieldTypes = [structure[key]];
    }

    for (var i = 0; i < fieldTypes.length; i++) {
      var fieldType = fieldTypes[i];

      if (fieldType === null) {
        walker.nullable = true;
      } else if (typeof fieldType === 'string') {
        walker.type = 'node';
      } else if (Array.isArray(fieldType)) {
        walker.type = 'list';
      }
    }

    if (walker.type) {
      walkers.push(walker);
    }
  }

  if (walkers.length) {
    return {
      context: nodeType.walkContext,
      fields: walkers
    };
  }

  return null;
}

function getTypesFromConfig(config) {
  var types = {};

  for (var name in config.node) {
    if (hasOwnProperty.call(config.node, name)) {
      var nodeType = config.node[name];

      if (!nodeType.structure) {
        throw new Error('Missed `structure` field in `' + name + '` node type definition');
      }

      types[name] = getWalkersFromStructure(name, nodeType);
    }
  }

  return types;
}

function createTypeIterator(config, reverse) {
  var fields = config.fields.slice();
  var contextName = config.context;
  var useContext = typeof contextName === 'string';

  if (reverse) {
    fields.reverse();
  }

  return function (node, context, walk) {
    var prevContextValue;

    if (useContext) {
      prevContextValue = context[contextName];
      context[contextName] = node;
    }

    for (var i = 0; i < fields.length; i++) {
      var field = fields[i];
      var ref = node[field.name];

      if (!field.nullable || ref) {
        if (field.type === 'list') {
          if (reverse) {
            ref.forEachRight(walk);
          } else {
            ref.forEach(walk);
          }
        } else {
          walk(ref);
        }
      }
    }

    if (useContext) {
      context[contextName] = prevContextValue;
    }
  };
}

function createFastTraveralMap(iterators) {
  return {
    Atrule: {
      StyleSheet: iterators.StyleSheet,
      Atrule: iterators.Atrule,
      Rule: iterators.Rule,
      Block: iterators.Block
    },
    Rule: {
      StyleSheet: iterators.StyleSheet,
      Atrule: iterators.Atrule,
      Rule: iterators.Rule,
      Block: iterators.Block
    },
    Declaration: {
      StyleSheet: iterators.StyleSheet,
      Atrule: iterators.Atrule,
      Rule: iterators.Rule,
      Block: iterators.Block
    }
  };
}

module.exports = function createWalker(config) {
  var types = getTypesFromConfig(config);
  var iteratorsNatural = {};
  var iteratorsReverse = {};

  for (var name in types) {
    if (hasOwnProperty.call(types, name) && types[name] !== null) {
      iteratorsNatural[name] = createTypeIterator(types[name], false);
      iteratorsReverse[name] = createTypeIterator(types[name], true);
    }
  }

  var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
  var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

  var walk = function walk(root, options) {
    function walkNode(node, item, list) {
      enter.call(context, node, item, list);

      if (iterators.hasOwnProperty(node.type)) {
        iterators[node.type](node, context, walkNode);
      }

      leave.call(context, node, item, list);
    }

    var enter = noop;
    var leave = noop;
    var iterators = iteratorsNatural;
    var context = {
      root: root,
      stylesheet: null,
      atrule: null,
      atrulePrelude: null,
      rule: null,
      selector: null,
      block: null,
      declaration: null,
      function: null
    };

    if (typeof options === 'function') {
      enter = options;
    } else if (options) {
      enter = ensureFunction(options.enter);
      leave = ensureFunction(options.leave);

      if (options.reverse) {
        iterators = iteratorsReverse;
      }

      if (options.visit) {
        if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
          iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
        } else if (!types.hasOwnProperty(options.visit)) {
          throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
        }

        enter = invokeForType(enter, options.visit);
        leave = invokeForType(leave, options.visit);
      }
    }

    if (enter === noop && leave === noop) {
      throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
    } // swap handlers in reverse mode to invert visit order


    if (options.reverse) {
      var tmp = enter;
      enter = leave;
      leave = tmp;
    }

    walkNode(root);
  };

  walk.find = function (ast, fn) {
    var found = null;
    walk(ast, function (node, item, list) {
      if (found === null && fn.call(this, node, item, list)) {
        found = node;
      }
    });
    return found;
  };

  walk.findLast = function (ast, fn) {
    var found = null;
    walk(ast, {
      reverse: true,
      enter: function enter(node, item, list) {
        if (found === null && fn.call(this, node, item, list)) {
          found = node;
        }
      }
    });
    return found;
  };

  walk.findAll = function (ast, fn) {
    var found = [];
    walk(ast, function (node, item, list) {
      if (fn.call(this, node, item, list)) {
        found.push(node);
      }
    });
    return found;
  };

  return walk;
};
},{}],"node_modules/css-tree/lib/utils/clone.js":[function(require,module,exports) {
var List = require('../common/List');

module.exports = function clone(node) {
  var result = {};

  for (var key in node) {
    var value = node[key];

    if (value) {
      if (Array.isArray(value) || value instanceof List) {
        value = value.map(clone);
      } else if (value.constructor === Object) {
        value = clone(value);
      }
    }

    result[key] = value;
  }

  return result;
};
},{"../common/List":"node_modules/css-tree/lib/common/List.js"}],"node_modules/css-tree/lib/syntax/config/mix.js":[function(require,module,exports) {
var hasOwnProperty = Object.prototype.hasOwnProperty;
var shape = {
  generic: true,
  types: {},
  properties: {},
  parseContext: {},
  scope: {},
  atrule: ['parse'],
  pseudo: ['parse'],
  node: ['name', 'structure', 'parse', 'generate', 'walkContext']
};

function isObject(value) {
  return value && value.constructor === Object;
}

function copy(value) {
  if (isObject(value)) {
    var res = {};

    for (var key in value) {
      if (hasOwnProperty.call(value, key)) {
        res[key] = value[key];
      }
    }

    return res;
  } else {
    return value;
  }
}

function extend(dest, src) {
  for (var key in src) {
    if (hasOwnProperty.call(src, key)) {
      if (isObject(dest[key])) {
        extend(dest[key], copy(src[key]));
      } else {
        dest[key] = copy(src[key]);
      }
    }
  }
}

function mix(dest, src, shape) {
  for (var key in shape) {
    if (hasOwnProperty.call(shape, key) === false) {
      continue;
    }

    if (shape[key] === true) {
      if (key in src) {
        if (hasOwnProperty.call(src, key)) {
          dest[key] = copy(src[key]);
        }
      }
    } else if (shape[key]) {
      if (isObject(shape[key])) {
        var res = {};
        extend(res, dest[key]);
        extend(res, src[key]);
        dest[key] = res;
      } else if (Array.isArray(shape[key])) {
        var res = {};
        var innerShape = shape[key].reduce(function (s, k) {
          s[k] = true;
          return s;
        }, {});

        for (var name in dest[key]) {
          if (hasOwnProperty.call(dest[key], name)) {
            res[name] = {};

            if (dest[key] && dest[key][name]) {
              mix(res[name], dest[key][name], innerShape);
            }
          }
        }

        for (var name in src[key]) {
          if (hasOwnProperty.call(src[key], name)) {
            if (!res[name]) {
              res[name] = {};
            }

            if (src[key] && src[key][name]) {
              mix(res[name], src[key][name], innerShape);
            }
          }
        }

        dest[key] = res;
      }
    }
  }

  return dest;
}

module.exports = function (dest, src) {
  return mix(dest, src, shape);
};
},{}],"node_modules/css-tree/lib/syntax/create.js":[function(require,module,exports) {
var List = require('../common/List');

var SyntaxError = require('../common/SyntaxError');

var TokenStream = require('../common/TokenStream');

var Lexer = require('../lexer/Lexer');

var definitionSyntax = require('../definition-syntax');

var tokenize = require('../tokenizer');

var createParser = require('../parser/create');

var createGenerator = require('../generator/create');

var createConvertor = require('../convertor/create');

var createWalker = require('../walker/create');

var clone = require('../utils/clone');

var names = require('../utils/names');

var mix = require('./config/mix');

function assign(dest, src) {
  for (var key in src) {
    dest[key] = src[key];
  }

  return dest;
}

function _createSyntax(config) {
  var parse = createParser(config);
  var walk = createWalker(config);
  var generate = createGenerator(config);
  var convert = createConvertor(walk);
  var syntax = {
    List: List,
    SyntaxError: SyntaxError,
    TokenStream: TokenStream,
    Lexer: Lexer,
    vendorPrefix: names.vendorPrefix,
    keyword: names.keyword,
    property: names.property,
    isCustomProperty: names.isCustomProperty,
    definitionSyntax: definitionSyntax,
    lexer: null,
    createLexer: function createLexer(config) {
      return new Lexer(config, syntax, syntax.lexer.structure);
    },
    tokenize: tokenize,
    parse: parse,
    walk: walk,
    generate: generate,
    find: walk.find,
    findLast: walk.findLast,
    findAll: walk.findAll,
    clone: clone,
    fromPlainObject: convert.fromPlainObject,
    toPlainObject: convert.toPlainObject,
    createSyntax: function createSyntax(config) {
      return _createSyntax(mix({}, config));
    },
    fork: function fork(extension) {
      var base = mix({}, config); // copy of config

      return _createSyntax(typeof extension === 'function' ? extension(base, assign) : mix(base, extension));
    }
  };
  syntax.lexer = new Lexer({
    generic: true,
    types: config.types,
    properties: config.properties,
    node: config.node
  }, syntax);
  return syntax;
}

;

exports.create = function (config) {
  return _createSyntax(mix({}, config));
};
},{"../common/List":"node_modules/css-tree/lib/common/List.js","../common/SyntaxError":"node_modules/css-tree/lib/common/SyntaxError.js","../common/TokenStream":"node_modules/css-tree/lib/common/TokenStream.js","../lexer/Lexer":"node_modules/css-tree/lib/lexer/Lexer.js","../definition-syntax":"node_modules/css-tree/lib/definition-syntax/index.js","../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js","../parser/create":"node_modules/css-tree/lib/parser/create.js","../generator/create":"node_modules/css-tree/lib/generator/create.js","../convertor/create":"node_modules/css-tree/lib/convertor/create.js","../walker/create":"node_modules/css-tree/lib/walker/create.js","../utils/clone":"node_modules/css-tree/lib/utils/clone.js","../utils/names":"node_modules/css-tree/lib/utils/names.js","./config/mix":"node_modules/css-tree/lib/syntax/config/mix.js"}],"node_modules/css-tree/dist/default-syntax.json":[function(require,module,exports) {
module.exports = {
  "generic": true,
  "types": {
    "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large",
    "alpha-value": "<number>|<percentage>",
    "angle-percentage": "<angle>|<percentage>",
    "angular-color-hint": "<angle-percentage>",
    "angular-color-stop": "<color>&&<color-stop-angle>?",
    "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>",
    "animateable-feature": "scroll-position|contents|<custom-ident>",
    "attachment": "scroll|fixed|local",
    "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )",
    "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='",
    "attr-modifier": "i|s",
    "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'",
    "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )",
    "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?",
    "baseline-position": "[first|last]? baseline",
    "basic-shape": "<inset()>|<circle()>|<ellipse()>|<polygon()>",
    "bg-image": "none|<image>",
    "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
    "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]",
    "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain",
    "blur()": "blur( <length> )",
    "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity",
    "box": "border-box|padding-box|content-box",
    "brightness()": "brightness( <number-percentage> )",
    "calc()": "calc( <calc-sum> )",
    "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*",
    "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*",
    "calc-value": "<number>|<dimension>|<percentage>|( <calc-sum> )",
    "cf-final-image": "<image>|<color>",
    "cf-mixing-image": "<percentage>?&&<image>",
    "circle()": "circle( [<shape-radius>]? [at <position>]? )",
    "clamp()": "clamp( <calc-sum>#{3} )",
    "class-selector": "'.' <ident-token>",
    "clip-source": "<url>",
    "color": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hex-color>|<named-color>|currentcolor|<deprecated-system-color>",
    "color-stop": "<color-stop-length>|<color-stop-angle>",
    "color-stop-angle": "<angle-percentage>{1,2}",
    "color-stop-length": "<length-percentage>{1,2}",
    "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>",
    "combinator": "'>'|'+'|'~'|['||']",
    "common-lig-values": "[common-ligatures|no-common-ligatures]",
    "compat": "searchfield|textarea|push-button|button-bevel|slider-horizontal|checkbox|radio|square-button|menulist|menulist-button|listbox|meter|progress-bar",
    "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor",
    "compositing-operator": "add|subtract|intersect|exclude",
    "compound-selector": "[<type-selector>? <subclass-selector>* [<pseudo-element-selector> <pseudo-class-selector>*]*]!",
    "compound-selector-list": "<compound-selector>#",
    "complex-selector": "<compound-selector> [<combinator>? <compound-selector>]*",
    "complex-selector-list": "<complex-selector>#",
    "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
    "contextual-alt-values": "[contextual|no-contextual]",
    "content-distribution": "space-between|space-around|space-evenly|stretch",
    "content-list": "[<string>|contents|<url>|<quote>|<attr()>|counter( <ident> , <'list-style-type'>? )]+",
    "content-position": "center|start|end|flex-start|flex-end",
    "content-replacement": "<image>",
    "contrast()": "contrast( [<number-percentage>] )",
    "counter()": "counter( <custom-ident> , [<counter-style>|none]? )",
    "counter-style": "<counter-style-name>|symbols( )",
    "counter-style-name": "<custom-ident>",
    "counters()": "counters( <custom-ident> , <string> , [<counter-style>|none]? )",
    "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
    "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number> , <number> , <number> , <number> )",
    "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText",
    "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]",
    "display-box": "contents|none",
    "display-inside": "flow|flow-root|table|flex|grid|ruby",
    "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container",
    "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid",
    "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item",
    "display-outside": "block|inline|run-in",
    "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
    "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]",
    "east-asian-width-values": "[full-width|proportional-width]",
    "element()": "element( <id-selector> )",
    "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )",
    "ending-shape": "circle|ellipse",
    "env()": "env( <custom-ident> , <declaration-value>? )",
    "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?",
    "family-name": "<string>|<custom-ident>+",
    "feature-tag-value": "<string> [<integer>|on|off]?",
    "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation",
    "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'",
    "feature-value-block-list": "<feature-value-block>+",
    "feature-value-declaration": "<custom-ident> : <integer>+ ;",
    "feature-value-declaration-list": "<feature-value-declaration>",
    "feature-value-name": "<custom-ident>",
    "fill-rule": "nonzero|evenodd",
    "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>",
    "filter-function-list": "[<filter-function>|<url>]+",
    "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
    "fit-content()": "fit-content( [<length>|<percentage>] )",
    "fixed-breadth": "<length-percentage>",
    "fixed-repeat": "repeat( [<positive-integer>] , [<line-names>? <fixed-size>]+ <line-names>? )",
    "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )",
    "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>",
    "font-variant-css21": "[normal|small-caps]",
    "font-weight-absolute": "normal|bold|<number>",
    "frequency-percentage": "<frequency>|<percentage>",
    "general-enclosed": "[<function-token> <any-value> )]|( <ident> <any-value> )",
    "generic-family": "serif|sans-serif|cursive|fantasy|monospace|-apple-system",
    "generic-name": "serif|sans-serif|cursive|fantasy|monospace",
    "geometry-box": "<shape-box>|fill-box|stroke-box|view-box",
    "gradient": "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<-legacy-gradient>",
    "grayscale()": "grayscale( <number-percentage> )",
    "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]",
    "historical-lig-values": "[historical-ligatures|no-historical-ligatures]",
    "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
    "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
    "hue": "<number>|<angle>",
    "hue-rotate()": "hue-rotate( <angle> )",
    "image": "<url>|<image()>|<image-set()>|<element()>|<cross-fade()>|<gradient>",
    "image()": "image( <image-tags>? [<image-src>? , <color>?]! )",
    "image-set()": "image-set( <image-set-option># )",
    "image-set-option": "[<image>|<string>] <resolution>",
    "image-src": "<url>|<string>",
    "image-tags": "ltr|rtl",
    "inflexible-breadth": "<length>|<percentage>|min-content|max-content|auto",
    "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )",
    "invert()": "invert( <number-percentage> )",
    "keyframes-name": "<custom-ident>|<string>",
    "keyframe-block": "<keyframe-selector># { <declaration-list> }",
    "keyframe-block-list": "<keyframe-block>+",
    "keyframe-selector": "from|to|<percentage>",
    "leader()": "leader( <leader-type> )",
    "leader-type": "dotted|solid|space|<string>",
    "length-percentage": "<length>|<percentage>",
    "line-names": "'[' <custom-ident>* ']'",
    "line-name-list": "[<line-names>|<name-repeat>]+",
    "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset",
    "line-width": "<length>|thin|medium|thick",
    "linear-color-hint": "<length-percentage>",
    "linear-color-stop": "<color> <color-stop-length>?",
    "linear-gradient()": "linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
    "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>",
    "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?",
    "mask-reference": "none|<image>|<mask-source>",
    "mask-source": "<url>",
    "masking-mode": "alpha|luminance|match-source",
    "matrix()": "matrix( <number>#{6} )",
    "matrix3d()": "matrix3d( <number>#{16} )",
    "max()": "max( <calc-sum># )",
    "media-and": "<media-in-parens> [and <media-in-parens>]+",
    "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>",
    "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>",
    "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )",
    "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>",
    "media-not": "not <media-in-parens>",
    "media-or": "<media-in-parens> [or <media-in-parens>]+",
    "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?",
    "media-query-list": "<media-query>#",
    "media-type": "<ident>",
    "mf-boolean": "<mf-name>",
    "mf-name": "<ident>",
    "mf-plain": "<mf-name> : <mf-value>",
    "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
    "mf-value": "<number>|<dimension>|<ident>|<ratio>",
    "min()": "min( <calc-sum># )",
    "minmax()": "minmax( [<length>|<percentage>|<flex>|min-content|max-content|auto] , [<length>|<percentage>|<flex>|min-content|max-content|auto] )",
    "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen|<-non-standard-color>",
    "namespace-prefix": "<ident>",
    "ns-prefix": "[<ident-token>|'*']? '|'",
    "number-percentage": "<number>|<percentage>",
    "numeric-figure-values": "[lining-nums|oldstyle-nums]",
    "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]",
    "numeric-spacing-values": "[proportional-nums|tabular-nums]",
    "nth": "<an-plus-b>|even|odd",
    "opacity()": "opacity( [<number-percentage>] )",
    "overflow-position": "unsafe|safe",
    "outline-radius": "<length>|<percentage>",
    "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>",
    "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'",
    "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom",
    "page-selector-list": "[<page-selector>#]?",
    "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*",
    "perspective()": "perspective( <length> )",
    "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )",
    "position": "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]",
    "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'",
    "pseudo-element-selector": "':' <pseudo-class-selector>",
    "pseudo-page": ": [left|right|first|blank]",
    "quote": "open-quote|close-quote|no-open-quote|no-close-quote",
    "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
    "relative-selector": "<combinator>? <complex-selector>",
    "relative-selector-list": "<relative-selector>#",
    "relative-size": "larger|smaller",
    "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}",
    "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
    "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
    "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )",
    "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )",
    "rotate()": "rotate( [<angle>|<zero>] )",
    "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )",
    "rotateX()": "rotateX( [<angle>|<zero>] )",
    "rotateY()": "rotateY( [<angle>|<zero>] )",
    "rotateZ()": "rotateZ( [<angle>|<zero>] )",
    "saturate()": "saturate( <number-percentage> )",
    "scale()": "scale( <number> , <number>? )",
    "scale3d()": "scale3d( <number> , <number> , <number> )",
    "scaleX()": "scaleX( <number> )",
    "scaleY()": "scaleY( <number> )",
    "scaleZ()": "scaleZ( <number> )",
    "self-position": "center|start|end|self-start|self-end|flex-start|flex-end",
    "shape-radius": "<length-percentage>|closest-side|farthest-side",
    "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )",
    "skewX()": "skewX( [<angle>|<zero>] )",
    "skewY()": "skewY( [<angle>|<zero>] )",
    "sepia()": "sepia( <number-percentage> )",
    "shadow": "inset?&&<length>{2,4}&&<color>?",
    "shadow-t": "[<length>{2,3}&&<color>?]",
    "shape": "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )",
    "shape-box": "<box>|margin-box",
    "side-or-corner": "[left|right]||[top|bottom]",
    "single-animation": "<time>||<timing-function>||<time>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]",
    "single-animation-direction": "normal|reverse|alternate|alternate-reverse",
    "single-animation-fill-mode": "none|forwards|backwards|both",
    "single-animation-iteration-count": "infinite|<number>",
    "single-animation-play-state": "running|paused",
    "single-transition": "[none|<single-transition-property>]||<time>||<timing-function>||<time>",
    "single-transition-property": "all|<custom-ident>",
    "size": "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}",
    "step-position": "jump-start|jump-end|jump-none|jump-both|start|end",
    "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )",
    "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>",
    "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*",
    "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>",
    "supports-feature": "<supports-decl>|<supports-selector-fn>",
    "supports-decl": "( <declaration> )",
    "supports-selector-fn": "selector( <complex-selector> )",
    "symbol": "<string>|<image>|<custom-ident>",
    "target": "<target-counter()>|<target-counters()>|<target-text()>",
    "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )",
    "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )",
    "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )",
    "time-percentage": "<time>|<percentage>",
    "timing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>",
    "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto",
    "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?",
    "track-repeat": "repeat( [<positive-integer>] , [<line-names>? <track-size>]+ <line-names>? )",
    "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( [<length>|<percentage>] )",
    "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>",
    "transform-list": "<transform-function>+",
    "translate()": "translate( <length-percentage> , <length-percentage>? )",
    "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
    "translateX()": "translateX( <length-percentage> )",
    "translateY()": "translateY( <length-percentage> )",
    "translateZ()": "translateZ( <length> )",
    "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%",
    "type-selector": "<wq-name>|<ns-prefix>? '*'",
    "var()": "var( <custom-property-name> , <declaration-value>? )",
    "viewport-length": "auto|<length-percentage>",
    "wq-name": "<ns-prefix>? <ident-token>",
    "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>",
    "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )",
    "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
    "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>",
    "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )",
    "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
    "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>",
    "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover",
    "-legacy-radial-gradient-shape": "circle|ellipse",
    "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body",
    "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text",
    "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast",
    "-non-standard-overflow": "-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable",
    "-non-standard-width": "min-intrinsic|intrinsic|-moz-min-content|-moz-max-content|-webkit-min-content|-webkit-max-content",
    "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
    "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )",
    "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]",
    "-webkit-gradient-radius": "<length>|<percentage>",
    "-webkit-gradient-type": "linear|radial",
    "-webkit-mask-box-repeat": "repeat|stretch|round",
    "-webkit-mask-clip-style": "border|border-box|padding|padding-box|content|content-box|text",
    "-ms-filter-function-list": "<-ms-filter-function>+",
    "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>",
    "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]",
    "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )",
    "-ms-filter": "<string>",
    "age": "child|young|old",
    "attr-name": "<wq-name>",
    "attr-fallback": "<any-value>",
    "border-radius": "<length-percentage>{1,2}",
    "bottom": "<length>|auto",
    "generic-voice": "[<age>? <gender> <integer>?]",
    "gender": "male|female|neutral",
    "left": "<length>|auto",
    "mask-image": "<mask-reference>#",
    "name-repeat": "repeat( [<positive-integer>|auto-fill] , <line-names>+ )",
    "paint": "none|<color>|<url> [none|<color>]?|context-fill|context-stroke",
    "path()": "path( <string> )",
    "ratio": "<integer> / <integer>",
    "right": "<length>|auto",
    "svg-length": "<percentage>|<length>|<number>",
    "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb",
    "top": "<length>|auto",
    "x": "<number>",
    "y": "<number>",
    "declaration": "<ident-token> : <declaration-value>? ['!' important]?",
    "declaration-list": "[<declaration>? ';']* <declaration>?",
    "url": "url( <string> <url-modifier>* )|<url-token>",
    "url-modifier": "<ident>|<function-token> <any-value> )",
    "number-zero-one": "<number [0,1]>",
    "number-one-or-greater": "<number [1,∞]>",
    "positive-integer": "<integer [0,∞]>"
  },
  "properties": {
    "--*": "<declaration-value>",
    "-ms-accelerator": "false|true",
    "-ms-block-progression": "tb|rl|bt|lr",
    "-ms-content-zoom-chaining": "none|chained",
    "-ms-content-zooming": "none|zoom",
    "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
    "-ms-content-zoom-limit-max": "<percentage>",
    "-ms-content-zoom-limit-min": "<percentage>",
    "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>",
    "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )",
    "-ms-content-zoom-snap-type": "none|proximity|mandatory",
    "-ms-filter": "<string>",
    "-ms-flow-from": "[none|<custom-ident>]#",
    "-ms-flow-into": "[none|<custom-ident>]#",
    "-ms-high-contrast-adjust": "auto|none",
    "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}",
    "-ms-hyphenate-limit-lines": "no-limit|<integer>",
    "-ms-hyphenate-limit-zone": "<percentage>|<length>",
    "-ms-ime-align": "auto|after",
    "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar",
    "-ms-scrollbar-3dlight-color": "<color>",
    "-ms-scrollbar-arrow-color": "<color>",
    "-ms-scrollbar-base-color": "<color>",
    "-ms-scrollbar-darkshadow-color": "<color>",
    "-ms-scrollbar-face-color": "<color>",
    "-ms-scrollbar-highlight-color": "<color>",
    "-ms-scrollbar-shadow-color": "<color>",
    "-ms-scrollbar-track-color": "<color>",
    "-ms-scroll-chaining": "chained|none",
    "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
    "-ms-scroll-limit-x-max": "auto|<length>",
    "-ms-scroll-limit-x-min": "<length>",
    "-ms-scroll-limit-y-max": "auto|<length>",
    "-ms-scroll-limit-y-min": "<length>",
    "-ms-scroll-rails": "none|railed",
    "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
    "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
    "-ms-scroll-snap-type": "none|proximity|mandatory",
    "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
    "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
    "-ms-scroll-translation": "none|vertical-to-horizontal",
    "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space",
    "-ms-touch-select": "grippers|none",
    "-ms-user-select": "none|element|text",
    "-ms-wrap-flow": "auto|both|start|end|maximum|clear",
    "-ms-wrap-margin": "<length>",
    "-ms-wrap-through": "wrap|none",
    "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized",
    "-moz-binding": "<url>|none",
    "-moz-border-bottom-colors": "<color>+|none",
    "-moz-border-left-colors": "<color>+|none",
    "-moz-border-right-colors": "<color>+|none",
    "-moz-border-top-colors": "<color>+|none",
    "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#",
    "-moz-float-edge": "border-box|content-box|margin-box|padding-box",
    "-moz-force-broken-image-icon": "<integer>",
    "-moz-image-region": "<shape>|auto",
    "-moz-orient": "inline|block|horizontal|vertical",
    "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?",
    "-moz-outline-radius-bottomleft": "<outline-radius>",
    "-moz-outline-radius-bottomright": "<outline-radius>",
    "-moz-outline-radius-topleft": "<outline-radius>",
    "-moz-outline-radius-topright": "<outline-radius>",
    "-moz-stack-sizing": "ignore|stretch-to-fit",
    "-moz-text-blink": "none|blink",
    "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none",
    "-moz-user-input": "auto|none|enabled|disabled",
    "-moz-user-modify": "read-only|read-write|write-only",
    "-moz-window-dragging": "drag|no-drag",
    "-moz-window-shadow": "default|menu|tooltip|sheet|none",
    "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|listbox|listitem|media-fullscreen-button|media-mute-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield",
    "-webkit-border-before": "<'border-width'>||<'border-style'>||<'color'>",
    "-webkit-border-before-color": "<'color'>",
    "-webkit-border-before-style": "<'border-style'>",
    "-webkit-border-before-width": "<'border-width'>",
    "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?",
    "-webkit-line-clamp": "none|<integer>",
    "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#",
    "-webkit-mask-attachment": "<attachment>#",
    "-webkit-mask-clip": "[<box>|border|padding|content|text]#",
    "-webkit-mask-composite": "<composite-style>#",
    "-webkit-mask-image": "<mask-reference>#",
    "-webkit-mask-origin": "[<box>|border|padding|content]#",
    "-webkit-mask-position": "<position>#",
    "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#",
    "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#",
    "-webkit-mask-repeat": "<repeat-style>#",
    "-webkit-mask-repeat-x": "repeat|no-repeat|space|round",
    "-webkit-mask-repeat-y": "repeat|no-repeat|space|round",
    "-webkit-mask-size": "<bg-size>#",
    "-webkit-overflow-scrolling": "auto|touch",
    "-webkit-tap-highlight-color": "<color>",
    "-webkit-text-fill-color": "<color>",
    "-webkit-text-stroke": "<length>||<color>",
    "-webkit-text-stroke-color": "<color>",
    "-webkit-text-stroke-width": "<length>",
    "-webkit-touch-callout": "default|none",
    "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only",
    "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>",
    "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]",
    "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>",
    "all": "initial|inherit|unset|revert",
    "animation": "<single-animation>#",
    "animation-delay": "<time>#",
    "animation-direction": "<single-animation-direction>#",
    "animation-duration": "<time>#",
    "animation-fill-mode": "<single-animation-fill-mode>#",
    "animation-iteration-count": "<single-animation-iteration-count>#",
    "animation-name": "[none|<keyframes-name>]#",
    "animation-play-state": "<single-animation-play-state>#",
    "animation-timing-function": "<timing-function>#",
    "appearance": "none|auto|button|textfield|<compat>",
    "azimuth": "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards",
    "backdrop-filter": "none|<filter-function-list>",
    "backface-visibility": "visible|hidden",
    "background": "[<bg-layer> ,]* <final-bg-layer>",
    "background-attachment": "<attachment>#",
    "background-blend-mode": "<blend-mode>#",
    "background-clip": "<box>#",
    "background-color": "<color>",
    "background-image": "<bg-image>#",
    "background-origin": "<box>#",
    "background-position": "<bg-position>#",
    "background-position-x": "[center|[left|right|x-start|x-end]? <length-percentage>?]#",
    "background-position-y": "[center|[top|bottom|y-start|y-end]? <length-percentage>?]#",
    "background-repeat": "<repeat-style>#",
    "background-size": "<bg-size>#",
    "block-overflow": "clip|ellipsis|<string>",
    "block-size": "<'width'>",
    "border": "<line-width>||<line-style>||<color>",
    "border-block": "<'border-top-width'>||<'border-top-style'>||<'color'>",
    "border-block-color": "<'border-top-color'>{1,2}",
    "border-block-style": "<'border-top-style'>",
    "border-block-width": "<'border-top-width'>",
    "border-block-end": "<'border-top-width'>||<'border-top-style'>||<'color'>",
    "border-block-end-color": "<'border-top-color'>",
    "border-block-end-style": "<'border-top-style'>",
    "border-block-end-width": "<'border-top-width'>",
    "border-block-start": "<'border-top-width'>||<'border-top-style'>||<'color'>",
    "border-block-start-color": "<'border-top-color'>",
    "border-block-start-style": "<'border-top-style'>",
    "border-block-start-width": "<'border-top-width'>",
    "border-bottom": "<line-width>||<line-style>||<color>",
    "border-bottom-color": "<'border-top-color'>",
    "border-bottom-left-radius": "<length-percentage>{1,2}",
    "border-bottom-right-radius": "<length-percentage>{1,2}",
    "border-bottom-style": "<line-style>",
    "border-bottom-width": "<line-width>",
    "border-collapse": "collapse|separate",
    "border-color": "<color>{1,4}",
    "border-end-end-radius": "<length-percentage>{1,2}",
    "border-end-start-radius": "<length-percentage>{1,2}",
    "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>",
    "border-image-outset": "[<length>|<number>]{1,4}",
    "border-image-repeat": "[stretch|repeat|round|space]{1,2}",
    "border-image-slice": "<number-percentage>{1,4}&&fill?",
    "border-image-source": "none|<image>",
    "border-image-width": "[<length-percentage>|<number>|auto]{1,4}",
    "border-inline": "<'border-top-width'>||<'border-top-style'>||<'color'>",
    "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<'color'>",
    "border-inline-color": "<'border-top-color'>{1,2}",
    "border-inline-style": "<'border-top-style'>",
    "border-inline-width": "<'border-top-width'>",
    "border-inline-end-color": "<'border-top-color'>",
    "border-inline-end-style": "<'border-top-style'>",
    "border-inline-end-width": "<'border-top-width'>",
    "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<'color'>",
    "border-inline-start-color": "<'border-top-color'>",
    "border-inline-start-style": "<'border-top-style'>",
    "border-inline-start-width": "<'border-top-width'>",
    "border-left": "<line-width>||<line-style>||<color>",
    "border-left-color": "<color>",
    "border-left-style": "<line-style>",
    "border-left-width": "<line-width>",
    "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?",
    "border-right": "<line-width>||<line-style>||<color>",
    "border-right-color": "<color>",
    "border-right-style": "<line-style>",
    "border-right-width": "<line-width>",
    "border-spacing": "<length> <length>?",
    "border-start-end-radius": "<length-percentage>{1,2}",
    "border-start-start-radius": "<length-percentage>{1,2}",
    "border-style": "<line-style>{1,4}",
    "border-top": "<line-width>||<line-style>||<color>",
    "border-top-color": "<color>",
    "border-top-left-radius": "<length-percentage>{1,2}",
    "border-top-right-radius": "<length-percentage>{1,2}",
    "border-top-style": "<line-style>",
    "border-top-width": "<line-width>",
    "border-width": "<line-width>{1,4}",
    "bottom": "<length>|<percentage>|auto",
    "box-align": "start|center|end|baseline|stretch",
    "box-decoration-break": "slice|clone",
    "box-direction": "normal|reverse|inherit",
    "box-flex": "<number>",
    "box-flex-group": "<integer>",
    "box-lines": "single|multiple",
    "box-ordinal-group": "<integer>",
    "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit",
    "box-pack": "start|center|end|justify",
    "box-shadow": "none|<shadow>#",
    "box-sizing": "content-box|border-box",
    "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
    "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
    "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region",
    "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end",
    "caret-color": "auto|<color>",
    "clear": "none|left|right|both|inline-start|inline-end",
    "clip": "<shape>|auto",
    "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none",
    "color": "<color>",
    "color-adjust": "economy|exact",
    "column-count": "<integer>|auto",
    "column-fill": "auto|balance|balance-all",
    "column-gap": "normal|<length-percentage>",
    "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>",
    "column-rule-color": "<color>",
    "column-rule-style": "<'border-style'>",
    "column-rule-width": "<'border-width'>",
    "column-span": "none|all",
    "column-width": "<length>|auto",
    "columns": "<'column-width'>||<'column-count'>",
    "contain": "none|strict|content|[size||layout||style||paint]",
    "content": "normal|none|[<content-replacement>|<content-list>] [/ <string>]?",
    "counter-increment": "[<custom-ident> <integer>?]+|none",
    "counter-reset": "[<custom-ident> <integer>?]+|none",
    "counter-set": "[<custom-ident> <integer>?]+|none",
    "cursor": "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]",
    "direction": "ltr|rtl",
    "display": "none|inline|block|list-item|inline-list-item|inline-block|inline-table|table|table-cell|table-column|table-column-group|table-footer-group|table-header-group|table-row|table-row-group|flex|inline-flex|grid|inline-grid|run-in|ruby|ruby-base|ruby-text|ruby-base-container|ruby-text-container|contents|-ms-flexbox|-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box",
    "empty-cells": "show|hide",
    "filter": "none|<filter-function-list>|<-ms-filter-function-list>",
    "flex": "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]",
    "flex-basis": "content|<'width'>",
    "flex-direction": "row|row-reverse|column|column-reverse",
    "flex-flow": "<'flex-direction'>||<'flex-wrap'>",
    "flex-grow": "<number>",
    "flex-shrink": "<number>",
    "flex-wrap": "nowrap|wrap|wrap-reverse",
    "float": "left|right|none|inline-start|inline-end",
    "font": "[[<'font-style'>||<font-variant-css21>||<'font-weight'>||<'font-stretch'>]? <'font-size'> [/ <'line-height'>]? <'font-family'>]|caption|icon|menu|message-box|small-caption|status-bar",
    "font-family": "[<family-name>|<generic-family>]#",
    "font-feature-settings": "normal|<feature-tag-value>#",
    "font-kerning": "auto|normal|none",
    "font-language-override": "normal|<string>",
    "font-optical-sizing": "auto|none",
    "font-variation-settings": "normal|[<string> <number>]#",
    "font-size": "<absolute-size>|<relative-size>|<length-percentage>",
    "font-size-adjust": "none|<number>",
    "font-stretch": "<font-stretch-absolute>",
    "font-style": "normal|italic|oblique <angle>?",
    "font-synthesis": "none|[weight||style]",
    "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
    "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]",
    "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps",
    "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]",
    "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]",
    "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]",
    "font-variant-position": "normal|sub|super",
    "font-weight": "<font-weight-absolute>|bolder|lighter",
    "gap": "<'row-gap'> <'column-gap'>?",
    "grid": "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>",
    "grid-area": "<grid-line> [/ <grid-line>]{0,3}",
    "grid-auto-columns": "<track-size>+",
    "grid-auto-flow": "[row|column]||dense",
    "grid-auto-rows": "<track-size>+",
    "grid-column": "<grid-line> [/ <grid-line>]?",
    "grid-column-end": "<grid-line>",
    "grid-column-gap": "<length-percentage>",
    "grid-column-start": "<grid-line>",
    "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
    "grid-row": "<grid-line> [/ <grid-line>]?",
    "grid-row-end": "<grid-line>",
    "grid-row-gap": "<length-percentage>",
    "grid-row-start": "<grid-line>",
    "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?",
    "grid-template-areas": "none|<string>+",
    "grid-template-columns": "none|<track-list>|<auto-track-list>",
    "grid-template-rows": "none|<track-list>|<auto-track-list>",
    "hanging-punctuation": "none|[first||[force-end|allow-end]||last]",
    "height": "[<length>|<percentage>]&&[border-box|content-box]?|available|min-content|max-content|fit-content|auto",
    "hyphens": "none|manual|auto",
    "image-orientation": "from-image|<angle>|[<angle>? flip]",
    "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>",
    "image-resolution": "[from-image||<resolution>]&&snap?",
    "ime-mode": "auto|normal|active|inactive|disabled",
    "initial-letter": "normal|[<number> <integer>?]",
    "initial-letter-align": "[auto|alphabetic|hanging|ideographic]",
    "inline-size": "<'width'>",
    "inset": "<'top'>{1,4}",
    "inset-block": "<'top'>{1,2}",
    "inset-block-end": "<'top'>",
    "inset-block-start": "<'top'>",
    "inset-inline": "<'top'>{1,2}",
    "inset-inline-end": "<'top'>",
    "inset-inline-start": "<'top'>",
    "isolation": "auto|isolate",
    "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]",
    "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]",
    "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]",
    "left": "<length>|<percentage>|auto",
    "letter-spacing": "normal|<length-percentage>",
    "line-break": "auto|loose|normal|strict",
    "line-clamp": "none|<integer>",
    "line-height": "normal|<number>|<length>|<percentage>",
    "line-height-step": "<length>",
    "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>",
    "list-style-image": "<url>|none",
    "list-style-position": "inside|outside",
    "list-style-type": "<counter-style>|<string>|none",
    "margin": "[<length>|<percentage>|auto]{1,4}",
    "margin-block": "<'margin-left'>{1,2}",
    "margin-block-end": "<'margin-left'>",
    "margin-block-start": "<'margin-left'>",
    "margin-bottom": "<length>|<percentage>|auto",
    "margin-inline": "<'margin-left'>{1,2}",
    "margin-inline-end": "<'margin-left'>",
    "margin-inline-start": "<'margin-left'>",
    "margin-left": "<length>|<percentage>|auto",
    "margin-right": "<length>|<percentage>|auto",
    "margin-top": "<length>|<percentage>|auto",
    "mask": "<mask-layer>#",
    "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>",
    "mask-border-mode": "luminance|alpha",
    "mask-border-outset": "[<length>|<number>]{1,4}",
    "mask-border-repeat": "[stretch|repeat|round|space]{1,2}",
    "mask-border-slice": "<number-percentage>{1,4} fill?",
    "mask-border-source": "none|<image>",
    "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}",
    "mask-clip": "[<geometry-box>|no-clip]#",
    "mask-composite": "<compositing-operator>#",
    "mask-image": "<mask-reference>#",
    "mask-mode": "<masking-mode>#",
    "mask-origin": "<geometry-box>#",
    "mask-position": "<position>#",
    "mask-repeat": "<repeat-style>#",
    "mask-size": "<bg-size>#",
    "mask-type": "luminance|alpha",
    "max-block-size": "<'max-width'>",
    "max-height": "<length>|<percentage>|none|max-content|min-content|fit-content|fill-available",
    "max-inline-size": "<'max-width'>",
    "max-lines": "none|<integer>",
    "max-width": "<length>|<percentage>|none|max-content|min-content|fit-content|fill-available|<-non-standard-width>",
    "min-block-size": "<'min-width'>",
    "min-height": "<length>|<percentage>|auto|max-content|min-content|fit-content|fill-available",
    "min-inline-size": "<'min-width'>",
    "min-width": "<length>|<percentage>|auto|max-content|min-content|fit-content|fill-available|<-non-standard-width>",
    "mix-blend-mode": "<blend-mode>",
    "object-fit": "fill|contain|cover|none|scale-down",
    "object-position": "<position>",
    "offset": "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?",
    "offset-anchor": "auto|<position>",
    "offset-distance": "<length-percentage>",
    "offset-path": "none|ray( [<angle>&&<size>?&&contain?] )|<path()>|<url>|[<basic-shape>||<geometry-box>]",
    "offset-position": "auto|<position>",
    "offset-rotate": "[auto|reverse]||<angle>",
    "opacity": "<number-zero-one>",
    "order": "<integer>",
    "orphans": "<integer>",
    "outline": "[<'outline-color'>||<'outline-style'>||<'outline-width'>]",
    "outline-color": "<color>|invert",
    "outline-offset": "<length>",
    "outline-style": "auto|<'border-style'>",
    "outline-width": "<line-width>",
    "overflow": "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>",
    "overflow-anchor": "auto|none",
    "overflow-block": "visible|hidden|clip|scroll|auto",
    "overflow-clip-box": "padding-box|content-box",
    "overflow-inline": "visible|hidden|clip|scroll|auto",
    "overflow-wrap": "normal|break-word|anywhere",
    "overflow-x": "visible|hidden|clip|scroll|auto",
    "overflow-y": "visible|hidden|clip|scroll|auto",
    "overscroll-behavior": "[contain|none|auto]{1,2}",
    "overscroll-behavior-x": "contain|none|auto",
    "overscroll-behavior-y": "contain|none|auto",
    "padding": "[<length>|<percentage>]{1,4}",
    "padding-block": "<'padding-left'>{1,2}",
    "padding-block-end": "<'padding-left'>",
    "padding-block-start": "<'padding-left'>",
    "padding-bottom": "<length>|<percentage>",
    "padding-inline": "<'padding-left'>{1,2}",
    "padding-inline-end": "<'padding-left'>",
    "padding-inline-start": "<'padding-left'>",
    "padding-left": "<length>|<percentage>",
    "padding-right": "<length>|<percentage>",
    "padding-top": "<length>|<percentage>",
    "page-break-after": "auto|always|avoid|left|right|recto|verso",
    "page-break-before": "auto|always|avoid|left|right|recto|verso",
    "page-break-inside": "auto|avoid",
    "paint-order": "normal|[fill||stroke||markers]",
    "perspective": "none|<length>",
    "perspective-origin": "<position>",
    "place-content": "<'align-content'> <'justify-content'>?",
    "place-items": "<'align-items'> <'justify-items'>?",
    "place-self": "<'align-self'> <'justify-self'>?",
    "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit",
    "position": "static|relative|absolute|sticky|fixed|-webkit-sticky",
    "quotes": "none|[<string> <string>]+",
    "resize": "none|both|horizontal|vertical|block|inline",
    "right": "<length>|<percentage>|auto",
    "rotate": "none|<angle>|[x|y|z|<number>{3}]&&<angle>",
    "row-gap": "normal|<length-percentage>",
    "ruby-align": "start|center|space-between|space-around",
    "ruby-merge": "separate|collapse|auto",
    "ruby-position": "over|under|inter-character",
    "scale": "none|<number>{1,3}",
    "scrollbar-color": "auto|dark|light|<color>{2}",
    "scrollbar-width": "auto|thin|none",
    "scroll-behavior": "auto|smooth",
    "scroll-margin": "<length>{1,4}",
    "scroll-margin-block": "<length>{1,2}",
    "scroll-margin-block-start": "<length>",
    "scroll-margin-block-end": "<length>",
    "scroll-margin-bottom": "<length>",
    "scroll-margin-inline": "<length>{1,2}",
    "scroll-margin-inline-start": "<length>",
    "scroll-margin-inline-end": "<length>",
    "scroll-margin-left": "<length>",
    "scroll-margin-right": "<length>",
    "scroll-margin-top": "<length>",
    "scroll-padding": "[auto|<length-percentage>]{1,4}",
    "scroll-padding-block": "[auto|<length-percentage>]{1,2}",
    "scroll-padding-block-start": "auto|<length-percentage>",
    "scroll-padding-block-end": "auto|<length-percentage>",
    "scroll-padding-bottom": "auto|<length-percentage>",
    "scroll-padding-inline": "[auto|<length-percentage>]{1,2}",
    "scroll-padding-inline-start": "auto|<length-percentage>",
    "scroll-padding-inline-end": "auto|<length-percentage>",
    "scroll-padding-left": "auto|<length-percentage>",
    "scroll-padding-right": "auto|<length-percentage>",
    "scroll-padding-top": "auto|<length-percentage>",
    "scroll-snap-align": "[none|start|end|center]{1,2}",
    "scroll-snap-coordinate": "none|<position>#",
    "scroll-snap-destination": "<position>",
    "scroll-snap-points-x": "none|repeat( <length-percentage> )",
    "scroll-snap-points-y": "none|repeat( <length-percentage> )",
    "scroll-snap-stop": "normal|always",
    "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?",
    "scroll-snap-type-x": "none|mandatory|proximity",
    "scroll-snap-type-y": "none|mandatory|proximity",
    "shape-image-threshold": "<number>",
    "shape-margin": "<length-percentage>",
    "shape-outside": "none|<shape-box>||<basic-shape>|<image>",
    "tab-size": "<integer>|<length>",
    "table-layout": "auto|fixed",
    "text-align": "start|end|left|right|center|justify|match-parent",
    "text-align-last": "auto|start|end|left|right|center|justify",
    "text-combine-upright": "none|all|[digits <integer>?]",
    "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>",
    "text-decoration-color": "<color>",
    "text-decoration-line": "none|[underline||overline||line-through||blink]",
    "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]",
    "text-decoration-skip-ink": "auto|none",
    "text-decoration-style": "solid|double|dotted|dashed|wavy",
    "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>",
    "text-emphasis-color": "<color>",
    "text-emphasis-position": "[over|under]&&[right|left]",
    "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>",
    "text-indent": "<length-percentage>&&hanging?&&each-line?",
    "text-justify": "auto|inter-character|inter-word|none",
    "text-orientation": "mixed|upright|sideways",
    "text-overflow": "[clip|ellipsis|<string>]{1,2}",
    "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision",
    "text-shadow": "none|<shadow-t>#",
    "text-size-adjust": "none|auto|<percentage>",
    "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana",
    "text-underline-position": "auto|[under||[left|right]]",
    "top": "<length>|<percentage>|auto",
    "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation",
    "transform": "none|<transform-list>",
    "transform-box": "border-box|fill-box|view-box",
    "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?",
    "transform-style": "flat|preserve-3d",
    "transition": "<single-transition>#",
    "transition-delay": "<time>#",
    "transition-duration": "<time>#",
    "transition-property": "none|<single-transition-property>#",
    "transition-timing-function": "<timing-function>#",
    "translate": "none|<length-percentage> [<length-percentage> <length>?]?",
    "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate",
    "user-select": "auto|text|none|contain|all",
    "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>",
    "visibility": "visible|hidden|collapse",
    "white-space": "normal|pre|nowrap|pre-wrap|pre-line",
    "widows": "<integer>",
    "width": "[<length>|<percentage>]&&[border-box|content-box]?|available|min-content|max-content|fit-content|auto",
    "will-change": "auto|<animateable-feature>#",
    "word-break": "normal|break-all|keep-all|break-word",
    "word-spacing": "normal|<length-percentage>",
    "word-wrap": "normal|break-word",
    "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>",
    "z-index": "auto|<integer>",
    "zoom": "normal|reset|<number>|<percentage>",
    "-moz-background-clip": "padding|border",
    "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
    "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
    "-moz-border-radius-topleft": "<'border-top-left-radius'>",
    "-moz-border-radius-topright": "<'border-bottom-right-radius'>",
    "-moz-osx-font-smoothing": "auto|grayscale",
    "-moz-user-select": "none|text|all|-moz-none",
    "-ms-flex-align": "start|end|center|baseline|stretch",
    "-ms-flex-item-align": "auto|start|end|center|baseline|stretch",
    "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch",
    "-ms-flex-negative": "<'flex-shrink'>",
    "-ms-flex-pack": "start|end|center|justify|distribute",
    "-ms-flex-order": "<integer>",
    "-ms-flex-positive": "<'flex-grow'>",
    "-ms-flex-preferred-size": "<'flex-basis'>",
    "-ms-interpolation-mode": "nearest-neighbor|bicubic",
    "-ms-grid-column-align": "start|end|center|stretch",
    "-ms-grid-row-align": "start|end|center|stretch",
    "-webkit-background-clip": "[<box>|border|padding|content|text]#",
    "-webkit-column-break-after": "always|auto|avoid",
    "-webkit-column-break-before": "always|auto|avoid",
    "-webkit-column-break-inside": "always|auto|avoid",
    "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased",
    "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?",
    "-webkit-print-color-adjust": "economy|exact",
    "-webkit-text-security": "none|circle|disc|square",
    "-webkit-user-drag": "none|element|auto",
    "-webkit-user-select": "auto|none|text|all",
    "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical",
    "baseline-shift": "baseline|sub|super|<svg-length>",
    "behavior": "<url>+",
    "clip-rule": "nonzero|evenodd",
    "cue": "<'cue-before'> <'cue-after'>?",
    "cue-after": "<url> <decibel>?|none",
    "cue-before": "<url> <decibel>?|none",
    "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge",
    "fill": "<paint>",
    "fill-opacity": "<number-zero-one>",
    "fill-rule": "nonzero|evenodd",
    "glyph-orientation-horizontal": "<angle>",
    "glyph-orientation-vertical": "<angle>",
    "kerning": "auto|<svg-length>",
    "marker": "none|<url>",
    "marker-end": "none|<url>",
    "marker-mid": "none|<url>",
    "marker-start": "none|<url>",
    "pause": "<'pause-before'> <'pause-after'>?",
    "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "rest": "<'rest-before'> <'rest-after'>?",
    "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision",
    "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
    "speak": "auto|none|normal",
    "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]",
    "stroke": "<paint>",
    "stroke-dasharray": "none|[<svg-length>+]#",
    "stroke-dashoffset": "<svg-length>",
    "stroke-linecap": "butt|round|square",
    "stroke-linejoin": "miter|round|bevel",
    "stroke-miterlimit": "<number-one-or-greater>",
    "stroke-opacity": "<number-zero-one>",
    "stroke-width": "<svg-length>",
    "text-anchor": "start|middle|end",
    "unicode-range": "<urange>#",
    "voice-balance": "<number>|left|center|right|leftwards|rightwards",
    "voice-duration": "auto|<time>",
    "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve",
    "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
    "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
    "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>",
    "voice-stress": "normal|strong|moderate|none|reduced",
    "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]"
  }
};
},{}],"node_modules/css-tree/lib/syntax/node/AnPlusB.js":[function(require,module,exports) {
var cmpChar = require('../../tokenizer').cmpChar;

var isDigit = require('../../tokenizer').isDigit;

var TYPE = require('../../tokenizer').TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var PLUSSIGN = 0x002B; // U+002B PLUS SIGN (+)

var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)

var N = 0x006E; // U+006E LATIN SMALL LETTER N (n)

var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;

function checkInteger(offset, disallowSign) {
  var pos = this.scanner.tokenStart + offset;
  var code = this.scanner.source.charCodeAt(pos);

  if (code === PLUSSIGN || code === HYPHENMINUS) {
    if (disallowSign) {
      this.error('Number sign is not allowed');
    }

    pos++;
  }

  for (; pos < this.scanner.tokenEnd; pos++) {
    if (!isDigit(this.scanner.source.charCodeAt(pos))) {
      this.error('Integer is expected', pos);
    }
  }
}

function checkTokenIsInteger(disallowSign) {
  return checkInteger.call(this, 0, disallowSign);
}

function expectCharCode(offset, code) {
  if (!cmpChar(this.scanner.source, this.scanner.tokenStart + offset, code)) {
    var msg = '';

    switch (code) {
      case N:
        msg = 'N is expected';
        break;

      case HYPHENMINUS:
        msg = 'HyphenMinus is expected';
        break;
    }

    this.error(msg, this.scanner.tokenStart + offset);
  }
} // ... <signed-integer>
// ... ['+' | '-'] <signless-integer>


function consumeB() {
  var offset = 0;
  var sign = 0;
  var type = this.scanner.tokenType;

  while (type === WHITESPACE || type === COMMENT) {
    type = this.scanner.lookupType(++offset);
  }

  if (type !== NUMBER) {
    if (this.scanner.isDelim(PLUSSIGN, offset) || this.scanner.isDelim(HYPHENMINUS, offset)) {
      sign = this.scanner.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;

      do {
        type = this.scanner.lookupType(++offset);
      } while (type === WHITESPACE || type === COMMENT);

      if (type !== NUMBER) {
        this.scanner.skip(offset);
        checkTokenIsInteger.call(this, DISALLOW_SIGN);
      }
    } else {
      return null;
    }
  }

  if (offset > 0) {
    this.scanner.skip(offset);
  }

  if (sign === 0) {
    type = this.scanner.source.charCodeAt(this.scanner.tokenStart);

    if (type !== PLUSSIGN && type !== HYPHENMINUS) {
      this.error('Number sign is expected');
    }
  }

  checkTokenIsInteger.call(this, sign !== 0);
  return sign === HYPHENMINUS ? '-' + this.consume(NUMBER) : this.consume(NUMBER);
} // An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb


module.exports = {
  name: 'AnPlusB',
  structure: {
    a: [String, null],
    b: [String, null]
  },
  parse: function parse() {
    /* eslint-disable brace-style*/
    var start = this.scanner.tokenStart;
    var a = null;
    var b = null; // <integer>

    if (this.scanner.tokenType === NUMBER) {
      checkTokenIsInteger.call(this, ALLOW_SIGN);
      b = this.consume(NUMBER);
    } // -n
    // -n <signed-integer>
    // -n ['+' | '-'] <signless-integer>
    // -n- <signless-integer>
    // <dashndashdigit-ident>
    else if (this.scanner.tokenType === IDENT && cmpChar(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS)) {
        a = '-1';
        expectCharCode.call(this, 1, N);

        switch (this.scanner.getTokenLength()) {
          // -n
          // -n <signed-integer>
          // -n ['+' | '-'] <signless-integer>
          case 2:
            this.scanner.next();
            b = consumeB.call(this);
            break;
          // -n- <signless-integer>

          case 3:
            expectCharCode.call(this, 2, HYPHENMINUS);
            this.scanner.next();
            this.scanner.skipSC();
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
            b = '-' + this.consume(NUMBER);
            break;
          // <dashndashdigit-ident>

          default:
            expectCharCode.call(this, 2, HYPHENMINUS);
            checkInteger.call(this, 3, DISALLOW_SIGN);
            this.scanner.next();
            b = this.scanner.substrToCursor(start + 2);
        }
      } // '+'? n
      // '+'? n <signed-integer>
      // '+'? n ['+' | '-'] <signless-integer>
      // '+'? n- <signless-integer>
      // '+'? <ndashdigit-ident>
      else if (this.scanner.tokenType === IDENT || this.scanner.isDelim(PLUSSIGN) && this.scanner.lookupType(1) === IDENT) {
          var sign = 0;
          a = '1'; // just ignore a plus

          if (this.scanner.isDelim(PLUSSIGN)) {
            sign = 1;
            this.scanner.next();
          }

          expectCharCode.call(this, 0, N);

          switch (this.scanner.getTokenLength()) {
            // '+'? n
            // '+'? n <signed-integer>
            // '+'? n ['+' | '-'] <signless-integer>
            case 1:
              this.scanner.next();
              b = consumeB.call(this);
              break;
            // '+'? n- <signless-integer>

            case 2:
              expectCharCode.call(this, 1, HYPHENMINUS);
              this.scanner.next();
              this.scanner.skipSC();
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
              b = '-' + this.consume(NUMBER);
              break;
            // '+'? <ndashdigit-ident>

            default:
              expectCharCode.call(this, 1, HYPHENMINUS);
              checkInteger.call(this, 2, DISALLOW_SIGN);
              this.scanner.next();
              b = this.scanner.substrToCursor(start + sign + 1);
          }
        } // <ndashdigit-dimension>
        // <ndash-dimension> <signless-integer>
        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        else if (this.scanner.tokenType === DIMENSION) {
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
            var sign = code === PLUSSIGN || code === HYPHENMINUS;

            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
              if (!isDigit(this.scanner.source.charCodeAt(i))) {
                break;
              }
            }

            if (i === this.scanner.tokenStart + sign) {
              this.error('Integer is expected', this.scanner.tokenStart + sign);
            }

            expectCharCode.call(this, i - this.scanner.tokenStart, N);
            a = this.scanner.source.substring(start, i); // <n-dimension>
            // <n-dimension> <signed-integer>
            // <n-dimension> ['+' | '-'] <signless-integer>

            if (i + 1 === this.scanner.tokenEnd) {
              this.scanner.next();
              b = consumeB.call(this);
            } else {
              expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS); // <ndash-dimension> <signless-integer>

              if (i + 2 === this.scanner.tokenEnd) {
                this.scanner.next();
                this.scanner.skipSC();
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
                b = '-' + this.consume(NUMBER);
              } // <ndashdigit-dimension>
              else {
                  checkInteger.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN);
                  this.scanner.next();
                  b = this.scanner.substrToCursor(i + 1);
                }
            }
          } else {
            this.error();
          }

    if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
      a = a.substr(1);
    }

    if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
      b = b.substr(1);
    }

    return {
      type: 'AnPlusB',
      loc: this.getLocation(start, this.scanner.tokenStart),
      a: a,
      b: b
    };
  },
  generate: function generate(node) {
    var a = node.a !== null && node.a !== undefined;
    var b = node.b !== null && node.b !== undefined;

    if (a) {
      this.chunk(node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
      node.a === '1' ? 'n' : // eslint-disable-line operator-linebreak, indent
      node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
      node.a + 'n' // eslint-disable-line operator-linebreak, indent
      );

      if (b) {
        b = String(node.b);

        if (b.charAt(0) === '-' || b.charAt(0) === '+') {
          this.chunk(b.charAt(0));
          this.chunk(b.substr(1));
        } else {
          this.chunk('+');
          this.chunk(b);
        }
      }
    } else {
      this.chunk(String(node.b));
    }
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Raw.js":[function(require,module,exports) {
var tokenizer = require('../../tokenizer');

var TYPE = tokenizer.TYPE;
var WhiteSpace = TYPE.WhiteSpace;
var Semicolon = TYPE.Semicolon;
var LeftCurlyBracket = TYPE.LeftCurlyBracket;
var Delim = TYPE.Delim;
var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

function getOffsetExcludeWS() {
  if (this.scanner.tokenIndex > 0) {
    if (this.scanner.lookupType(-1) === WhiteSpace) {
      return this.scanner.tokenIndex > 1 ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1) : this.scanner.firstCharOffset;
    }
  }

  return this.scanner.tokenStart;
} // 0, 0, false


function balanceEnd() {
  return 0;
} // LEFTCURLYBRACKET, 0, false


function leftCurlyBracket(tokenType) {
  return tokenType === LeftCurlyBracket ? 1 : 0;
} // LEFTCURLYBRACKET, SEMICOLON, false


function leftCurlyBracketOrSemicolon(tokenType) {
  return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
} // EXCLAMATIONMARK, SEMICOLON, false


function exclamationMarkOrSemicolon(tokenType, source, offset) {
  if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK) {
    return 1;
  }

  return tokenType === Semicolon ? 1 : 0;
} // 0, SEMICOLON, true


function semicolonIncluded(tokenType) {
  return tokenType === Semicolon ? 2 : 0;
}

module.exports = {
  name: 'Raw',
  structure: {
    value: String
  },
  parse: function parse(startToken, mode, excludeWhiteSpace) {
    var startOffset = this.scanner.getTokenStart(startToken);
    var endOffset;
    this.scanner.skip(this.scanner.getRawLength(startToken, mode || balanceEnd));

    if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
      endOffset = getOffsetExcludeWS.call(this);
    } else {
      endOffset = this.scanner.tokenStart;
    }

    return {
      type: 'Raw',
      loc: this.getLocation(startOffset, endOffset),
      value: this.scanner.source.substring(startOffset, endOffset)
    };
  },
  generate: function generate(node) {
    this.chunk(node.value);
  },
  mode: {
    default: balanceEnd,
    leftCurlyBracket: leftCurlyBracket,
    leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
    exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
    semicolonIncluded: semicolonIncluded
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Atrule.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var rawMode = require('./Raw').mode;

var ATKEYWORD = TYPE.AtKeyword;
var SEMICOLON = TYPE.Semicolon;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

function consumeRaw(startToken) {
  return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
}

function isDeclarationBlockAtrule() {
  for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
    if (type === RIGHTCURLYBRACKET) {
      return true;
    }

    if (type === LEFTCURLYBRACKET || type === ATKEYWORD) {
      return false;
    }
  }

  return false;
}

module.exports = {
  name: 'Atrule',
  structure: {
    name: String,
    prelude: ['AtrulePrelude', 'Raw', null],
    block: ['Block', null]
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    var name;
    var nameLowerCase;
    var prelude = null;
    var block = null;
    this.eat(ATKEYWORD);
    name = this.scanner.substrToCursor(start + 1);
    nameLowerCase = name.toLowerCase();
    this.scanner.skipSC(); // parse prelude

    if (this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET && this.scanner.tokenType !== SEMICOLON) {
      if (this.parseAtrulePrelude) {
        prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw); // turn empty AtrulePrelude into null

        if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
          prelude = null;
        }
      } else {
        prelude = consumeRaw.call(this, this.scanner.tokenIndex);
      }

      this.scanner.skipSC();
    }

    switch (this.scanner.tokenType) {
      case SEMICOLON:
        this.scanner.next();
        break;

      case LEFTCURLYBRACKET:
        if (this.atrule.hasOwnProperty(nameLowerCase) && typeof this.atrule[nameLowerCase].block === 'function') {
          block = this.atrule[nameLowerCase].block.call(this);
        } else {
          // TODO: should consume block content as Raw?
          block = this.Block(isDeclarationBlockAtrule.call(this));
        }

        break;
    }

    return {
      type: 'Atrule',
      loc: this.getLocation(start, this.scanner.tokenStart),
      name: name,
      prelude: prelude,
      block: block
    };
  },
  generate: function generate(node) {
    this.chunk('@');
    this.chunk(node.name);

    if (node.prelude !== null) {
      this.chunk(' ');
      this.node(node.prelude);
    }

    if (node.block) {
      this.node(node.block);
    } else {
      this.chunk(';');
    }
  },
  walkContext: 'atrule'
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js","./Raw":"node_modules/css-tree/lib/syntax/node/Raw.js"}],"node_modules/css-tree/lib/syntax/node/AtrulePrelude.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var SEMICOLON = TYPE.Semicolon;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
module.exports = {
  name: 'AtrulePrelude',
  structure: {
    children: [[]]
  },
  parse: function parse(name) {
    var children = null;

    if (name !== null) {
      name = name.toLowerCase();
    }

    this.scanner.skipSC();

    if (this.atrule.hasOwnProperty(name) && typeof this.atrule[name].prelude === 'function') {
      // custom consumer
      children = this.atrule[name].prelude.call(this);
    } else {
      // default consumer
      children = this.readSequence(this.scope.AtrulePrelude);
    }

    this.scanner.skipSC();

    if (this.scanner.eof !== true && this.scanner.tokenType !== LEFTCURLYBRACKET && this.scanner.tokenType !== SEMICOLON) {
      this.error('Semicolon or block is expected');
    }

    if (children === null) {
      children = this.createList();
    }

    return {
      type: 'AtrulePrelude',
      loc: this.getLocationFromList(children),
      children: children
    };
  },
  generate: function generate(node) {
    this.children(node);
  },
  walkContext: 'atrulePrelude'
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/AttributeSelector.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var IDENT = TYPE.Ident;
var STRING = TYPE.String;
var COLON = TYPE.Colon;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
var DOLLARSIGN = 0x0024; // U+0024 DOLLAR SIGN ($)

var ASTERISK = 0x002A; // U+002A ASTERISK (*)

var EQUALSSIGN = 0x003D; // U+003D EQUALS SIGN (=)

var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)

var VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)

var TILDE = 0x007E; // U+007E TILDE (~)

function getAttributeName() {
  if (this.scanner.eof) {
    this.error('Unexpected end of input');
  }

  var start = this.scanner.tokenStart;
  var expectIdent = false;
  var checkColon = true;

  if (this.scanner.isDelim(ASTERISK)) {
    expectIdent = true;
    checkColon = false;
    this.scanner.next();
  } else if (!this.scanner.isDelim(VERTICALLINE)) {
    this.eat(IDENT);
  }

  if (this.scanner.isDelim(VERTICALLINE)) {
    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
      this.scanner.next();
      this.eat(IDENT);
    } else if (expectIdent) {
      this.error('Identifier is expected', this.scanner.tokenEnd);
    }
  } else if (expectIdent) {
    this.error('Vertical line is expected');
  }

  if (checkColon && this.scanner.tokenType === COLON) {
    this.scanner.next();
    this.eat(IDENT);
  }

  return {
    type: 'Identifier',
    loc: this.getLocation(start, this.scanner.tokenStart),
    name: this.scanner.substrToCursor(start)
  };
}

function getOperator() {
  var start = this.scanner.tokenStart;
  var code = this.scanner.source.charCodeAt(start);

  if (code !== EQUALSSIGN && // =
  code !== TILDE && // ~=
  code !== CIRCUMFLEXACCENT && // ^=
  code !== DOLLARSIGN && // $=
  code !== ASTERISK && // *=
  code !== VERTICALLINE // |=
  ) {
      this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
    }

  this.scanner.next();

  if (code !== EQUALSSIGN) {
    if (!this.scanner.isDelim(EQUALSSIGN)) {
      this.error('Equal sign is expected');
    }

    this.scanner.next();
  }

  return this.scanner.substrToCursor(start);
} // '[' <wq-name> ']'
// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'


module.exports = {
  name: 'AttributeSelector',
  structure: {
    name: 'Identifier',
    matcher: [String, null],
    value: ['String', 'Identifier', null],
    flags: [String, null]
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    var name;
    var matcher = null;
    var value = null;
    var flags = null;
    this.eat(LEFTSQUAREBRACKET);
    this.scanner.skipSC();
    name = getAttributeName.call(this);
    this.scanner.skipSC();

    if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
      // avoid case `[name i]`
      if (this.scanner.tokenType !== IDENT) {
        matcher = getOperator.call(this);
        this.scanner.skipSC();
        value = this.scanner.tokenType === STRING ? this.String() : this.Identifier();
        this.scanner.skipSC();
      } // attribute flags


      if (this.scanner.tokenType === IDENT) {
        flags = this.scanner.getTokenValue();
        this.scanner.next();
        this.scanner.skipSC();
      }
    }

    this.eat(RIGHTSQUAREBRACKET);
    return {
      type: 'AttributeSelector',
      loc: this.getLocation(start, this.scanner.tokenStart),
      name: name,
      matcher: matcher,
      value: value,
      flags: flags
    };
  },
  generate: function generate(node) {
    var flagsPrefix = ' ';
    this.chunk('[');
    this.node(node.name);

    if (node.matcher !== null) {
      this.chunk(node.matcher);

      if (node.value !== null) {
        this.node(node.value); // space between string and flags is not required

        if (node.value.type === 'String') {
          flagsPrefix = '';
        }
      }
    }

    if (node.flags !== null) {
      this.chunk(flagsPrefix);
      this.chunk(node.flags);
    }

    this.chunk(']');
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Block.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var rawMode = require('./Raw').mode;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var SEMICOLON = TYPE.Semicolon;
var ATKEYWORD = TYPE.AtKeyword;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

function consumeRaw(startToken) {
  return this.Raw(startToken, null, true);
}

function consumeRule() {
  return this.parseWithFallback(this.Rule, consumeRaw);
}

function consumeRawDeclaration(startToken) {
  return this.Raw(startToken, rawMode.semicolonIncluded, true);
}

function consumeDeclaration() {
  if (this.scanner.tokenType === SEMICOLON) {
    return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
  }

  var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

  if (this.scanner.tokenType === SEMICOLON) {
    this.scanner.next();
  }

  return node;
}

module.exports = {
  name: 'Block',
  structure: {
    children: [['Atrule', 'Rule', 'Declaration']]
  },
  parse: function parse(isDeclaration) {
    var consumer = isDeclaration ? consumeDeclaration : consumeRule;
    var start = this.scanner.tokenStart;
    var children = this.createList();
    this.eat(LEFTCURLYBRACKET);

    scan: while (!this.scanner.eof) {
      switch (this.scanner.tokenType) {
        case RIGHTCURLYBRACKET:
          break scan;

        case WHITESPACE:
        case COMMENT:
          this.scanner.next();
          break;

        case ATKEYWORD:
          children.push(this.parseWithFallback(this.Atrule, consumeRaw));
          break;

        default:
          children.push(consumer.call(this));
      }
    }

    if (!this.scanner.eof) {
      this.eat(RIGHTCURLYBRACKET);
    }

    return {
      type: 'Block',
      loc: this.getLocation(start, this.scanner.tokenStart),
      children: children
    };
  },
  generate: function generate(node) {
    this.chunk('{');
    this.children(node, function (prev) {
      if (prev.type === 'Declaration') {
        this.chunk(';');
      }
    });
    this.chunk('}');
  },
  walkContext: 'block'
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js","./Raw":"node_modules/css-tree/lib/syntax/node/Raw.js"}],"node_modules/css-tree/lib/syntax/node/Brackets.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
module.exports = {
  name: 'Brackets',
  structure: {
    children: [[]]
  },
  parse: function parse(readSequence, recognizer) {
    var start = this.scanner.tokenStart;
    var children = null;
    this.eat(LEFTSQUAREBRACKET);
    children = readSequence.call(this, recognizer);

    if (!this.scanner.eof) {
      this.eat(RIGHTSQUAREBRACKET);
    }

    return {
      type: 'Brackets',
      loc: this.getLocation(start, this.scanner.tokenStart),
      children: children
    };
  },
  generate: function generate(node) {
    this.chunk('[');
    this.children(node);
    this.chunk(']');
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/CDC.js":[function(require,module,exports) {
var CDC = require('../../tokenizer').TYPE.CDC;

module.exports = {
  name: 'CDC',
  structure: [],
  parse: function parse() {
    var start = this.scanner.tokenStart;
    this.eat(CDC); // -->

    return {
      type: 'CDC',
      loc: this.getLocation(start, this.scanner.tokenStart)
    };
  },
  generate: function generate() {
    this.chunk('-->');
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/CDO.js":[function(require,module,exports) {
var CDO = require('../../tokenizer').TYPE.CDO;

module.exports = {
  name: 'CDO',
  structure: [],
  parse: function parse() {
    var start = this.scanner.tokenStart;
    this.eat(CDO); // <!--

    return {
      type: 'CDO',
      loc: this.getLocation(start, this.scanner.tokenStart)
    };
  },
  generate: function generate() {
    this.chunk('<!--');
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/ClassSelector.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var IDENT = TYPE.Ident;
var FULLSTOP = 0x002E; // U+002E FULL STOP (.)
// '.' ident

module.exports = {
  name: 'ClassSelector',
  structure: {
    name: String
  },
  parse: function parse() {
    if (!this.scanner.isDelim(FULLSTOP)) {
      this.error('Full stop is expected');
    }

    this.scanner.next();
    return {
      type: 'ClassSelector',
      loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
      name: this.consume(IDENT)
    };
  },
  generate: function generate(node) {
    this.chunk('.');
    this.chunk(node.name);
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Combinator.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var IDENT = TYPE.Ident;
var PLUSSIGN = 0x002B; // U+002B PLUS SIGN (+)

var SOLIDUS = 0x002F; // U+002F SOLIDUS (/)

var GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)

var TILDE = 0x007E; // U+007E TILDE (~)
// + | > | ~ | /deep/

module.exports = {
  name: 'Combinator',
  structure: {
    name: String
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

    switch (code) {
      case GREATERTHANSIGN:
      case PLUSSIGN:
      case TILDE:
        this.scanner.next();
        break;

      case SOLIDUS:
        this.scanner.next();

        if (this.scanner.tokenType !== IDENT || this.scanner.lookupValue(0, 'deep') === false) {
          this.error('Identifier `deep` is expected');
        }

        this.scanner.next();

        if (!this.scanner.isDelim(SOLIDUS)) {
          this.error('Solidus is expected');
        }

        this.scanner.next();
        break;

      default:
        this.error('Combinator is expected');
    }

    return {
      type: 'Combinator',
      loc: this.getLocation(start, this.scanner.tokenStart),
      name: this.scanner.substrToCursor(start)
    };
  },
  generate: function generate(node) {
    this.chunk(node.name);
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Comment.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var COMMENT = TYPE.Comment;
var ASTERISK = 0x002A; // U+002A ASTERISK (*)

var SOLIDUS = 0x002F; // U+002F SOLIDUS (/)
// '/*' .* '*/'

module.exports = {
  name: 'Comment',
  structure: {
    value: String
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    var end = this.scanner.tokenEnd;
    this.eat(COMMENT);

    if (end - start + 2 >= 2 && this.scanner.source.charCodeAt(end - 2) === ASTERISK && this.scanner.source.charCodeAt(end - 1) === SOLIDUS) {
      end -= 2;
    }

    return {
      type: 'Comment',
      loc: this.getLocation(start, this.scanner.tokenStart),
      value: this.scanner.source.substring(start + 2, end)
    };
  },
  generate: function generate(node) {
    this.chunk('/*');
    this.chunk(node.value);
    this.chunk('*/');
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Declaration.js":[function(require,module,exports) {
var isCustomProperty = require('../../utils/names').isCustomProperty;

var TYPE = require('../../tokenizer').TYPE;

var rawMode = require('./Raw').mode;

var IDENT = TYPE.Ident;
var HASH = TYPE.Hash;
var COLON = TYPE.Colon;
var SEMICOLON = TYPE.Semicolon;
var DELIM = TYPE.Delim;
var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

var NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)

var DOLLARSIGN = 0x0024; // U+0024 DOLLAR SIGN ($)

var AMPERSAND = 0x0026; // U+0026 ANPERSAND (&)

var ASTERISK = 0x002A; // U+002A ASTERISK (*)

var PLUSSIGN = 0x002B; // U+002B PLUS SIGN (+)

var SOLIDUS = 0x002F; // U+002F SOLIDUS (/)

function consumeValueRaw(startToken) {
  return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, true);
}

function consumeCustomPropertyRaw(startToken) {
  return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, false);
}

function consumeValue() {
  var startValueToken = this.scanner.tokenIndex;
  var value = this.Value();

  if (value.type !== 'Raw' && this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON && this.scanner.isDelim(EXCLAMATIONMARK) === false && this.scanner.isBalanceEdge(startValueToken) === false) {
    this.error();
  }

  return value;
}

module.exports = {
  name: 'Declaration',
  structure: {
    important: [Boolean, String],
    property: String,
    value: ['Value', 'Raw']
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    var startToken = this.scanner.tokenIndex;
    var property = readProperty.call(this);
    var customProperty = isCustomProperty(property);
    var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
    var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
    var important = false;
    var value;
    this.scanner.skipSC();
    this.eat(COLON);

    if (!customProperty) {
      this.scanner.skipSC();
    }

    if (parseValue) {
      value = this.parseWithFallback(consumeValue, consumeRaw);
    } else {
      value = consumeRaw.call(this, this.scanner.tokenIndex);
    }

    if (this.scanner.isDelim(EXCLAMATIONMARK)) {
      important = getImportant.call(this);
      this.scanner.skipSC();
    } // Do not include semicolon to range per spec
    // https://drafts.csswg.org/css-syntax/#declaration-diagram


    if (this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON && this.scanner.isBalanceEdge(startToken) === false) {
      this.error();
    }

    return {
      type: 'Declaration',
      loc: this.getLocation(start, this.scanner.tokenStart),
      important: important,
      property: property,
      value: value
    };
  },
  generate: function generate(node) {
    this.chunk(node.property);
    this.chunk(':');
    this.node(node.value);

    if (node.important) {
      this.chunk(node.important === true ? '!important' : '!' + node.important);
    }
  },
  walkContext: 'declaration'
};

function readProperty() {
  var start = this.scanner.tokenStart;
  var prefix = 0; // hacks

  if (this.scanner.tokenType === DELIM) {
    switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
      case ASTERISK:
      case DOLLARSIGN:
      case PLUSSIGN:
      case NUMBERSIGN:
      case AMPERSAND:
        this.scanner.next();
        break;
      // TODO: not sure we should support this hack

      case SOLIDUS:
        this.scanner.next();

        if (this.scanner.isDelim(SOLIDUS)) {
          this.scanner.next();
        }

        break;
    }
  }

  if (prefix) {
    this.scanner.skip(prefix);
  }

  if (this.scanner.tokenType === HASH) {
    this.eat(HASH);
  } else {
    this.eat(IDENT);
  }

  return this.scanner.substrToCursor(start);
} // ! ws* important


function getImportant() {
  this.eat(DELIM);
  this.scanner.skipSC();
  var important = this.consume(IDENT); // store original value in case it differ from `important`
  // for better original source restoring and hacks like `!ie` support

  return important === 'important' ? true : important;
}
},{"../../utils/names":"node_modules/css-tree/lib/utils/names.js","../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js","./Raw":"node_modules/css-tree/lib/syntax/node/Raw.js"}],"node_modules/css-tree/lib/syntax/node/DeclarationList.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var rawMode = require('./Raw').mode;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var SEMICOLON = TYPE.Semicolon;

function consumeRaw(startToken) {
  return this.Raw(startToken, rawMode.semicolonIncluded, true);
}

module.exports = {
  name: 'DeclarationList',
  structure: {
    children: [['Declaration']]
  },
  parse: function parse() {
    var children = this.createList();

    scan: while (!this.scanner.eof) {
      switch (this.scanner.tokenType) {
        case WHITESPACE:
        case COMMENT:
        case SEMICOLON:
          this.scanner.next();
          break;

        default:
          children.push(this.parseWithFallback(this.Declaration, consumeRaw));
      }
    }

    return {
      type: 'DeclarationList',
      loc: this.getLocationFromList(children),
      children: children
    };
  },
  generate: function generate(node) {
    this.children(node, function (prev) {
      if (prev.type === 'Declaration') {
        this.chunk(';');
      }
    });
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js","./Raw":"node_modules/css-tree/lib/syntax/node/Raw.js"}],"node_modules/css-tree/lib/syntax/node/Dimension.js":[function(require,module,exports) {
var consumeNumber = require('../../tokenizer/utils').consumeNumber;

var TYPE = require('../../tokenizer').TYPE;

var DIMENSION = TYPE.Dimension;
module.exports = {
  name: 'Dimension',
  structure: {
    value: String,
    unit: String
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    var numberEnd = consumeNumber(this.scanner.source, start);
    this.eat(DIMENSION);
    return {
      type: 'Dimension',
      loc: this.getLocation(start, this.scanner.tokenStart),
      value: this.scanner.source.substring(start, numberEnd),
      unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
    };
  },
  generate: function generate(node) {
    this.chunk(node.value);
    this.chunk(node.unit);
  }
};
},{"../../tokenizer/utils":"node_modules/css-tree/lib/tokenizer/utils.js","../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Function.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var RIGHTPARENTHESIS = TYPE.RightParenthesis; // <function-token> <sequence> )

module.exports = {
  name: 'Function',
  structure: {
    name: String,
    children: [[]]
  },
  parse: function parse(readSequence, recognizer) {
    var start = this.scanner.tokenStart;
    var name = this.consumeFunctionName();
    var nameLowerCase = name.toLowerCase();
    var children;
    children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence.call(this, recognizer);

    if (!this.scanner.eof) {
      this.eat(RIGHTPARENTHESIS);
    }

    return {
      type: 'Function',
      loc: this.getLocation(start, this.scanner.tokenStart),
      name: name,
      children: children
    };
  },
  generate: function generate(node) {
    this.chunk(node.name);
    this.chunk('(');
    this.children(node);
    this.chunk(')');
  },
  walkContext: 'function'
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/HexColor.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var HASH = TYPE.Hash; // '#' ident

module.exports = {
  name: 'HexColor',
  structure: {
    value: String
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    this.eat(HASH);
    return {
      type: 'HexColor',
      loc: this.getLocation(start, this.scanner.tokenStart),
      value: this.scanner.substrToCursor(start + 1)
    };
  },
  generate: function generate(node) {
    this.chunk('#');
    this.chunk(node.value);
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Identifier.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var IDENT = TYPE.Ident;
module.exports = {
  name: 'Identifier',
  structure: {
    name: String
  },
  parse: function parse() {
    return {
      type: 'Identifier',
      loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
      name: this.consume(IDENT)
    };
  },
  generate: function generate(node) {
    this.chunk(node.name);
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/IdSelector.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var HASH = TYPE.Hash; // <hash-token>

module.exports = {
  name: 'IdSelector',
  structure: {
    name: String
  },
  parse: function parse() {
    var start = this.scanner.tokenStart; // TODO: check value is an ident

    this.eat(HASH);
    return {
      type: 'IdSelector',
      loc: this.getLocation(start, this.scanner.tokenStart),
      name: this.scanner.substrToCursor(start + 1)
    };
  },
  generate: function generate(node) {
    this.chunk('#');
    this.chunk(node.name);
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/MediaFeature.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var IDENT = TYPE.Ident;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;
var COLON = TYPE.Colon;
var DELIM = TYPE.Delim;
module.exports = {
  name: 'MediaFeature',
  structure: {
    name: String,
    value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    var name;
    var value = null;
    this.eat(LEFTPARENTHESIS);
    this.scanner.skipSC();
    name = this.consume(IDENT);
    this.scanner.skipSC();

    if (this.scanner.tokenType !== RIGHTPARENTHESIS) {
      this.eat(COLON);
      this.scanner.skipSC();

      switch (this.scanner.tokenType) {
        case NUMBER:
          if (this.lookupNonWSType(1) === DELIM) {
            value = this.Ratio();
          } else {
            value = this.Number();
          }

          break;

        case DIMENSION:
          value = this.Dimension();
          break;

        case IDENT:
          value = this.Identifier();
          break;

        default:
          this.error('Number, dimension, ratio or identifier is expected');
      }

      this.scanner.skipSC();
    }

    this.eat(RIGHTPARENTHESIS);
    return {
      type: 'MediaFeature',
      loc: this.getLocation(start, this.scanner.tokenStart),
      name: name,
      value: value
    };
  },
  generate: function generate(node) {
    this.chunk('(');
    this.chunk(node.name);

    if (node.value !== null) {
      this.chunk(':');
      this.node(node.value);
    }

    this.chunk(')');
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/MediaQuery.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
module.exports = {
  name: 'MediaQuery',
  structure: {
    children: [['Identifier', 'MediaFeature', 'WhiteSpace']]
  },
  parse: function parse() {
    this.scanner.skipSC();
    var children = this.createList();
    var child = null;
    var space = null;

    scan: while (!this.scanner.eof) {
      switch (this.scanner.tokenType) {
        case COMMENT:
          this.scanner.next();
          continue;

        case WHITESPACE:
          space = this.WhiteSpace();
          continue;

        case IDENT:
          child = this.Identifier();
          break;

        case LEFTPARENTHESIS:
          child = this.MediaFeature();
          break;

        default:
          break scan;
      }

      if (space !== null) {
        children.push(space);
        space = null;
      }

      children.push(child);
    }

    if (child === null) {
      this.error('Identifier or parenthesis is expected');
    }

    return {
      type: 'MediaQuery',
      loc: this.getLocationFromList(children),
      children: children
    };
  },
  generate: function generate(node) {
    this.children(node);
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/MediaQueryList.js":[function(require,module,exports) {
var COMMA = require('../../tokenizer').TYPE.Comma;

module.exports = {
  name: 'MediaQueryList',
  structure: {
    children: [['MediaQuery']]
  },
  parse: function parse(relative) {
    var children = this.createList();
    this.scanner.skipSC();

    while (!this.scanner.eof) {
      children.push(this.MediaQuery(relative));

      if (this.scanner.tokenType !== COMMA) {
        break;
      }

      this.scanner.next();
    }

    return {
      type: 'MediaQueryList',
      loc: this.getLocationFromList(children),
      children: children
    };
  },
  generate: function generate(node) {
    this.children(node, function () {
      this.chunk(',');
    });
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Nth.js":[function(require,module,exports) {
module.exports = {
  name: 'Nth',
  structure: {
    nth: ['AnPlusB', 'Identifier'],
    selector: ['SelectorList', null]
  },
  parse: function parse(allowOfClause) {
    this.scanner.skipSC();
    var start = this.scanner.tokenStart;
    var end = start;
    var selector = null;
    var query;

    if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
      query = this.Identifier();
    } else {
      query = this.AnPlusB();
    }

    this.scanner.skipSC();

    if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
      this.scanner.next();
      selector = this.SelectorList();

      if (this.needPositions) {
        end = this.getLastListNode(selector.children).loc.end.offset;
      }
    } else {
      if (this.needPositions) {
        end = query.loc.end.offset;
      }
    }

    return {
      type: 'Nth',
      loc: this.getLocation(start, end),
      nth: query,
      selector: selector
    };
  },
  generate: function generate(node) {
    this.node(node.nth);

    if (node.selector !== null) {
      this.chunk(' of ');
      this.node(node.selector);
    }
  }
};
},{}],"node_modules/css-tree/lib/syntax/node/Number.js":[function(require,module,exports) {
var NUMBER = require('../../tokenizer').TYPE.Number;

module.exports = {
  name: 'Number',
  structure: {
    value: String
  },
  parse: function parse() {
    return {
      type: 'Number',
      loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
      value: this.consume(NUMBER)
    };
  },
  generate: function generate(node) {
    this.chunk(node.value);
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Operator.js":[function(require,module,exports) {
// '/' | '*' | ',' | ':' | '+' | '-'
module.exports = {
  name: 'Operator',
  structure: {
    value: String
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    this.scanner.next();
    return {
      type: 'Operator',
      loc: this.getLocation(start, this.scanner.tokenStart),
      value: this.scanner.substrToCursor(start)
    };
  },
  generate: function generate(node) {
    this.chunk(node.value);
  }
};
},{}],"node_modules/css-tree/lib/syntax/node/Parentheses.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;
module.exports = {
  name: 'Parentheses',
  structure: {
    children: [[]]
  },
  parse: function parse(readSequence, recognizer) {
    var start = this.scanner.tokenStart;
    var children = null;
    this.eat(LEFTPARENTHESIS);
    children = readSequence.call(this, recognizer);

    if (!this.scanner.eof) {
      this.eat(RIGHTPARENTHESIS);
    }

    return {
      type: 'Parentheses',
      loc: this.getLocation(start, this.scanner.tokenStart),
      children: children
    };
  },
  generate: function generate(node) {
    this.chunk('(');
    this.children(node);
    this.chunk(')');
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Percentage.js":[function(require,module,exports) {
var consumeNumber = require('../../tokenizer/utils').consumeNumber;

var TYPE = require('../../tokenizer').TYPE;

var PERCENTAGE = TYPE.Percentage;
module.exports = {
  name: 'Percentage',
  structure: {
    value: String
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    var numberEnd = consumeNumber(this.scanner.source, start);
    this.eat(PERCENTAGE);
    return {
      type: 'Percentage',
      loc: this.getLocation(start, this.scanner.tokenStart),
      value: this.scanner.source.substring(start, numberEnd)
    };
  },
  generate: function generate(node) {
    this.chunk(node.value);
    this.chunk('%');
  }
};
},{"../../tokenizer/utils":"node_modules/css-tree/lib/tokenizer/utils.js","../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var IDENT = TYPE.Ident;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var RIGHTPARENTHESIS = TYPE.RightParenthesis; // : [ <ident> | <function-token> <any-value>? ) ]

module.exports = {
  name: 'PseudoClassSelector',
  structure: {
    name: String,
    children: [['Raw'], null]
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    var children = null;
    var name;
    var nameLowerCase;
    this.eat(COLON);

    if (this.scanner.tokenType === FUNCTION) {
      name = this.consumeFunctionName();
      nameLowerCase = name.toLowerCase();

      if (this.pseudo.hasOwnProperty(nameLowerCase)) {
        this.scanner.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.scanner.skipSC();
      } else {
        children = this.createList();
        children.push(this.Raw(this.scanner.tokenIndex, null, false));
      }

      this.eat(RIGHTPARENTHESIS);
    } else {
      name = this.consume(IDENT);
    }

    return {
      type: 'PseudoClassSelector',
      loc: this.getLocation(start, this.scanner.tokenStart),
      name: name,
      children: children
    };
  },
  generate: function generate(node) {
    this.chunk(':');
    this.chunk(node.name);

    if (node.children !== null) {
      this.chunk('(');
      this.children(node);
      this.chunk(')');
    }
  },
  walkContext: 'function'
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var IDENT = TYPE.Ident;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var RIGHTPARENTHESIS = TYPE.RightParenthesis; // :: [ <ident> | <function-token> <any-value>? ) ]

module.exports = {
  name: 'PseudoElementSelector',
  structure: {
    name: String,
    children: [['Raw'], null]
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    var children = null;
    var name;
    var nameLowerCase;
    this.eat(COLON);
    this.eat(COLON);

    if (this.scanner.tokenType === FUNCTION) {
      name = this.consumeFunctionName();
      nameLowerCase = name.toLowerCase();

      if (this.pseudo.hasOwnProperty(nameLowerCase)) {
        this.scanner.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.scanner.skipSC();
      } else {
        children = this.createList();
        children.push(this.Raw(this.scanner.tokenIndex, null, false));
      }

      this.eat(RIGHTPARENTHESIS);
    } else {
      name = this.consume(IDENT);
    }

    return {
      type: 'PseudoElementSelector',
      loc: this.getLocation(start, this.scanner.tokenStart),
      name: name,
      children: children
    };
  },
  generate: function generate(node) {
    this.chunk('::');
    this.chunk(node.name);

    if (node.children !== null) {
      this.chunk('(');
      this.children(node);
      this.chunk(')');
    }
  },
  walkContext: 'function'
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Ratio.js":[function(require,module,exports) {
var isDigit = require('../../tokenizer').isDigit;

var TYPE = require('../../tokenizer').TYPE;

var NUMBER = TYPE.Number;
var DELIM = TYPE.Delim;
var SOLIDUS = 0x002F; // U+002F SOLIDUS (/)

var FULLSTOP = 0x002E; // U+002E FULL STOP (.)
// Terms of <ratio> should be a positive numbers (not zero or negative)
// (see https://drafts.csswg.org/mediaqueries-3/#values)
// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
// and this is using by various sites. Therefore we relax checking on parse
// to test a term is unsigned number without an exponent part.
// Additional checking may be applied on lexer validation.

function consumeNumber() {
  this.scanner.skipWS();
  var value = this.consume(NUMBER);

  for (var i = 0; i < value.length; i++) {
    var code = value.charCodeAt(i);

    if (!isDigit(code) && code !== FULLSTOP) {
      this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
    }
  }

  if (Number(value) === 0) {
    this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
  }

  return value;
} // <positive-integer> S* '/' S* <positive-integer>


module.exports = {
  name: 'Ratio',
  structure: {
    left: String,
    right: String
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    var left = consumeNumber.call(this);
    var right;
    this.scanner.skipWS();

    if (!this.scanner.isDelim(SOLIDUS)) {
      this.error('Solidus is expected');
    }

    this.eat(DELIM);
    right = consumeNumber.call(this);
    return {
      type: 'Ratio',
      loc: this.getLocation(start, this.scanner.tokenStart),
      left: left,
      right: right
    };
  },
  generate: function generate(node) {
    this.chunk(node.left);
    this.chunk('/');
    this.chunk(node.right);
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Rule.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var rawMode = require('./Raw').mode;

var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

function consumeRaw(startToken) {
  return this.Raw(startToken, rawMode.leftCurlyBracket, true);
}

function consumePrelude() {
  var prelude = this.SelectorList();

  if (prelude.type !== 'Raw' && this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET) {
    this.error();
  }

  return prelude;
}

module.exports = {
  name: 'Rule',
  structure: {
    prelude: ['SelectorList', 'Raw'],
    block: ['Block']
  },
  parse: function parse() {
    var startToken = this.scanner.tokenIndex;
    var startOffset = this.scanner.tokenStart;
    var prelude;
    var block;

    if (this.parseRulePrelude) {
      prelude = this.parseWithFallback(consumePrelude, consumeRaw);
    } else {
      prelude = consumeRaw.call(this, startToken);
    }

    block = this.Block(true);
    return {
      type: 'Rule',
      loc: this.getLocation(startOffset, this.scanner.tokenStart),
      prelude: prelude,
      block: block
    };
  },
  generate: function generate(node) {
    this.node(node.prelude);
    this.node(node.block);
  },
  walkContext: 'rule'
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js","./Raw":"node_modules/css-tree/lib/syntax/node/Raw.js"}],"node_modules/css-tree/lib/syntax/node/Selector.js":[function(require,module,exports) {
module.exports = {
  name: 'Selector',
  structure: {
    children: [['TypeSelector', 'IdSelector', 'ClassSelector', 'AttributeSelector', 'PseudoClassSelector', 'PseudoElementSelector', 'Combinator', 'WhiteSpace']]
  },
  parse: function parse() {
    var children = this.readSequence(this.scope.Selector); // nothing were consumed

    if (this.getFirstListNode(children) === null) {
      this.error('Selector is expected');
    }

    return {
      type: 'Selector',
      loc: this.getLocationFromList(children),
      children: children
    };
  },
  generate: function generate(node) {
    this.children(node);
  }
};
},{}],"node_modules/css-tree/lib/syntax/node/SelectorList.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var COMMA = TYPE.Comma;
module.exports = {
  name: 'SelectorList',
  structure: {
    children: [['Selector', 'Raw']]
  },
  parse: function parse() {
    var children = this.createList();

    while (!this.scanner.eof) {
      children.push(this.Selector());

      if (this.scanner.tokenType === COMMA) {
        this.scanner.next();
        continue;
      }

      break;
    }

    return {
      type: 'SelectorList',
      loc: this.getLocationFromList(children),
      children: children
    };
  },
  generate: function generate(node) {
    this.children(node, function () {
      this.chunk(',');
    });
  },
  walkContext: 'selector'
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/String.js":[function(require,module,exports) {
var STRING = require('../../tokenizer').TYPE.String;

module.exports = {
  name: 'String',
  structure: {
    value: String
  },
  parse: function parse() {
    return {
      type: 'String',
      loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
      value: this.consume(STRING)
    };
  },
  generate: function generate(node) {
    this.chunk(node.value);
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/StyleSheet.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var ATKEYWORD = TYPE.AtKeyword;
var CDO = TYPE.CDO;
var CDC = TYPE.CDC;
var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

function consumeRaw(startToken) {
  return this.Raw(startToken, null, false);
}

module.exports = {
  name: 'StyleSheet',
  structure: {
    children: [['Comment', 'CDO', 'CDC', 'Atrule', 'Rule', 'Raw']]
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    var children = this.createList();
    var child;

    scan: while (!this.scanner.eof) {
      switch (this.scanner.tokenType) {
        case WHITESPACE:
          this.scanner.next();
          continue;

        case COMMENT:
          // ignore comments except exclamation comments (i.e. /*! .. */) on top level
          if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK) {
            this.scanner.next();
            continue;
          }

          child = this.Comment();
          break;

        case CDO:
          // <!--
          child = this.CDO();
          break;

        case CDC:
          // -->
          child = this.CDC();
          break;
        // CSS Syntax Module Level 3
        // §2.2 Error handling
        // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.

        case ATKEYWORD:
          child = this.parseWithFallback(this.Atrule, consumeRaw);
          break;
        // Anything else starts a qualified rule ...

        default:
          child = this.parseWithFallback(this.Rule, consumeRaw);
      }

      children.push(child);
    }

    return {
      type: 'StyleSheet',
      loc: this.getLocation(start, this.scanner.tokenStart),
      children: children
    };
  },
  generate: function generate(node) {
    this.children(node);
  },
  walkContext: 'stylesheet'
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/TypeSelector.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var IDENT = TYPE.Ident;
var ASTERISK = 0x002A; // U+002A ASTERISK (*)

var VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)

function eatIdentifierOrAsterisk() {
  if (this.scanner.tokenType !== IDENT && this.scanner.isDelim(ASTERISK) === false) {
    this.error('Identifier or asterisk is expected');
  }

  this.scanner.next();
} // ident
// ident|ident
// ident|*
// *
// *|ident
// *|*
// |ident
// |*


module.exports = {
  name: 'TypeSelector',
  structure: {
    name: String
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;

    if (this.scanner.isDelim(VERTICALLINE)) {
      this.scanner.next();
      eatIdentifierOrAsterisk.call(this);
    } else {
      eatIdentifierOrAsterisk.call(this);

      if (this.scanner.isDelim(VERTICALLINE)) {
        this.scanner.next();
        eatIdentifierOrAsterisk.call(this);
      }
    }

    return {
      type: 'TypeSelector',
      loc: this.getLocation(start, this.scanner.tokenStart),
      name: this.scanner.substrToCursor(start)
    };
  },
  generate: function generate(node) {
    this.chunk(node.name);
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/UnicodeRange.js":[function(require,module,exports) {
var isHexDigit = require('../../tokenizer').isHexDigit;

var cmpChar = require('../../tokenizer').cmpChar;

var TYPE = require('../../tokenizer').TYPE;

var NAME = require('../../tokenizer').NAME;

var IDENT = TYPE.Ident;
var NUMBER = TYPE.Number;
var DIMENSION = TYPE.Dimension;
var PLUSSIGN = 0x002B; // U+002B PLUS SIGN (+)

var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)

var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)

var U = 0x0075; // U+0075 LATIN SMALL LETTER U (u)

function eatHexSequence(offset, allowDash) {
  for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
    var code = this.scanner.source.charCodeAt(pos);

    if (code === HYPHENMINUS && allowDash && len !== 0) {
      if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
        this.error();
      }

      return -1;
    }

    if (!isHexDigit(code)) {
      this.error(allowDash && len !== 0 ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected' : len < 6 ? 'Hex digit is expected' : 'Unexpected input', pos);
    }

    if (++len > 6) {
      this.error('Too many hex digits', pos);
    }

    ;
  }

  this.scanner.next();
  return len;
}

function eatQuestionMarkSequence(max) {
  var count = 0;

  while (this.scanner.isDelim(QUESTIONMARK)) {
    if (++count > max) {
      this.error('Too many question marks');
    }

    this.scanner.next();
  }
}

function startsWith(code) {
  if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
    this.error(NAME[code] + ' is expected');
  }
} // https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+


function scanUnicodeRange() {
  var hexLength = 0; // u '+' <ident-token> '?'*
  // u '+' '?'+

  if (this.scanner.isDelim(PLUSSIGN)) {
    this.scanner.next();

    if (this.scanner.tokenType === IDENT) {
      hexLength = eatHexSequence.call(this, 0, true);

      if (hexLength > 0) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
      }

      return;
    }

    if (this.scanner.isDelim(QUESTIONMARK)) {
      this.scanner.next();
      eatQuestionMarkSequence.call(this, 5);
      return;
    }

    this.error('Hex digit or question mark is expected');
    return;
  } // u <number-token> '?'*
  // u <number-token> <dimension-token>
  // u <number-token> <number-token>


  if (this.scanner.tokenType === NUMBER) {
    startsWith.call(this, PLUSSIGN);
    hexLength = eatHexSequence.call(this, 1, true);

    if (this.scanner.isDelim(QUESTIONMARK)) {
      eatQuestionMarkSequence.call(this, 6 - hexLength);
      return;
    }

    if (this.scanner.tokenType === DIMENSION || this.scanner.tokenType === NUMBER) {
      startsWith.call(this, HYPHENMINUS);
      eatHexSequence.call(this, 1, false);
      return;
    }

    return;
  } // u <dimension-token> '?'*


  if (this.scanner.tokenType === DIMENSION) {
    startsWith.call(this, PLUSSIGN);
    hexLength = eatHexSequence.call(this, 1, true);

    if (hexLength > 0) {
      eatQuestionMarkSequence.call(this, 6 - hexLength);
    }

    return;
  }

  this.error();
}

module.exports = {
  name: 'UnicodeRange',
  structure: {
    value: String
  },
  parse: function parse() {
    var start = this.scanner.tokenStart; // U or u

    if (!cmpChar(this.scanner.source, start, U)) {
      this.error('U is expected');
    }

    if (!cmpChar(this.scanner.source, start + 1, PLUSSIGN)) {
      this.error('Plus sign is expected');
    }

    this.scanner.next();
    scanUnicodeRange.call(this);
    return {
      type: 'UnicodeRange',
      loc: this.getLocation(start, this.scanner.tokenStart),
      value: this.scanner.substrToCursor(start)
    };
  },
  generate: function generate(node) {
    this.chunk(node.value);
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Url.js":[function(require,module,exports) {
var isWhiteSpace = require('../../tokenizer').isWhiteSpace;

var cmpStr = require('../../tokenizer').cmpStr;

var TYPE = require('../../tokenizer').TYPE;

var FUNCTION = TYPE.Function;
var URL = TYPE.Url;
var RIGHTPARENTHESIS = TYPE.RightParenthesis; // <url-token> | <function-token> <string> )

module.exports = {
  name: 'Url',
  structure: {
    value: ['String', 'Raw']
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    var value;

    switch (this.scanner.tokenType) {
      case URL:
        var rawStart = start + 4;
        var rawEnd = this.scanner.tokenEnd - 1;

        while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawStart))) {
          rawStart++;
        }

        while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawEnd - 1))) {
          rawEnd--;
        }

        value = {
          type: 'Raw',
          loc: this.getLocation(rawStart, rawEnd),
          value: this.scanner.source.substring(rawStart, rawEnd)
        };
        this.eat(URL);
        break;

      case FUNCTION:
        if (!cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
          this.error('Function name must be `url`');
        }

        this.eat(FUNCTION);
        this.scanner.skipSC();
        value = this.String();
        this.scanner.skipSC();
        this.eat(RIGHTPARENTHESIS);
        break;

      default:
        this.error('Url or Function is expected');
    }

    return {
      type: 'Url',
      loc: this.getLocation(start, this.scanner.tokenStart),
      value: value
    };
  },
  generate: function generate(node) {
    this.chunk('url');
    this.chunk('(');
    this.node(node.value);
    this.chunk(')');
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/Value.js":[function(require,module,exports) {
module.exports = {
  name: 'Value',
  structure: {
    children: [[]]
  },
  parse: function parse() {
    var start = this.scanner.tokenStart;
    var children = this.readSequence(this.scope.Value);
    return {
      type: 'Value',
      loc: this.getLocation(start, this.scanner.tokenStart),
      children: children
    };
  },
  generate: function generate(node) {
    this.children(node);
  }
};
},{}],"node_modules/css-tree/lib/syntax/node/WhiteSpace.js":[function(require,module,exports) {
var WHITESPACE = require('../../tokenizer').TYPE.WhiteSpace;

var SPACE = Object.freeze({
  type: 'WhiteSpace',
  loc: null,
  value: ' '
});
module.exports = {
  name: 'WhiteSpace',
  structure: {
    value: String
  },
  parse: function parse() {
    this.eat(WHITESPACE);
    return SPACE; // return {
    //     type: 'WhiteSpace',
    //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
    //     value: this.consume(WHITESPACE)
    // };
  },
  generate: function generate(node) {
    this.chunk(node.value);
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/node/index.js":[function(require,module,exports) {
module.exports = {
  AnPlusB: require('./AnPlusB'),
  Atrule: require('./Atrule'),
  AtrulePrelude: require('./AtrulePrelude'),
  AttributeSelector: require('./AttributeSelector'),
  Block: require('./Block'),
  Brackets: require('./Brackets'),
  CDC: require('./CDC'),
  CDO: require('./CDO'),
  ClassSelector: require('./ClassSelector'),
  Combinator: require('./Combinator'),
  Comment: require('./Comment'),
  Declaration: require('./Declaration'),
  DeclarationList: require('./DeclarationList'),
  Dimension: require('./Dimension'),
  Function: require('./Function'),
  HexColor: require('./HexColor'),
  Identifier: require('./Identifier'),
  IdSelector: require('./IdSelector'),
  MediaFeature: require('./MediaFeature'),
  MediaQuery: require('./MediaQuery'),
  MediaQueryList: require('./MediaQueryList'),
  Nth: require('./Nth'),
  Number: require('./Number'),
  Operator: require('./Operator'),
  Parentheses: require('./Parentheses'),
  Percentage: require('./Percentage'),
  PseudoClassSelector: require('./PseudoClassSelector'),
  PseudoElementSelector: require('./PseudoElementSelector'),
  Ratio: require('./Ratio'),
  Raw: require('./Raw'),
  Rule: require('./Rule'),
  Selector: require('./Selector'),
  SelectorList: require('./SelectorList'),
  String: require('./String'),
  StyleSheet: require('./StyleSheet'),
  TypeSelector: require('./TypeSelector'),
  UnicodeRange: require('./UnicodeRange'),
  Url: require('./Url'),
  Value: require('./Value'),
  WhiteSpace: require('./WhiteSpace')
};
},{"./AnPlusB":"node_modules/css-tree/lib/syntax/node/AnPlusB.js","./Atrule":"node_modules/css-tree/lib/syntax/node/Atrule.js","./AtrulePrelude":"node_modules/css-tree/lib/syntax/node/AtrulePrelude.js","./AttributeSelector":"node_modules/css-tree/lib/syntax/node/AttributeSelector.js","./Block":"node_modules/css-tree/lib/syntax/node/Block.js","./Brackets":"node_modules/css-tree/lib/syntax/node/Brackets.js","./CDC":"node_modules/css-tree/lib/syntax/node/CDC.js","./CDO":"node_modules/css-tree/lib/syntax/node/CDO.js","./ClassSelector":"node_modules/css-tree/lib/syntax/node/ClassSelector.js","./Combinator":"node_modules/css-tree/lib/syntax/node/Combinator.js","./Comment":"node_modules/css-tree/lib/syntax/node/Comment.js","./Declaration":"node_modules/css-tree/lib/syntax/node/Declaration.js","./DeclarationList":"node_modules/css-tree/lib/syntax/node/DeclarationList.js","./Dimension":"node_modules/css-tree/lib/syntax/node/Dimension.js","./Function":"node_modules/css-tree/lib/syntax/node/Function.js","./HexColor":"node_modules/css-tree/lib/syntax/node/HexColor.js","./Identifier":"node_modules/css-tree/lib/syntax/node/Identifier.js","./IdSelector":"node_modules/css-tree/lib/syntax/node/IdSelector.js","./MediaFeature":"node_modules/css-tree/lib/syntax/node/MediaFeature.js","./MediaQuery":"node_modules/css-tree/lib/syntax/node/MediaQuery.js","./MediaQueryList":"node_modules/css-tree/lib/syntax/node/MediaQueryList.js","./Nth":"node_modules/css-tree/lib/syntax/node/Nth.js","./Number":"node_modules/css-tree/lib/syntax/node/Number.js","./Operator":"node_modules/css-tree/lib/syntax/node/Operator.js","./Parentheses":"node_modules/css-tree/lib/syntax/node/Parentheses.js","./Percentage":"node_modules/css-tree/lib/syntax/node/Percentage.js","./PseudoClassSelector":"node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js","./PseudoElementSelector":"node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js","./Ratio":"node_modules/css-tree/lib/syntax/node/Ratio.js","./Raw":"node_modules/css-tree/lib/syntax/node/Raw.js","./Rule":"node_modules/css-tree/lib/syntax/node/Rule.js","./Selector":"node_modules/css-tree/lib/syntax/node/Selector.js","./SelectorList":"node_modules/css-tree/lib/syntax/node/SelectorList.js","./String":"node_modules/css-tree/lib/syntax/node/String.js","./StyleSheet":"node_modules/css-tree/lib/syntax/node/StyleSheet.js","./TypeSelector":"node_modules/css-tree/lib/syntax/node/TypeSelector.js","./UnicodeRange":"node_modules/css-tree/lib/syntax/node/UnicodeRange.js","./Url":"node_modules/css-tree/lib/syntax/node/Url.js","./Value":"node_modules/css-tree/lib/syntax/node/Value.js","./WhiteSpace":"node_modules/css-tree/lib/syntax/node/WhiteSpace.js"}],"node_modules/css-tree/lib/syntax/config/lexer.js":[function(require,module,exports) {
var data = require('../../../data');

module.exports = {
  generic: true,
  types: data.types,
  properties: data.properties,
  node: require('../node')
};
},{"../../../data":"node_modules/css-tree/dist/default-syntax.json","../node":"node_modules/css-tree/lib/syntax/node/index.js"}],"node_modules/css-tree/lib/syntax/scope/default.js":[function(require,module,exports) {
var cmpChar = require('../../tokenizer').cmpChar;

var cmpStr = require('../../tokenizer').cmpStr;

var TYPE = require('../../tokenizer').TYPE;

var IDENT = TYPE.Ident;
var STRING = TYPE.String;
var NUMBER = TYPE.Number;
var FUNCTION = TYPE.Function;
var URL = TYPE.Url;
var HASH = TYPE.Hash;
var DIMENSION = TYPE.Dimension;
var PERCENTAGE = TYPE.Percentage;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var COMMA = TYPE.Comma;
var DELIM = TYPE.Delim;
var NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)

var ASTERISK = 0x002A; // U+002A ASTERISK (*)

var PLUSSIGN = 0x002B; // U+002B PLUS SIGN (+)

var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)

var SOLIDUS = 0x002F; // U+002F SOLIDUS (/)

var U = 0x0075; // U+0075 LATIN SMALL LETTER U (u)

module.exports = function defaultRecognizer(context) {
  switch (this.scanner.tokenType) {
    case HASH:
      return this.HexColor();

    case COMMA:
      context.space = null;
      context.ignoreWSAfter = true;
      return this.Operator();

    case LEFTPARENTHESIS:
      return this.Parentheses(this.readSequence, context.recognizer);

    case LEFTSQUAREBRACKET:
      return this.Brackets(this.readSequence, context.recognizer);

    case STRING:
      return this.String();

    case DIMENSION:
      return this.Dimension();

    case PERCENTAGE:
      return this.Percentage();

    case NUMBER:
      return this.Number();

    case FUNCTION:
      return cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(') ? this.Url() : this.Function(this.readSequence, context.recognizer);

    case URL:
      return this.Url();

    case IDENT:
      // check for unicode range, it should start with u+ or U+
      if (cmpChar(this.scanner.source, this.scanner.tokenStart, U) && cmpChar(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN)) {
        return this.UnicodeRange();
      } else {
        return this.Identifier();
      }

    case DELIM:
      var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

      if (code === SOLIDUS || code === ASTERISK || code === PLUSSIGN || code === HYPHENMINUS) {
        return this.Operator(); // TODO: replace with Delim
      } // TODO: produce a node with Delim node type


      if (code === NUMBERSIGN) {
        this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
      }

      break;
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/scope/atrulePrelude.js":[function(require,module,exports) {
module.exports = {
  getNode: require('./default')
};
},{"./default":"node_modules/css-tree/lib/syntax/scope/default.js"}],"node_modules/css-tree/lib/syntax/scope/selector.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var DELIM = TYPE.Delim;
var IDENT = TYPE.Ident;
var DIMENSION = TYPE.Dimension;
var PERCENTAGE = TYPE.Percentage;
var NUMBER = TYPE.Number;
var HASH = TYPE.Hash;
var COLON = TYPE.Colon;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)

var ASTERISK = 0x002A; // U+002A ASTERISK (*)

var PLUSSIGN = 0x002B; // U+002B PLUS SIGN (+)

var SOLIDUS = 0x002F; // U+002F SOLIDUS (/)

var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

var GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)

var VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)

var TILDE = 0x007E; // U+007E TILDE (~)

function getNode(context) {
  switch (this.scanner.tokenType) {
    case LEFTSQUAREBRACKET:
      return this.AttributeSelector();

    case HASH:
      return this.IdSelector();

    case COLON:
      if (this.scanner.lookupType(1) === COLON) {
        return this.PseudoElementSelector();
      } else {
        return this.PseudoClassSelector();
      }

    case IDENT:
      return this.TypeSelector();

    case NUMBER:
    case PERCENTAGE:
      return this.Percentage();

    case DIMENSION:
      // throws when .123ident
      if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP) {
        this.error('Identifier is expected', this.scanner.tokenStart + 1);
      }

      break;

    case DELIM:
      var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

      switch (code) {
        case PLUSSIGN:
        case GREATERTHANSIGN:
        case TILDE:
          context.space = null;
          context.ignoreWSAfter = true;
          return this.Combinator();

        case SOLIDUS:
          // /deep/
          return this.Combinator();

        case FULLSTOP:
          return this.ClassSelector();

        case ASTERISK:
        case VERTICALLINE:
          return this.TypeSelector();

        case NUMBERSIGN:
          return this.IdSelector();
      }

      break;
  }
}

;
module.exports = {
  getNode: getNode
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/function/element.js":[function(require,module,exports) {
// https://drafts.csswg.org/css-images-4/#element-notation
// https://developer.mozilla.org/en-US/docs/Web/CSS/element
module.exports = function () {
  this.scanner.skipSC();
  var children = this.createSingleNodeList(this.IdSelector());
  this.scanner.skipSC();
  return children;
};
},{}],"node_modules/css-tree/lib/syntax/function/expression.js":[function(require,module,exports) {
// legacy IE function
// expression( <any-value> )
module.exports = function () {
  return this.createSingleNodeList(this.Raw(this.scanner.tokenIndex, null, false));
};
},{}],"node_modules/css-tree/lib/syntax/function/var.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var rawMode = require('../node/Raw').mode;

var COMMA = TYPE.Comma; // var( <ident> , <value>? )

module.exports = function () {
  var children = this.createList();
  this.scanner.skipSC(); // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer

  children.push(this.Identifier());
  this.scanner.skipSC();

  if (this.scanner.tokenType === COMMA) {
    children.push(this.Operator());
    children.push(this.parseCustomProperty ? this.Value(null) : this.Raw(this.scanner.tokenIndex, rawMode.exclamationMarkOrSemicolon, false));
  }

  return children;
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js","../node/Raw":"node_modules/css-tree/lib/syntax/node/Raw.js"}],"node_modules/css-tree/lib/syntax/scope/value.js":[function(require,module,exports) {
module.exports = {
  getNode: require('./default'),
  '-moz-element': require('../function/element'),
  'element': require('../function/element'),
  'expression': require('../function/expression'),
  'var': require('../function/var')
};
},{"./default":"node_modules/css-tree/lib/syntax/scope/default.js","../function/element":"node_modules/css-tree/lib/syntax/function/element.js","../function/expression":"node_modules/css-tree/lib/syntax/function/expression.js","../function/var":"node_modules/css-tree/lib/syntax/function/var.js"}],"node_modules/css-tree/lib/syntax/scope/index.js":[function(require,module,exports) {
module.exports = {
  AtrulePrelude: require('./atrulePrelude'),
  Selector: require('./selector'),
  Value: require('./value')
};
},{"./atrulePrelude":"node_modules/css-tree/lib/syntax/scope/atrulePrelude.js","./selector":"node_modules/css-tree/lib/syntax/scope/selector.js","./value":"node_modules/css-tree/lib/syntax/scope/value.js"}],"node_modules/css-tree/lib/syntax/atrule/font-face.js":[function(require,module,exports) {
module.exports = {
  parse: {
    prelude: null,
    block: function block() {
      return this.Block(true);
    }
  }
};
},{}],"node_modules/css-tree/lib/syntax/atrule/import.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var STRING = TYPE.String;
var IDENT = TYPE.Ident;
var URL = TYPE.Url;
var FUNCTION = TYPE.Function;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
module.exports = {
  parse: {
    prelude: function prelude() {
      var children = this.createList();
      this.scanner.skipSC();

      switch (this.scanner.tokenType) {
        case STRING:
          children.push(this.String());
          break;

        case URL:
        case FUNCTION:
          children.push(this.Url());
          break;

        default:
          this.error('String or url() is expected');
      }

      if (this.lookupNonWSType(0) === IDENT || this.lookupNonWSType(0) === LEFTPARENTHESIS) {
        children.push(this.WhiteSpace());
        children.push(this.MediaQueryList());
      }

      return children;
    },
    block: null
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/atrule/media.js":[function(require,module,exports) {
module.exports = {
  parse: {
    prelude: function prelude() {
      return this.createSingleNodeList(this.MediaQueryList());
    },
    block: function block() {
      return this.Block(false);
    }
  }
};
},{}],"node_modules/css-tree/lib/syntax/atrule/page.js":[function(require,module,exports) {
module.exports = {
  parse: {
    prelude: function prelude() {
      return this.createSingleNodeList(this.SelectorList());
    },
    block: function block() {
      return this.Block(true);
    }
  }
};
},{}],"node_modules/css-tree/lib/syntax/atrule/supports.js":[function(require,module,exports) {
var TYPE = require('../../tokenizer').TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENT = TYPE.Ident;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;

function consumeRaw() {
  return this.createSingleNodeList(this.Raw(this.scanner.tokenIndex, null, false));
}

function parentheses() {
  this.scanner.skipSC();

  if (this.scanner.tokenType === IDENT && this.lookupNonWSType(1) === COLON) {
    return this.createSingleNodeList(this.Declaration());
  }

  return readSequence.call(this);
}

function readSequence() {
  var children = this.createList();
  var space = null;
  var child;
  this.scanner.skipSC();

  scan: while (!this.scanner.eof) {
    switch (this.scanner.tokenType) {
      case WHITESPACE:
        space = this.WhiteSpace();
        continue;

      case COMMENT:
        this.scanner.next();
        continue;

      case FUNCTION:
        child = this.Function(consumeRaw, this.scope.AtrulePrelude);
        break;

      case IDENT:
        child = this.Identifier();
        break;

      case LEFTPARENTHESIS:
        child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
        break;

      default:
        break scan;
    }

    if (space !== null) {
      children.push(space);
      space = null;
    }

    children.push(child);
  }

  return children;
}

module.exports = {
  parse: {
    prelude: function prelude() {
      var children = readSequence.call(this);

      if (this.getFirstListNode(children) === null) {
        this.error('Condition is expected');
      }

      return children;
    },
    block: function block() {
      return this.Block(false);
    }
  }
};
},{"../../tokenizer":"node_modules/css-tree/lib/tokenizer/index.js"}],"node_modules/css-tree/lib/syntax/atrule/index.js":[function(require,module,exports) {
module.exports = {
  'font-face': require('./font-face'),
  'import': require('./import'),
  'media': require('./media'),
  'page': require('./page'),
  'supports': require('./supports')
};
},{"./font-face":"node_modules/css-tree/lib/syntax/atrule/font-face.js","./import":"node_modules/css-tree/lib/syntax/atrule/import.js","./media":"node_modules/css-tree/lib/syntax/atrule/media.js","./page":"node_modules/css-tree/lib/syntax/atrule/page.js","./supports":"node_modules/css-tree/lib/syntax/atrule/supports.js"}],"node_modules/css-tree/lib/syntax/pseudo/dir.js":[function(require,module,exports) {
module.exports = {
  parse: function parse() {
    return this.createSingleNodeList(this.Identifier());
  }
};
},{}],"node_modules/css-tree/lib/syntax/pseudo/has.js":[function(require,module,exports) {
module.exports = {
  parse: function parse() {
    return this.createSingleNodeList(this.SelectorList());
  }
};
},{}],"node_modules/css-tree/lib/syntax/pseudo/lang.js":[function(require,module,exports) {
module.exports = {
  parse: function parse() {
    return this.createSingleNodeList(this.Identifier());
  }
};
},{}],"node_modules/css-tree/lib/syntax/pseudo/common/selectorList.js":[function(require,module,exports) {
module.exports = {
  parse: function selectorList() {
    return this.createSingleNodeList(this.SelectorList());
  }
};
},{}],"node_modules/css-tree/lib/syntax/pseudo/matches.js":[function(require,module,exports) {
module.exports = require('./common/selectorList');
},{"./common/selectorList":"node_modules/css-tree/lib/syntax/pseudo/common/selectorList.js"}],"node_modules/css-tree/lib/syntax/pseudo/not.js":[function(require,module,exports) {
module.exports = require('./common/selectorList');
},{"./common/selectorList":"node_modules/css-tree/lib/syntax/pseudo/common/selectorList.js"}],"node_modules/css-tree/lib/syntax/pseudo/common/nthWithOfClause.js":[function(require,module,exports) {
var ALLOW_OF_CLAUSE = true;
module.exports = {
  parse: function nthWithOfClause() {
    return this.createSingleNodeList(this.Nth(ALLOW_OF_CLAUSE));
  }
};
},{}],"node_modules/css-tree/lib/syntax/pseudo/nth-child.js":[function(require,module,exports) {
module.exports = require('./common/nthWithOfClause');
},{"./common/nthWithOfClause":"node_modules/css-tree/lib/syntax/pseudo/common/nthWithOfClause.js"}],"node_modules/css-tree/lib/syntax/pseudo/nth-last-child.js":[function(require,module,exports) {
module.exports = require('./common/nthWithOfClause');
},{"./common/nthWithOfClause":"node_modules/css-tree/lib/syntax/pseudo/common/nthWithOfClause.js"}],"node_modules/css-tree/lib/syntax/pseudo/common/nth.js":[function(require,module,exports) {
var DISALLOW_OF_CLAUSE = false;
module.exports = {
  parse: function nth() {
    return this.createSingleNodeList(this.Nth(DISALLOW_OF_CLAUSE));
  }
};
},{}],"node_modules/css-tree/lib/syntax/pseudo/nth-last-of-type.js":[function(require,module,exports) {
module.exports = require('./common/nth');
},{"./common/nth":"node_modules/css-tree/lib/syntax/pseudo/common/nth.js"}],"node_modules/css-tree/lib/syntax/pseudo/nth-of-type.js":[function(require,module,exports) {
module.exports = require('./common/nth');
},{"./common/nth":"node_modules/css-tree/lib/syntax/pseudo/common/nth.js"}],"node_modules/css-tree/lib/syntax/pseudo/slotted.js":[function(require,module,exports) {
module.exports = {
  parse: function compoundSelector() {
    return this.createSingleNodeList(this.Selector());
  }
};
},{}],"node_modules/css-tree/lib/syntax/pseudo/index.js":[function(require,module,exports) {
module.exports = {
  'dir': require('./dir'),
  'has': require('./has'),
  'lang': require('./lang'),
  'matches': require('./matches'),
  'not': require('./not'),
  'nth-child': require('./nth-child'),
  'nth-last-child': require('./nth-last-child'),
  'nth-last-of-type': require('./nth-last-of-type'),
  'nth-of-type': require('./nth-of-type'),
  'slotted': require('./slotted')
};
},{"./dir":"node_modules/css-tree/lib/syntax/pseudo/dir.js","./has":"node_modules/css-tree/lib/syntax/pseudo/has.js","./lang":"node_modules/css-tree/lib/syntax/pseudo/lang.js","./matches":"node_modules/css-tree/lib/syntax/pseudo/matches.js","./not":"node_modules/css-tree/lib/syntax/pseudo/not.js","./nth-child":"node_modules/css-tree/lib/syntax/pseudo/nth-child.js","./nth-last-child":"node_modules/css-tree/lib/syntax/pseudo/nth-last-child.js","./nth-last-of-type":"node_modules/css-tree/lib/syntax/pseudo/nth-last-of-type.js","./nth-of-type":"node_modules/css-tree/lib/syntax/pseudo/nth-of-type.js","./slotted":"node_modules/css-tree/lib/syntax/pseudo/slotted.js"}],"node_modules/css-tree/lib/syntax/config/parser.js":[function(require,module,exports) {
module.exports = {
  parseContext: {
    default: 'StyleSheet',
    stylesheet: 'StyleSheet',
    atrule: 'Atrule',
    atrulePrelude: function atrulePrelude(options) {
      return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
    },
    mediaQueryList: 'MediaQueryList',
    mediaQuery: 'MediaQuery',
    rule: 'Rule',
    selectorList: 'SelectorList',
    selector: 'Selector',
    block: function block() {
      return this.Block(true);
    },
    declarationList: 'DeclarationList',
    declaration: 'Declaration',
    value: 'Value'
  },
  scope: require('../scope'),
  atrule: require('../atrule'),
  pseudo: require('../pseudo'),
  node: require('../node')
};
},{"../scope":"node_modules/css-tree/lib/syntax/scope/index.js","../atrule":"node_modules/css-tree/lib/syntax/atrule/index.js","../pseudo":"node_modules/css-tree/lib/syntax/pseudo/index.js","../node":"node_modules/css-tree/lib/syntax/node/index.js"}],"node_modules/css-tree/lib/syntax/config/walker.js":[function(require,module,exports) {
module.exports = {
  node: require('../node')
};
},{"../node":"node_modules/css-tree/lib/syntax/node/index.js"}],"node_modules/css-tree/lib/syntax/index.js":[function(require,module,exports) {
function merge() {
  var dest = {};

  for (var i = 0; i < arguments.length; i++) {
    var src = arguments[i];

    for (var key in src) {
      dest[key] = src[key];
    }
  }

  return dest;
}

module.exports = require('./create').create(merge(require('./config/lexer'), require('./config/parser'), require('./config/walker')));
},{"./create":"node_modules/css-tree/lib/syntax/create.js","./config/lexer":"node_modules/css-tree/lib/syntax/config/lexer.js","./config/parser":"node_modules/css-tree/lib/syntax/config/parser.js","./config/walker":"node_modules/css-tree/lib/syntax/config/walker.js"}],"node_modules/css-tree/lib/index.js":[function(require,module,exports) {
module.exports = require('./syntax');
},{"./syntax":"node_modules/css-tree/lib/syntax/index.js"}],"node_modules/stable/stable.js":[function(require,module,exports) {
var define;
var global = arguments[3];
//! stable.js 0.1.8, https://github.com/Two-Screen/stable
//! © 2018 Angry Bytes and contributors. MIT licensed.

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.stable = factory());
}(this, (function () { 'use strict';

  // A stable array sort, because `Array#sort()` is not guaranteed stable.
  // This is an implementation of merge sort, without recursion.

  var stable = function (arr, comp) {
    return exec(arr.slice(), comp)
  };

  stable.inplace = function (arr, comp) {
    var result = exec(arr, comp);

    // This simply copies back if the result isn't in the original array,
    // which happens on an odd number of passes.
    if (result !== arr) {
      pass(result, null, arr.length, arr);
    }

    return arr
  };

  // Execute the sort using the input array and a second buffer as work space.
  // Returns one of those two, containing the final result.
  function exec(arr, comp) {
    if (typeof(comp) !== 'function') {
      comp = function (a, b) {
        return String(a).localeCompare(b)
      };
    }

    // Short-circuit when there's nothing to sort.
    var len = arr.length;
    if (len <= 1) {
      return arr
    }

    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.
    // Chunks are the size of the left or right hand in merge sort.
    // Stop when the left-hand covers all of the array.
    var buffer = new Array(len);
    for (var chk = 1; chk < len; chk *= 2) {
      pass(arr, comp, chk, buffer);

      var tmp = arr;
      arr = buffer;
      buffer = tmp;
    }

    return arr
  }

  // Run a single pass with the given chunk size.
  var pass = function (arr, comp, chk, result) {
    var len = arr.length;
    var i = 0;
    // Step size / double chunk size.
    var dbl = chk * 2;
    // Bounds of the left and right chunks.
    var l, r, e;
    // Iterators over the left and right chunk.
    var li, ri;

    // Iterate over pairs of chunks.
    for (l = 0; l < len; l += dbl) {
      r = l + chk;
      e = r + chk;
      if (r > len) r = len;
      if (e > len) e = len;

      // Iterate both chunks in parallel.
      li = l;
      ri = r;
      while (true) {
        // Compare the chunks.
        if (li < r && ri < e) {
          // This works for a regular `sort()` compatible comparator,
          // but also for a simple comparator like: `a > b`
          if (comp(arr[li], arr[ri]) <= 0) {
            result[i++] = arr[li++];
          }
          else {
            result[i++] = arr[ri++];
          }
        }
        // Nothing to compare, just flush what's left.
        else if (li < r) {
          result[i++] = arr[li++];
        }
        else if (ri < e) {
          result[i++] = arr[ri++];
        }
        // Both iterators are at the chunk ends.
        else {
          break
        }
      }
    }
  };

  return stable;

})));

},{}],"node_modules/csso/lib/restructure/prepare/specificity.js":[function(require,module,exports) {
module.exports = function specificity(simpleSelector) {
  var A = 0;
  var B = 0;
  var C = 0;
  simpleSelector.children.each(function walk(node) {
    switch (node.type) {
      case 'SelectorList':
      case 'Selector':
        node.children.each(walk);
        break;

      case 'IdSelector':
        A++;
        break;

      case 'ClassSelector':
      case 'AttributeSelector':
        B++;
        break;

      case 'PseudoClassSelector':
        switch (node.name.toLowerCase()) {
          case 'not':
            node.children.each(walk);
            break;

          case 'before':
          case 'after':
          case 'first-line':
          case 'first-letter':
            C++;
            break;
          // TODO: support for :nth-*(.. of <SelectorList>), :matches(), :has()

          default:
            B++;
        }

        break;

      case 'PseudoElementSelector':
        C++;
        break;

      case 'TypeSelector':
        // ignore universal selector
        if (node.name.charAt(node.name.length - 1) !== '*') {
          C++;
        }

        break;
    }
  });
  return [A, B, C];
};
},{}],"node_modules/svgo/lib/css-tools.js":[function(require,module,exports) {
'use strict';

var csstree = require('css-tree'),
    List = csstree.List,
    stable = require('stable'),
    specificity = require('csso/lib/restructure/prepare/specificity');
/**
 * Flatten a CSS AST to a selectors list.
 *
 * @param {Object} cssAst css-tree AST to flatten
 * @return {Array} selectors
 */


function flattenToSelectors(cssAst) {
  var selectors = [];
  csstree.walk(cssAst, {
    visit: 'Rule',
    enter: function (node) {
      if (node.type !== 'Rule') {
        return;
      }

      var atrule = this.atrule;
      var rule = node;
      node.prelude.children.each(function (selectorNode, selectorItem) {
        var selector = {
          item: selectorItem,
          atrule: atrule,
          rule: rule,
          pseudos: []
        };
        selectorNode.children.each(function (selectorChildNode, selectorChildItem, selectorChildList) {
          if (selectorChildNode.type === 'PseudoClassSelector' || selectorChildNode.type === 'PseudoElementSelector') {
            selector.pseudos.push({
              item: selectorChildItem,
              list: selectorChildList
            });
          }
        });
        selectors.push(selector);
      });
    }
  });
  return selectors;
}
/**
 * Filter selectors by Media Query.
 *
 * @param {Array} selectors to filter
 * @param {Array} useMqs Array with strings of media queries that should pass (<name> <expression>)
 * @return {Array} Filtered selectors that match the passed media queries
 */


function filterByMqs(selectors, useMqs) {
  return selectors.filter(function (selector) {
    if (selector.atrule === null) {
      return ~useMqs.indexOf('');
    }

    var mqName = selector.atrule.name;
    var mqStr = mqName;

    if (selector.atrule.expression && selector.atrule.expression.children.first().type === 'MediaQueryList') {
      var mqExpr = csstree.generate(selector.atrule.expression);
      mqStr = [mqName, mqExpr].join(' ');
    }

    return ~useMqs.indexOf(mqStr);
  });
}
/**
 * Filter selectors by the pseudo-elements and/or -classes they contain.
 *
 * @param {Array} selectors to filter
 * @param {Array} usePseudos Array with strings of single or sequence of pseudo-elements and/or -classes that should pass
 * @return {Array} Filtered selectors that match the passed pseudo-elements and/or -classes
 */


function filterByPseudos(selectors, usePseudos) {
  return selectors.filter(function (selector) {
    var pseudoSelectorsStr = csstree.generate({
      type: 'Selector',
      children: new List().fromArray(selector.pseudos.map(function (pseudo) {
        return pseudo.item.data;
      }))
    });
    return ~usePseudos.indexOf(pseudoSelectorsStr);
  });
}
/**
 * Remove pseudo-elements and/or -classes from the selectors for proper matching.
 *
 * @param {Array} selectors to clean
 * @return {Array} Selectors without pseudo-elements and/or -classes
 */


function cleanPseudos(selectors) {
  selectors.forEach(function (selector) {
    selector.pseudos.forEach(function (pseudo) {
      pseudo.list.remove(pseudo.item);
    });
  });
}
/**
 * Compares two selector specificities.
 * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211
 *
 * @param {Array} aSpecificity Specificity of selector A
 * @param {Array} bSpecificity Specificity of selector B
 * @return {Number} Score of selector specificity A compared to selector specificity B
 */


function compareSpecificity(aSpecificity, bSpecificity) {
  for (var i = 0; i < 4; i += 1) {
    if (aSpecificity[i] < bSpecificity[i]) {
      return -1;
    } else if (aSpecificity[i] > bSpecificity[i]) {
      return 1;
    }
  }

  return 0;
}
/**
 * Compare two simple selectors.
 *
 * @param {Object} aSimpleSelectorNode Simple selector A
 * @param {Object} bSimpleSelectorNode Simple selector B
 * @return {Number} Score of selector A compared to selector B
 */


function compareSimpleSelectorNode(aSimpleSelectorNode, bSimpleSelectorNode) {
  var aSpecificity = specificity(aSimpleSelectorNode),
      bSpecificity = specificity(bSimpleSelectorNode);
  return compareSpecificity(aSpecificity, bSpecificity);
}

function _bySelectorSpecificity(selectorA, selectorB) {
  return compareSimpleSelectorNode(selectorA.item.data, selectorB.item.data);
}
/**
 * Sort selectors stably by their specificity.
 *
 * @param {Array} selectors to be sorted
 * @return {Array} Stable sorted selectors
 */


function sortSelectors(selectors) {
  return stable(selectors, _bySelectorSpecificity);
}
/**
 * Convert a css-tree AST style declaration to CSSStyleDeclaration property.
 *
 * @param {Object} declaration css-tree style declaration
 * @return {Object} CSSStyleDeclaration property
 */


function csstreeToStyleDeclaration(declaration) {
  var propertyName = declaration.property,
      propertyValue = csstree.generate(declaration.value),
      propertyPriority = declaration.important ? 'important' : '';
  return {
    name: propertyName,
    value: propertyValue,
    priority: propertyPriority
  };
}
/**
 * Gets the CSS string of a style element
 *
 * @param {Object} element style element
 * @return {String|Array} CSS string or empty array if no styles are set
 */


function getCssStr(elem) {
  return elem.content[0].text || elem.content[0].cdata || [];
}
/**
 * Sets the CSS string of a style element
 *
 * @param {Object} element style element
 * @param {String} CSS string to be set
 * @return {Object} reference to field with CSS
 */


function setCssStr(elem, css) {
  // in case of cdata field
  if (elem.content[0].cdata) {
    elem.content[0].cdata = css;
    return elem.content[0].cdata;
  } // in case of text field + if nothing was set yet


  elem.content[0].text = css;
  return elem.content[0].text;
}

module.exports.flattenToSelectors = flattenToSelectors;
module.exports.filterByMqs = filterByMqs;
module.exports.filterByPseudos = filterByPseudos;
module.exports.cleanPseudos = cleanPseudos;
module.exports.compareSpecificity = compareSpecificity;
module.exports.compareSimpleSelectorNode = compareSimpleSelectorNode;
module.exports.sortSelectors = sortSelectors;
module.exports.csstreeToStyleDeclaration = csstreeToStyleDeclaration;
module.exports.getCssStr = getCssStr;
module.exports.setCssStr = setCssStr;
},{"css-tree":"node_modules/css-tree/lib/index.js","stable":"node_modules/stable/stable.js","csso/lib/restructure/prepare/specificity":"node_modules/csso/lib/restructure/prepare/specificity.js"}],"node_modules/svgo/lib/svgo/css-style-declaration.js":[function(require,module,exports) {
'use strict';

var csstree = require('css-tree'),
    csstools = require('../css-tools');

var CSSStyleDeclaration = function (node) {
  this.parentNode = node;
  this.properties = new Map();
  this.hasSynced = false;
  this.styleAttr = null;
  this.styleValue = null;
  this.parseError = false;
};
/**
 * Performs a deep clone of this object.
 *
 * @param parentNode the parentNode to assign to the cloned result
 */


CSSStyleDeclaration.prototype.clone = function (parentNode) {
  var node = this;
  var nodeData = {};
  Object.keys(node).forEach(function (key) {
    if (key !== 'parentNode') {
      nodeData[key] = node[key];
    }
  }); // Deep-clone node data.

  nodeData = JSON.parse(JSON.stringify(nodeData));
  var clone = new CSSStyleDeclaration(parentNode);
  Object.assign(clone, nodeData);
  return clone;
};

CSSStyleDeclaration.prototype.hasStyle = function () {
  this.addStyleHandler();
}; // attr.style


CSSStyleDeclaration.prototype.addStyleHandler = function () {
  this.styleAttr = {
    // empty style attr
    'name': 'style',
    'value': null
  };
  Object.defineProperty(this.parentNode.attrs, 'style', {
    get: this.getStyleAttr.bind(this),
    set: this.setStyleAttr.bind(this),
    enumerable: true,
    configurable: true
  });
  this.addStyleValueHandler();
}; // attr.style.value


CSSStyleDeclaration.prototype.addStyleValueHandler = function () {
  Object.defineProperty(this.styleAttr, 'value', {
    get: this.getStyleValue.bind(this),
    set: this.setStyleValue.bind(this),
    enumerable: true,
    configurable: true
  });
};

CSSStyleDeclaration.prototype.getStyleAttr = function () {
  return this.styleAttr;
};

CSSStyleDeclaration.prototype.setStyleAttr = function (newStyleAttr) {
  this.setStyleValue(newStyleAttr.value); // must before applying value handler!

  this.styleAttr = newStyleAttr;
  this.addStyleValueHandler();
  this.hasSynced = false; // raw css changed
};

CSSStyleDeclaration.prototype.getStyleValue = function () {
  return this.getCssText();
};

CSSStyleDeclaration.prototype.setStyleValue = function (newValue) {
  this.properties.clear(); // reset all existing properties

  this.styleValue = newValue;
  this.hasSynced = false; // raw css changed
};

CSSStyleDeclaration.prototype._loadCssText = function () {
  if (this.hasSynced) {
    return;
  }

  this.hasSynced = true; // must be set here to prevent loop in setProperty(...)

  if (!this.styleValue || this.styleValue.length === 0) {
    return;
  }

  var inlineCssStr = this.styleValue;
  var declarations = {};

  try {
    declarations = csstree.parse(inlineCssStr, {
      context: 'declarationList',
      parseValue: false
    });
  } catch (parseError) {
    this.parseError = parseError;
    return;
  }

  this.parseError = false;
  var self = this;
  declarations.children.each(function (declaration) {
    try {
      var styleDeclaration = csstools.csstreeToStyleDeclaration(declaration);
      self.setProperty(styleDeclaration.name, styleDeclaration.value, styleDeclaration.priority);
    } catch (styleError) {
      if (styleError.message !== 'Unknown node type: undefined') {
        self.parseError = styleError;
      }
    }
  });
}; // only reads from properties

/**
 * Get the textual representation of the declaration block (equivalent to .cssText attribute).
 *
 * @return {String} Textual representation of the declaration block (empty string for no properties)
 */


CSSStyleDeclaration.prototype.getCssText = function () {
  var properties = this.getProperties();

  if (this.parseError) {
    // in case of a parse error, pass through original styles
    return this.styleValue;
  }

  var cssText = [];
  properties.forEach(function (property, propertyName) {
    var strImportant = property.priority === 'important' ? '!important' : '';
    cssText.push(propertyName.trim() + ':' + property.value.trim() + strImportant);
  });
  return cssText.join(';');
};

CSSStyleDeclaration.prototype._handleParseError = function () {
  if (this.parseError) {
    console.warn('Warning: Parse error when parsing inline styles, style properties of this element cannot be used. The raw styles can still be get/set using .attr(\'style\').value. Error details: ' + this.parseError);
  }
};

CSSStyleDeclaration.prototype._getProperty = function (propertyName) {
  if (typeof propertyName === 'undefined') {
    throw Error('1 argument required, but only 0 present.');
  }

  var properties = this.getProperties();

  this._handleParseError();

  var property = properties.get(propertyName.trim());
  return property;
};
/**
 * Return the optional priority, "important".
 *
 * @param {String} propertyName representing the property name to be checked.
 * @return {String} priority that represents the priority (e.g. "important") if one exists. If none exists, returns the empty string.
 */


CSSStyleDeclaration.prototype.getPropertyPriority = function (propertyName) {
  var property = this._getProperty(propertyName);

  return property ? property.priority : '';
};
/**
 * Return the property value given a property name.
 *
 * @param {String} propertyName representing the property name to be checked.
 * @return {String} value containing the value of the property. If not set, returns the empty string.
 */


CSSStyleDeclaration.prototype.getPropertyValue = function (propertyName) {
  var property = this._getProperty(propertyName);

  return property ? property.value : null;
};
/**
 * Return a property name.
 *
 * @param {Number} index of the node to be fetched. The index is zero-based.
 * @return {String} propertyName that is the name of the CSS property at the specified index.
 */


CSSStyleDeclaration.prototype.item = function (index) {
  if (typeof index === 'undefined') {
    throw Error('1 argument required, but only 0 present.');
  }

  var properties = this.getProperties();

  this._handleParseError();

  return Array.from(properties.keys())[index];
};
/**
 * Return all properties of the node.
 *
 * @return {Map} properties that is a Map with propertyName as key and property (propertyValue + propertyPriority) as value.
 */


CSSStyleDeclaration.prototype.getProperties = function () {
  this._loadCssText();

  return this.properties;
}; // writes to properties

/**
 * Remove a property from the CSS declaration block.
 *
 * @param {String} propertyName representing the property name to be removed.
 * @return {String} oldValue equal to the value of the CSS property before it was removed.
 */


CSSStyleDeclaration.prototype.removeProperty = function (propertyName) {
  if (typeof propertyName === 'undefined') {
    throw Error('1 argument required, but only 0 present.');
  }

  this.hasStyle();
  var properties = this.getProperties();

  this._handleParseError();

  var oldValue = this.getPropertyValue(propertyName);
  properties.delete(propertyName.trim());
  return oldValue;
};
/**
 * Modify an existing CSS property or creates a new CSS property in the declaration block.
 *
 * @param {String} propertyName representing the CSS property name to be modified.
 * @param {String} [value] containing the new property value. If not specified, treated as the empty string. value must not contain "!important" -- that should be set using the priority parameter.
 * @param {String} [priority] allowing the "important" CSS priority to be set. If not specified, treated as the empty string.
 * @return {undefined}
 */


CSSStyleDeclaration.prototype.setProperty = function (propertyName, value, priority) {
  if (typeof propertyName === 'undefined') {
    throw Error('propertyName argument required, but only not present.');
  }

  this.hasStyle();
  var properties = this.getProperties();

  this._handleParseError();

  var property = {
    value: value.trim(),
    priority: priority.trim()
  };
  properties.set(propertyName.trim(), property);
  return property;
};

module.exports = CSSStyleDeclaration;
},{"css-tree":"node_modules/css-tree/lib/index.js","../css-tools":"node_modules/svgo/lib/css-tools.js"}],"node_modules/svgo/lib/svgo/svg2js.js":[function(require,module,exports) {
'use strict';

var SAX = require('sax'),
    JSAPI = require('./jsAPI.js'),
    CSSClassList = require('./css-class-list'),
    CSSStyleDeclaration = require('./css-style-declaration'),
    entityDeclaration = /<!ENTITY\s+(\S+)\s+(?:'([^\']+)'|"([^\"]+)")\s*>/g;

var config = {
  strict: true,
  trim: false,
  normalize: true,
  lowercase: true,
  xmlns: true,
  position: true
};
/**
 * Convert SVG (XML) string to SVG-as-JS object.
 *
 * @param {String} data input data
 * @param {Function} callback
 */

module.exports = function (data, callback) {
  var sax = SAX.parser(config.strict, config),
      root = new JSAPI({
    elem: '#document',
    content: []
  }),
      current = root,
      stack = [root],
      textContext = null,
      parsingError = false;

  function pushToContent(content) {
    content = new JSAPI(content, current);
    (current.content = current.content || []).push(content);
    return content;
  }

  sax.ondoctype = function (doctype) {
    pushToContent({
      doctype: doctype
    });
    var subsetStart = doctype.indexOf('['),
        entityMatch;

    if (subsetStart >= 0) {
      entityDeclaration.lastIndex = subsetStart;

      while ((entityMatch = entityDeclaration.exec(data)) != null) {
        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
      }
    }
  };

  sax.onprocessinginstruction = function (data) {
    pushToContent({
      processinginstruction: data
    });
  };

  sax.oncomment = function (comment) {
    pushToContent({
      comment: comment.trim()
    });
  };

  sax.oncdata = function (cdata) {
    pushToContent({
      cdata: cdata
    });
  };

  sax.onopentag = function (data) {
    var elem = {
      elem: data.name,
      prefix: data.prefix,
      local: data.local,
      attrs: {}
    };
    elem.class = new CSSClassList(elem);
    elem.style = new CSSStyleDeclaration(elem);

    if (Object.keys(data.attributes).length) {
      for (var name in data.attributes) {
        if (name === 'class') {
          // has class attribute
          elem.class.hasClass();
        }

        if (name === 'style') {
          // has style attribute
          elem.style.hasStyle();
        }

        elem.attrs[name] = {
          name: name,
          value: data.attributes[name].value,
          prefix: data.attributes[name].prefix,
          local: data.attributes[name].local
        };
      }
    }

    elem = pushToContent(elem);
    current = elem; // Save info about <text> tag to prevent trimming of meaningful whitespace

    if (data.name == 'text' && !data.prefix) {
      textContext = current;
    }

    stack.push(elem);
  };

  sax.ontext = function (text) {
    if (/\S/.test(text) || textContext) {
      if (!textContext) text = text.trim();
      pushToContent({
        text: text
      });
    }
  };

  sax.onclosetag = function () {
    var last = stack.pop(); // Trim text inside <text> tag.

    if (last == textContext) {
      trim(textContext);
      textContext = null;
    }

    current = stack[stack.length - 1];
  };

  sax.onerror = function (e) {
    e.message = 'Error in parsing SVG: ' + e.message;

    if (e.message.indexOf('Unexpected end') < 0) {
      throw e;
    }
  };

  sax.onend = function () {
    if (!this.error) {
      callback(root);
    } else {
      callback({
        error: this.error.message
      });
    }
  };

  try {
    sax.write(data);
  } catch (e) {
    callback({
      error: e.message
    });
    parsingError = true;
  }

  if (!parsingError) sax.close();

  function trim(elem) {
    if (!elem.content) return elem;
    var start = elem.content[0],
        end = elem.content[elem.content.length - 1];

    while (start && start.content && !start.text) start = start.content[0];

    if (start && start.text) start.text = start.text.replace(/^\s+/, '');

    while (end && end.content && !end.text) end = end.content[end.content.length - 1];

    if (end && end.text) end.text = end.text.replace(/\s+$/, '');
    return elem;
  }
};
},{"sax":"node_modules/sax/lib/sax.js","./jsAPI.js":"node_modules/svgo/lib/svgo/jsAPI.js","./css-class-list":"node_modules/svgo/lib/svgo/css-class-list.js","./css-style-declaration":"node_modules/svgo/lib/svgo/css-style-declaration.js"}],"node_modules/svgo/lib/svgo/plugins.js":[function(require,module,exports) {
'use strict';
/**
 * Plugins engine.
 *
 * @module plugins
 *
 * @param {Object} data input data
 * @param {Object} info extra information
 * @param {Object} plugins plugins object from config
 * @return {Object} output data
 */

module.exports = function (data, info, plugins) {
  plugins.forEach(function (group) {
    switch (group[0].type) {
      case 'perItem':
        data = perItem(data, info, group);
        break;

      case 'perItemReverse':
        data = perItem(data, info, group, true);
        break;

      case 'full':
        data = full(data, info, group);
        break;
    }
  });
  return data;
};
/**
 * Direct or reverse per-item loop.
 *
 * @param {Object} data input data
 * @param {Object} info extra information
 * @param {Array} plugins plugins list to process
 * @param {Boolean} [reverse] reverse pass?
 * @return {Object} output data
 */


function perItem(data, info, plugins, reverse) {
  function monkeys(items) {
    items.content = items.content.filter(function (item) {
      // reverse pass
      if (reverse && item.content) {
        monkeys(item);
      } // main filter


      var filter = true;

      for (var i = 0; filter && i < plugins.length; i++) {
        var plugin = plugins[i];

        if (plugin.active && plugin.fn(item, plugin.params, info) === false) {
          filter = false;
        }
      } // direct pass


      if (!reverse && item.content) {
        monkeys(item);
      }

      return filter;
    });
    return items;
  }

  return monkeys(data);
}
/**
 * "Full" plugins.
 *
 * @param {Object} data input data
 * @param {Object} info extra information
 * @param {Array} plugins plugins list to process
 * @return {Object} output data
 */


function full(data, info, plugins) {
  plugins.forEach(function (plugin) {
    if (plugin.active) {
      data = plugin.fn(data, plugin.params, info);
    }
  });
  return data;
}
},{}],"node_modules/svgo/lib/svgo/tools.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
'use strict';

var FS = require('fs');
/**
 * Encode plain SVG data string into Data URI string.
 *
 * @param {String} str input string
 * @param {String} type Data URI type
 * @return {String} output string
 */


exports.encodeSVGDatauri = function (str, type) {
  var prefix = 'data:image/svg+xml';

  if (!type || type === 'base64') {
    // base64
    prefix += ';base64,';

    if (Buffer.from) {
      str = prefix + Buffer.from(str).toString('base64');
    } else {
      str = prefix + new Buffer(str).toString('base64');
    }
  } else if (type === 'enc') {
    // URI encoded
    str = prefix + ',' + encodeURIComponent(str);
  } else if (type === 'unenc') {
    // unencoded
    str = prefix + ',' + str;
  }

  return str;
};
/**
 * Decode SVG Data URI string into plain SVG string.
 *
 * @param {string} str input string
 * @return {String} output string
 */


exports.decodeSVGDatauri = function (str) {
  var regexp = /data:image\/svg\+xml(;charset=[^;,]*)?(;base64)?,(.*)/;
  var match = regexp.exec(str); // plain string

  if (!match) return str;
  var data = match[3];

  if (match[2]) {
    // base64
    str = new Buffer(data, 'base64').toString('utf8');
  } else if (data.charAt(0) === '%') {
    // URI encoded
    str = decodeURIComponent(data);
  } else if (data.charAt(0) === '<') {
    // unencoded
    str = data;
  }

  return str;
};

exports.intersectArrays = function (a, b) {
  return a.filter(function (n) {
    return b.indexOf(n) > -1;
  });
};
/**
 * Convert a row of numbers to an optimized string view.
 *
 * @example
 * [0, -1, .5, .5] → "0-1 .5.5"
 *
 * @param {number[]} data
 * @param {Object} params
 * @param {string?} command path data instruction
 * @return {string}
 */


exports.cleanupOutData = function (data, params, command) {
  var str = '',
      delimiter,
      prev;
  data.forEach(function (item, i) {
    // space delimiter by default
    delimiter = ' '; // no extra space in front of first number

    if (i == 0) delimiter = ''; // no extra space after 'arcto' command flags

    if (params.noSpaceAfterFlags && (command == 'A' || command == 'a')) {
      var pos = i % 7;
      if (pos == 4 || pos == 5) delimiter = '';
    } // remove floating-point numbers leading zeros
    // 0.5 → .5
    // -0.5 → -.5


    if (params.leadingZero) {
      item = removeLeadingZero(item);
    } // no extra space in front of negative number or
    // in front of a floating number if a previous number is floating too


    if (params.negativeExtraSpace && delimiter != '' && (item < 0 || String(item).charCodeAt(0) == 46 && prev % 1 !== 0)) {
      delimiter = '';
    } // save prev item value


    prev = item;
    str += delimiter + item;
  });
  return str;
};
/**
 * Remove floating-point numbers leading zero.
 *
 * @example
 * 0.5 → .5
 *
 * @example
 * -0.5 → -.5
 *
 * @param {Float} num input number
 *
 * @return {String} output number as string
 */


var removeLeadingZero = exports.removeLeadingZero = function (num) {
  var strNum = num.toString();

  if (0 < num && num < 1 && strNum.charCodeAt(0) == 48) {
    strNum = strNum.slice(1);
  } else if (-1 < num && num < 0 && strNum.charCodeAt(1) == 48) {
    strNum = strNum.charAt(0) + strNum.slice(2);
  }

  return strNum;
};
/**
 * Synchronously check if path is a directory. Tolerant to errors like ENOENT.
 * @param {string} path
 */


exports.checkIsDir = function (path) {
  try {
    return FS.lstatSync(path).isDirectory();
  } catch (e) {
    return false;
  }
};
},{"fs":"node_modules/parcel-bundler/src/builtins/_empty.js","buffer":"node_modules/buffer/index.js"}],"node_modules/os-browserify/browser.js":[function(require,module,exports) {
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

},{}],"node_modules/svgo/plugins/_collections.js":[function(require,module,exports) {
'use strict'; // http://www.w3.org/TR/SVG11/intro.html#Definitions

exports.elemsGroups = {
  animation: ['animate', 'animateColor', 'animateMotion', 'animateTransform', 'set'],
  descriptive: ['desc', 'metadata', 'title'],
  shape: ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect'],
  structural: ['defs', 'g', 'svg', 'symbol', 'use'],
  paintServer: ['solidColor', 'linearGradient', 'radialGradient', 'meshGradient', 'pattern', 'hatch'],
  nonRendering: ['linearGradient', 'radialGradient', 'pattern', 'clipPath', 'mask', 'marker', 'symbol', 'filter', 'solidColor'],
  container: ['a', 'defs', 'g', 'marker', 'mask', 'missing-glyph', 'pattern', 'svg', 'switch', 'symbol', 'foreignObject'],
  textContent: ['altGlyph', 'altGlyphDef', 'altGlyphItem', 'glyph', 'glyphRef', 'textPath', 'text', 'tref', 'tspan'],
  textContentChild: ['altGlyph', 'textPath', 'tref', 'tspan'],
  lightSource: ['feDiffuseLighting', 'feSpecularLighting', 'feDistantLight', 'fePointLight', 'feSpotLight'],
  filterPrimitive: ['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feFlood', 'feGaussianBlur', 'feImage', 'feMerge', 'feMorphology', 'feOffset', 'feSpecularLighting', 'feTile', 'feTurbulence']
};
exports.pathElems = ['path', 'glyph', 'missing-glyph']; // http://www.w3.org/TR/SVG11/intro.html#Definitions

exports.attrsGroups = {
  animationAddition: ['additive', 'accumulate'],
  animationAttributeTarget: ['attributeType', 'attributeName'],
  animationEvent: ['onbegin', 'onend', 'onrepeat', 'onload'],
  animationTiming: ['begin', 'dur', 'end', 'min', 'max', 'restart', 'repeatCount', 'repeatDur', 'fill'],
  animationValue: ['calcMode', 'values', 'keyTimes', 'keySplines', 'from', 'to', 'by'],
  conditionalProcessing: ['requiredFeatures', 'requiredExtensions', 'systemLanguage'],
  core: ['id', 'tabindex', 'xml:base', 'xml:lang', 'xml:space'],
  graphicalEvent: ['onfocusin', 'onfocusout', 'onactivate', 'onclick', 'onmousedown', 'onmouseup', 'onmouseover', 'onmousemove', 'onmouseout', 'onload'],
  presentation: ['alignment-baseline', 'baseline-shift', 'clip', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cursor', 'direction', 'display', 'dominant-baseline', 'enable-background', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'mask', 'opacity', 'overflow', 'paint-order', 'pointer-events', 'shape-rendering', 'stop-color', 'stop-opacity', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-overflow', 'text-rendering', 'transform', 'unicode-bidi', 'vector-effect', 'visibility', 'word-spacing', 'writing-mode'],
  xlink: ['xlink:href', 'xlink:show', 'xlink:actuate', 'xlink:type', 'xlink:role', 'xlink:arcrole', 'xlink:title'],
  documentEvent: ['onunload', 'onabort', 'onerror', 'onresize', 'onscroll', 'onzoom'],
  filterPrimitive: ['x', 'y', 'width', 'height', 'result'],
  transferFunction: ['type', 'tableValues', 'slope', 'intercept', 'amplitude', 'exponent', 'offset']
};
exports.attrsGroupsDefaults = {
  core: {
    'xml:space': 'preserve'
  },
  filterPrimitive: {
    x: '0',
    y: '0',
    width: '100%',
    height: '100%'
  },
  presentation: {
    clip: 'auto',
    'clip-path': 'none',
    'clip-rule': 'nonzero',
    mask: 'none',
    opacity: '1',
    'stop-color': '#000',
    'stop-opacity': '1',
    'fill-opacity': '1',
    'fill-rule': 'nonzero',
    fill: '#000',
    stroke: 'none',
    'stroke-width': '1',
    'stroke-linecap': 'butt',
    'stroke-linejoin': 'miter',
    'stroke-miterlimit': '4',
    'stroke-dasharray': 'none',
    'stroke-dashoffset': '0',
    'stroke-opacity': '1',
    'paint-order': 'normal',
    'vector-effect': 'none',
    display: 'inline',
    visibility: 'visible',
    'marker-start': 'none',
    'marker-mid': 'none',
    'marker-end': 'none',
    'color-interpolation': 'sRGB',
    'color-interpolation-filters': 'linearRGB',
    'color-rendering': 'auto',
    'shape-rendering': 'auto',
    'text-rendering': 'auto',
    'image-rendering': 'auto',
    'font-style': 'normal',
    'font-variant': 'normal',
    'font-weight': 'normal',
    'font-stretch': 'normal',
    'font-size': 'medium',
    'font-size-adjust': 'none',
    kerning: 'auto',
    'letter-spacing': 'normal',
    'word-spacing': 'normal',
    'text-decoration': 'none',
    'text-anchor': 'start',
    'text-overflow': 'clip',
    'writing-mode': 'lr-tb',
    'glyph-orientation-vertical': 'auto',
    'glyph-orientation-horizontal': '0deg',
    direction: 'ltr',
    'unicode-bidi': 'normal',
    'dominant-baseline': 'auto',
    'alignment-baseline': 'baseline',
    'baseline-shift': 'baseline'
  },
  transferFunction: {
    slope: '1',
    intercept: '0',
    amplitude: '1',
    exponent: '1',
    offset: '0'
  }
}; // http://www.w3.org/TR/SVG11/eltindex.html

exports.elems = {
  a: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation', 'xlink'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform', 'target'],
    defaults: {
      target: '_self'
    },
    contentGroups: ['animation', 'descriptive', 'shape', 'structural', 'paintServer'],
    content: ['a', 'altGlyphDef', 'clipPath', 'color-profile', 'cursor', 'filter', 'font', 'font-face', 'foreignObject', 'image', 'marker', 'mask', 'pattern', 'script', 'style', 'switch', 'text', 'view']
  },
  altGlyph: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation', 'xlink'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'x', 'y', 'dx', 'dy', 'glyphRef', 'format', 'rotate']
  },
  altGlyphDef: {
    attrsGroups: ['core'],
    content: ['glyphRef']
  },
  altGlyphItem: {
    attrsGroups: ['core'],
    content: ['glyphRef', 'altGlyphItem']
  },
  animate: {
    attrsGroups: ['conditionalProcessing', 'core', 'animationAddition', 'animationAttributeTarget', 'animationEvent', 'animationTiming', 'animationValue', 'presentation', 'xlink'],
    attrs: ['externalResourcesRequired'],
    contentGroups: ['descriptive']
  },
  animateColor: {
    attrsGroups: ['conditionalProcessing', 'core', 'animationEvent', 'xlink', 'animationAttributeTarget', 'animationTiming', 'animationValue', 'animationAddition', 'presentation'],
    attrs: ['externalResourcesRequired'],
    contentGroups: ['descriptive']
  },
  animateMotion: {
    attrsGroups: ['conditionalProcessing', 'core', 'animationEvent', 'xlink', 'animationTiming', 'animationValue', 'animationAddition'],
    attrs: ['externalResourcesRequired', 'path', 'keyPoints', 'rotate', 'origin'],
    defaults: {
      'rotate': '0'
    },
    contentGroups: ['descriptive'],
    content: ['mpath']
  },
  animateTransform: {
    attrsGroups: ['conditionalProcessing', 'core', 'animationEvent', 'xlink', 'animationAttributeTarget', 'animationTiming', 'animationValue', 'animationAddition'],
    attrs: ['externalResourcesRequired', 'type'],
    contentGroups: ['descriptive']
  },
  circle: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform', 'cx', 'cy', 'r'],
    defaults: {
      cx: '0',
      cy: '0'
    },
    contentGroups: ['animation', 'descriptive']
  },
  clipPath: {
    attrsGroups: ['conditionalProcessing', 'core', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform', 'clipPathUnits'],
    defaults: {
      clipPathUnits: 'userSpaceOnUse'
    },
    contentGroups: ['animation', 'descriptive', 'shape'],
    content: ['text', 'use']
  },
  'color-profile': {
    attrsGroups: ['core', 'xlink'],
    attrs: ['local', 'name', 'rendering-intent'],
    defaults: {
      name: 'sRGB',
      'rendering-intent': 'auto'
    },
    contentGroups: ['descriptive']
  },
  cursor: {
    attrsGroups: ['core', 'conditionalProcessing', 'xlink'],
    attrs: ['externalResourcesRequired', 'x', 'y'],
    defaults: {
      x: '0',
      y: '0'
    },
    contentGroups: ['descriptive']
  },
  defs: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform'],
    contentGroups: ['animation', 'descriptive', 'shape', 'structural', 'paintServer'],
    content: ['a', 'altGlyphDef', 'clipPath', 'color-profile', 'cursor', 'filter', 'font', 'font-face', 'foreignObject', 'image', 'marker', 'mask', 'pattern', 'script', 'style', 'switch', 'text', 'view']
  },
  desc: {
    attrsGroups: ['core'],
    attrs: ['class', 'style']
  },
  ellipse: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform', 'cx', 'cy', 'rx', 'ry'],
    defaults: {
      cx: '0',
      cy: '0'
    },
    contentGroups: ['animation', 'descriptive']
  },
  feBlend: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', // TODO: in - 'If no value is provided and this is the first filter primitive,
    // then this filter primitive will use SourceGraphic as its input'
    'in', 'in2', 'mode'],
    defaults: {
      mode: 'normal'
    },
    content: ['animate', 'set']
  },
  feColorMatrix: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in', 'type', 'values'],
    defaults: {
      type: 'matrix'
    },
    content: ['animate', 'set']
  },
  feComponentTransfer: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in'],
    content: ['feFuncA', 'feFuncB', 'feFuncG', 'feFuncR']
  },
  feComposite: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in', 'in2', 'operator', 'k1', 'k2', 'k3', 'k4'],
    defaults: {
      operator: 'over',
      k1: '0',
      k2: '0',
      k3: '0',
      k4: '0'
    },
    content: ['animate', 'set']
  },
  feConvolveMatrix: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in', 'order', 'kernelMatrix', // TODO: divisor - 'The default value is the sum of all values in kernelMatrix,
    // with the exception that if the sum is zero, then the divisor is set to 1'
    'divisor', 'bias', // TODO: targetX - 'By default, the convolution matrix is centered in X over each
    // pixel of the input image (i.e., targetX = floor ( orderX / 2 ))'
    'targetX', 'targetY', 'edgeMode', // TODO: kernelUnitLength - 'The first number is the <dx> value. The second number
    // is the <dy> value. If the <dy> value is not specified, it defaults to the same value as <dx>'
    'kernelUnitLength', 'preserveAlpha'],
    defaults: {
      order: '3',
      bias: '0',
      edgeMode: 'duplicate',
      preserveAlpha: 'false'
    },
    content: ['animate', 'set']
  },
  feDiffuseLighting: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in', 'surfaceScale', 'diffuseConstant', 'kernelUnitLength'],
    defaults: {
      surfaceScale: '1',
      diffuseConstant: '1'
    },
    contentGroups: ['descriptive'],
    content: [// TODO: 'exactly one light source element, in any order'
    'feDistantLight', 'fePointLight', 'feSpotLight']
  },
  feDisplacementMap: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in', 'in2', 'scale', 'xChannelSelector', 'yChannelSelector'],
    defaults: {
      scale: '0',
      xChannelSelector: 'A',
      yChannelSelector: 'A'
    },
    content: ['animate', 'set']
  },
  feDistantLight: {
    attrsGroups: ['core'],
    attrs: ['azimuth', 'elevation'],
    defaults: {
      azimuth: '0',
      elevation: '0'
    },
    content: ['animate', 'set']
  },
  feFlood: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style'],
    content: ['animate', 'animateColor', 'set']
  },
  feFuncA: {
    attrsGroups: ['core', 'transferFunction'],
    content: ['set', 'animate']
  },
  feFuncB: {
    attrsGroups: ['core', 'transferFunction'],
    content: ['set', 'animate']
  },
  feFuncG: {
    attrsGroups: ['core', 'transferFunction'],
    content: ['set', 'animate']
  },
  feFuncR: {
    attrsGroups: ['core', 'transferFunction'],
    content: ['set', 'animate']
  },
  feGaussianBlur: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in', 'stdDeviation'],
    defaults: {
      stdDeviation: '0'
    },
    content: ['set', 'animate']
  },
  feImage: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive', 'xlink'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'preserveAspectRatio', 'href', 'xlink:href'],
    defaults: {
      preserveAspectRatio: 'xMidYMid meet'
    },
    content: ['animate', 'animateTransform', 'set']
  },
  feMerge: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style'],
    content: ['feMergeNode']
  },
  feMergeNode: {
    attrsGroups: ['core'],
    attrs: ['in'],
    content: ['animate', 'set']
  },
  feMorphology: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in', 'operator', 'radius'],
    defaults: {
      operator: 'erode',
      radius: '0'
    },
    content: ['animate', 'set']
  },
  feOffset: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in', 'dx', 'dy'],
    defaults: {
      dx: '0',
      dy: '0'
    },
    content: ['animate', 'set']
  },
  fePointLight: {
    attrsGroups: ['core'],
    attrs: ['x', 'y', 'z'],
    defaults: {
      x: '0',
      y: '0',
      z: '0'
    },
    content: ['animate', 'set']
  },
  feSpecularLighting: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in', 'surfaceScale', 'specularConstant', 'specularExponent', 'kernelUnitLength'],
    defaults: {
      surfaceScale: '1',
      specularConstant: '1',
      specularExponent: '1'
    },
    contentGroups: ['descriptive', // TODO: exactly one 'light source element'
    'lightSource']
  },
  feSpotLight: {
    attrsGroups: ['core'],
    attrs: ['x', 'y', 'z', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'specularExponent', 'limitingConeAngle'],
    defaults: {
      x: '0',
      y: '0',
      z: '0',
      pointsAtX: '0',
      pointsAtY: '0',
      pointsAtZ: '0',
      specularExponent: '1'
    },
    content: ['animate', 'set']
  },
  feTile: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'in'],
    content: ['animate', 'set']
  },
  feTurbulence: {
    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
    attrs: ['class', 'style', 'baseFrequency', 'numOctaves', 'seed', 'stitchTiles', 'type'],
    defaults: {
      baseFrequency: '0',
      numOctaves: '1',
      seed: '0',
      stitchTiles: 'noStitch',
      type: 'turbulence'
    },
    content: ['animate', 'set']
  },
  filter: {
    attrsGroups: ['core', 'presentation', 'xlink'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'x', 'y', 'width', 'height', 'filterRes', 'filterUnits', 'primitiveUnits', 'href', 'xlink:href'],
    defaults: {
      primitiveUnits: 'userSpaceOnUse',
      x: '-10%',
      y: '-10%',
      width: '120%',
      height: '120%'
    },
    contentGroups: ['descriptive', 'filterPrimitive'],
    content: ['animate', 'set']
  },
  font: {
    attrsGroups: ['core', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'horiz-origin-x', 'horiz-origin-y', 'horiz-adv-x', 'vert-origin-x', 'vert-origin-y', 'vert-adv-y'],
    defaults: {
      'horiz-origin-x': '0',
      'horiz-origin-y': '0'
    },
    contentGroups: ['descriptive'],
    content: ['font-face', 'glyph', 'hkern', 'missing-glyph', 'vkern']
  },
  'font-face': {
    attrsGroups: ['core'],
    attrs: ['font-family', 'font-style', 'font-variant', 'font-weight', 'font-stretch', 'font-size', 'unicode-range', 'units-per-em', 'panose-1', 'stemv', 'stemh', 'slope', 'cap-height', 'x-height', 'accent-height', 'ascent', 'descent', 'widths', 'bbox', 'ideographic', 'alphabetic', 'mathematical', 'hanging', 'v-ideographic', 'v-alphabetic', 'v-mathematical', 'v-hanging', 'underline-position', 'underline-thickness', 'strikethrough-position', 'strikethrough-thickness', 'overline-position', 'overline-thickness'],
    defaults: {
      'font-style': 'all',
      'font-variant': 'normal',
      'font-weight': 'all',
      'font-stretch': 'normal',
      'unicode-range': 'U+0-10FFFF',
      'units-per-em': '1000',
      'panose-1': '0 0 0 0 0 0 0 0 0 0',
      'slope': '0'
    },
    contentGroups: ['descriptive'],
    content: [// TODO: "at most one 'font-face-src' element"
    'font-face-src']
  },
  // TODO: empty content
  'font-face-format': {
    attrsGroups: ['core'],
    attrs: ['string']
  },
  'font-face-name': {
    attrsGroups: ['core'],
    attrs: ['name']
  },
  'font-face-src': {
    attrsGroups: ['core'],
    content: ['font-face-name', 'font-face-uri']
  },
  'font-face-uri': {
    attrsGroups: ['core', 'xlink'],
    attrs: ['href', 'xlink:href'],
    content: ['font-face-format']
  },
  foreignObject: {
    attrsGroups: ['core', 'conditionalProcessing', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform', 'x', 'y', 'width', 'height'],
    defaults: {
      x: 0,
      y: 0
    }
  },
  g: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform'],
    contentGroups: ['animation', 'descriptive', 'shape', 'structural', 'paintServer'],
    content: ['a', 'altGlyphDef', 'clipPath', 'color-profile', 'cursor', 'filter', 'font', 'font-face', 'foreignObject', 'image', 'marker', 'mask', 'pattern', 'script', 'style', 'switch', 'text', 'view']
  },
  glyph: {
    attrsGroups: ['core', 'presentation'],
    attrs: ['class', 'style', 'd', 'horiz-adv-x', 'vert-origin-x', 'vert-origin-y', 'vert-adv-y', 'unicode', 'glyph-name', 'orientation', 'arabic-form', 'lang'],
    defaults: {
      'arabic-form': 'initial'
    },
    contentGroups: ['animation', 'descriptive', 'shape', 'structural', 'paintServer'],
    content: ['a', 'altGlyphDef', 'clipPath', 'color-profile', 'cursor', 'filter', 'font', 'font-face', 'foreignObject', 'image', 'marker', 'mask', 'pattern', 'script', 'style', 'switch', 'text', 'view']
  },
  glyphRef: {
    attrsGroups: ['core', 'presentation'],
    attrs: ['class', 'style', 'd', 'horiz-adv-x', 'vert-origin-x', 'vert-origin-y', 'vert-adv-y'],
    contentGroups: ['animation', 'descriptive', 'shape', 'structural', 'paintServer'],
    content: ['a', 'altGlyphDef', 'clipPath', 'color-profile', 'cursor', 'filter', 'font', 'font-face', 'foreignObject', 'image', 'marker', 'mask', 'pattern', 'script', 'style', 'switch', 'text', 'view']
  },
  hatch: {
    attrsGroups: ['core', 'presentation', 'xlink'],
    attrs: ['class', 'style', 'x', 'y', 'pitch', 'rotate', 'hatchUnits', 'hatchContentUnits', 'transform'],
    defaults: {
      hatchUnits: 'objectBoundingBox',
      hatchContentUnits: 'userSpaceOnUse',
      x: '0',
      y: '0',
      pitch: '0',
      rotate: '0'
    },
    contentGroups: ['animation', 'descriptive'],
    content: ['hatchPath']
  },
  hatchPath: {
    attrsGroups: ['core', 'presentation', 'xlink'],
    attrs: ['class', 'style', 'd', 'offset'],
    defaults: {
      offset: '0'
    },
    contentGroups: ['animation', 'descriptive']
  },
  hkern: {
    attrsGroups: ['core'],
    attrs: ['u1', 'g1', 'u2', 'g2', 'k']
  },
  image: {
    attrsGroups: ['core', 'conditionalProcessing', 'graphicalEvent', 'xlink', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'preserveAspectRatio', 'transform', 'x', 'y', 'width', 'height', 'href', 'xlink:href'],
    defaults: {
      x: '0',
      y: '0',
      preserveAspectRatio: 'xMidYMid meet'
    },
    contentGroups: ['animation', 'descriptive']
  },
  line: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform', 'x1', 'y1', 'x2', 'y2'],
    defaults: {
      x1: '0',
      y1: '0',
      x2: '0',
      y2: '0'
    },
    contentGroups: ['animation', 'descriptive']
  },
  linearGradient: {
    attrsGroups: ['core', 'presentation', 'xlink'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'x1', 'y1', 'x2', 'y2', 'gradientUnits', 'gradientTransform', 'spreadMethod', 'href', 'xlink:href'],
    defaults: {
      x1: '0',
      y1: '0',
      x2: '100%',
      y2: '0',
      spreadMethod: 'pad'
    },
    contentGroups: ['descriptive'],
    content: ['animate', 'animateTransform', 'set', 'stop']
  },
  marker: {
    attrsGroups: ['core', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'viewBox', 'preserveAspectRatio', 'refX', 'refY', 'markerUnits', 'markerWidth', 'markerHeight', 'orient'],
    defaults: {
      markerUnits: 'strokeWidth',
      refX: '0',
      refY: '0',
      markerWidth: '3',
      markerHeight: '3'
    },
    contentGroups: ['animation', 'descriptive', 'shape', 'structural', 'paintServer'],
    content: ['a', 'altGlyphDef', 'clipPath', 'color-profile', 'cursor', 'filter', 'font', 'font-face', 'foreignObject', 'image', 'marker', 'mask', 'pattern', 'script', 'style', 'switch', 'text', 'view']
  },
  mask: {
    attrsGroups: ['conditionalProcessing', 'core', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'x', 'y', 'width', 'height', 'maskUnits', 'maskContentUnits'],
    defaults: {
      maskUnits: 'objectBoundingBox',
      maskContentUnits: 'userSpaceOnUse',
      x: '-10%',
      y: '-10%',
      width: '120%',
      height: '120%'
    },
    contentGroups: ['animation', 'descriptive', 'shape', 'structural', 'paintServer'],
    content: ['a', 'altGlyphDef', 'clipPath', 'color-profile', 'cursor', 'filter', 'font', 'font-face', 'foreignObject', 'image', 'marker', 'mask', 'pattern', 'script', 'style', 'switch', 'text', 'view']
  },
  metadata: {
    attrsGroups: ['core']
  },
  'missing-glyph': {
    attrsGroups: ['core', 'presentation'],
    attrs: ['class', 'style', 'd', 'horiz-adv-x', 'vert-origin-x', 'vert-origin-y', 'vert-adv-y'],
    contentGroups: ['animation', 'descriptive', 'shape', 'structural', 'paintServer'],
    content: ['a', 'altGlyphDef', 'clipPath', 'color-profile', 'cursor', 'filter', 'font', 'font-face', 'foreignObject', 'image', 'marker', 'mask', 'pattern', 'script', 'style', 'switch', 'text', 'view']
  },
  mpath: {
    attrsGroups: ['core', 'xlink'],
    attrs: ['externalResourcesRequired', 'href', 'xlink:href'],
    contentGroups: ['descriptive']
  },
  path: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform', 'd', 'pathLength'],
    contentGroups: ['animation', 'descriptive']
  },
  pattern: {
    attrsGroups: ['conditionalProcessing', 'core', 'presentation', 'xlink'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'viewBox', 'preserveAspectRatio', 'x', 'y', 'width', 'height', 'patternUnits', 'patternContentUnits', 'patternTransform', 'href', 'xlink:href'],
    defaults: {
      patternUnits: 'objectBoundingBox',
      patternContentUnits: 'userSpaceOnUse',
      x: '0',
      y: '0',
      width: '0',
      height: '0',
      preserveAspectRatio: 'xMidYMid meet'
    },
    contentGroups: ['animation', 'descriptive', 'paintServer', 'shape', 'structural'],
    content: ['a', 'altGlyphDef', 'clipPath', 'color-profile', 'cursor', 'filter', 'font', 'font-face', 'foreignObject', 'image', 'marker', 'mask', 'pattern', 'script', 'style', 'switch', 'text', 'view']
  },
  polygon: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform', 'points'],
    contentGroups: ['animation', 'descriptive']
  },
  polyline: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform', 'points'],
    contentGroups: ['animation', 'descriptive']
  },
  radialGradient: {
    attrsGroups: ['core', 'presentation', 'xlink'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'cx', 'cy', 'r', 'fx', 'fy', 'fr', 'gradientUnits', 'gradientTransform', 'spreadMethod', 'href', 'xlink:href'],
    defaults: {
      gradientUnits: 'objectBoundingBox',
      cx: '50%',
      cy: '50%',
      r: '50%'
    },
    contentGroups: ['descriptive'],
    content: ['animate', 'animateTransform', 'set', 'stop']
  },
  meshGradient: {
    attrsGroups: ['core', 'presentation', 'xlink'],
    attrs: ['class', 'style', 'x', 'y', 'gradientUnits', 'transform'],
    contentGroups: ['descriptive', 'paintServer', 'animation'],
    content: ['meshRow']
  },
  meshRow: {
    attrsGroups: ['core', 'presentation'],
    attrs: ['class', 'style'],
    contentGroups: ['descriptive'],
    content: ['meshPatch']
  },
  meshPatch: {
    attrsGroups: ['core', 'presentation'],
    attrs: ['class', 'style'],
    contentGroups: ['descriptive'],
    content: ['stop']
  },
  rect: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform', 'x', 'y', 'width', 'height', 'rx', 'ry'],
    defaults: {
      x: '0',
      y: '0'
    },
    contentGroups: ['animation', 'descriptive']
  },
  script: {
    attrsGroups: ['core', 'xlink'],
    attrs: ['externalResourcesRequired', 'type', 'href', 'xlink:href']
  },
  set: {
    attrsGroups: ['conditionalProcessing', 'core', 'animation', 'xlink', 'animationAttributeTarget', 'animationTiming'],
    attrs: ['externalResourcesRequired', 'to'],
    contentGroups: ['descriptive']
  },
  solidColor: {
    attrsGroups: ['core', 'presentation'],
    attrs: ['class', 'style'],
    contentGroups: ['paintServer']
  },
  stop: {
    attrsGroups: ['core', 'presentation'],
    attrs: ['class', 'style', 'offset', 'path'],
    content: ['animate', 'animateColor', 'set']
  },
  style: {
    attrsGroups: ['core'],
    attrs: ['type', 'media', 'title'],
    defaults: {
      type: 'text/css'
    }
  },
  svg: {
    attrsGroups: ['conditionalProcessing', 'core', 'documentEvent', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'x', 'y', 'width', 'height', 'viewBox', 'preserveAspectRatio', 'zoomAndPan', 'version', 'baseProfile', 'contentScriptType', 'contentStyleType'],
    defaults: {
      x: '0',
      y: '0',
      width: '100%',
      height: '100%',
      preserveAspectRatio: 'xMidYMid meet',
      zoomAndPan: 'magnify',
      version: '1.1',
      baseProfile: 'none',
      contentScriptType: 'application/ecmascript',
      contentStyleType: 'text/css'
    },
    contentGroups: ['animation', 'descriptive', 'shape', 'structural', 'paintServer'],
    content: ['a', 'altGlyphDef', 'clipPath', 'color-profile', 'cursor', 'filter', 'font', 'font-face', 'foreignObject', 'image', 'marker', 'mask', 'pattern', 'script', 'style', 'switch', 'text', 'view']
  },
  switch: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform'],
    contentGroups: ['animation', 'descriptive', 'shape'],
    content: ['a', 'foreignObject', 'g', 'image', 'svg', 'switch', 'text', 'use']
  },
  symbol: {
    attrsGroups: ['core', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'preserveAspectRatio', 'viewBox', 'refX', 'refY'],
    defaults: {
      refX: 0,
      refY: 0
    },
    contentGroups: ['animation', 'descriptive', 'shape', 'structural', 'paintServer'],
    content: ['a', 'altGlyphDef', 'clipPath', 'color-profile', 'cursor', 'filter', 'font', 'font-face', 'foreignObject', 'image', 'marker', 'mask', 'pattern', 'script', 'style', 'switch', 'text', 'view']
  },
  text: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform', 'lengthAdjust', 'x', 'y', 'dx', 'dy', 'rotate', 'textLength'],
    defaults: {
      x: '0',
      y: '0',
      lengthAdjust: 'spacing'
    },
    contentGroups: ['animation', 'descriptive', 'textContentChild'],
    content: ['a']
  },
  textPath: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation', 'xlink'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'href', 'xlink:href', 'startOffset', 'method', 'spacing', 'd'],
    defaults: {
      startOffset: '0',
      method: 'align',
      spacing: 'exact'
    },
    contentGroups: ['descriptive'],
    content: ['a', 'altGlyph', 'animate', 'animateColor', 'set', 'tref', 'tspan']
  },
  title: {
    attrsGroups: ['core'],
    attrs: ['class', 'style']
  },
  tref: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation', 'xlink'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'href', 'xlink:href'],
    contentGroups: ['descriptive'],
    content: ['animate', 'animateColor', 'set']
  },
  tspan: {
    attrsGroups: ['conditionalProcessing', 'core', 'graphicalEvent', 'presentation'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'x', 'y', 'dx', 'dy', 'rotate', 'textLength', 'lengthAdjust'],
    contentGroups: ['descriptive'],
    content: ['a', 'altGlyph', 'animate', 'animateColor', 'set', 'tref', 'tspan']
  },
  use: {
    attrsGroups: ['core', 'conditionalProcessing', 'graphicalEvent', 'presentation', 'xlink'],
    attrs: ['class', 'style', 'externalResourcesRequired', 'transform', 'x', 'y', 'width', 'height', 'href', 'xlink:href'],
    defaults: {
      x: '0',
      y: '0'
    },
    contentGroups: ['animation', 'descriptive']
  },
  view: {
    attrsGroups: ['core'],
    attrs: ['externalResourcesRequired', 'viewBox', 'preserveAspectRatio', 'zoomAndPan', 'viewTarget'],
    contentGroups: ['descriptive']
  },
  vkern: {
    attrsGroups: ['core'],
    attrs: ['u1', 'g1', 'u2', 'g2', 'k']
  }
}; // http://wiki.inkscape.org/wiki/index.php/Inkscape-specific_XML_attributes

exports.editorNamespaces = ['http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd', 'http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd', 'http://www.inkscape.org/namespaces/inkscape', 'http://www.bohemiancoding.com/sketch/ns', 'http://ns.adobe.com/AdobeIllustrator/10.0/', 'http://ns.adobe.com/Graphs/1.0/', 'http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/', 'http://ns.adobe.com/Variables/1.0/', 'http://ns.adobe.com/SaveForWeb/1.0/', 'http://ns.adobe.com/Extensibility/1.0/', 'http://ns.adobe.com/Flows/1.0/', 'http://ns.adobe.com/ImageReplacement/1.0/', 'http://ns.adobe.com/GenericCustomNamespace/1.0/', 'http://ns.adobe.com/XPath/1.0/', 'http://schemas.microsoft.com/visio/2003/SVGExtensions/', 'http://taptrix.com/vectorillustrator/svg_extensions', 'http://www.figma.com/figma/ns', 'http://purl.org/dc/elements/1.1/', 'http://creativecommons.org/ns#', 'http://www.w3.org/1999/02/22-rdf-syntax-ns#', 'http://www.serif.com/', 'http://www.vector.evaxdesign.sk']; // http://www.w3.org/TR/SVG11/linking.html#processingIRI

exports.referencesProps = ['clip-path', 'color-profile', 'fill', 'filter', 'marker-start', 'marker-mid', 'marker-end', 'mask', 'stroke', 'style']; // http://www.w3.org/TR/SVG11/propidx.html

exports.inheritableAttrs = ['clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cursor', 'direction', 'dominant-baseline', 'fill', 'fill-opacity', 'fill-rule', 'font', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'image-rendering', 'letter-spacing', 'marker', 'marker-end', 'marker-mid', 'marker-start', 'paint-order', 'pointer-events', 'shape-rendering', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-rendering', 'transform', 'visibility', 'word-spacing', 'writing-mode'];
exports.presentationNonInheritableGroupAttrs = ['display', 'clip-path', 'filter', 'mask', 'opacity', 'text-decoration', 'transform', 'unicode-bidi', 'visibility']; // http://www.w3.org/TR/SVG11/single-page.html#types-ColorKeywords

exports.colorsNames = {
  'aliceblue': '#f0f8ff',
  'antiquewhite': '#faebd7',
  'aqua': '#0ff',
  'aquamarine': '#7fffd4',
  'azure': '#f0ffff',
  'beige': '#f5f5dc',
  'bisque': '#ffe4c4',
  'black': '#000',
  'blanchedalmond': '#ffebcd',
  'blue': '#00f',
  'blueviolet': '#8a2be2',
  'brown': '#a52a2a',
  'burlywood': '#deb887',
  'cadetblue': '#5f9ea0',
  'chartreuse': '#7fff00',
  'chocolate': '#d2691e',
  'coral': '#ff7f50',
  'cornflowerblue': '#6495ed',
  'cornsilk': '#fff8dc',
  'crimson': '#dc143c',
  'cyan': '#0ff',
  'darkblue': '#00008b',
  'darkcyan': '#008b8b',
  'darkgoldenrod': '#b8860b',
  'darkgray': '#a9a9a9',
  'darkgreen': '#006400',
  'darkgrey': '#a9a9a9',
  'darkkhaki': '#bdb76b',
  'darkmagenta': '#8b008b',
  'darkolivegreen': '#556b2f',
  'darkorange': '#ff8c00',
  'darkorchid': '#9932cc',
  'darkred': '#8b0000',
  'darksalmon': '#e9967a',
  'darkseagreen': '#8fbc8f',
  'darkslateblue': '#483d8b',
  'darkslategray': '#2f4f4f',
  'darkslategrey': '#2f4f4f',
  'darkturquoise': '#00ced1',
  'darkviolet': '#9400d3',
  'deeppink': '#ff1493',
  'deepskyblue': '#00bfff',
  'dimgray': '#696969',
  'dimgrey': '#696969',
  'dodgerblue': '#1e90ff',
  'firebrick': '#b22222',
  'floralwhite': '#fffaf0',
  'forestgreen': '#228b22',
  'fuchsia': '#f0f',
  'gainsboro': '#dcdcdc',
  'ghostwhite': '#f8f8ff',
  'gold': '#ffd700',
  'goldenrod': '#daa520',
  'gray': '#808080',
  'green': '#008000',
  'greenyellow': '#adff2f',
  'grey': '#808080',
  'honeydew': '#f0fff0',
  'hotpink': '#ff69b4',
  'indianred': '#cd5c5c',
  'indigo': '#4b0082',
  'ivory': '#fffff0',
  'khaki': '#f0e68c',
  'lavender': '#e6e6fa',
  'lavenderblush': '#fff0f5',
  'lawngreen': '#7cfc00',
  'lemonchiffon': '#fffacd',
  'lightblue': '#add8e6',
  'lightcoral': '#f08080',
  'lightcyan': '#e0ffff',
  'lightgoldenrodyellow': '#fafad2',
  'lightgray': '#d3d3d3',
  'lightgreen': '#90ee90',
  'lightgrey': '#d3d3d3',
  'lightpink': '#ffb6c1',
  'lightsalmon': '#ffa07a',
  'lightseagreen': '#20b2aa',
  'lightskyblue': '#87cefa',
  'lightslategray': '#789',
  'lightslategrey': '#789',
  'lightsteelblue': '#b0c4de',
  'lightyellow': '#ffffe0',
  'lime': '#0f0',
  'limegreen': '#32cd32',
  'linen': '#faf0e6',
  'magenta': '#f0f',
  'maroon': '#800000',
  'mediumaquamarine': '#66cdaa',
  'mediumblue': '#0000cd',
  'mediumorchid': '#ba55d3',
  'mediumpurple': '#9370db',
  'mediumseagreen': '#3cb371',
  'mediumslateblue': '#7b68ee',
  'mediumspringgreen': '#00fa9a',
  'mediumturquoise': '#48d1cc',
  'mediumvioletred': '#c71585',
  'midnightblue': '#191970',
  'mintcream': '#f5fffa',
  'mistyrose': '#ffe4e1',
  'moccasin': '#ffe4b5',
  'navajowhite': '#ffdead',
  'navy': '#000080',
  'oldlace': '#fdf5e6',
  'olive': '#808000',
  'olivedrab': '#6b8e23',
  'orange': '#ffa500',
  'orangered': '#ff4500',
  'orchid': '#da70d6',
  'palegoldenrod': '#eee8aa',
  'palegreen': '#98fb98',
  'paleturquoise': '#afeeee',
  'palevioletred': '#db7093',
  'papayawhip': '#ffefd5',
  'peachpuff': '#ffdab9',
  'peru': '#cd853f',
  'pink': '#ffc0cb',
  'plum': '#dda0dd',
  'powderblue': '#b0e0e6',
  'purple': '#800080',
  'rebeccapurple': '#639',
  'red': '#f00',
  'rosybrown': '#bc8f8f',
  'royalblue': '#4169e1',
  'saddlebrown': '#8b4513',
  'salmon': '#fa8072',
  'sandybrown': '#f4a460',
  'seagreen': '#2e8b57',
  'seashell': '#fff5ee',
  'sienna': '#a0522d',
  'silver': '#c0c0c0',
  'skyblue': '#87ceeb',
  'slateblue': '#6a5acd',
  'slategray': '#708090',
  'slategrey': '#708090',
  'snow': '#fffafa',
  'springgreen': '#00ff7f',
  'steelblue': '#4682b4',
  'tan': '#d2b48c',
  'teal': '#008080',
  'thistle': '#d8bfd8',
  'tomato': '#ff6347',
  'turquoise': '#40e0d0',
  'violet': '#ee82ee',
  'wheat': '#f5deb3',
  'white': '#fff',
  'whitesmoke': '#f5f5f5',
  'yellow': '#ff0',
  'yellowgreen': '#9acd32'
};
exports.colorsShortNames = {
  '#f0ffff': 'azure',
  '#f5f5dc': 'beige',
  '#ffe4c4': 'bisque',
  '#a52a2a': 'brown',
  '#ff7f50': 'coral',
  '#ffd700': 'gold',
  '#808080': 'gray',
  '#008000': 'green',
  '#4b0082': 'indigo',
  '#fffff0': 'ivory',
  '#f0e68c': 'khaki',
  '#faf0e6': 'linen',
  '#800000': 'maroon',
  '#000080': 'navy',
  '#808000': 'olive',
  '#ffa500': 'orange',
  '#da70d6': 'orchid',
  '#cd853f': 'peru',
  '#ffc0cb': 'pink',
  '#dda0dd': 'plum',
  '#800080': 'purple',
  '#f00': 'red',
  '#ff0000': 'red',
  '#fa8072': 'salmon',
  '#a0522d': 'sienna',
  '#c0c0c0': 'silver',
  '#fffafa': 'snow',
  '#d2b48c': 'tan',
  '#008080': 'teal',
  '#ff6347': 'tomato',
  '#ee82ee': 'violet',
  '#f5deb3': 'wheat'
}; // http://www.w3.org/TR/SVG11/single-page.html#types-DataTypeColor

exports.colorsProps = ['color', 'fill', 'stroke', 'stop-color', 'flood-color', 'lighting-color'];
},{}],"node_modules/svgo/lib/svgo/js2svg.js":[function(require,module,exports) {
'use strict';

var EOL = require('os').EOL,
    textElem = require('../../plugins/_collections.js').elemsGroups.textContent.concat('title');

var defaults = {
  doctypeStart: '<!DOCTYPE',
  doctypeEnd: '>',
  procInstStart: '<?',
  procInstEnd: '?>',
  tagOpenStart: '<',
  tagOpenEnd: '>',
  tagCloseStart: '</',
  tagCloseEnd: '>',
  tagShortStart: '<',
  tagShortEnd: '/>',
  attrStart: '="',
  attrEnd: '"',
  commentStart: '<!--',
  commentEnd: '-->',
  cdataStart: '<![CDATA[',
  cdataEnd: ']]>',
  textStart: '',
  textEnd: '',
  indent: 4,
  regEntities: /[&'"<>]/g,
  regValEntities: /[&"<>]/g,
  encodeEntity: encodeEntity,
  pretty: false,
  useShortTags: true
};
var entities = {
  '&': '&amp;',
  '\'': '&apos;',
  '"': '&quot;',
  '>': '&gt;',
  '<': '&lt;'
};
/**
 * Convert SVG-as-JS object to SVG (XML) string.
 *
 * @param {Object} data input data
 * @param {Object} config config
 *
 * @return {Object} output data
 */

module.exports = function (data, config) {
  return new JS2SVG(config).convert(data);
};

function JS2SVG(config) {
  if (config) {
    this.config = Object.assign({}, defaults, config);
  } else {
    this.config = Object.assign({}, defaults);
  }

  var indent = this.config.indent;

  if (typeof indent == 'number' && !isNaN(indent)) {
    this.config.indent = indent < 0 ? '\t' : ' '.repeat(indent);
  } else if (typeof indent != 'string') {
    this.config.indent = '    ';
  }

  if (this.config.pretty) {
    this.config.doctypeEnd += EOL;
    this.config.procInstEnd += EOL;
    this.config.commentEnd += EOL;
    this.config.cdataEnd += EOL;
    this.config.tagShortEnd += EOL;
    this.config.tagOpenEnd += EOL;
    this.config.tagCloseEnd += EOL;
    this.config.textEnd += EOL;
  }

  this.indentLevel = 0;
  this.textContext = null;
}

function encodeEntity(char) {
  return entities[char];
}
/**
 * Start conversion.
 *
 * @param {Object} data input data
 *
 * @return {String}
 */


JS2SVG.prototype.convert = function (data) {
  var svg = '';

  if (data.content) {
    this.indentLevel++;
    data.content.forEach(function (item) {
      if (item.elem) {
        svg += this.createElem(item);
      } else if (item.text) {
        svg += this.createText(item.text);
      } else if (item.doctype) {
        svg += this.createDoctype(item.doctype);
      } else if (item.processinginstruction) {
        svg += this.createProcInst(item.processinginstruction);
      } else if (item.comment) {
        svg += this.createComment(item.comment);
      } else if (item.cdata) {
        svg += this.createCDATA(item.cdata);
      }
    }, this);
  }

  this.indentLevel--;
  return {
    data: svg,
    info: {
      width: this.width,
      height: this.height
    }
  };
};
/**
 * Create indent string in accordance with the current node level.
 *
 * @return {String}
 */


JS2SVG.prototype.createIndent = function () {
  var indent = '';

  if (this.config.pretty && !this.textContext) {
    indent = this.config.indent.repeat(this.indentLevel - 1);
  }

  return indent;
};
/**
 * Create doctype tag.
 *
 * @param {String} doctype doctype body string
 *
 * @return {String}
 */


JS2SVG.prototype.createDoctype = function (doctype) {
  return this.config.doctypeStart + doctype + this.config.doctypeEnd;
};
/**
 * Create XML Processing Instruction tag.
 *
 * @param {Object} instruction instruction object
 *
 * @return {String}
 */


JS2SVG.prototype.createProcInst = function (instruction) {
  return this.config.procInstStart + instruction.name + ' ' + instruction.body + this.config.procInstEnd;
};
/**
 * Create comment tag.
 *
 * @param {String} comment comment body
 *
 * @return {String}
 */


JS2SVG.prototype.createComment = function (comment) {
  return this.config.commentStart + comment + this.config.commentEnd;
};
/**
 * Create CDATA section.
 *
 * @param {String} cdata CDATA body
 *
 * @return {String}
 */


JS2SVG.prototype.createCDATA = function (cdata) {
  return this.createIndent() + this.config.cdataStart + cdata + this.config.cdataEnd;
};
/**
 * Create element tag.
 *
 * @param {Object} data element object
 *
 * @return {String}
 */


JS2SVG.prototype.createElem = function (data) {
  // beautiful injection for obtaining SVG information :)
  if (data.isElem('svg') && data.hasAttr('width') && data.hasAttr('height')) {
    this.width = data.attr('width').value;
    this.height = data.attr('height').value;
  } // empty element and short tag


  if (data.isEmpty()) {
    if (this.config.useShortTags) {
      return this.createIndent() + this.config.tagShortStart + data.elem + this.createAttrs(data) + this.config.tagShortEnd;
    } else {
      return this.createIndent() + this.config.tagShortStart + data.elem + this.createAttrs(data) + this.config.tagOpenEnd + this.config.tagCloseStart + data.elem + this.config.tagCloseEnd;
    } // non-empty element

  } else {
    var tagOpenStart = this.config.tagOpenStart,
        tagOpenEnd = this.config.tagOpenEnd,
        tagCloseStart = this.config.tagCloseStart,
        tagCloseEnd = this.config.tagCloseEnd,
        openIndent = this.createIndent(),
        textIndent = '',
        processedData = '',
        dataEnd = '';

    if (this.textContext) {
      tagOpenStart = defaults.tagOpenStart;
      tagOpenEnd = defaults.tagOpenEnd;
      tagCloseStart = defaults.tagCloseStart;
      tagCloseEnd = defaults.tagCloseEnd;
      openIndent = '';
    } else if (data.isElem(textElem)) {
      if (this.config.pretty) {
        textIndent += openIndent + this.config.indent;
      }

      this.textContext = data;
    }

    processedData += this.convert(data).data;

    if (this.textContext == data) {
      this.textContext = null;
      if (this.config.pretty) dataEnd = EOL;
    }

    return openIndent + tagOpenStart + data.elem + this.createAttrs(data) + tagOpenEnd + textIndent + processedData + dataEnd + this.createIndent() + tagCloseStart + data.elem + tagCloseEnd;
  }
};
/**
 * Create element attributes.
 *
 * @param {Object} elem attributes object
 *
 * @return {String}
 */


JS2SVG.prototype.createAttrs = function (elem) {
  var attrs = '';
  elem.eachAttr(function (attr) {
    if (attr.value !== undefined) {
      attrs += ' ' + attr.name + this.config.attrStart + String(attr.value).replace(this.config.regValEntities, this.config.encodeEntity) + this.config.attrEnd;
    } else {
      attrs += ' ' + attr.name;
    }
  }, this);
  return attrs;
};
/**
 * Create text node.
 *
 * @param {String} text text
 *
 * @return {String}
 */


JS2SVG.prototype.createText = function (text) {
  return this.createIndent() + this.config.textStart + text.replace(this.config.regEntities, this.config.encodeEntity) + (this.textContext ? '' : this.config.textEnd);
};
},{"os":"node_modules/os-browserify/browser.js","../../plugins/_collections.js":"node_modules/svgo/plugins/_collections.js"}],"node_modules/svgo/lib/svgo.js":[function(require,module,exports) {
'use strict';
/**
 * SVGO is a Nodejs-based tool for optimizing SVG vector graphics files.
 *
 * @see https://github.com/svg/svgo
 *
 * @author Kir Belevich <kir@soulshine.in> (https://github.com/deepsweet)
 * @copyright © 2012 Kir Belevich
 * @license MIT https://raw.githubusercontent.com/svg/svgo/master/LICENSE
 */

var CONFIG = require('./svgo/config.js'),
    SVG2JS = require('./svgo/svg2js.js'),
    PLUGINS = require('./svgo/plugins.js'),
    JSAPI = require('./svgo/jsAPI.js'),
    encodeSVGDatauri = require('./svgo/tools.js').encodeSVGDatauri,
    JS2SVG = require('./svgo/js2svg.js');

var SVGO = function (config) {
  this.config = CONFIG(config);
};

SVGO.prototype.optimize = function (svgstr, info) {
  info = info || {};
  return new Promise((resolve, reject) => {
    if (this.config.error) {
      reject(this.config.error);
      return;
    }

    var config = this.config,
        maxPassCount = config.multipass ? 10 : 1,
        counter = 0,
        prevResultSize = Number.POSITIVE_INFINITY,
        optimizeOnceCallback = svgjs => {
      if (svgjs.error) {
        reject(svgjs.error);
        return;
      }

      info.multipassCount = counter;

      if (++counter < maxPassCount && svgjs.data.length < prevResultSize) {
        prevResultSize = svgjs.data.length;

        this._optimizeOnce(svgjs.data, info, optimizeOnceCallback);
      } else {
        if (config.datauri) {
          svgjs.data = encodeSVGDatauri(svgjs.data, config.datauri);
        }

        if (info && info.path) {
          svgjs.path = info.path;
        }

        resolve(svgjs);
      }
    };

    this._optimizeOnce(svgstr, info, optimizeOnceCallback);
  });
};

SVGO.prototype._optimizeOnce = function (svgstr, info, callback) {
  var config = this.config;
  SVG2JS(svgstr, function (svgjs) {
    if (svgjs.error) {
      callback(svgjs);
      return;
    }

    svgjs = PLUGINS(svgjs, info, config.plugins);
    callback(JS2SVG(svgjs, config.js2svg));
  });
};
/**
 * The factory that creates a content item with the helper methods.
 *
 * @param {Object} data which passed to jsAPI constructor
 * @returns {JSAPI} content item
 */


SVGO.prototype.createContentItem = function (data) {
  return new JSAPI(data);
};

SVGO.Config = CONFIG;
module.exports = SVGO; // Offer ES module interop compatibility.

module.exports.default = SVGO;
},{"./svgo/config.js":"node_modules/svgo/lib/svgo/config.js","./svgo/svg2js.js":"node_modules/svgo/lib/svgo/svg2js.js","./svgo/plugins.js":"node_modules/svgo/lib/svgo/plugins.js","./svgo/jsAPI.js":"node_modules/svgo/lib/svgo/jsAPI.js","./svgo/tools.js":"node_modules/svgo/lib/svgo/tools.js","./svgo/js2svg.js":"node_modules/svgo/lib/svgo/js2svg.js"}],"node_modules/html-comment-regex/index.js":[function(require,module,exports) {
'use strict';
module.exports = /<!--([\s\S]*?)-->/g;

},{}],"node_modules/is-svg/index.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
'use strict';

const htmlCommentRegex = require('html-comment-regex');

function isBinary(buf) {
  const isBuf = Buffer.isBuffer(buf);

  for (let i = 0; i < 24; i++) {
    const charCode = isBuf ? buf[i] : buf.charCodeAt(i);

    if (charCode === 65533 || charCode <= 8) {
      return true;
    }
  }

  return false;
}

const regex = /^\s*(?:<\?xml[^>]*>\s*)?(?:<!doctype svg[^>]*\s*(?:\[?(?:\s*<![^>]*>\s*)*\]?)*[^>]*>\s*)?<svg[^>]*>[^]*<\/svg>\s*$/i;

module.exports = input => Boolean(input) && !isBinary(input) && regex.test(input.toString().replace(htmlCommentRegex, ''));
},{"html-comment-regex":"node_modules/html-comment-regex/index.js","buffer":"node_modules/buffer/index.js"}],"node_modules/postcss-svgo/dist/lib/url.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = encode;

function encode(data) {
  return data.replace(/"/g, '\'').replace(/%/g, '%25').replace(/</g, '%3C').replace(/>/g, '%3E').replace(/&/g, '%26').replace(/#/g, '%23').replace(/\s+/g, ' ');
}

;
var decode = exports.decode = decodeURIComponent;
},{}],"node_modules/postcss-svgo/dist/index.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _svgo = require('svgo');

var _svgo2 = _interopRequireDefault(_svgo);

var _isSvg = require('is-svg');

var _isSvg2 = _interopRequireDefault(_isSvg);

var _url = require('./lib/url');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var PLUGIN = 'postcss-svgo';
var dataURI = /data:image\/svg\+xml(;((charset=)?utf-8|base64))?,/i;
var dataURIBase64 = /data:image\/svg\+xml;base64,/i;

function minifyPromise(decl, getSvgo, opts) {
  var promises = [];
  var parsed = (0, _postcssValueParser2.default)(decl.value);
  decl.value = parsed.walk(function (node) {
    if (node.type !== 'function' || node.value.toLowerCase() !== 'url' || !node.nodes.length) {
      return;
    }

    var _node$nodes$ = node.nodes[0],
        value = _node$nodes$.value,
        quote = _node$nodes$.quote;
    var isBase64, isUriEncoded;
    var svg = value.replace(dataURI, '');

    if (dataURIBase64.test(value)) {
      svg = Buffer.from(svg, 'base64').toString('utf8');
      isBase64 = true;
    } else {
      var decodedUri;

      try {
        decodedUri = (0, _url.decode)(svg);
        isUriEncoded = decodedUri !== svg;
      } catch (e) {
        // Swallow exception if we cannot decode the value
        isUriEncoded = false;
      }

      if (isUriEncoded) {
        svg = decodedUri;
      }

      if (opts.encode !== undefined) {
        isUriEncoded = opts.encode;
      }
    }

    if (!(0, _isSvg2.default)(svg)) {
      return;
    }

    promises.push(getSvgo().optimize(svg).then(function (result) {
      var data, optimizedValue;

      if (isBase64) {
        data = Buffer.from(result.data).toString('base64');
        optimizedValue = 'data:image/svg+xml;base64,' + data;
      } else {
        data = isUriEncoded ? (0, _url.encode)(result.data) : result.data; // Should always encode # otherwise we yield a broken SVG
        // in Firefox (works in Chrome however). See this issue:
        // https://github.com/cssnano/cssnano/issues/245

        data = data.replace(/#/g, '%23');
        optimizedValue = 'data:image/svg+xml;charset=utf-8,' + data;
        quote = isUriEncoded ? '"' : '\'';
      }

      node.nodes[0] = Object.assign({}, node.nodes[0], {
        value: optimizedValue,
        quote: quote,
        type: 'string',
        before: '',
        after: ''
      });
    }).catch(function (error) {
      throw new Error("".concat(PLUGIN, ": ").concat(error));
    }));
    return false;
  });
  return Promise.all(promises).then(function () {
    return decl.value = decl.value.toString();
  });
}

exports.default = _postcss2.default.plugin(PLUGIN, function () {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var svgo = null;

  var getSvgo = function getSvgo() {
    if (!svgo) {
      svgo = new _svgo2.default(opts);
    }

    return svgo;
  };

  return function (css) {
    return new Promise(function (resolve, reject) {
      var svgoQueue = [];
      css.walkDecls(function (decl) {
        if (!dataURI.test(decl.value)) {
          return;
        }

        svgoQueue.push(minifyPromise(decl, getSvgo, opts));
      });
      return Promise.all(svgoQueue).then(resolve, reject);
    });
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","svgo":"node_modules/svgo/lib/svgo.js","is-svg":"node_modules/is-svg/index.js","./lib/url":"node_modules/postcss-svgo/dist/lib/url.js","buffer":"node_modules/buffer/index.js"}],"node_modules/cssnano-util-get-match/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getMatchFactory;

function getMatchFactory(map) {
  return function getMatch(args) {
    var match = args.reduce(function (list, arg, i) {
      return list.filter(function (keyword) {
        return keyword[1][i] === arg;
      });
    }, map);

    if (match.length) {
      return match[0][0];
    }

    return false;
  };
}

module.exports = exports["default"];
},{}],"node_modules/postcss-reduce-transforms/dist/index.js":[function(require,module,exports) {
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _has = require('has');

var _has2 = _interopRequireDefault(_has);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _cssnanoUtilGetMatch = require('cssnano-util-get-match');

var _cssnanoUtilGetMatch2 = _interopRequireDefault(_cssnanoUtilGetMatch);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function getValues(list, _ref, index) {
  var value = _ref.value;

  if (index % 2 === 0) {
    return [].concat(_toConsumableArray(list), [parseFloat(value)]);
  }

  return list;
}

function matrix3d(node, values) {
  // matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1) => matrix(a, b, c, d, tx, ty)
  if (values[15] && values[2] === 0 && values[3] === 0 && values[6] === 0 && values[7] === 0 && values[8] === 0 && values[9] === 0 && values[10] === 1 && values[11] === 0 && values[14] === 0 && values[15] === 1) {
    var nodes = node.nodes;
    node.value = 'matrix';
    node.nodes = [nodes[0], // a
    nodes[1], // ,
    nodes[2], // b
    nodes[3], // ,
    nodes[8], // c
    nodes[9], // ,
    nodes[10], // d
    nodes[11], // ,
    nodes[24], // tx
    nodes[25], // ,
    nodes[26]];
  }
}

var rotate3dMappings = [['rotateX', [1, 0, 0]], // rotate3d(1, 0, 0, a) => rotateX(a)
['rotateY', [0, 1, 0]], // rotate3d(0, 1, 0, a) => rotateY(a)
['rotate', [0, 0, 1]]];
var rotate3dMatch = (0, _cssnanoUtilGetMatch2.default)(rotate3dMappings);

function rotate3d(node, values) {
  var nodes = node.nodes;
  var match = rotate3dMatch(values.slice(0, 3));

  if (match.length) {
    node.value = match;
    node.nodes = [nodes[6]];
  }
}

function rotateZ(node) {
  // rotateZ(rz) => rotate(rz)
  node.value = 'rotate';
}

function scale(node, values) {
  var nodes = node.nodes;

  if (!nodes[2]) {
    return;
  }

  var _values = _slicedToArray(values, 2),
      first = _values[0],
      second = _values[1]; // scale(sx, sy) => scale(sx)


  if (first === second) {
    node.nodes = [nodes[0]];
    return;
  } // scale(sx, 1) => scaleX(sx)


  if (second === 1) {
    node.value = 'scaleX';
    node.nodes = [nodes[0]];
    return;
  } // scale(1, sy) => scaleY(sy)


  if (first === 1) {
    node.value = 'scaleY';
    node.nodes = [nodes[2]];
    return;
  }
}

function scale3d(node, values) {
  var nodes = node.nodes;

  var _values2 = _slicedToArray(values, 3),
      first = _values2[0],
      second = _values2[1],
      third = _values2[2]; // scale3d(sx, 1, 1) => scaleX(sx)


  if (second === 1 && third === 1) {
    node.value = 'scaleX';
    node.nodes = [nodes[0]];
    return;
  } // scale3d(1, sy, 1) => scaleY(sy)


  if (first === 1 && third === 1) {
    node.value = 'scaleY';
    node.nodes = [nodes[2]];
    return;
  } // scale3d(1, 1, sz) => scaleZ(sz)


  if (first === 1 && second === 1) {
    node.value = 'scaleZ';
    node.nodes = [nodes[4]];
    return;
  }
}

function translate(node, values) {
  var nodes = node.nodes;

  if (!nodes[2]) {
    return;
  } // translate(tx, 0) => translate(tx)


  if (values[1] === 0) {
    node.nodes = [nodes[0]];
    return;
  } // translate(0, ty) => translateY(ty)


  if (values[0] === 0) {
    node.value = 'translateY';
    node.nodes = [nodes[2]];
    return;
  }
}

function translate3d(node, values) {
  var nodes = node.nodes; // translate3d(0, 0, tz) => translateZ(tz)

  if (values[0] === 0 && values[1] === 0) {
    node.value = 'translateZ';
    node.nodes = [nodes[4]];
  }
}

var reducers = {
  matrix3d: matrix3d,
  rotate3d: rotate3d,
  rotateZ: rotateZ,
  scale: scale,
  scale3d: scale3d,
  translate: translate,
  translate3d: translate3d
};

function normalizeReducerName(name) {
  var lowerCasedName = name.toLowerCase();

  if (lowerCasedName === 'rotatez') {
    return 'rotateZ';
  }

  return lowerCasedName;
}

function reduce(node) {
  var nodes = node.nodes,
      type = node.type,
      value = node.value;
  var normalizedReducerName = normalizeReducerName(value);

  if (type === 'function' && (0, _has2.default)(reducers, normalizedReducerName)) {
    reducers[normalizedReducerName](node, nodes.reduce(getValues, []));
  }

  return false;
}

exports.default = _postcss2.default.plugin('postcss-reduce-transforms', function () {
  return function (css) {
    var cache = {};
    css.walkDecls(/transform$/i, function (decl) {
      var value = decl.value;

      if (cache[value]) {
        decl.value = cache[value];
        return;
      }

      var result = (0, _postcssValueParser2.default)(value).walk(reduce).toString();
      decl.value = result;
      cache[value] = result;
    });
  };
});
module.exports = exports['default'];
},{"has":"node_modules/has/src/index.js","postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","cssnano-util-get-match":"node_modules/cssnano-util-get-match/dist/index.js"}],"node_modules/postcss-convert-values/dist/lib/convert.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (number, unit, _ref) {
  var time = _ref.time,
      length = _ref.length,
      angle = _ref.angle;
  var value = dropLeadingZero(number) + (unit ? unit : '');
  var converted;

  if (length !== false && unit.toLowerCase() in lengthConv) {
    converted = transform(number, unit, lengthConv);
  }

  if (time !== false && unit.toLowerCase() in timeConv) {
    converted = transform(number, unit, timeConv);
  }

  if (angle !== false && unit.toLowerCase() in angleConv) {
    converted = transform(number, unit, angleConv);
  }

  if (converted && converted.length < value.length) {
    value = converted;
  }

  return value;
};

var lengthConv = {
  in: 96,
  px: 1,
  pt: 4 / 3,
  pc: 16
};
var timeConv = {
  s: 1000,
  ms: 1
};
var angleConv = {
  turn: 360,
  deg: 1
};

function dropLeadingZero(number) {
  var value = String(number);

  if (number % 1) {
    if (value[0] === '0') {
      return value.slice(1);
    }

    if (value[0] === '-' && value[1] === '0') {
      return '-' + value.slice(2);
    }
  }

  return value;
}

function transform(number, unit, conversion) {
  var lowerCasedUnit = unit.toLowerCase();
  var one, base;
  var convertionUnits = Object.keys(conversion).filter(function (u) {
    if (conversion[u] === 1) {
      one = u;
    }

    return lowerCasedUnit !== u;
  });

  if (lowerCasedUnit === one) {
    base = number / conversion[lowerCasedUnit];
  } else {
    base = number * conversion[lowerCasedUnit];
  }

  return convertionUnits.map(function (u) {
    return dropLeadingZero(base / conversion[u]) + u;
  }).reduce(function (a, b) {
    return a.length < b.length ? a : b;
  });
}

module.exports = exports['default'];
},{}],"node_modules/postcss-convert-values/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _convert = require('./lib/convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var LENGTH_UNITS = ['em', 'ex', 'ch', 'rem', 'vw', 'vh', 'vmin', 'vmax', 'cm', 'mm', 'q', 'in', 'pt', 'pc', 'px'];

function parseWord(node, opts, keepZeroUnit) {
  var pair = (0, _postcssValueParser.unit)(node.value);

  if (pair) {
    var num = Number(pair.number);
    var u = pair.unit;

    if (num === 0) {
      node.value = keepZeroUnit || !~LENGTH_UNITS.indexOf(u.toLowerCase()) && u !== '%' ? 0 + u : 0;
    } else {
      node.value = (0, _convert2.default)(num, u, opts);

      if (typeof opts.precision === 'number' && u.toLowerCase() === 'px' && ~pair.number.indexOf('.')) {
        var precision = Math.pow(10, opts.precision);
        node.value = Math.round(parseFloat(node.value) * precision) / precision + u;
      }
    }
  }
}

function clampOpacity(node) {
  var pair = (0, _postcssValueParser.unit)(node.value);

  if (!pair) {
    return;
  }

  var num = Number(pair.number);

  if (num > 1) {
    node.value = 1 + pair.unit;
  } else if (num < 0) {
    node.value = 0 + pair.unit;
  }
}

function shouldStripPercent(decl) {
  var parent = decl.parent;
  var lowerCasedProp = decl.prop.toLowerCase();
  return ~decl.value.indexOf('%') && (lowerCasedProp === 'max-height' || lowerCasedProp === 'height') || parent.parent && parent.parent.name && parent.parent.name.toLowerCase() === 'keyframes' && lowerCasedProp === 'stroke-dasharray' || lowerCasedProp === 'stroke-dashoffset' || lowerCasedProp === 'stroke-width';
}

function transform(opts, decl) {
  var lowerCasedProp = decl.prop.toLowerCase();

  if (~lowerCasedProp.indexOf('flex') || lowerCasedProp.indexOf('--') === 0) {
    return;
  }

  decl.value = (0, _postcssValueParser2.default)(decl.value).walk(function (node) {
    var lowerCasedValue = node.value.toLowerCase();

    if (node.type === 'word') {
      parseWord(node, opts, shouldStripPercent(decl));

      if (lowerCasedProp === 'opacity' || lowerCasedProp === 'shape-image-threshold') {
        clampOpacity(node);
      }
    } else if (node.type === 'function') {
      if (lowerCasedValue === 'calc' || lowerCasedValue === 'hsl' || lowerCasedValue === 'hsla') {
        (0, _postcssValueParser.walk)(node.nodes, function (n) {
          if (n.type === 'word') {
            parseWord(n, opts, true);
          }
        });
        return false;
      }

      if (lowerCasedValue === 'url') {
        return false;
      }
    }
  }).toString();
}

var plugin = 'postcss-convert-values';
exports.default = _postcss2.default.plugin(plugin, function () {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    precision: false
  };
  return function (css) {
    return css.walkDecls(transform.bind(null, opts));
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","./lib/convert":"node_modules/postcss-convert-values/dist/lib/convert.js"}],"node_modules/indexes-of/index.js":[function(require,module,exports) {
module.exports = function (ary, item) {
  var i = -1, indexes = []
  while((i = ary.indexOf(item, i + 1)) !== -1)
    indexes.push(i)
  return indexes
}

},{}],"node_modules/uniq/uniq.js":[function(require,module,exports) {
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/util/unesc.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = unesc;
var whitespace = '[\\x20\\t\\r\\n\\f]';
var unescapeRegExp = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig');

function unesc(str) {
  return str.replace(unescapeRegExp, function (_, escaped, escapedWhitespace) {
    var high = '0x' + escaped - 0x10000; // NaN means non-codepoint
    // Workaround erroneous numeric interpretation of +"0x"
    // eslint-disable-next-line no-self-compare

    return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint
    String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);
  });
}

module.exports = exports.default;
},{}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/util/getProp.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = getProp;

function getProp(obj) {
  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    props[_key - 1] = arguments[_key];
  }

  while (props.length > 0) {
    var prop = props.shift();

    if (!obj[prop]) {
      return undefined;
    }

    obj = obj[prop];
  }

  return obj;
}

module.exports = exports.default;
},{}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/util/ensureObject.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = ensureObject;

function ensureObject(obj) {
  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    props[_key - 1] = arguments[_key];
  }

  while (props.length > 0) {
    var prop = props.shift();

    if (!obj[prop]) {
      obj[prop] = {};
    }

    obj = obj[prop];
  }
}

module.exports = exports.default;
},{}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/util/stripComments.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = stripComments;

function stripComments(str) {
  var s = "";
  var commentStart = str.indexOf("/*");
  var lastEnd = 0;

  while (commentStart >= 0) {
    s = s + str.slice(lastEnd, commentStart);
    var commentEnd = str.indexOf("*/", commentStart + 2);

    if (commentEnd < 0) {
      return s;
    }

    lastEnd = commentEnd + 2;
    commentStart = str.indexOf("/*", lastEnd);
  }

  s = s + str.slice(lastEnd);
  return s;
}

module.exports = exports.default;
},{}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/util/index.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.stripComments = exports.ensureObject = exports.getProp = exports.unesc = void 0;

var _unesc = _interopRequireDefault(require("./unesc"));

exports.unesc = _unesc.default;

var _getProp = _interopRequireDefault(require("./getProp"));

exports.getProp = _getProp.default;

var _ensureObject = _interopRequireDefault(require("./ensureObject"));

exports.ensureObject = _ensureObject.default;

var _stripComments = _interopRequireDefault(require("./stripComments"));

exports.stripComments = _stripComments.default;

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
},{"./unesc":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/util/unesc.js","./getProp":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/util/getProp.js","./ensureObject":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/util/ensureObject.js","./stripComments":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/util/stripComments.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/node.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.default = void 0;

var _util = require("../util");

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var cloneNode = function cloneNode(obj, parent) {
  if (_typeof(obj) !== 'object' || obj === null) {
    return obj;
  }

  var cloned = new obj.constructor();

  for (var i in obj) {
    if (!obj.hasOwnProperty(i)) {
      continue;
    }

    var value = obj[i];

    var type = _typeof(value);

    if (i === 'parent' && type === 'object') {
      if (parent) {
        cloned[i] = parent;
      }
    } else if (value instanceof Array) {
      cloned[i] = value.map(function (j) {
        return cloneNode(j, cloned);
      });
    } else {
      cloned[i] = cloneNode(value, cloned);
    }
  }

  return cloned;
};

var Node = /*#__PURE__*/function () {
  function Node(opts) {
    if (opts === void 0) {
      opts = {};
    }

    Object.assign(this, opts);
    this.spaces = this.spaces || {};
    this.spaces.before = this.spaces.before || '';
    this.spaces.after = this.spaces.after || '';
  }

  var _proto = Node.prototype;

  _proto.remove = function remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }

    this.parent = undefined;
    return this;
  };

  _proto.replaceWith = function replaceWith() {
    if (this.parent) {
      for (var index in arguments) {
        this.parent.insertBefore(this, arguments[index]);
      }

      this.remove();
    }

    return this;
  };

  _proto.next = function next() {
    return this.parent.at(this.parent.index(this) + 1);
  };

  _proto.prev = function prev() {
    return this.parent.at(this.parent.index(this) - 1);
  };

  _proto.clone = function clone(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    var cloned = cloneNode(this);

    for (var name in overrides) {
      cloned[name] = overrides[name];
    }

    return cloned;
  }
  /**
   * Some non-standard syntax doesn't follow normal escaping rules for css.
   * This allows non standard syntax to be appended to an existing property
   * by specifying the escaped value. By specifying the escaped value,
   * illegal characters are allowed to be directly inserted into css output.
   * @param {string} name the property to set
   * @param {any} value the unescaped value of the property
   * @param {string} valueEscaped optional. the escaped value of the property.
   */
  ;

  _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
    if (!this.raws) {
      this.raws = {};
    }

    var originalValue = this[name];
    var originalEscaped = this.raws[name];
    this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.

    if (originalEscaped || valueEscaped !== value) {
      this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
    } else {
      delete this.raws[name]; // delete any escaped value that was created by the setter.
    }
  }
  /**
   * Some non-standard syntax doesn't follow normal escaping rules for css.
   * This allows the escaped value to be specified directly, allowing illegal
   * characters to be directly inserted into css output.
   * @param {string} name the property to set
   * @param {any} value the unescaped value of the property
   * @param {string} valueEscaped the escaped value of the property.
   */
  ;

  _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
    if (!this.raws) {
      this.raws = {};
    }

    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

    this.raws[name] = valueEscaped;
  }
  /**
   * When you want a value to passed through to CSS directly. This method
   * deletes the corresponding raw value causing the stringifier to fallback
   * to the unescaped value.
   * @param {string} name the property to set.
   * @param {any} value The value that is both escaped and unescaped.
   */
  ;

  _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

    if (this.raws) {
      delete this.raws[name];
    }
  }
  /**
   * 
   * @param {number} line The number (starting with 1)
   * @param {number} column The column number (starting with 1)
   */
  ;

  _proto.isAtPosition = function isAtPosition(line, column) {
    if (this.source && this.source.start && this.source.end) {
      if (this.source.start.line > line) {
        return false;
      }

      if (this.source.end.line < line) {
        return false;
      }

      if (this.source.start.line === line && this.source.start.column > column) {
        return false;
      }

      if (this.source.end.line === line && this.source.end.column < column) {
        return false;
      }

      return true;
    }

    return undefined;
  };

  _proto.stringifyProperty = function stringifyProperty(name) {
    return this.raws && this.raws[name] || this[name];
  };

  _proto.toString = function toString() {
    return [this.rawSpaceBefore, String(this.stringifyProperty("value")), this.rawSpaceAfter].join('');
  };

  _createClass(Node, [{
    key: "rawSpaceBefore",
    get: function get() {
      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;

      if (rawSpace === undefined) {
        rawSpace = this.spaces && this.spaces.before;
      }

      return rawSpace || "";
    },
    set: function set(raw) {
      (0, _util.ensureObject)(this, "raws", "spaces");
      this.raws.spaces.before = raw;
    }
  }, {
    key: "rawSpaceAfter",
    get: function get() {
      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;

      if (rawSpace === undefined) {
        rawSpace = this.spaces.after;
      }

      return rawSpace || "";
    },
    set: function set(raw) {
      (0, _util.ensureObject)(this, "raws", "spaces");
      this.raws.spaces.after = raw;
    }
  }]);

  return Node;
}();

exports.default = Node;
module.exports = exports.default;
},{"../util":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/util/index.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.UNIVERSAL = exports.ATTRIBUTE = exports.CLASS = exports.COMBINATOR = exports.COMMENT = exports.ID = exports.NESTING = exports.PSEUDO = exports.ROOT = exports.SELECTOR = exports.STRING = exports.TAG = void 0;
var TAG = 'tag';
exports.TAG = TAG;
var STRING = 'string';
exports.STRING = STRING;
var SELECTOR = 'selector';
exports.SELECTOR = SELECTOR;
var ROOT = 'root';
exports.ROOT = ROOT;
var PSEUDO = 'pseudo';
exports.PSEUDO = PSEUDO;
var NESTING = 'nesting';
exports.NESTING = NESTING;
var ID = 'id';
exports.ID = ID;
var COMMENT = 'comment';
exports.COMMENT = COMMENT;
var COMBINATOR = 'combinator';
exports.COMBINATOR = COMBINATOR;
var CLASS = 'class';
exports.CLASS = CLASS;
var ATTRIBUTE = 'attribute';
exports.ATTRIBUTE = ATTRIBUTE;
var UNIVERSAL = 'universal';
exports.UNIVERSAL = UNIVERSAL;
},{}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/container.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(require("./node"));

var types = _interopRequireWildcard(require("./types"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var Container = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Container, _Node);

  function Container(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;

    if (!_this.nodes) {
      _this.nodes = [];
    }

    return _this;
  }

  var _proto = Container.prototype;

  _proto.append = function append(selector) {
    selector.parent = this;
    this.nodes.push(selector);
    return this;
  };

  _proto.prepend = function prepend(selector) {
    selector.parent = this;
    this.nodes.unshift(selector);
    return this;
  };

  _proto.at = function at(index) {
    return this.nodes[index];
  };

  _proto.index = function index(child) {
    if (typeof child === 'number') {
      return child;
    }

    return this.nodes.indexOf(child);
  };

  _proto.removeChild = function removeChild(child) {
    child = this.index(child);
    this.at(child).parent = undefined;
    this.nodes.splice(child, 1);
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index >= child) {
        this.indexes[id] = index - 1;
      }
    }

    return this;
  };

  _proto.removeAll = function removeAll() {
    for (var _iterator = this.nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var node = _ref;
      node.parent = undefined;
    }

    this.nodes = [];
    return this;
  };

  _proto.empty = function empty() {
    return this.removeAll();
  };

  _proto.insertAfter = function insertAfter(oldNode, newNode) {
    newNode.parent = this;
    var oldIndex = this.index(oldNode);
    this.nodes.splice(oldIndex + 1, 0, newNode);
    newNode.parent = this;
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (oldIndex <= index) {
        this.indexes[id] = index + 1;
      }
    }

    return this;
  };

  _proto.insertBefore = function insertBefore(oldNode, newNode) {
    newNode.parent = this;
    var oldIndex = this.index(oldNode);
    this.nodes.splice(oldIndex, 0, newNode);
    newNode.parent = this;
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index <= oldIndex) {
        this.indexes[id] = index + 1;
      }
    }

    return this;
  };

  _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
    var found = undefined;
    this.each(function (node) {
      if (node.atPosition) {
        var foundChild = node.atPosition(line, col);

        if (foundChild) {
          found = foundChild;
          return false;
        }
      } else if (node.isAtPosition(line, col)) {
        found = node;
        return false;
      }
    });
    return found;
  }
  /**
   * Return the most specific node at the line and column number given.
   * The source location is based on the original parsed location, locations aren't
   * updated as selector nodes are mutated.
   * 
   * Note that this location is relative to the location of the first character
   * of the selector, and not the location of the selector in the overall document
   * when used in conjunction with postcss.
   *
   * If not found, returns undefined.
   * @param {number} line The line number of the node to find. (1-based index)
   * @param {number} col  The column number of the node to find. (1-based index)
   */
  ;

  _proto.atPosition = function atPosition(line, col) {
    if (this.isAtPosition(line, col)) {
      return this._findChildAtPosition(line, col) || this;
    } else {
      return undefined;
    }
  };

  _proto._inferEndPosition = function _inferEndPosition() {
    if (this.last && this.last.source && this.last.source.end) {
      this.source = this.source || {};
      this.source.end = this.source.end || {};
      Object.assign(this.source.end, this.last.source.end);
    }
  };

  _proto.each = function each(callback) {
    if (!this.lastEach) {
      this.lastEach = 0;
    }

    if (!this.indexes) {
      this.indexes = {};
    }

    this.lastEach++;
    var id = this.lastEach;
    this.indexes[id] = 0;

    if (!this.length) {
      return undefined;
    }

    var index, result;

    while (this.indexes[id] < this.length) {
      index = this.indexes[id];
      result = callback(this.at(index), index);

      if (result === false) {
        break;
      }

      this.indexes[id] += 1;
    }

    delete this.indexes[id];

    if (result === false) {
      return false;
    }
  };

  _proto.walk = function walk(callback) {
    return this.each(function (node, i) {
      var result = callback(node, i);

      if (result !== false && node.length) {
        result = node.walk(callback);
      }

      if (result === false) {
        return false;
      }
    });
  };

  _proto.walkAttributes = function walkAttributes(callback) {
    var _this2 = this;

    return this.walk(function (selector) {
      if (selector.type === types.ATTRIBUTE) {
        return callback.call(_this2, selector);
      }
    });
  };

  _proto.walkClasses = function walkClasses(callback) {
    var _this3 = this;

    return this.walk(function (selector) {
      if (selector.type === types.CLASS) {
        return callback.call(_this3, selector);
      }
    });
  };

  _proto.walkCombinators = function walkCombinators(callback) {
    var _this4 = this;

    return this.walk(function (selector) {
      if (selector.type === types.COMBINATOR) {
        return callback.call(_this4, selector);
      }
    });
  };

  _proto.walkComments = function walkComments(callback) {
    var _this5 = this;

    return this.walk(function (selector) {
      if (selector.type === types.COMMENT) {
        return callback.call(_this5, selector);
      }
    });
  };

  _proto.walkIds = function walkIds(callback) {
    var _this6 = this;

    return this.walk(function (selector) {
      if (selector.type === types.ID) {
        return callback.call(_this6, selector);
      }
    });
  };

  _proto.walkNesting = function walkNesting(callback) {
    var _this7 = this;

    return this.walk(function (selector) {
      if (selector.type === types.NESTING) {
        return callback.call(_this7, selector);
      }
    });
  };

  _proto.walkPseudos = function walkPseudos(callback) {
    var _this8 = this;

    return this.walk(function (selector) {
      if (selector.type === types.PSEUDO) {
        return callback.call(_this8, selector);
      }
    });
  };

  _proto.walkTags = function walkTags(callback) {
    var _this9 = this;

    return this.walk(function (selector) {
      if (selector.type === types.TAG) {
        return callback.call(_this9, selector);
      }
    });
  };

  _proto.walkUniversals = function walkUniversals(callback) {
    var _this10 = this;

    return this.walk(function (selector) {
      if (selector.type === types.UNIVERSAL) {
        return callback.call(_this10, selector);
      }
    });
  };

  _proto.split = function split(callback) {
    var _this11 = this;

    var current = [];
    return this.reduce(function (memo, node, index) {
      var split = callback.call(_this11, node);
      current.push(node);

      if (split) {
        memo.push(current);
        current = [];
      } else if (index === _this11.length - 1) {
        memo.push(current);
      }

      return memo;
    }, []);
  };

  _proto.map = function map(callback) {
    return this.nodes.map(callback);
  };

  _proto.reduce = function reduce(callback, memo) {
    return this.nodes.reduce(callback, memo);
  };

  _proto.every = function every(callback) {
    return this.nodes.every(callback);
  };

  _proto.some = function some(callback) {
    return this.nodes.some(callback);
  };

  _proto.filter = function filter(callback) {
    return this.nodes.filter(callback);
  };

  _proto.sort = function sort(callback) {
    return this.nodes.sort(callback);
  };

  _proto.toString = function toString() {
    return this.map(String).join('');
  };

  _createClass(Container, [{
    key: "first",
    get: function get() {
      return this.at(0);
    }
  }, {
    key: "last",
    get: function get() {
      return this.at(this.length - 1);
    }
  }, {
    key: "length",
    get: function get() {
      return this.nodes.length;
    }
  }]);

  return Container;
}(_node.default);

exports.default = Container;
module.exports = exports.default;
},{"./node":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/node.js","./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/root.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(require("./container"));

var _types = require("./types");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var Root = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Root, _Container);

  function Root(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.ROOT;
    return _this;
  }

  var _proto = Root.prototype;

  _proto.toString = function toString() {
    var str = this.reduce(function (memo, selector) {
      memo.push(String(selector));
      return memo;
    }, []).join(',');
    return this.trailingComma ? str + ',' : str;
  };

  _proto.error = function error(message, options) {
    if (this._error) {
      return this._error(message, options);
    } else {
      return new Error(message);
    }
  };

  _createClass(Root, [{
    key: "errorGenerator",
    set: function set(handler) {
      this._error = handler;
    }
  }]);

  return Root;
}(_container.default);

exports.default = Root;
module.exports = exports.default;
},{"./container":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/container.js","./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/selector.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(require("./container"));

var _types = require("./types");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var Selector = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Selector, _Container);

  function Selector(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.SELECTOR;
    return _this;
  }

  return Selector;
}(_container.default);

exports.default = Selector;
module.exports = exports.default;
},{"./container":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/container.js","./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/cssesc/cssesc.js":[function(require,module,exports) {
/*! https://mths.be/cssesc v3.0.0 by @mathias */
'use strict';

var object = {};
var hasOwnProperty = object.hasOwnProperty;

var merge = function merge(options, defaults) {
  if (!options) {
    return defaults;
  }

  var result = {};

  for (var key in defaults) {
    // `if (defaults.hasOwnProperty(key) { … }` is not needed here, since
    // only recognized option names are used.
    result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
  }

  return result;
};

var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexAlwaysEscape = /['"\\]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g; // https://mathiasbynens.be/notes/css-escapes#css

var cssesc = function cssesc(string, options) {
  options = merge(options, cssesc.options);

  if (options.quotes != 'single' && options.quotes != 'double') {
    options.quotes = 'single';
  }

  var quote = options.quotes == 'double' ? '"' : '\'';
  var isIdentifier = options.isIdentifier;
  var firstChar = string.charAt(0);
  var output = '';
  var counter = 0;
  var length = string.length;

  while (counter < length) {
    var character = string.charAt(counter++);
    var codePoint = character.charCodeAt();
    var value = void 0; // If it’s not a printable ASCII character…

    if (codePoint < 0x20 || codePoint > 0x7E) {
      if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
        // It’s a high surrogate, and there is a next character.
        var extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // next character is low surrogate
          codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
        } else {
          // It’s an unmatched surrogate; only append this code unit, in case
          // the next code unit is the high surrogate of a surrogate pair.
          counter--;
        }
      }

      value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
    } else {
      if (options.escapeEverything) {
        if (regexAnySingleEscape.test(character)) {
          value = '\\' + character;
        } else {
          value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
        }
      } else if (/[\t\n\f\r\x0B]/.test(character)) {
        value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
      } else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
        value = '\\' + character;
      } else {
        value = character;
      }
    }

    output += value;
  }

  if (isIdentifier) {
    if (/^-[-\d]/.test(output)) {
      output = '\\-' + output.slice(1);
    } else if (/\d/.test(firstChar)) {
      output = '\\3' + firstChar + ' ' + output.slice(1);
    }
  } // Remove spaces after `\HEX` escapes that are not followed by a hex digit,
  // since they’re redundant. Note that this is only possible if the escape
  // sequence isn’t preceded by an odd number of backslashes.


  output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {
    if ($1 && $1.length % 2) {
      // It’s not safe to remove the space, so don’t.
      return $0;
    } // Strip the space.


    return ($1 || '') + $2;
  });

  if (!isIdentifier && options.wrap) {
    return quote + output + quote;
  }

  return output;
}; // Expose default options (so they can be overridden globally).


cssesc.options = {
  'escapeEverything': false,
  'isIdentifier': false,
  'quotes': 'single',
  'wrap': false
};
cssesc.version = '3.0.0';
module.exports = cssesc;
},{}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/className.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _cssesc = _interopRequireDefault(require("cssesc"));

var _util = require("../util");

var _node = _interopRequireDefault(require("./node"));

var _types = require("./types");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var ClassName = /*#__PURE__*/function (_Node) {
  _inheritsLoose(ClassName, _Node);

  function ClassName(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.CLASS;
    _this._constructed = true;
    return _this;
  }

  var _proto = ClassName.prototype;

  _proto.toString = function toString() {
    return [this.rawSpaceBefore, String('.' + this.stringifyProperty("value")), this.rawSpaceAfter].join('');
  };

  _createClass(ClassName, [{
    key: "value",
    set: function set(v) {
      if (this._constructed) {
        var escaped = (0, _cssesc.default)(v, {
          isIdentifier: true
        });

        if (escaped !== v) {
          (0, _util.ensureObject)(this, "raws");
          this.raws.value = escaped;
        } else if (this.raws) {
          delete this.raws.value;
        }
      }

      this._value = v;
    },
    get: function get() {
      return this._value;
    }
  }]);

  return ClassName;
}(_node.default);

exports.default = ClassName;
module.exports = exports.default;
},{"cssesc":"node_modules/cssesc/cssesc.js","../util":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/util/index.js","./node":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/node.js","./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/comment.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(require("./node"));

var _types = require("./types");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var Comment = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Comment, _Node);

  function Comment(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.COMMENT;
    return _this;
  }

  return Comment;
}(_node.default);

exports.default = Comment;
module.exports = exports.default;
},{"./node":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/node.js","./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/id.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(require("./node"));

var _types = require("./types");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var ID = /*#__PURE__*/function (_Node) {
  _inheritsLoose(ID, _Node);

  function ID(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.ID;
    return _this;
  }

  var _proto = ID.prototype;

  _proto.toString = function toString() {
    return [this.rawSpaceBefore, String('#' + this.stringifyProperty("value")), this.rawSpaceAfter].join('');
  };

  return ID;
}(_node.default);

exports.default = ID;
module.exports = exports.default;
},{"./node":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/node.js","./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/namespace.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _cssesc = _interopRequireDefault(require("cssesc"));

var _util = require("../util");

var _node = _interopRequireDefault(require("./node"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var Namespace = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Namespace, _Node);

  function Namespace() {
    return _Node.apply(this, arguments) || this;
  }

  var _proto = Namespace.prototype;

  _proto.qualifiedName = function qualifiedName(value) {
    if (this.namespace) {
      return this.namespaceString + "|" + value;
    } else {
      return value;
    }
  };

  _proto.toString = function toString() {
    return [this.rawSpaceBefore, this.qualifiedName(this.stringifyProperty("value")), this.rawSpaceAfter].join('');
  };

  _createClass(Namespace, [{
    key: "namespace",
    get: function get() {
      return this._namespace;
    },
    set: function set(namespace) {
      if (namespace === true || namespace === "*" || namespace === "&") {
        this._namespace = namespace;

        if (this.raws) {
          delete this.raws.namespace;
        }

        return;
      }

      var escaped = (0, _cssesc.default)(namespace, {
        isIdentifier: true
      });
      this._namespace = namespace;

      if (escaped !== namespace) {
        (0, _util.ensureObject)(this, "raws");
        this.raws.namespace = escaped;
      } else if (this.raws) {
        delete this.raws.namespace;
      }
    }
  }, {
    key: "ns",
    get: function get() {
      return this._namespace;
    },
    set: function set(namespace) {
      this.namespace = namespace;
    }
  }, {
    key: "namespaceString",
    get: function get() {
      if (this.namespace) {
        var ns = this.stringifyProperty("namespace");

        if (ns === true) {
          return '';
        } else {
          return ns;
        }
      } else {
        return '';
      }
    }
  }]);

  return Namespace;
}(_node.default);

exports.default = Namespace;
;
module.exports = exports.default;
},{"cssesc":"node_modules/cssesc/cssesc.js","../util":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/util/index.js","./node":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/node.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/tag.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _namespace = _interopRequireDefault(require("./namespace"));

var _types = require("./types");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var Tag = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Tag, _Namespace);

  function Tag(opts) {
    var _this;

    _this = _Namespace.call(this, opts) || this;
    _this.type = _types.TAG;
    return _this;
  }

  return Tag;
}(_namespace.default);

exports.default = Tag;
module.exports = exports.default;
},{"./namespace":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/namespace.js","./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/string.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(require("./node"));

var _types = require("./types");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var String = /*#__PURE__*/function (_Node) {
  _inheritsLoose(String, _Node);

  function String(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.STRING;
    return _this;
  }

  return String;
}(_node.default);

exports.default = String;
module.exports = exports.default;
},{"./node":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/node.js","./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/pseudo.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(require("./container"));

var _types = require("./types");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var Pseudo = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Pseudo, _Container);

  function Pseudo(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.PSEUDO;
    return _this;
  }

  var _proto = Pseudo.prototype;

  _proto.toString = function toString() {
    var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
    return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join('');
  };

  return Pseudo;
}(_container.default);

exports.default = Pseudo;
module.exports = exports.default;
},{"./container":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/container.js","./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/util/support/isBufferBrowser.js":[function(require,module,exports) {
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"node_modules/util/node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"node_modules/util/util.js":[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};

  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }

  return descriptors;
};

var formatRegExp = /%[sdj%]/g;

exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
}; // Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.


exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  } // Allow for deprecating things in the process of starting up.


  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;

exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = undefined || '';
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;

      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/


function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function isArray(ar) {
  return Array.isArray(ar);
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */


exports.inherits = require('inherits');

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];

    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }

    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};

exports.promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }

  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  } // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.


  function callbackified() {
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();

    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }

    var self = this;

    var cb = function () {
      return maybeCb.apply(self, arguments);
    }; // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)


    original.apply(this, args).then(function (ret) {
      process.nextTick(cb, null, ret);
    }, function (rej) {
      process.nextTick(callbackifyOnRejected, rej, cb);
    });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}

exports.callbackify = callbackify;
},{"./support/isBuffer":"node_modules/util/support/isBufferBrowser.js","inherits":"node_modules/util/node_modules/inherits/inherits_browser.js","process":"node_modules/process/browser.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/attribute.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.unescapeValue = unescapeValue;
exports.default = void 0;

var _cssesc = _interopRequireDefault(require("cssesc"));

var _unesc = _interopRequireDefault(require("../util/unesc"));

var _namespace = _interopRequireDefault(require("./namespace"));

var _types = require("./types");

var _CSSESC_QUOTE_OPTIONS;

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var _require = require("util"),
    deprecate = _require.deprecate;

var WRAPPED_IN_QUOTES = /^('|")(.*)\1$/;
var warnOfDeprecatedValueAssignment = deprecate(function () {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. " + "Call attribute.setValue() instead.");
var warnOfDeprecatedQuotedAssignment = deprecate(function () {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
var warnOfDeprecatedConstructor = deprecate(function () {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");

function unescapeValue(value) {
  var deprecatedUsage = false;
  var quoteMark = null;
  var unescaped = value;
  var m = unescaped.match(WRAPPED_IN_QUOTES);

  if (m) {
    quoteMark = m[1];
    unescaped = m[2];
  }

  unescaped = (0, _unesc.default)(unescaped);

  if (unescaped !== value) {
    deprecatedUsage = true;
  }

  return {
    deprecatedUsage: deprecatedUsage,
    unescaped: unescaped,
    quoteMark: quoteMark
  };
}

function handleDeprecatedContructorOpts(opts) {
  if (opts.quoteMark !== undefined) {
    return opts;
  }

  if (opts.value === undefined) {
    return opts;
  }

  warnOfDeprecatedConstructor();

  var _unescapeValue = unescapeValue(opts.value),
      quoteMark = _unescapeValue.quoteMark,
      unescaped = _unescapeValue.unescaped;

  if (!opts.raws) {
    opts.raws = {};
  }

  if (opts.raws.value === undefined) {
    opts.raws.value = opts.value;
  }

  opts.value = unescaped;
  opts.quoteMark = quoteMark;
  return opts;
}

var Attribute = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Attribute, _Namespace);

  function Attribute(opts) {
    var _this;

    if (opts === void 0) {
      opts = {};
    }

    _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
    _this.type = _types.ATTRIBUTE;
    _this.raws = _this.raws || {};
    Object.defineProperty(_this.raws, 'unquoted', {
      get: deprecate(function () {
        return _this.value;
      }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
      set: deprecate(function () {
        return _this.value;
      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
    });
    _this._constructed = true;
    return _this;
  }
  /**
   * Returns the Attribute's value quoted such that it would be legal to use
   * in the value of a css file. The original value's quotation setting
   * used for stringification is left unchanged. See `setValue(value, options)`
   * if you want to control the quote settings of a new value for the attribute.
   *
   * You can also change the quotation used for the current value by setting quoteMark.
   *
   * Options:
   *   * quoteMark {'"' | "'" | null} - Use this value to quote the value. If this
   *     option is not set, the original value for quoteMark will be used. If
   *     indeterminate, a double quote is used. The legal values are:
   *     * `null` - the value will be unquoted and characters will be escaped as necessary.
   *     * `'` - the value will be quoted with a single quote and single quotes are escaped.
   *     * `"` - the value will be quoted with a double quote and double quotes are escaped.
   *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark
   *     over the quoteMark option value.
   *   * smart {boolean} - if true, will select a quote mark based on the value
   *     and the other options specified here. See the `smartQuoteMark()`
   *     method.
   **/


  var _proto = Attribute.prototype;

  _proto.getQuotedValue = function getQuotedValue(options) {
    if (options === void 0) {
      options = {};
    }

    var quoteMark = this._determineQuoteMark(options);

    var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
    var escaped = (0, _cssesc.default)(this._value, cssescopts);
    return escaped;
  };

  _proto._determineQuoteMark = function _determineQuoteMark(options) {
    return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
  }
  /**
   * Set the unescaped value with the specified quotation options. The value
   * provided must not include any wrapping quote marks -- those quotes will
   * be interpreted as part of the value and escaped accordingly.
   */
  ;

  _proto.setValue = function setValue(value, options) {
    if (options === void 0) {
      options = {};
    }

    this._value = value;
    this._quoteMark = this._determineQuoteMark(options);

    this._syncRawValue();
  }
  /**
   * Intelligently select a quoteMark value based on the value's contents. If
   * the value is a legal CSS ident, it will not be quoted. Otherwise a quote
   * mark will be picked that minimizes the number of escapes.
   *
   * If there's no clear winner, the quote mark from these options is used,
   * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is
   * true). If the quoteMark is unspecified, a double quote is used.
   *
   * @param options This takes the quoteMark and preferCurrentQuoteMark options
   * from the quoteValue method.
   */
  ;

  _proto.smartQuoteMark = function smartQuoteMark(options) {
    var v = this.value;
    var numSingleQuotes = v.replace(/[^']/g, '').length;
    var numDoubleQuotes = v.replace(/[^"]/g, '').length;

    if (numSingleQuotes + numDoubleQuotes === 0) {
      var escaped = (0, _cssesc.default)(v, {
        isIdentifier: true
      });

      if (escaped === v) {
        return Attribute.NO_QUOTE;
      } else {
        var pref = this.preferredQuoteMark(options);

        if (pref === Attribute.NO_QUOTE) {
          // pick a quote mark that isn't none and see if it's smaller
          var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;
          var opts = CSSESC_QUOTE_OPTIONS[quote];
          var quoteValue = (0, _cssesc.default)(v, opts);

          if (quoteValue.length < escaped.length) {
            return quote;
          }
        }

        return pref;
      }
    } else if (numDoubleQuotes === numSingleQuotes) {
      return this.preferredQuoteMark(options);
    } else if (numDoubleQuotes < numSingleQuotes) {
      return Attribute.DOUBLE_QUOTE;
    } else {
      return Attribute.SINGLE_QUOTE;
    }
  }
  /**
   * Selects the preferred quote mark based on the options and the current quote mark value.
   * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`
   * instead.
   */
  ;

  _proto.preferredQuoteMark = function preferredQuoteMark(options) {
    var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;

    if (quoteMark === undefined) {
      quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
    }

    if (quoteMark === undefined) {
      quoteMark = Attribute.DOUBLE_QUOTE;
    }

    return quoteMark;
  };

  _proto._syncRawValue = function _syncRawValue() {
    var rawValue = (0, _cssesc.default)(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);

    if (rawValue === this._value) {
      if (this.raws) {
        delete this.raws.value;
      }
    } else {
      this.raws.value = rawValue;
    }
  };

  _proto._handleEscapes = function _handleEscapes(prop, value) {
    if (this._constructed) {
      var escaped = (0, _cssesc.default)(value, {
        isIdentifier: true
      });

      if (escaped !== value) {
        this.raws[prop] = escaped;
      } else {
        delete this.raws[prop];
      }
    }
  };

  _proto._spacesFor = function _spacesFor(name) {
    var attrSpaces = {
      before: '',
      after: ''
    };
    var spaces = this.spaces[name] || {};
    var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
    return Object.assign(attrSpaces, spaces, rawSpaces);
  };

  _proto._stringFor = function _stringFor(name, spaceName, concat) {
    if (spaceName === void 0) {
      spaceName = name;
    }

    if (concat === void 0) {
      concat = defaultAttrConcat;
    }

    var attrSpaces = this._spacesFor(spaceName);

    return concat(this.stringifyProperty(name), attrSpaces);
  }
  /**
   * returns the offset of the attribute part specified relative to the
   * start of the node of the output string.
   *
   * * "ns" - alias for "namespace"
   * * "namespace" - the namespace if it exists.
   * * "attribute" - the attribute name
   * * "attributeNS" - the start of the attribute or its namespace
   * * "operator" - the match operator of the attribute
   * * "value" - The value (string or identifier)
   * * "insensitive" - the case insensitivity flag;
   * @param part One of the possible values inside an attribute.
   * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
   */
  ;

  _proto.offsetOf = function offsetOf(name) {
    var count = 1;

    var attributeSpaces = this._spacesFor("attribute");

    count += attributeSpaces.before.length;

    if (name === "namespace" || name === "ns") {
      return this.namespace ? count : -1;
    }

    if (name === "attributeNS") {
      return count;
    }

    count += this.namespaceString.length;

    if (this.namespace) {
      count += 1;
    }

    if (name === "attribute") {
      return count;
    }

    count += this.stringifyProperty("attribute").length;
    count += attributeSpaces.after.length;

    var operatorSpaces = this._spacesFor("operator");

    count += operatorSpaces.before.length;
    var operator = this.stringifyProperty("operator");

    if (name === "operator") {
      return operator ? count : -1;
    }

    count += operator.length;
    count += operatorSpaces.after.length;

    var valueSpaces = this._spacesFor("value");

    count += valueSpaces.before.length;
    var value = this.stringifyProperty("value");

    if (name === "value") {
      return value ? count : -1;
    }

    count += value.length;
    count += valueSpaces.after.length;

    var insensitiveSpaces = this._spacesFor("insensitive");

    count += insensitiveSpaces.before.length;

    if (name === "insensitive") {
      return this.insensitive ? count : -1;
    }

    return -1;
  };

  _proto.toString = function toString() {
    var _this2 = this;

    var selector = [this.rawSpaceBefore, '['];
    selector.push(this._stringFor('qualifiedAttribute', 'attribute'));

    if (this.operator && (this.value || this.value === '')) {
      selector.push(this._stringFor('operator'));
      selector.push(this._stringFor('value'));
      selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
        if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
          attrSpaces.before = " ";
        }

        return defaultAttrConcat(attrValue, attrSpaces);
      }));
    }

    selector.push(']');
    selector.push(this.rawSpaceAfter);
    return selector.join('');
  };

  _createClass(Attribute, [{
    key: "quoted",
    get: function get() {
      var qm = this.quoteMark;
      return qm === "'" || qm === '"';
    },
    set: function set(value) {
      warnOfDeprecatedQuotedAssignment();
    }
    /**
     * returns a single (`'`) or double (`"`) quote character if the value is quoted.
     * returns `null` if the value is not quoted.
     * returns `undefined` if the quotation state is unknown (this can happen when
     * the attribute is constructed without specifying a quote mark.)
     */

  }, {
    key: "quoteMark",
    get: function get() {
      return this._quoteMark;
    }
    /**
     * Set the quote mark to be used by this attribute's value.
     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute
     * value is updated accordingly.
     *
     * @param {"'" | '"' | null} quoteMark The quote mark or `null` if the value should be unquoted.
     */
    ,
    set: function set(quoteMark) {
      if (!this._constructed) {
        this._quoteMark = quoteMark;
        return;
      }

      if (this._quoteMark !== quoteMark) {
        this._quoteMark = quoteMark;

        this._syncRawValue();
      }
    }
  }, {
    key: "qualifiedAttribute",
    get: function get() {
      return this.qualifiedName(this.raws.attribute || this.attribute);
    }
  }, {
    key: "insensitiveFlag",
    get: function get() {
      return this.insensitive ? 'i' : '';
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Before 3.0, the value had to be set to an escaped value including any wrapped
     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
     * is unescaped during parsing and any quote marks are removed.
     *
     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
     * a deprecation warning is raised when the new value contains any characters that would
     * require escaping (including if it contains wrapped quotes).
     *
     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
     * how the new value is quoted.
     */
    ,
    set: function set(v) {
      if (this._constructed) {
        var _unescapeValue2 = unescapeValue(v),
            deprecatedUsage = _unescapeValue2.deprecatedUsage,
            unescaped = _unescapeValue2.unescaped,
            quoteMark = _unescapeValue2.quoteMark;

        if (deprecatedUsage) {
          warnOfDeprecatedValueAssignment();
        }

        if (unescaped === this._value && quoteMark === this._quoteMark) {
          return;
        }

        this._value = unescaped;
        this._quoteMark = quoteMark;

        this._syncRawValue();
      } else {
        this._value = v;
      }
    }
  }, {
    key: "attribute",
    get: function get() {
      return this._attribute;
    },
    set: function set(name) {
      this._handleEscapes("attribute", name);

      this._attribute = name;
    }
  }]);

  return Attribute;
}(_namespace.default);

exports.default = Attribute;
Attribute.NO_QUOTE = null;
Attribute.SINGLE_QUOTE = "'";
Attribute.DOUBLE_QUOTE = '"';
var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
  "'": {
    quotes: 'single',
    wrap: true
  },
  '"': {
    quotes: 'double',
    wrap: true
  }
}, _CSSESC_QUOTE_OPTIONS[null] = {
  isIdentifier: true
}, _CSSESC_QUOTE_OPTIONS);

function defaultAttrConcat(attrValue, attrSpaces) {
  return "" + attrSpaces.before + attrValue + attrSpaces.after;
}
},{"cssesc":"node_modules/cssesc/cssesc.js","../util/unesc":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/util/unesc.js","./namespace":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/namespace.js","./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js","util":"node_modules/util/util.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/universal.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _namespace = _interopRequireDefault(require("./namespace"));

var _types = require("./types");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var Universal = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Universal, _Namespace);

  function Universal(opts) {
    var _this;

    _this = _Namespace.call(this, opts) || this;
    _this.type = _types.UNIVERSAL;
    _this.value = '*';
    return _this;
  }

  return Universal;
}(_namespace.default);

exports.default = Universal;
module.exports = exports.default;
},{"./namespace":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/namespace.js","./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/combinator.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(require("./node"));

var _types = require("./types");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var Combinator = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Combinator, _Node);

  function Combinator(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.COMBINATOR;
    return _this;
  }

  return Combinator;
}(_node.default);

exports.default = Combinator;
module.exports = exports.default;
},{"./node":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/node.js","./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/nesting.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(require("./node"));

var _types = require("./types");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var Nesting = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Nesting, _Node);

  function Nesting(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.NESTING;
    _this.value = '&';
    return _this;
  }

  return Nesting;
}(_node.default);

exports.default = Nesting;
module.exports = exports.default;
},{"./node":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/node.js","./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/sortAscending.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = sortAscending;

function sortAscending(list) {
  return list.sort(function (a, b) {
    return a - b;
  });
}

;
module.exports = exports.default;
},{}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/tokenTypes.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.combinator = exports.word = exports.comment = exports.str = exports.tab = exports.newline = exports.feed = exports.cr = exports.backslash = exports.bang = exports.slash = exports.doubleQuote = exports.singleQuote = exports.space = exports.greaterThan = exports.pipe = exports.equals = exports.plus = exports.caret = exports.tilde = exports.dollar = exports.closeSquare = exports.openSquare = exports.closeParenthesis = exports.openParenthesis = exports.semicolon = exports.colon = exports.comma = exports.at = exports.asterisk = exports.ampersand = void 0;
var ampersand = 38; // `&`.charCodeAt(0);

exports.ampersand = ampersand;
var asterisk = 42; // `*`.charCodeAt(0);

exports.asterisk = asterisk;
var at = 64; // `@`.charCodeAt(0);

exports.at = at;
var comma = 44; // `,`.charCodeAt(0);

exports.comma = comma;
var colon = 58; // `:`.charCodeAt(0);

exports.colon = colon;
var semicolon = 59; // `;`.charCodeAt(0);

exports.semicolon = semicolon;
var openParenthesis = 40; // `(`.charCodeAt(0);

exports.openParenthesis = openParenthesis;
var closeParenthesis = 41; // `)`.charCodeAt(0);

exports.closeParenthesis = closeParenthesis;
var openSquare = 91; // `[`.charCodeAt(0);

exports.openSquare = openSquare;
var closeSquare = 93; // `]`.charCodeAt(0);

exports.closeSquare = closeSquare;
var dollar = 36; // `$`.charCodeAt(0);

exports.dollar = dollar;
var tilde = 126; // `~`.charCodeAt(0);

exports.tilde = tilde;
var caret = 94; // `^`.charCodeAt(0);

exports.caret = caret;
var plus = 43; // `+`.charCodeAt(0);

exports.plus = plus;
var equals = 61; // `=`.charCodeAt(0);

exports.equals = equals;
var pipe = 124; // `|`.charCodeAt(0);

exports.pipe = pipe;
var greaterThan = 62; // `>`.charCodeAt(0);

exports.greaterThan = greaterThan;
var space = 32; // ` `.charCodeAt(0);

exports.space = space;
var singleQuote = 39; // `'`.charCodeAt(0);

exports.singleQuote = singleQuote;
var doubleQuote = 34; // `"`.charCodeAt(0);

exports.doubleQuote = doubleQuote;
var slash = 47; // `/`.charCodeAt(0);

exports.slash = slash;
var bang = 33; // `!`.charCodeAt(0);

exports.bang = bang;
var backslash = 92; // '\\'.charCodeAt(0);

exports.backslash = backslash;
var cr = 13; // '\r'.charCodeAt(0);

exports.cr = cr;
var feed = 12; // '\f'.charCodeAt(0);

exports.feed = feed;
var newline = 10; // '\n'.charCodeAt(0);

exports.newline = newline;
var tab = 9; // '\t'.charCodeAt(0);
// Expose aliases primarily for readability.

exports.tab = tab;
var str = singleQuote; // No good single character representation!

exports.str = str;
var comment = -1;
exports.comment = comment;
var word = -2;
exports.word = word;
var combinator = -3;
exports.combinator = combinator;
},{}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/tokenize.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = tokenize;
exports.FIELDS = void 0;

var t = _interopRequireWildcard(require("./tokenTypes"));

var _unescapable, _wordDelimiters;

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
var hex = {};
var hexChars = "0123456789abcdefABCDEF";

for (var i = 0; i < hexChars.length; i++) {
  hex[hexChars.charCodeAt(i)] = true;
}
/**
 *  Returns the last index of the bar css word
 * @param {string} css The string in which the word begins
 * @param {number} start The index into the string where word's first letter occurs
 */


function consumeWord(css, start) {
  var next = start;
  var code;

  do {
    code = css.charCodeAt(next);

    if (wordDelimiters[code]) {
      return next - 1;
    } else if (code === t.backslash) {
      next = consumeEscape(css, next) + 1;
    } else {
      // All other characters are part of the word
      next++;
    }
  } while (next < css.length);

  return next - 1;
}
/**
 *  Returns the last index of the escape sequence
 * @param {string} css The string in which the sequence begins
 * @param {number} start The index into the string where escape character (`\`) occurs.
 */


function consumeEscape(css, start) {
  var next = start;
  var code = css.charCodeAt(next + 1);

  if (unescapable[code]) {// just consume the escape char
  } else if (hex[code]) {
    var hexDigits = 0; // consume up to 6 hex chars

    do {
      next++;
      hexDigits++;
      code = css.charCodeAt(next + 1);
    } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape


    if (hexDigits < 6 && code === t.space) {
      next++;
    }
  } else {
    // the next char is part of the current word
    next++;
  }

  return next;
}

var FIELDS = {
  TYPE: 0,
  START_LINE: 1,
  START_COL: 2,
  END_LINE: 3,
  END_COL: 4,
  START_POS: 5,
  END_POS: 6
};
exports.FIELDS = FIELDS;

function tokenize(input) {
  var tokens = [];
  var css = input.css.valueOf();
  var _css = css,
      length = _css.length;
  var offset = -1;
  var line = 1;
  var start = 0;
  var end = 0;
  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;

  function unclosed(what, fix) {
    if (input.safe) {
      // fyi: this is never set to true.
      css += fix;
      next = css.length - 1;
    } else {
      throw input.error('Unclosed ' + what, line, start - offset, start);
    }
  }

  while (start < length) {
    code = css.charCodeAt(start);

    if (code === t.newline) {
      offset = start;
      line += 1;
    }

    switch (code) {
      case t.space:
      case t.tab:
      case t.newline:
      case t.cr:
      case t.feed:
        next = start;

        do {
          next += 1;
          code = css.charCodeAt(next);

          if (code === t.newline) {
            offset = next;
            line += 1;
          }
        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);

        tokenType = t.space;
        endLine = line;
        endColumn = next - offset - 1;
        end = next;
        break;

      case t.plus:
      case t.greaterThan:
      case t.tilde:
      case t.pipe:
        next = start;

        do {
          next += 1;
          code = css.charCodeAt(next);
        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);

        tokenType = t.combinator;
        endLine = line;
        endColumn = start - offset;
        end = next;
        break;
      // Consume these characters as single tokens.

      case t.asterisk:
      case t.ampersand:
      case t.bang:
      case t.comma:
      case t.equals:
      case t.dollar:
      case t.caret:
      case t.openSquare:
      case t.closeSquare:
      case t.colon:
      case t.semicolon:
      case t.openParenthesis:
      case t.closeParenthesis:
        next = start;
        tokenType = code;
        endLine = line;
        endColumn = start - offset;
        end = next + 1;
        break;

      case t.singleQuote:
      case t.doubleQuote:
        quote = code === t.singleQuote ? "'" : '"';
        next = start;

        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);

          if (next === -1) {
            unclosed('quote', quote);
          }

          escapePos = next;

          while (css.charCodeAt(escapePos - 1) === t.backslash) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);

        tokenType = t.str;
        endLine = line;
        endColumn = start - offset;
        end = next + 1;
        break;

      default:
        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
          next = css.indexOf('*/', start + 2) + 1;

          if (next === 0) {
            unclosed('comment', '*/');
          }

          content = css.slice(start, next + 1);
          lines = content.split('\n');
          last = lines.length - 1;

          if (last > 0) {
            nextLine = line + last;
            nextOffset = next - lines[last].length;
          } else {
            nextLine = line;
            nextOffset = offset;
          }

          tokenType = t.comment;
          line = nextLine;
          endLine = nextLine;
          endColumn = next - nextOffset;
        } else if (code === t.slash) {
          next = start;
          tokenType = code;
          endLine = line;
          endColumn = start - offset;
          end = next + 1;
        } else {
          next = consumeWord(css, start);
          tokenType = t.word;
          endLine = line;
          endColumn = next - offset;
        }

        end = next + 1;
        break;
    } // Ensure that the token structure remains consistent


    tokens.push([tokenType, // [0] Token type
    line, // [1] Starting line
    start - offset, // [2] Starting column
    endLine, // [3] Ending line
    endColumn, // [4] Ending column
    start, // [5] Start position / Source index
    end]); // Reset offset for the next token

    if (nextOffset) {
      offset = nextOffset;
      nextOffset = null;
    }

    start = end;
  }

  return tokens;
}
},{"./tokenTypes":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/tokenTypes.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/parser.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _indexesOf = _interopRequireDefault(require("indexes-of"));

var _uniq = _interopRequireDefault(require("uniq"));

var _root = _interopRequireDefault(require("./selectors/root"));

var _selector = _interopRequireDefault(require("./selectors/selector"));

var _className = _interopRequireDefault(require("./selectors/className"));

var _comment = _interopRequireDefault(require("./selectors/comment"));

var _id = _interopRequireDefault(require("./selectors/id"));

var _tag = _interopRequireDefault(require("./selectors/tag"));

var _string = _interopRequireDefault(require("./selectors/string"));

var _pseudo = _interopRequireDefault(require("./selectors/pseudo"));

var _attribute = _interopRequireWildcard(require("./selectors/attribute"));

var _universal = _interopRequireDefault(require("./selectors/universal"));

var _combinator = _interopRequireDefault(require("./selectors/combinator"));

var _nesting = _interopRequireDefault(require("./selectors/nesting"));

var _sortAscending = _interopRequireDefault(require("./sortAscending"));

var _tokenize = _interopRequireWildcard(require("./tokenize"));

var tokens = _interopRequireWildcard(require("./tokenTypes"));

var types = _interopRequireWildcard(require("./selectors/types"));

var _util = require("./util");

var _WHITESPACE_TOKENS, _Object$assign;

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));

function tokenStart(token) {
  return {
    line: token[_tokenize.FIELDS.START_LINE],
    column: token[_tokenize.FIELDS.START_COL]
  };
}

function tokenEnd(token) {
  return {
    line: token[_tokenize.FIELDS.END_LINE],
    column: token[_tokenize.FIELDS.END_COL]
  };
}

function getSource(startLine, startColumn, endLine, endColumn) {
  return {
    start: {
      line: startLine,
      column: startColumn
    },
    end: {
      line: endLine,
      column: endColumn
    }
  };
}

function getTokenSource(token) {
  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
}

function getTokenSourceSpan(startToken, endToken) {
  if (!startToken) {
    return undefined;
  }

  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
}

function unescapeProp(node, prop) {
  var value = node[prop];

  if (typeof value !== "string") {
    return;
  }

  if (value.indexOf("\\") !== -1) {
    (0, _util.ensureObject)(node, 'raws');
    node[prop] = (0, _util.unesc)(value);

    if (node.raws[prop] === undefined) {
      node.raws[prop] = value;
    }
  }

  return node;
}

var Parser = /*#__PURE__*/function () {
  function Parser(rule, options) {
    if (options === void 0) {
      options = {};
    }

    this.rule = rule;
    this.options = Object.assign({
      lossy: false,
      safe: false
    }, options);
    this.position = 0;
    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;
    this.tokens = (0, _tokenize.default)({
      css: this.css,
      error: this._errorGenerator(),
      safe: this.options.safe
    });
    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
    this.root = new _root.default({
      source: rootSource
    });
    this.root.errorGenerator = this._errorGenerator();
    var selector = new _selector.default({
      source: {
        start: {
          line: 1,
          column: 1
        }
      }
    });
    this.root.append(selector);
    this.current = selector;
    this.loop();
  }

  var _proto = Parser.prototype;

  _proto._errorGenerator = function _errorGenerator() {
    var _this = this;

    return function (message, errorOptions) {
      if (typeof _this.rule === 'string') {
        return new Error(message);
      }

      return _this.rule.error(message, errorOptions);
    };
  };

  _proto.attribute = function attribute() {
    var attr = [];
    var startingToken = this.currToken;
    this.position++;

    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
      attr.push(this.currToken);
      this.position++;
    }

    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
    }

    var len = attr.length;
    var node = {
      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
    };

    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);
    }

    var pos = 0;
    var spaceBefore = '';
    var commentBefore = '';
    var lastAdded = null;
    var spaceAfterMeaningfulToken = false;

    while (pos < len) {
      var token = attr[pos];
      var content = this.content(token);
      var next = attr[pos + 1];

      switch (token[_tokenize.FIELDS.TYPE]) {
        case tokens.space:
          // if (
          //     len === 1 ||
          //     pos === 0 && this.content(next) === '|'
          // ) {
          //     return this.expected('attribute', token[TOKEN.START_POS], content);
          // }
          spaceAfterMeaningfulToken = true;

          if (this.options.lossy) {
            break;
          }

          if (lastAdded) {
            (0, _util.ensureObject)(node, 'spaces', lastAdded);
            var prevContent = node.spaces[lastAdded].after || '';
            node.spaces[lastAdded].after = prevContent + content;
            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;

            if (existingComment) {
              node.raws.spaces[lastAdded].after = existingComment + content;
            }
          } else {
            spaceBefore = spaceBefore + content;
            commentBefore = commentBefore + content;
          }

          break;

        case tokens.asterisk:
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
            if (spaceBefore) {
              (0, _util.ensureObject)(node, 'spaces', 'attribute');
              node.spaces.attribute.before = spaceBefore;
              spaceBefore = '';
            }

            if (commentBefore) {
              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
              node.raws.spaces.attribute.before = spaceBefore;
              commentBefore = '';
            }

            node.namespace = (node.namespace || "") + content;
            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;

            if (rawValue) {
              node.raws.namespace += content;
            }

            lastAdded = 'namespace';
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.dollar:
          if (lastAdded === "value") {
            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');
            node.value += "$";

            if (oldRawValue) {
              node.raws.value = oldRawValue + "$";
            }

            break;
          }

        // Falls through

        case tokens.caret:
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.combinator:
          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }

          if (content !== '|') {
            spaceAfterMeaningfulToken = false;
            break;
          }

          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if (!node.namespace && !node.attribute) {
            node.namespace = true;
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.word:
          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
          !node.operator && !node.namespace) {
            node.namespace = content;
            lastAdded = 'namespace';
          } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
            if (spaceBefore) {
              (0, _util.ensureObject)(node, 'spaces', 'attribute');
              node.spaces.attribute.before = spaceBefore;
              spaceBefore = '';
            }

            if (commentBefore) {
              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
              node.raws.spaces.attribute.before = commentBefore;
              commentBefore = '';
            }

            node.attribute = (node.attribute || "") + content;

            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;

            if (_rawValue) {
              node.raws.attribute += content;
            }

            lastAdded = 'attribute';
          } else if (!node.value && node.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
            var _unescaped = (0, _util.unesc)(content);

            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';

            var oldValue = node.value || '';
            node.value = oldValue + _unescaped;
            node.quoteMark = null;

            if (_unescaped !== content || _oldRawValue) {
              (0, _util.ensureObject)(node, 'raws');
              node.raws.value = (_oldRawValue || oldValue) + content;
            }

            lastAdded = 'value';
          } else {
            var insensitive = content === 'i' || content === "I";

            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {
              node.insensitive = insensitive;

              if (!insensitive || content === "I") {
                (0, _util.ensureObject)(node, 'raws');
                node.raws.insensitiveFlag = content;
              }

              lastAdded = 'insensitive';

              if (spaceBefore) {
                (0, _util.ensureObject)(node, 'spaces', 'insensitive');
                node.spaces.insensitive.before = spaceBefore;
                spaceBefore = '';
              }

              if (commentBefore) {
                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');
                node.raws.spaces.insensitive.before = commentBefore;
                commentBefore = '';
              }
            } else if (node.value || node.value === '') {
              lastAdded = 'value';
              node.value += content;

              if (node.raws.value) {
                node.raws.value += content;
              }
            }
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.str:
          if (!node.attribute || !node.operator) {
            return this.error("Expected an attribute followed by an operator preceding the string.", {
              index: token[_tokenize.FIELDS.START_POS]
            });
          }

          var _unescapeValue = (0, _attribute.unescapeValue)(content),
              unescaped = _unescapeValue.unescaped,
              quoteMark = _unescapeValue.quoteMark;

          node.value = unescaped;
          node.quoteMark = quoteMark;
          lastAdded = 'value';
          (0, _util.ensureObject)(node, 'raws');
          node.raws.value = content;
          spaceAfterMeaningfulToken = false;
          break;

        case tokens.equals:
          if (!node.attribute) {
            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);
          }

          if (node.value) {
            return this.error('Unexpected "=" found; an operator was already defined.', {
              index: token[_tokenize.FIELDS.START_POS]
            });
          }

          node.operator = node.operator ? node.operator + content : content;
          lastAdded = 'operator';
          spaceAfterMeaningfulToken = false;
          break;

        case tokens.comment:
          if (lastAdded) {
            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {
              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';
              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;
              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);
              node.raws.spaces[lastAdded].after = rawLastComment + content;
            } else {
              var lastValue = node[lastAdded] || '';
              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;
              (0, _util.ensureObject)(node, 'raws');
              node.raws[lastAdded] = rawLastValue + content;
            }
          } else {
            commentBefore = commentBefore + content;
          }

          break;

        default:
          return this.error("Unexpected \"" + content + "\" found.", {
            index: token[_tokenize.FIELDS.START_POS]
          });
      }

      pos++;
    }

    unescapeProp(node, "attribute");
    unescapeProp(node, "namespace");
    this.newNode(new _attribute.default(node));
    this.position++;
  }
  /**
   * return a node containing meaningless garbage up to (but not including) the specified token position.
   * if the token position is negative, all remaining tokens are consumed.
   *
   * This returns an array containing a single string node if all whitespace,
   * otherwise an array of comment nodes with space before and after.
   *
   * These tokens are not added to the current selector, the caller can add them or use them to amend
   * a previous node's space metadata.
   *
   * In lossy mode, this returns only comments.
   */
  ;

  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
    if (stopPosition < 0) {
      stopPosition = this.tokens.length;
    }

    var startPosition = this.position;
    var nodes = [];
    var space = "";
    var lastComment = undefined;

    do {
      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
        if (!this.options.lossy) {
          space += this.content();
        }
      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
        var spaces = {};

        if (space) {
          spaces.before = space;
          space = "";
        }

        lastComment = new _comment.default({
          value: this.content(),
          source: getTokenSource(this.currToken),
          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
          spaces: spaces
        });
        nodes.push(lastComment);
      }
    } while (++this.position < stopPosition);

    if (space) {
      if (lastComment) {
        lastComment.spaces.after = space;
      } else if (!this.options.lossy) {
        var firstToken = this.tokens[startPosition];
        var lastToken = this.tokens[this.position - 1];
        nodes.push(new _string.default({
          value: '',
          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
          spaces: {
            before: space,
            after: ''
          }
        }));
      }
    }

    return nodes;
  }
  /**
   * 
   * @param {*} nodes 
   */
  ;

  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
    var _this2 = this;

    if (requiredSpace === void 0) {
      requiredSpace = false;
    }

    var space = "";
    var rawSpace = "";
    nodes.forEach(function (n) {
      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);

      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);

      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
    });

    if (rawSpace === space) {
      rawSpace = undefined;
    }

    var result = {
      space: space,
      rawSpace: rawSpace
    };
    return result;
  };

  _proto.isNamedCombinator = function isNamedCombinator(position) {
    if (position === void 0) {
      position = this.position;
    }

    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
  };

  _proto.namedCombinator = function namedCombinator() {
    if (this.isNamedCombinator()) {
      var nameRaw = this.content(this.tokens[this.position + 1]);
      var name = (0, _util.unesc)(nameRaw).toLowerCase();
      var raws = {};

      if (name !== nameRaw) {
        raws.value = "/" + nameRaw + "/";
      }

      var node = new _combinator.default({
        value: "/" + name + "/",
        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
        raws: raws
      });
      this.position = this.position + 3;
      return node;
    } else {
      this.unexpected();
    }
  };

  _proto.combinator = function combinator() {
    var _this3 = this;

    if (this.content() === '|') {
      return this.namespace();
    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.


    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);

    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);

      if (nodes.length > 0) {
        var last = this.current.last;

        if (last) {
          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),
              space = _this$convertWhitespa.space,
              rawSpace = _this$convertWhitespa.rawSpace;

          if (rawSpace !== undefined) {
            last.rawSpaceAfter += rawSpace;
          }

          last.spaces.after += space;
        } else {
          nodes.forEach(function (n) {
            return _this3.newNode(n);
          });
        }
      }

      return;
    }

    var firstToken = this.currToken;
    var spaceOrDescendantSelectorNodes = undefined;

    if (nextSigTokenPos > this.position) {
      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
    }

    var node;

    if (this.isNamedCombinator()) {
      node = this.namedCombinator();
    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
      node = new _combinator.default({
        value: this.content(),
        source: getTokenSource(this.currToken),
        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
      });
      this.position++;
    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass
    } else if (!spaceOrDescendantSelectorNodes) {
      this.unexpected();
    }

    if (node) {
      if (spaceOrDescendantSelectorNodes) {
        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),
            _space = _this$convertWhitespa2.space,
            _rawSpace = _this$convertWhitespa2.rawSpace;

        node.spaces.before = _space;
        node.rawSpaceBefore = _rawSpace;
      }
    } else {
      // descendant combinator
      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),
          _space2 = _this$convertWhitespa3.space,
          _rawSpace2 = _this$convertWhitespa3.rawSpace;

      if (!_rawSpace2) {
        _rawSpace2 = _space2;
      }

      var spaces = {};
      var raws = {
        spaces: {}
      };

      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {
        spaces.before = _space2.slice(0, _space2.length - 1);
        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {
        spaces.after = _space2.slice(1);
        raws.spaces.after = _rawSpace2.slice(1);
      } else {
        raws.value = _rawSpace2;
      }

      node = new _combinator.default({
        value: ' ',
        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
        spaces: spaces,
        raws: raws
      });
    }

    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
      node.spaces.after = this.optionalSpace(this.content());
      this.position++;
    }

    return this.newNode(node);
  };

  _proto.comma = function comma() {
    if (this.position === this.tokens.length - 1) {
      this.root.trailingComma = true;
      this.position++;
      return;
    }

    this.current._inferEndPosition();

    var selector = new _selector.default({
      source: {
        start: tokenStart(this.tokens[this.position + 1])
      }
    });
    this.current.parent.append(selector);
    this.current = selector;
    this.position++;
  };

  _proto.comment = function comment() {
    var current = this.currToken;
    this.newNode(new _comment.default({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.error = function error(message, opts) {
    throw this.root.error(message, opts);
  };

  _proto.missingBackslash = function missingBackslash() {
    return this.error('Expected a backslash preceding the semicolon.', {
      index: this.currToken[_tokenize.FIELDS.START_POS]
    });
  };

  _proto.missingParenthesis = function missingParenthesis() {
    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.missingSquareBracket = function missingSquareBracket() {
    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.unexpected = function unexpected() {
    return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.namespace = function namespace() {
    var before = this.prevToken && this.content(this.prevToken) || true;

    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
      this.position++;
      return this.word(before);
    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
      this.position++;
      return this.universal(before);
    }
  };

  _proto.nesting = function nesting() {
    if (this.nextToken) {
      var nextContent = this.content(this.nextToken);

      if (nextContent === "|") {
        this.position++;
        return;
      }
    }

    var current = this.currToken;
    this.newNode(new _nesting.default({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.parentheses = function parentheses() {
    var last = this.current.last;
    var unbalanced = 1;
    this.position++;

    if (last && last.type === types.PSEUDO) {
      var selector = new _selector.default({
        source: {
          start: tokenStart(this.tokens[this.position - 1])
        }
      });
      var cache = this.current;
      last.append(selector);
      this.current = selector;

      while (this.position < this.tokens.length && unbalanced) {
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          unbalanced++;
        }

        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          unbalanced--;
        }

        if (unbalanced) {
          this.parse();
        } else {
          this.current.source.end = tokenEnd(this.currToken);
          this.current.parent.source.end = tokenEnd(this.currToken);
          this.position++;
        }
      }

      this.current = cache;
    } else {
      // I think this case should be an error. It's used to implement a basic parse of media queries
      // but I don't think it's a good idea.
      var parenStart = this.currToken;
      var parenValue = "(";
      var parenEnd;

      while (this.position < this.tokens.length && unbalanced) {
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          unbalanced++;
        }

        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          unbalanced--;
        }

        parenEnd = this.currToken;
        parenValue += this.parseParenthesisToken(this.currToken);
        this.position++;
      }

      if (last) {
        last.appendToPropertyAndEscape("value", parenValue, parenValue);
      } else {
        this.newNode(new _string.default({
          value: parenValue,
          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
        }));
      }
    }

    if (unbalanced) {
      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
    }
  };

  _proto.pseudo = function pseudo() {
    var _this4 = this;

    var pseudoStr = '';
    var startingToken = this.currToken;

    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
      pseudoStr += this.content();
      this.position++;
    }

    if (!this.currToken) {
      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
    }

    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
      this.splitWord(false, function (first, length) {
        pseudoStr += first;

        _this4.newNode(new _pseudo.default({
          value: pseudoStr,
          source: getTokenSourceSpan(startingToken, _this4.currToken),
          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        }));

        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          _this4.error('Misplaced parenthesis.', {
            index: _this4.nextToken[_tokenize.FIELDS.START_POS]
          });
        }
      });
    } else {
      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);
    }
  };

  _proto.space = function space() {
    var content = this.content(); // Handle space before and after the selector

    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
      this.spaces = this.optionalSpace(content);
      this.position++;
    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
      this.current.last.spaces.after = this.optionalSpace(content);
      this.position++;
    } else {
      this.combinator();
    }
  };

  _proto.string = function string() {
    var current = this.currToken;
    this.newNode(new _string.default({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.universal = function universal(namespace) {
    var nextToken = this.nextToken;

    if (nextToken && this.content(nextToken) === '|') {
      this.position++;
      return this.namespace();
    }

    var current = this.currToken;
    this.newNode(new _universal.default({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }), namespace);
    this.position++;
  };

  _proto.splitWord = function splitWord(namespace, firstCallback) {
    var _this5 = this;

    var nextToken = this.nextToken;
    var word = this.content();

    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
      this.position++;
      var current = this.content();
      word += current;

      if (current.lastIndexOf('\\') === current.length - 1) {
        var next = this.nextToken;

        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
          word += this.requiredSpace(this.content(next));
          this.position++;
        }
      }

      nextToken = this.nextToken;
    }

    var hasClass = (0, _indexesOf.default)(word, '.').filter(function (i) {
      return word[i - 1] !== '\\';
    });
    var hasId = (0, _indexesOf.default)(word, '#').filter(function (i) {
      return word[i - 1] !== '\\';
    }); // Eliminate Sass interpolations from the list of id indexes

    var interpolations = (0, _indexesOf.default)(word, '#{');

    if (interpolations.length) {
      hasId = hasId.filter(function (hashIndex) {
        return !~interpolations.indexOf(hashIndex);
      });
    }

    var indices = (0, _sortAscending.default)((0, _uniq.default)([0].concat(hasClass, hasId)));
    indices.forEach(function (ind, i) {
      var index = indices[i + 1] || word.length;
      var value = word.slice(ind, index);

      if (i === 0 && firstCallback) {
        return firstCallback.call(_this5, value, indices.length);
      }

      var node;
      var current = _this5.currToken;
      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];
      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));

      if (~hasClass.indexOf(ind)) {
        var classNameOpts = {
          value: value.slice(1),
          source: source,
          sourceIndex: sourceIndex
        };
        node = new _className.default(unescapeProp(classNameOpts, "value"));
      } else if (~hasId.indexOf(ind)) {
        var idOpts = {
          value: value.slice(1),
          source: source,
          sourceIndex: sourceIndex
        };
        node = new _id.default(unescapeProp(idOpts, "value"));
      } else {
        var tagOpts = {
          value: value,
          source: source,
          sourceIndex: sourceIndex
        };
        unescapeProp(tagOpts, "value");
        node = new _tag.default(tagOpts);
      }

      _this5.newNode(node, namespace); // Ensure that the namespace is used only once


      namespace = null;
    });
    this.position++;
  };

  _proto.word = function word(namespace) {
    var nextToken = this.nextToken;

    if (nextToken && this.content(nextToken) === '|') {
      this.position++;
      return this.namespace();
    }

    return this.splitWord(namespace);
  };

  _proto.loop = function loop() {
    while (this.position < this.tokens.length) {
      this.parse(true);
    }

    this.current._inferEndPosition();

    return this.root;
  };

  _proto.parse = function parse(throwOnParenthesis) {
    switch (this.currToken[_tokenize.FIELDS.TYPE]) {
      case tokens.space:
        this.space();
        break;

      case tokens.comment:
        this.comment();
        break;

      case tokens.openParenthesis:
        this.parentheses();
        break;

      case tokens.closeParenthesis:
        if (throwOnParenthesis) {
          this.missingParenthesis();
        }

        break;

      case tokens.openSquare:
        this.attribute();
        break;

      case tokens.dollar:
      case tokens.caret:
      case tokens.equals:
      case tokens.word:
        this.word();
        break;

      case tokens.colon:
        this.pseudo();
        break;

      case tokens.comma:
        this.comma();
        break;

      case tokens.asterisk:
        this.universal();
        break;

      case tokens.ampersand:
        this.nesting();
        break;

      case tokens.slash:
      case tokens.combinator:
        this.combinator();
        break;

      case tokens.str:
        this.string();
        break;
      // These cases throw; no break needed.

      case tokens.closeSquare:
        this.missingSquareBracket();

      case tokens.semicolon:
        this.missingBackslash();

      default:
        this.unexpected();
    }
  }
  /**
   * Helpers
   */
  ;

  _proto.expected = function expected(description, index, found) {
    if (Array.isArray(description)) {
      var last = description.pop();
      description = description.join(', ') + " or " + last;
    }

    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';

    if (!found) {
      return this.error("Expected " + an + " " + description + ".", {
        index: index
      });
    }

    return this.error("Expected " + an + " " + description + ", found \"" + found + "\" instead.", {
      index: index
    });
  };

  _proto.requiredSpace = function requiredSpace(space) {
    return this.options.lossy ? ' ' : space;
  };

  _proto.optionalSpace = function optionalSpace(space) {
    return this.options.lossy ? '' : space;
  };

  _proto.lossySpace = function lossySpace(space, required) {
    if (this.options.lossy) {
      return required ? ' ' : '';
    } else {
      return space;
    }
  };

  _proto.parseParenthesisToken = function parseParenthesisToken(token) {
    var content = this.content(token);

    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
      return this.requiredSpace(content);
    } else {
      return content;
    }
  };

  _proto.newNode = function newNode(node, namespace) {
    if (namespace) {
      if (/^ +$/.test(namespace)) {
        if (!this.options.lossy) {
          this.spaces = (this.spaces || '') + namespace;
        }

        namespace = true;
      }

      node.namespace = namespace;
      unescapeProp(node, "namespace");
    }

    if (this.spaces) {
      node.spaces.before = this.spaces;
      this.spaces = '';
    }

    return this.current.append(node);
  };

  _proto.content = function content(token) {
    if (token === void 0) {
      token = this.currToken;
    }

    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
  };
  /**
   * returns the index of the next non-whitespace, non-comment token.
   * returns -1 if no meaningful token is found.
   */


  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
    if (startPosition === void 0) {
      startPosition = this.position + 1;
    }

    var searchPosition = startPosition;

    while (searchPosition < this.tokens.length) {
      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
        searchPosition++;
        continue;
      } else {
        return searchPosition;
      }
    }

    return -1;
  };

  _createClass(Parser, [{
    key: "currToken",
    get: function get() {
      return this.tokens[this.position];
    }
  }, {
    key: "nextToken",
    get: function get() {
      return this.tokens[this.position + 1];
    }
  }, {
    key: "prevToken",
    get: function get() {
      return this.tokens[this.position - 1];
    }
  }]);

  return Parser;
}();

exports.default = Parser;
module.exports = exports.default;
},{"indexes-of":"node_modules/indexes-of/index.js","uniq":"node_modules/uniq/uniq.js","./selectors/root":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/root.js","./selectors/selector":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/selector.js","./selectors/className":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/className.js","./selectors/comment":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/comment.js","./selectors/id":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/id.js","./selectors/tag":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/tag.js","./selectors/string":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/string.js","./selectors/pseudo":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/pseudo.js","./selectors/attribute":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/attribute.js","./selectors/universal":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/universal.js","./selectors/combinator":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/combinator.js","./selectors/nesting":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/nesting.js","./sortAscending":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/sortAscending.js","./tokenize":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/tokenize.js","./tokenTypes":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/tokenTypes.js","./selectors/types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js","./util":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/util/index.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/processor.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _parser = _interopRequireDefault(require("./parser"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var Processor = /*#__PURE__*/function () {
  function Processor(func, options) {
    this.func = func || function noop() {};

    this.funcRes = null;
    this.options = options;
  }

  var _proto = Processor.prototype;

  _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var merged = Object.assign({}, this.options, options);

    if (merged.updateSelector === false) {
      return false;
    } else {
      return typeof rule !== "string";
    }
  };

  _proto._isLossy = function _isLossy(options) {
    if (options === void 0) {
      options = {};
    }

    var merged = Object.assign({}, this.options, options);

    if (merged.lossless === false) {
      return true;
    } else {
      return false;
    }
  };

  _proto._root = function _root(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var parser = new _parser.default(rule, this._parseOptions(options));
    return parser.root;
  };

  _proto._parseOptions = function _parseOptions(options) {
    return {
      lossy: this._isLossy(options)
    };
  };

  _proto._run = function _run(rule, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    return new Promise(function (resolve, reject) {
      try {
        var root = _this._root(rule, options);

        Promise.resolve(_this.func(root)).then(function (transform) {
          var string = undefined;

          if (_this._shouldUpdateSelector(rule, options)) {
            string = root.toString();
            rule.selector = string;
          }

          return {
            transform: transform,
            root: root,
            string: string
          };
        }).then(resolve, reject);
      } catch (e) {
        reject(e);
        return;
      }
    });
  };

  _proto._runSync = function _runSync(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var root = this._root(rule, options);

    var transform = this.func(root);

    if (transform && typeof transform.then === "function") {
      throw new Error("Selector processor returned a promise to a synchronous call.");
    }

    var string = undefined;

    if (options.updateSelector && typeof rule !== "string") {
      string = root.toString();
      rule.selector = string;
    }

    return {
      transform: transform,
      root: root,
      string: string
    };
  }
  /**
   * Process rule into a selector AST.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {Promise<parser.Root>} The AST of the selector after processing it.
   */
  ;

  _proto.ast = function ast(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.root;
    });
  }
  /**
   * Process rule into a selector AST synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {parser.Root} The AST of the selector after processing it.
   */
  ;

  _proto.astSync = function astSync(rule, options) {
    return this._runSync(rule, options).root;
  }
  /**
   * Process a selector into a transformed value asynchronously
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {Promise<any>} The value returned by the processor.
   */
  ;

  _proto.transform = function transform(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.transform;
    });
  }
  /**
   * Process a selector into a transformed value synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {any} The value returned by the processor.
   */
  ;

  _proto.transformSync = function transformSync(rule, options) {
    return this._runSync(rule, options).transform;
  }
  /**
   * Process a selector into a new selector string asynchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {string} the selector after processing.
   */
  ;

  _proto.process = function process(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.string || result.root.toString();
    });
  }
  /**
   * Process a selector into a new selector string synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {string} the selector after processing.
   */
  ;

  _proto.processSync = function processSync(rule, options) {
    var result = this._runSync(rule, options);

    return result.string || result.root.toString();
  };

  return Processor;
}();

exports.default = Processor;
module.exports = exports.default;
},{"./parser":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/parser.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/constructors.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;

var _attribute = _interopRequireDefault(require("./attribute"));

var _className = _interopRequireDefault(require("./className"));

var _combinator = _interopRequireDefault(require("./combinator"));

var _comment = _interopRequireDefault(require("./comment"));

var _id = _interopRequireDefault(require("./id"));

var _nesting = _interopRequireDefault(require("./nesting"));

var _pseudo = _interopRequireDefault(require("./pseudo"));

var _root = _interopRequireDefault(require("./root"));

var _selector = _interopRequireDefault(require("./selector"));

var _string = _interopRequireDefault(require("./string"));

var _tag = _interopRequireDefault(require("./tag"));

var _universal = _interopRequireDefault(require("./universal"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var attribute = function attribute(opts) {
  return new _attribute.default(opts);
};

exports.attribute = attribute;

var className = function className(opts) {
  return new _className.default(opts);
};

exports.className = className;

var combinator = function combinator(opts) {
  return new _combinator.default(opts);
};

exports.combinator = combinator;

var comment = function comment(opts) {
  return new _comment.default(opts);
};

exports.comment = comment;

var id = function id(opts) {
  return new _id.default(opts);
};

exports.id = id;

var nesting = function nesting(opts) {
  return new _nesting.default(opts);
};

exports.nesting = nesting;

var pseudo = function pseudo(opts) {
  return new _pseudo.default(opts);
};

exports.pseudo = pseudo;

var root = function root(opts) {
  return new _root.default(opts);
};

exports.root = root;

var selector = function selector(opts) {
  return new _selector.default(opts);
};

exports.selector = selector;

var string = function string(opts) {
  return new _string.default(opts);
};

exports.string = string;

var tag = function tag(opts) {
  return new _tag.default(opts);
};

exports.tag = tag;

var universal = function universal(opts) {
  return new _universal.default(opts);
};

exports.universal = universal;
},{"./attribute":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/attribute.js","./className":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/className.js","./combinator":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/combinator.js","./comment":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/comment.js","./id":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/id.js","./nesting":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/nesting.js","./pseudo":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/pseudo.js","./root":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/root.js","./selector":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/selector.js","./string":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/string.js","./tag":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/tag.js","./universal":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/universal.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/guards.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;
exports.isNode = isNode;
exports.isPseudoElement = isPseudoElement;
exports.isPseudoClass = isPseudoClass;
exports.isContainer = isContainer;
exports.isNamespace = isNamespace;
exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;

var _types = require("./types");

var _IS_TYPE;

var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);

function isNode(node) {
  return _typeof(node) === "object" && IS_TYPE[node.type];
}

function isNodeType(type, node) {
  return isNode(node) && node.type === type;
}

var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
exports.isAttribute = isAttribute;
var isClassName = isNodeType.bind(null, _types.CLASS);
exports.isClassName = isClassName;
var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
exports.isCombinator = isCombinator;
var isComment = isNodeType.bind(null, _types.COMMENT);
exports.isComment = isComment;
var isIdentifier = isNodeType.bind(null, _types.ID);
exports.isIdentifier = isIdentifier;
var isNesting = isNodeType.bind(null, _types.NESTING);
exports.isNesting = isNesting;
var isPseudo = isNodeType.bind(null, _types.PSEUDO);
exports.isPseudo = isPseudo;
var isRoot = isNodeType.bind(null, _types.ROOT);
exports.isRoot = isRoot;
var isSelector = isNodeType.bind(null, _types.SELECTOR);
exports.isSelector = isSelector;
var isString = isNodeType.bind(null, _types.STRING);
exports.isString = isString;
var isTag = isNodeType.bind(null, _types.TAG);
exports.isTag = isTag;
var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
exports.isUniversal = isUniversal;

function isPseudoElement(node) {
  return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value === ":before" || node.value === ":after");
}

function isPseudoClass(node) {
  return isPseudo(node) && !isPseudoElement(node);
}

function isContainer(node) {
  return !!(isNode(node) && node.walk);
}

function isNamespace(node) {
  return isAttribute(node) || isTag(node);
}
},{"./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/index.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;

var _types = require("./types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  exports[key] = _types[key];
});

var _constructors = require("./constructors");

Object.keys(_constructors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  exports[key] = _constructors[key];
});

var _guards = require("./guards");

Object.keys(_guards).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  exports[key] = _guards[key];
});
},{"./types":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/types.js","./constructors":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/constructors.js","./guards":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/guards.js"}],"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/index.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = void 0;

var _processor = _interopRequireDefault(require("./processor"));

var selectors = _interopRequireWildcard(require("./selectors"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var parser = function parser(processor) {
  return new _processor.default(processor);
};

Object.assign(parser, selectors);
delete parser.__esModule;
var _default = parser;
exports.default = _default;
module.exports = exports.default;
},{"./processor":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/processor.js","./selectors":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/selectors/index.js"}],"node_modules/postcss-calc/node_modules/postcss-value-parser/lib/parse.js":[function(require,module,exports) {
var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);
var uLower = "u".charCodeAt(0);
var uUpper = "U".charCodeAt(0);
var plus = "+".charCodeAt(0);
var isUnicodeRange = /^[a-f0-9?-]+$/i;

module.exports = function(input) {
  var tokens = [];
  var value = input;

  var next,
    quote,
    prev,
    token,
    escape,
    escapePos,
    whitespacePos,
    parenthesesOpenPos;
  var pos = 0;
  var code = value.charCodeAt(pos);
  var max = value.length;
  var stack = [{ nodes: tokens }];
  var balanced = 0;
  var parent;

  var name = "";
  var before = "";
  var after = "";

  while (pos < max) {
    // Whitespaces
    if (code <= 32) {
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = value.slice(pos, next);

      prev = tokens[tokens.length - 1];
      if (code === closeParentheses && balanced) {
        after = token;
      } else if (prev && prev.type === "div") {
        prev.after = token;
      } else if (
        code === comma ||
        code === colon ||
        (code === slash &&
          value.charCodeAt(next + 1) !== star &&
          (!parent ||
            (parent && parent.type === "function" && parent.value !== "calc")))
      ) {
        before = token;
      } else {
        tokens.push({
          type: "space",
          sourceIndex: pos,
          value: token
        });
      }

      pos = next;

      // Quotes
    } else if (code === singleQuote || code === doubleQuote) {
      next = pos;
      quote = code === singleQuote ? "'" : '"';
      token = {
        type: "string",
        sourceIndex: pos,
        quote: quote
      };
      do {
        escape = false;
        next = value.indexOf(quote, next + 1);
        if (~next) {
          escapePos = next;
          while (value.charCodeAt(escapePos - 1) === backslash) {
            escapePos -= 1;
            escape = !escape;
          }
        } else {
          value += quote;
          next = value.length - 1;
          token.unclosed = true;
        }
      } while (escape);
      token.value = value.slice(pos + 1, next);

      tokens.push(token);
      pos = next + 1;
      code = value.charCodeAt(pos);

      // Comments
    } else if (code === slash && value.charCodeAt(pos + 1) === star) {
      token = {
        type: "comment",
        sourceIndex: pos
      };

      next = value.indexOf("*/", pos);
      if (next === -1) {
        token.unclosed = true;
        next = value.length;
      }

      token.value = value.slice(pos + 2, next);
      tokens.push(token);

      pos = next + 2;
      code = value.charCodeAt(pos);

      // Operation within calc
    } else if (
      (code === slash || code === star) &&
      parent &&
      parent.type === "function" &&
      parent.value === "calc"
    ) {
      token = value[pos];
      tokens.push({
        type: "word",
        sourceIndex: pos - before.length,
        value: token
      });
      pos += 1;
      code = value.charCodeAt(pos);

      // Dividers
    } else if (code === slash || code === comma || code === colon) {
      token = value[pos];

      tokens.push({
        type: "div",
        sourceIndex: pos - before.length,
        value: token,
        before: before,
        after: ""
      });
      before = "";

      pos += 1;
      code = value.charCodeAt(pos);

      // Open parentheses
    } else if (openParentheses === code) {
      // Whitespaces after open parentheses
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      parenthesesOpenPos = pos;
      token = {
        type: "function",
        sourceIndex: pos - name.length,
        value: name,
        before: value.slice(parenthesesOpenPos + 1, next)
      };
      pos = next;

      if (name === "url" && code !== singleQuote && code !== doubleQuote) {
        next -= 1;
        do {
          escape = false;
          next = value.indexOf(")", next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += ")";
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);
        // Whitespaces before closed
        whitespacePos = next;
        do {
          whitespacePos -= 1;
          code = value.charCodeAt(whitespacePos);
        } while (code <= 32);
        if (parenthesesOpenPos < whitespacePos) {
          if (pos !== whitespacePos + 1) {
            token.nodes = [
              {
                type: "word",
                sourceIndex: pos,
                value: value.slice(pos, whitespacePos + 1)
              }
            ];
          } else {
            token.nodes = [];
          }
          if (token.unclosed && whitespacePos + 1 !== next) {
            token.after = "";
            token.nodes.push({
              type: "space",
              sourceIndex: whitespacePos + 1,
              value: value.slice(whitespacePos + 1, next)
            });
          } else {
            token.after = value.slice(whitespacePos + 1, next);
          }
        } else {
          token.after = "";
          token.nodes = [];
        }
        pos = next + 1;
        code = value.charCodeAt(pos);
        tokens.push(token);
      } else {
        balanced += 1;
        token.after = "";
        tokens.push(token);
        stack.push(token);
        tokens = token.nodes = [];
        parent = token;
      }
      name = "";

      // Close parentheses
    } else if (closeParentheses === code && balanced) {
      pos += 1;
      code = value.charCodeAt(pos);

      parent.after = after;
      after = "";
      balanced -= 1;
      stack.pop();
      parent = stack[balanced];
      tokens = parent.nodes;

      // Words
    } else {
      next = pos;
      do {
        if (code === backslash) {
          next += 1;
        }
        next += 1;
        code = value.charCodeAt(next);
      } while (
        next < max &&
        !(
          code <= 32 ||
          code === singleQuote ||
          code === doubleQuote ||
          code === comma ||
          code === colon ||
          code === slash ||
          code === openParentheses ||
          (code === star &&
            parent &&
            parent.type === "function" &&
            parent.value === "calc") ||
          (code === slash &&
            parent.type === "function" &&
            parent.value === "calc") ||
          (code === closeParentheses && balanced)
        )
      );
      token = value.slice(pos, next);

      if (openParentheses === code) {
        name = token;
      } else if (
        (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&
        plus === token.charCodeAt(1) &&
        isUnicodeRange.test(token.slice(2))
      ) {
        tokens.push({
          type: "unicode-range",
          sourceIndex: pos,
          value: token
        });
      } else {
        tokens.push({
          type: "word",
          sourceIndex: pos,
          value: token
        });
      }

      pos = next;
    }
  }

  for (pos = stack.length - 1; pos; pos -= 1) {
    stack[pos].unclosed = true;
  }

  return stack[0].nodes;
};

},{}],"node_modules/postcss-calc/node_modules/postcss-value-parser/lib/walk.js":[function(require,module,exports) {
module.exports = function walk(nodes, cb, bubble) {
  var i, max, node, result;

  for (i = 0, max = nodes.length; i < max; i += 1) {
    node = nodes[i];
    if (!bubble) {
      result = cb(node, i, nodes);
    }

    if (
      result !== false &&
      node.type === "function" &&
      Array.isArray(node.nodes)
    ) {
      walk(node.nodes, cb, bubble);
    }

    if (bubble) {
      cb(node, i, nodes);
    }
  }
};

},{}],"node_modules/postcss-calc/node_modules/postcss-value-parser/lib/stringify.js":[function(require,module,exports) {
function stringifyNode(node, custom) {
  var type = node.type;
  var value = node.value;
  var buf;
  var customResult;

  if (custom && (customResult = custom(node)) !== undefined) {
    return customResult;
  } else if (type === "word" || type === "space") {
    return value;
  } else if (type === "string") {
    buf = node.quote || "";
    return buf + value + (node.unclosed ? "" : buf);
  } else if (type === "comment") {
    return "/*" + value + (node.unclosed ? "" : "*/");
  } else if (type === "div") {
    return (node.before || "") + value + (node.after || "");
  } else if (Array.isArray(node.nodes)) {
    buf = stringify(node.nodes, custom);
    if (type !== "function") {
      return buf;
    }
    return (
      value +
      "(" +
      (node.before || "") +
      buf +
      (node.after || "") +
      (node.unclosed ? "" : ")")
    );
  }
  return value;
}

function stringify(nodes, custom) {
  var result, i;

  if (Array.isArray(nodes)) {
    result = "";
    for (i = nodes.length - 1; ~i; i -= 1) {
      result = stringifyNode(nodes[i], custom) + result;
    }
    return result;
  }
  return stringifyNode(nodes, custom);
}

module.exports = stringify;

},{}],"node_modules/postcss-calc/node_modules/postcss-value-parser/lib/unit.js":[function(require,module,exports) {
var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);

// Check if three code points would start a number
// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
function likeNumber(value) {
  var code = value.charCodeAt(0);
  var nextCode;

  if (code === plus || code === minus) {
    nextCode = value.charCodeAt(1);

    if (nextCode >= 48 && nextCode <= 57) {
      return true;
    }

    var nextNextCode = value.charCodeAt(2);

    if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
      return true;
    }

    return false;
  }

  if (code === dot) {
    nextCode = value.charCodeAt(1);

    if (nextCode >= 48 && nextCode <= 57) {
      return true;
    }

    return false;
  }

  if (code >= 48 && code <= 57) {
    return true;
  }

  return false;
}

// Consume a number
// https://www.w3.org/TR/css-syntax-3/#consume-number
module.exports = function(value) {
  var pos = 0;
  var length = value.length;
  var code;
  var nextCode;
  var nextNextCode;

  if (length === 0 || !likeNumber(value)) {
    return false;
  }

  code = value.charCodeAt(pos);

  if (code === plus || code === minus) {
    pos++;
  }

  while (pos < length) {
    code = value.charCodeAt(pos);

    if (code < 48 || code > 57) {
      break;
    }

    pos += 1;
  }

  code = value.charCodeAt(pos);
  nextCode = value.charCodeAt(pos + 1);

  if (code === dot && nextCode >= 48 && nextCode <= 57) {
    pos += 2;

    while (pos < length) {
      code = value.charCodeAt(pos);

      if (code < 48 || code > 57) {
        break;
      }

      pos += 1;
    }
  }

  code = value.charCodeAt(pos);
  nextCode = value.charCodeAt(pos + 1);
  nextNextCode = value.charCodeAt(pos + 2);

  if (
    (code === exp || code === EXP) &&
    ((nextCode >= 48 && nextCode <= 57) ||
      ((nextCode === plus || nextCode === minus) &&
        nextNextCode >= 48 &&
        nextNextCode <= 57))
  ) {
    pos += nextCode === plus || nextCode === minus ? 3 : 2;

    while (pos < length) {
      code = value.charCodeAt(pos);

      if (code < 48 || code > 57) {
        break;
      }

      pos += 1;
    }
  }

  return {
    number: value.slice(0, pos),
    unit: value.slice(pos)
  };
};

},{}],"node_modules/postcss-calc/node_modules/postcss-value-parser/lib/index.js":[function(require,module,exports) {
var parse = require("./parse");
var walk = require("./walk");
var stringify = require("./stringify");

function ValueParser(value) {
  if (this instanceof ValueParser) {
    this.nodes = parse(value);
    return this;
  }
  return new ValueParser(value);
}

ValueParser.prototype.toString = function() {
  return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};

ValueParser.prototype.walk = function(cb, bubble) {
  walk(this.nodes, cb, bubble);
  return this;
};

ValueParser.unit = require("./unit");

ValueParser.walk = walk;

ValueParser.stringify = stringify;

module.exports = ValueParser;

},{"./parse":"node_modules/postcss-calc/node_modules/postcss-value-parser/lib/parse.js","./walk":"node_modules/postcss-calc/node_modules/postcss-value-parser/lib/walk.js","./stringify":"node_modules/postcss-calc/node_modules/postcss-value-parser/lib/stringify.js","./unit":"node_modules/postcss-calc/node_modules/postcss-value-parser/lib/unit.js"}],"node_modules/postcss-calc/dist/parser.js":[function(require,module,exports) {

/* parser generated by jison 0.6.1-215 */

/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a derivative/copy of this one,
 *               not a direct reference!
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, ...),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    originalQuoteName: function(name),
 *               The basic quoteName handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function
 *               at the end of the `parse()`.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)
 *                             to store/reference the rule value `$$` and location info `@$`.
 *
 *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets
 *                 to see the same object via the `this` reference, i.e. if you wish to carry custom
 *                 data from one reduce action through to the next within a single parse run, then you
 *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.
 *
 *                 `this.yy` is a direct reference to the `yy` shared state object.
 *
 *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`
 *                 object at `parse()` start and are therefore available to the action code via the
 *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from
 *                 the %parse-param` list.
 *
 *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used
 *                             to match this rule. This is *not* the look-ahead token, but the last token
 *                             that's actually part of this rule.
 *
 *                 Formulated another way, `yytext` is the value of the token immediately preceeding
 *                 the current look-ahead token.
 *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.
 *
 *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.
 *
 *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.
 *
 *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.
 *
 *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead
 *                               of an empty object when no suitable location info can be provided.
 *
 *               - `yystate` : the current parser state number, used internally for dispatching and
 *                               executing the action code chunk matching the rule currently being reduced.
 *
 *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *                 Also note that you can access this and other stack index values using the new double-hash
 *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things
 *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.
 *                 This is made available to write very advanced grammar action rules, e.g. when you want
 *                 to investigate the parse state stack in your action code, which would, for example,
 *                 be relevant when you wish to implement error diagnostics and reporting schemes similar
 *                 to the work described here:
 *
 *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.
 *                   In Journées Francophones des Languages Applicatifs.
 *
 *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.
 *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.
 *
 *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.
 *
 *                 This one comes in handy when you are going to do advanced things to the parser
 *                 stacks, all of which are accessible from your action code (see the next entries below).
 *
 *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.
 *                             constructs.
 *
 *               - `yylstack`: reference to the parser token location stack. Also accessed via
 *                             the `@1` etc. constructs.
 *
 *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are
 *                             UNDEFINED rather than an empty (location) object, when the lexer/parser
 *                             action code did not provide a suitable location info object when such a
 *                             slot was filled!
 *
 *               - `yystack` : reference to the parser token id stack. Also accessed via the
 *                             `#1` etc. constructs.
 *
 *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to
 *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might
 *                 want access this array for your own purposes, such as error analysis as mentioned above!
 *
 *                 Note that this stack stores the current stack of *tokens*, that is the sequence of
 *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*
 *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and
 *                 *reduced*.
 *
 *               - `yysstack`: reference to the parser state stack. This one carries the internal parser
 *                             *states* such as the one in `yystate`, which are used to represent
 *                             the parser state machine in the *parse table*. *Very* *internal* stuff,
 *                             what can I say? If you access this one, you're clearly doing wicked things
 *
 *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your
 *                             grammar definition file.
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash, ExceptionClass),
 *    yyError: function(str, ...),
 *    yyRecovering: function(),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this parser kernel in many places; example usage:
 *
 *                   var infoObj = parser.constructParseErrorInfo('fail!', null,
 *                                     parser.collect_expected_token_set(state), true);
 *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);
 *
 *    originalParseError: function(str, hash, ExceptionClass),
 *               The basic `parseError` handler provided by JISON.
 *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function
 *               at the end of the `parse()`.
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input[, args...]),
 *               Parse the given `input` and return the parsed value (or `true` when none was provided by
 *               the root action, in which case the parser is acting as a *matcher*).
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the jison run-time;
 *               when such a collision is detected an exception is thrown to prevent the generated run-time
 *               from silently accepting this confusing and potentially hazardous situation!
 *
 *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in
 *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state
 *               object and any collision with those will be reported by the lexer via a thrown exception.
 *
 *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown
 *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY
 *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and
 *               the internal parser gets properly garbage collected under these particular circumstances.
 *
 *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),
 *               Helper function **which will be set up during the first invocation of the `parse()` method**.
 *               This helper API can be invoked to calculate a spanning `yylloc` location info object.
 *
 *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case
 *               this function will attempt to obtain a suitable location marker by inspecting the location stack
 *               backwards.
 *
 *               For more info see the documentation comment further below, immediately above this function's
 *               implementation.
 *
 *    lexer: {
 *        yy: {...},           A reference to the so-called "shared state" `yy` once
 *                             received via a call to the `.setInput(input, yy)` lexer API.
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash, ExceptionClass),
 *        setInput: function(input, [yy]),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(n),
 *        upcomingInput: function(n),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index, ...),
 *        next: function(...),
 *        lex: function(...),
 *        begin: function(condition),
 *        pushState: function(condition),
 *        popState: function(),
 *        topState: function(),
 *        _currentRules: function(),
 *        stateStackSize: function(),
 *        cleanupAfterLex: function()
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be UNDEFINED when we cannot easily produce such a set)
 *    state:       (integer (or array when the table includes grammar collisions);
 *                  represents the current internal state of the parser kernel.
 *                  can, for example, be used to pass to the `collect_expected_token_set()`
 *                  API to obtain the expected token set)
 *    action:      (integer; represents the current internal action which will be executed)
 *    new_state:   (integer; represents the next/planned internal state, once the current
 *                  action has executed)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *    parser:      (reference to the current parser instance)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 * from either the parser or lexer, `this` will still reference the related *parser*
 * instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 * Please do note that in the latter situation, the `expected` field will be omitted as
 * this type of failure is assumed not to be due to *parse errors* but rather due to user
 * action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy)
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *
 *  yy: {
 *      pre_parse:  function(yy)
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval, parseInfo) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another.
 *                 When it does not return any value, the parser will return the original
 *                 `retval`.
 *                 This function is invoked immediately before `parser.post_parse()`.
 *
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */

        
    
            var parser = (function () {


// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';




        // helper: reconstruct the productions[] table
        function bp(s) {
            var rv = [];
            var p = s.pop;
            var r = s.rule;
            for (var i = 0, l = p.length; i < l; i++) {
                rv.push([
                    p[i],
                    r[i]
                ]);
            }
            return rv;
        }
    


        // helper: reconstruct the defaultActions[] table
        function bda(s) {
            var rv = {};
            var d = s.idx;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var j = d[i];
                rv[j] = g[i];
            }
            return rv;
        }
    


        // helper: reconstruct the 'goto' table
        function bt(s) {
            var rv = [];
            var d = s.len;
            var y = s.symbol;
            var t = s.type;
            var a = s.state;
            var m = s.mode;
            var g = s.goto;
            for (var i = 0, l = d.length; i < l; i++) {
                var n = d[i];
                var q = {};
                for (var j = 0; j < n; j++) {
                    var z = y.shift();
                    switch (t.shift()) {
                    case 2:
                        q[z] = [
                            m.shift(),
                            g.shift()
                        ];
                        break;

                    case 0:
                        q[z] = a.shift();
                        break;

                    default:
                        // type === 1: accept
                        q[z] = [
                            3
                        ];
                    }
                }
                rv.push(q);
            }
            return rv;
        }
    


        // helper: runlength encoding with increment step: code, length: step (default step = 0)
        // `this` references an array
        function s(c, l, a) {
            a = a || 0;
            for (var i = 0; i < l; i++) {
                this.push(c);
                c += a;
            }
        }

        // helper: duplicate sequence from *relative* offset and length.
        // `this` references an array
        function c(i, l) {
            i = this.length - i;
            for (l += i; i < l; i++) {
                this.push(this[i]);
            }
        }

        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.
        function u(a) {
            var rv = [];
            for (var i = 0, l = a.length; i < l; i++) {
                var e = a[i];
                // Is this entry a helper function?
                if (typeof e === 'function') {
                    i++;
                    e.apply(rv, a[i]);
                } else {
                    rv.push(e);
                }
            }
            return rv;
        }
    

var parser = {
    // Code Generator Information Report
    // ---------------------------------
    //
    // Options:
    //
    //   default action mode: ............. ["classic","merge"]
    //   test-compile action mode: ........ "parser:*,lexer:*"
    //   try..catch: ...................... true
    //   default resolve on conflict: ..... true
    //   on-demand look-ahead: ............ false
    //   error recovery token skip maximum: 3
    //   yyerror in parse actions is: ..... NOT recoverable,
    //   yyerror in lexer actions and other non-fatal lexer are:
    //   .................................. NOT recoverable,
    //   debug grammar/output: ............ false
    //   has partial LR conflict upgrade:   true
    //   rudimentary token-stack support:   false
    //   parser table compression mode: ... 2
    //   export debug tables: ............. false
    //   export *all* tables: ............. false
    //   module type: ..................... commonjs
    //   parser engine type: .............. lalr
    //   output main() in the module: ..... true
    //   has user-specified main(): ....... false
    //   has user-specified require()/import modules for main():
    //   .................................. false
    //   number of expected conflicts: .... 0
    //
    //
    // Parser Analysis flags:
    //
    //   no significant actions (parser is a language matcher only):
    //   .................................. false
    //   uses yyleng: ..................... false
    //   uses yylineno: ................... false
    //   uses yytext: ..................... false
    //   uses yylloc: ..................... false
    //   uses ParseError API: ............. false
    //   uses YYERROR: .................... false
    //   uses YYRECOVERING: ............... false
    //   uses YYERROK: .................... false
    //   uses YYCLEARIN: .................. false
    //   tracks rule values: .............. true
    //   assigns rule values: ............. true
    //   uses location tracking: .......... false
    //   assigns location: ................ false
    //   uses yystack: .................... false
    //   uses yysstack: ................... false
    //   uses yysp: ....................... true
    //   uses yyrulelength: ............... false
    //   uses yyMergeLocationInfo API: .... false
    //   has error recovery: .............. false
    //   has error reporting: ............. false
    //
    // --------- END OF REPORT -----------

trace: function no_op_trace() { },
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr",
  hasPartialLrUpgradeOnConflict: true,
  errorRecoveryTokenDiscardCount: 3
},
symbols_: {
  "$accept": 0,
  "$end": 1,
  "ADD": 6,
  "ANGLE": 12,
  "CALC": 3,
  "CHS": 19,
  "DIV": 9,
  "EMS": 17,
  "EOF": 1,
  "EXS": 18,
  "FREQ": 14,
  "FUNCTION": 10,
  "LENGTH": 11,
  "LPAREN": 4,
  "MUL": 8,
  "NUMBER": 26,
  "PERCENTAGE": 25,
  "REMS": 20,
  "RES": 15,
  "RPAREN": 5,
  "SUB": 7,
  "TIME": 13,
  "UNKNOWN_DIMENSION": 16,
  "VHS": 21,
  "VMAXS": 24,
  "VMINS": 23,
  "VWS": 22,
  "dimension": 30,
  "error": 2,
  "expression": 27,
  "function": 29,
  "math_expression": 28,
  "number": 31
},
terminals_: {
  1: "EOF",
  2: "error",
  3: "CALC",
  4: "LPAREN",
  5: "RPAREN",
  6: "ADD",
  7: "SUB",
  8: "MUL",
  9: "DIV",
  10: "FUNCTION",
  11: "LENGTH",
  12: "ANGLE",
  13: "TIME",
  14: "FREQ",
  15: "RES",
  16: "UNKNOWN_DIMENSION",
  17: "EMS",
  18: "EXS",
  19: "CHS",
  20: "REMS",
  21: "VHS",
  22: "VWS",
  23: "VMINS",
  24: "VMAXS",
  25: "PERCENTAGE",
  26: "NUMBER"
},
TERROR: 2,
    EOF: 1,

    // internals: defined here so the object *structure* doesn't get modified by parse() et al,
    // thus helping JIT compilers like Chrome V8.
    originalQuoteName: null,
    originalParseError: null,
    cleanupAfterParse: null,
    constructParseErrorInfo: null,
    yyMergeLocationInfo: null,

    __reentrant_call_depth: 0,      // INTERNAL USE ONLY
    __error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
    __error_recovery_infos: [],     // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup

    // APIs which will be set up depending on user action code analysis:
    //yyRecovering: 0,
    //yyErrOk: 0,
    //yyClearIn: 0,

    // Helper APIs
    // -----------

    // Helper function which can be overridden by user code later on: put suitable quotes around
    // literal IDs in a description string.
    quoteName: function parser_quoteName(id_str) {
        return '"' + id_str + '"';
    },

    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.
    //
    // Return NULL when the symbol is unknown to the parser.
    getSymbolName: function parser_getSymbolName(symbol) {
        if (this.terminals_[symbol]) {
            return this.terminals_[symbol];
        }

        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.
        //
        // An example of this may be where a rule's action code contains a call like this:
        //
        //      parser.getSymbolName(#$)
        //
        // to obtain a human-readable name of the current grammar rule.
        var s = this.symbols_;
        for (var key in s) {
            if (s[key] === symbol) {
                return key;
            }
        }
        return null;
    },

    // Return a more-or-less human-readable description of the given symbol, when available,
    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.
    //
    // Return NULL when the symbol is unknown to the parser.
    describeSymbol: function parser_describeSymbol(symbol) {
        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
            return this.terminal_descriptions_[symbol];
        }
        else if (symbol === this.EOF) {
            return 'end of input';
        }
        var id = this.getSymbolName(symbol);
        if (id) {
            return this.quoteName(id);
        }
        return null;
    },

    // Produce a (more or less) human-readable list of expected tokens at the point of failure.
    //
    // The produced list may contain token or token set descriptions instead of the tokens
    // themselves to help turning this output into something that easier to read by humans
    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
    // expected terminals and nonterminals is produced.
    //
    // The returned list (array) will not contain any duplicate entries.
    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
        var TERROR = this.TERROR;
        var tokenset = [];
        var check = {};
        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
        // If so, use that one instead of the less palatable token set.
        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
            return [
                this.state_descriptions_[state]
            ];
        }
        for (var p in this.table[state]) {
            p = +p;
            if (p !== TERROR) {
                var d = do_not_describe ? p : this.describeSymbol(p);
                if (d && !check[d]) {
                    tokenset.push(d);
                    check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.
                }
            }
        }
        return tokenset;
    },
productions_: bp({
  pop: u([
  27,
  s,
  [28, 9],
  29,
  s,
  [30, 17],
  s,
  [31, 3]
]),
  rule: u([
  2,
  4,
  s,
  [3, 5],
  s,
  [1, 19],
  2,
  2,
  c,
  [3, 3]
])
}),
performAction: function parser__PerformAction(yystate /* action[1] */, yysp, yyvstack) {

          /* this == yyval */

          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;

          

          switch (yystate) {
case 0:
    /*! Production::    $accept : expression $end */

    // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-):
    this.$ = yyvstack[yysp - 1];
    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-)
    break;

case 1:
    /*! Production::    expression : math_expression EOF */

    // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-):
    this.$ = yyvstack[yysp - 1];
    // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-)
    
    
    return yyvstack[yysp - 1];
    break;

case 2:
    /*! Production::    math_expression : CALC LPAREN math_expression RPAREN */
case 7:
    /*! Production::    math_expression : LPAREN math_expression RPAREN */

    this.$ = yyvstack[yysp - 1];
    break;

case 3:
    /*! Production::    math_expression : math_expression ADD math_expression */
case 4:
    /*! Production::    math_expression : math_expression SUB math_expression */
case 5:
    /*! Production::    math_expression : math_expression MUL math_expression */
case 6:
    /*! Production::    math_expression : math_expression DIV math_expression */

    this.$ = { type: 'MathExpression', operator: yyvstack[yysp - 1], left: yyvstack[yysp - 2], right: yyvstack[yysp] };
    break;

case 8:
    /*! Production::    math_expression : function */
case 9:
    /*! Production::    math_expression : dimension */
case 10:
    /*! Production::    math_expression : number */

    this.$ = yyvstack[yysp];
    break;

case 11:
    /*! Production::    function : FUNCTION */

    this.$ = { type: 'Function', value: yyvstack[yysp] };
    break;

case 12:
    /*! Production::    dimension : LENGTH */

    this.$ = { type: 'LengthValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
    break;

case 13:
    /*! Production::    dimension : ANGLE */

    this.$ = { type: 'AngleValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
    break;

case 14:
    /*! Production::    dimension : TIME */

    this.$ = { type: 'TimeValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
    break;

case 15:
    /*! Production::    dimension : FREQ */

    this.$ = { type: 'FrequencyValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
    break;

case 16:
    /*! Production::    dimension : RES */

    this.$ = { type: 'ResolutionValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
    break;

case 17:
    /*! Production::    dimension : UNKNOWN_DIMENSION */

    this.$ = { type: 'UnknownDimension', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
    break;

case 18:
    /*! Production::    dimension : EMS */

    this.$ = { type: 'EmValue', value: parseFloat(yyvstack[yysp]), unit: 'em' };
    break;

case 19:
    /*! Production::    dimension : EXS */

    this.$ = { type: 'ExValue', value: parseFloat(yyvstack[yysp]), unit: 'ex' };
    break;

case 20:
    /*! Production::    dimension : CHS */

    this.$ = { type: 'ChValue', value: parseFloat(yyvstack[yysp]), unit: 'ch' };
    break;

case 21:
    /*! Production::    dimension : REMS */

    this.$ = { type: 'RemValue', value: parseFloat(yyvstack[yysp]), unit: 'rem' };
    break;

case 22:
    /*! Production::    dimension : VHS */

    this.$ = { type: 'VhValue', value: parseFloat(yyvstack[yysp]), unit: 'vh' };
    break;

case 23:
    /*! Production::    dimension : VWS */

    this.$ = { type: 'VwValue', value: parseFloat(yyvstack[yysp]), unit: 'vw' };
    break;

case 24:
    /*! Production::    dimension : VMINS */

    this.$ = { type: 'VminValue', value: parseFloat(yyvstack[yysp]), unit: 'vmin' };
    break;

case 25:
    /*! Production::    dimension : VMAXS */

    this.$ = { type: 'VmaxValue', value: parseFloat(yyvstack[yysp]), unit: 'vmax' };
    break;

case 26:
    /*! Production::    dimension : PERCENTAGE */

    this.$ = { type: 'PercentageValue', value: parseFloat(yyvstack[yysp]), unit: '%' };
    break;

case 27:
    /*! Production::    dimension : ADD dimension */

    var prev = yyvstack[yysp]; this.$ = prev;
    break;

case 28:
    /*! Production::    dimension : SUB dimension */

    var prev = yyvstack[yysp]; prev.value *= -1; this.$ = prev;
    break;

case 29:
    /*! Production::    number : NUMBER */
case 30:
    /*! Production::    number : ADD NUMBER */

    this.$ = { type: 'Number', value: parseFloat(yyvstack[yysp]) };
    break;

case 31:
    /*! Production::    number : SUB NUMBER */

    this.$ = { type: 'Number', value: parseFloat(yyvstack[yysp]) * -1 };
    break;

}
},
table: bt({
  len: u([
  26,
  1,
  5,
  1,
  25,
  s,
  [0, 19],
  19,
  19,
  0,
  0,
  s,
  [25, 5],
  5,
  0,
  0,
  18,
  18,
  0,
  0,
  6,
  6,
  0,
  0,
  c,
  [11, 3]
]),
  symbol: u([
  3,
  4,
  6,
  7,
  s,
  [10, 22, 1],
  1,
  1,
  s,
  [6, 4, 1],
  4,
  c,
  [33, 21],
  c,
  [32, 4],
  6,
  7,
  c,
  [22, 16],
  30,
  c,
  [19, 19],
  c,
  [63, 25],
  c,
  [25, 100],
  s,
  [5, 5, 1],
  c,
  [149, 17],
  c,
  [167, 18],
  30,
  1,
  c,
  [42, 5],
  c,
  [6, 6],
  c,
  [5, 5]
]),
  type: u([
  s,
  [2, 21],
  s,
  [0, 5],
  1,
  s,
  [2, 27],
  s,
  [0, 4],
  c,
  [22, 19],
  c,
  [19, 37],
  c,
  [63, 25],
  c,
  [25, 103],
  c,
  [148, 19],
  c,
  [18, 18]
]),
  state: u([
  1,
  2,
  5,
  6,
  7,
  33,
  c,
  [4, 3],
  34,
  38,
  40,
  c,
  [6, 3],
  41,
  c,
  [4, 3],
  42,
  c,
  [4, 3],
  43,
  c,
  [4, 3],
  44,
  c,
  [22, 5]
]),
  mode: u([
  s,
  [1, 228],
  s,
  [2, 4],
  c,
  [6, 8],
  s,
  [1, 5]
]),
  goto: u([
  3,
  4,
  24,
  25,
  s,
  [8, 16, 1],
  s,
  [26, 7, 1],
  c,
  [27, 21],
  36,
  37,
  c,
  [18, 15],
  35,
  c,
  [18, 17],
  39,
  c,
  [57, 21],
  c,
  [21, 84],
  45,
  c,
  [168, 4],
  c,
  [128, 17],
  c,
  [17, 17],
  s,
  [3, 4],
  30,
  31,
  s,
  [4, 4],
  30,
  31,
  46,
  c,
  [51, 4]
])
}),
defaultActions: bda({
  idx: u([
  s,
  [5, 19, 1],
  26,
  27,
  34,
  35,
  38,
  39,
  42,
  43,
  45,
  46
]),
  goto: u([
  s,
  [8, 19, 1],
  29,
  1,
  27,
  30,
  28,
  31,
  5,
  6,
  7,
  2
])
}),
parseError: function parseError(str, hash, ExceptionClass) {
    if (hash.recoverable) {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        hash.destroy();             // destroy... well, *almost*!
    } else {
        if (typeof this.trace === 'function') {
            this.trace(str);
        }
        if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
        }
        throw new ExceptionClass(str, hash);
    }
},
parse: function parse(input) {
    var self = this;
    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)
    var sstack = new Array(128);        // state stack: stores states (column storage)

    var vstack = new Array(128);        // semantic value stack

    var table = this.table;
    var sp = 0;                         // 'stack pointer': index into the stacks


    


    var symbol = 0;



    var TERROR = this.TERROR;
    var EOF = this.EOF;
    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;
    var NO_ACTION = [0, 47 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState_yy = {
        parseError: undefined,
        quoteName: undefined,
        lexer: undefined,
        parser: undefined,
        pre_parse: undefined,
        post_parse: undefined,
        pre_lex: undefined,
        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
    };

    var ASSERT;
    if (typeof assert !== 'function') {
        ASSERT = function JisonAssert(cond, msg) {
            if (!cond) {
                throw new Error('assertion failed: ' + (msg || '***'));
            }
        };
    } else {
        ASSERT = assert;
    }

    this.yyGetSharedState = function yyGetSharedState() {
        return sharedState_yy;
    };








    function shallow_copy_noclobber(dst, src) {
        for (var k in src) {
            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {
                dst[k] = src[k];
            }
        }
    }

    // copy state
    shallow_copy_noclobber(sharedState_yy, this.yy);

    sharedState_yy.lexer = lexer;
    sharedState_yy.parser = this;






    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState_yy.parseError === 'function') {
        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
        };
    } else {
        this.parseError = this.originalParseError;
    }

    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState_yy.quoteName === 'function') {
        this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
        };
    } else {
        this.quoteName = this.originalQuoteName;
    }

    // set up the cleanup function; make it an API so that external code can re-use this one in case of
    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which
    // case this parse() API method doesn't come with a `finally { ... }` block any more!
    //
    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `sharedState`, etc. references will be *wrong*!
    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
        var rv;

        if (invoke_post_methods) {
            var hash;

            if (sharedState_yy.post_parse || this.post_parse) {
                // create an error hash info instance: we re-use this API in a **non-error situation**
                // as this one delivers all parser internals ready for access by userland code.
                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);
            }

            if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }
            if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== 'undefined') resultValue = rv;
            }

            // cleanup:
            if (hash && hash.destroy) {
                hash.destroy();
            }
        }

        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.

        // clean up the lingering lexer structures as well:
        if (lexer.cleanupAfterLex) {
            lexer.cleanupAfterLex(do_not_nuke_errorinfos);
        }

        // prevent lingering circular references from causing memory leaks:
        if (sharedState_yy) {
            sharedState_yy.lexer = undefined;
            sharedState_yy.parser = undefined;
            if (lexer.yy === sharedState_yy) {
                lexer.yy = undefined;
            }
        }
        sharedState_yy = undefined;
        this.parseError = this.originalParseError;
        this.quoteName = this.originalQuoteName;

        // nuke the vstack[] array at least as that one will still reference obsoleted user values.
        // To be safe, we nuke the other internal stack columns as well...
        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC
        sstack.length = 0;

        vstack.length = 0;
        sp = 0;

        // nuke the error hash info instances created during this run.
        // Userland code must COPY any data/references
        // in the error hash instance(s) it is more permanently interested in.
        if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
                var el = this.__error_infos[i];
                if (el && typeof el.destroy === 'function') {
                    el.destroy();
                }
            }
            this.__error_infos.length = 0;


        }

        return resultValue;
    };






































































































































    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,
    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!
    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {
        var pei = {
            errStr: msg,
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,

            expected: expected,
            recoverable: recoverable,
            state: state,
            action: action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,

            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer,
            parser: this,

            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
                // remove cyclic references added to error info:
                // info.yy = null;
                // info.lexer = null;
                // info.value = null;
                // info.value_stack = null;
                // ...
                var rec = !!this.recoverable;
                for (var key in this) {
                    if (this.hasOwnProperty(key) && typeof key === 'object') {
                        this[key] = undefined;
                    }
                }
                this.recoverable = rec;
            }
        };
        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
        this.__error_infos.push(pei);
        return pei;
    };













    function getNonTerminalFromCode(symbol) {
        var tokenName = self.getSymbolName(symbol);
        if (!tokenName) {
            tokenName = symbol;
        }
        return tokenName;
    }


    function stdLex() {
        var token = lexer.lex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || EOF;
    }

    function fastLex() {
        var token = lexer.fastLex();
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }

        return token || EOF;
    }

    var lex = stdLex;


    var state, action, r, t;
    var yyval = {
        $: true,
        _$: undefined,
        yy: sharedState_yy
    };
    var p;
    var yyrulelen;
    var this_production;
    var newState;
    var retval = false;


    try {
        this.__reentrant_call_depth++;

        lexer.setInput(input, sharedState_yy);

        // NOTE: we *assume* no lexer pre/post handlers are set up *after* 
        // this initial `setInput()` call: hence we can now check and decide
        // whether we'll go with the standard, slower, lex() API or the
        // `fast_lex()` one:
        if (typeof lexer.canIUse === 'function') {
            var lexerInfo = lexer.canIUse();
            if (lexerInfo.fastLex && typeof fastLex === 'function') {
                lex = fastLex;
            }
        } 



        vstack[sp] = null;
        sstack[sp] = 0;
        stack[sp] = 0;
        ++sp;





        if (this.pre_parse) {
            this.pre_parse.call(this, sharedState_yy);
        }
        if (sharedState_yy.pre_parse) {
            sharedState_yy.pre_parse.call(this, sharedState_yy);
        }

        newState = sstack[sp - 1];
        for (;;) {
            // retrieve state number from top of stack
            state = newState;               // sstack[sp - 1];

            // use default actions if available
            if (this.defaultActions[state]) {
                action = 2;
                newState = this.defaultActions[state];
            } else {
                // The single `==` condition below covers both these `===` comparisons in a single
                // operation:
                //
                //     if (symbol === null || typeof symbol === 'undefined') ...
                if (!symbol) {
                    symbol = lex();
                }
                // read action for current state and first input
                t = (table[state] && table[state][symbol]) || NO_ACTION;
                newState = t[1];
                action = t[0];











                // handle parse error
                if (!action) {
                    var errStr;
                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);
                    var expected = this.collect_expected_token_set(state);

                    // Report error
                    if (typeof lexer.yylineno === 'number') {
                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                    } else {
                        errStr = 'Parse error: ';
                    }
                    if (typeof lexer.showPosition === 'function') {
                        errStr += '\n' + lexer.showPosition(79 - 10, 10) + '\n';
                    }
                    if (expected.length) {
                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;
                    } else {
                        errStr += 'Unexpected ' + errSymbolDescr;
                    }
                    // we cannot recover from the error!
                    p = this.constructParseErrorInfo(errStr, null, expected, false);
                    r = this.parseError(p.errStr, p, this.JisonParserError);
                    if (typeof r !== 'undefined') {
                        retval = r;
                    }
                    break;
                }


            }










            switch (action) {
            // catch misc. parse failures:
            default:
                // this shouldn't happen, unless resolve defaults are off
                if (action instanceof Array) {
                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);
                    r = this.parseError(p.errStr, p, this.JisonParserError);
                    if (typeof r !== 'undefined') {
                        retval = r;
                    }
                    break;
                }
                // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                // or a buggy LUT (LookUp Table):
                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);
                r = this.parseError(p.errStr, p, this.JisonParserError);
                if (typeof r !== 'undefined') {
                    retval = r;
                }
                break;

            // shift:
            case 1:
                stack[sp] = symbol;
                vstack[sp] = lexer.yytext;

                sstack[sp] = newState; // push state

                ++sp;
                symbol = 0;




                // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:




                continue;

            // reduce:
            case 2:



                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...
                yyrulelen = this_production[1];










                r = this.performAction.call(yyval, newState, sp - 1, vstack);

                if (typeof r !== 'undefined') {
                    retval = r;
                    break;
                }

                // pop off stack
                sp -= yyrulelen;

                // don't overwrite the `symbol` variable: use a local var to speed things up:
                var ntsymbol = this_production[0];    // push nonterminal (reduce)
                stack[sp] = ntsymbol;
                vstack[sp] = yyval.$;

                // goto new state = table[STATE][NONTERMINAL]
                newState = table[sstack[sp - 1]][ntsymbol];
                sstack[sp] = newState;
                ++sp;









                continue;

            // accept:
            case 3:
                if (sp !== -2) {
                    retval = true;
                    // Return the `$accept` rule's `$$` result, if available.
                    //
                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,
                    // default, action):
                    //
                    //     $accept: <startSymbol> $end
                    //                  %{ $$ = $1; @$ = @1; %}
                    //
                    // which, combined with the parse kernel's `$accept` state behaviour coded below,
                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,
                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                    //
                    // In code:
                    //
                    //                  %{
                    //                      @$ = @1;            // if location tracking support is included
                    //                      if (typeof $1 !== 'undefined')
                    //                          return $1;
                    //                      else
                    //                          return true;           // the default parse result if the rule actions don't produce anything
                    //                  %}
                    sp--;
                    if (typeof vstack[sp] !== 'undefined') {
                        retval = vstack[sp];
                    }
                }
                break;
            }

            // break out of loop: we accept or fail with error
            break;
        }
    } catch (ex) {
        // report exceptions through the parseError callback too, but keep the exception intact
        // if it is a known parser or lexer error which has been thrown by parseError() already:
        if (ex instanceof this.JisonParserError) {
            throw ex;
        }
        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {
            throw ex;
        }

        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);
        retval = false;
        r = this.parseError(p.errStr, p, this.JisonParserError);
        if (typeof r !== 'undefined') {
            retval = r;
        }
    } finally {
        retval = this.cleanupAfterParse(retval, true, true);
        this.__reentrant_call_depth--;
    }   // /finally

    return retval;
}
};
parser.originalParseError = parser.parseError;
parser.originalQuoteName = parser.quoteName;
/* lexer generated by jison-lex 0.6.1-215 */

/*
 * Returns a Lexer object of the following structure:
 *
 *  Lexer: {
 *    yy: {}     The so-called "shared state" or rather the *source* of it;
 *               the real "shared state" `yy` passed around to
 *               the rule actions, etc. is a direct reference!
 *
 *               This "shared context" object was passed to the lexer by way of 
 *               the `lexer.setInput(str, yy)` API before you may use it.
 *
 *               This "shared context" object is passed to the lexer action code in `performAction()`
 *               so userland code in the lexer actions may communicate with the outside world 
 *               and/or other lexer rules' actions in more or less complex ways.
 *
 *  }
 *
 *  Lexer.prototype: {
 *    EOF: 1,
 *    ERROR: 2,
 *
 *    yy:        The overall "shared context" object reference.
 *
 *    JisonLexerError: function(msg, hash),
 *
 *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),
 *
 *               The function parameters and `this` have the following value/meaning:
 *               - `this`    : reference to the `lexer` instance. 
 *                               `yy_` is an alias for `this` lexer instance reference used internally.
 *
 *               - `yy`      : a reference to the `yy` "shared state" object which was passed to the lexer
 *                             by way of the `lexer.setInput(str, yy)` API before.
 *
 *                             Note:
 *                             The extra arguments you specified in the `%parse-param` statement in your
 *                             **parser** grammar definition file are passed to the lexer via this object
 *                             reference as member variables.
 *
 *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.
 *
 *               - `YY_START`: the current lexer "start condition" state.
 *
 *    parseError: function(str, hash, ExceptionClass),
 *
 *    constructLexErrorInfo: function(error_message, is_recoverable),
 *               Helper function.
 *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.
 *               See it's use in this lexer kernel in many places; example usage:
 *
 *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);
 *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);
 *
 *    options: { ... lexer %options ... },
 *
 *    lex: function(),
 *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.
 *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:
 *               these extra `args...` are added verbatim to the `yy` object reference as member variables.
 *
 *               WARNING:
 *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with
 *               any attributes already added to `yy` by the **parser** or the jison run-time; 
 *               when such a collision is detected an exception is thrown to prevent the generated run-time 
 *               from silently accepting this confusing and potentially hazardous situation! 
 *
 *    cleanupAfterLex: function(do_not_nuke_errorinfos),
 *               Helper function.
 *
 *               This helper API is invoked when the **parse process** has completed: it is the responsibility
 *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. 
 *
 *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.
 *
 *    setInput: function(input, [yy]),
 *
 *
 *    input: function(),
 *
 *
 *    unput: function(str),
 *
 *
 *    more: function(),
 *
 *
 *    reject: function(),
 *
 *
 *    less: function(n),
 *
 *
 *    pastInput: function(n),
 *
 *
 *    upcomingInput: function(n),
 *
 *
 *    showPosition: function(),
 *
 *
 *    test_match: function(regex_match_array, rule_index),
 *
 *
 *    next: function(),
 *
 *
 *    begin: function(condition),
 *
 *
 *    pushState: function(condition),
 *
 *
 *    popState: function(),
 *
 *
 *    topState: function(),
 *
 *
 *    _currentRules: function(),
 *
 *
 *    stateStackSize: function(),
 *
 *
 *    performAction: function(yy, yy_, yyrulenumber, YY_START),
 *
 *
 *    rules: [...],
 *
 *
 *    conditions: {associative list: name ==> set},
 *  }
 *
 *
 *  token location info (`yylloc`): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The `parseError` function receives a 'hash' object with these members for lexer errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    yy:          (object: the current parser internal "shared state" `yy`
 *                  as is also available in the rule actions; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *  }
 *
 * while `this` will reference the current lexer instance.
 *
 * When `parseError` is invoked by the lexer, the default implementation will
 * attempt to invoke `yy.parser.parseError()`; when this callback is not provided
 * it will try to invoke `yy.parseError()` instead. When that callback is also not
 * provided, a `JisonLexerError` exception will be thrown containing the error
 * message and `hash`, as constructed by the `constructLexErrorInfo()` API.
 *
 * Note that the lexer's `JisonLexerError` error class is passed via the
 * `ExceptionClass` argument, which is invoked to construct the exception
 * instance to be thrown, so technically `parseError` will throw the object
 * produced by the `new ExceptionClass(str, hash)` JavaScript expression.
 *
 * ---
 *
 * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.
 * These options are available:
 *
 * (Options are permanent.)
 *  
 *  yy: {
 *      parseError: function(str, hash, ExceptionClass)
 *                 optional: overrides the default `parseError` function.
 *  }
 *
 *  lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 * WARNING: the next set of options are not meant to be changed. They echo the abilities of
 * the lexer as per when it was compiled!
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */


var lexer = function() {
  /**
   * See also:
   * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
   * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
   * with userland code which might access the derived class in a 'classic' way.
   *
   * @public
   * @constructor
   * @nocollapse
   */
  function JisonLexerError(msg, hash) {
    Object.defineProperty(this, 'name', {
      enumerable: false,
      writable: false,
      value: 'JisonLexerError'
    });

    if (msg == null)
      msg = '???';

    Object.defineProperty(this, 'message', {
      enumerable: false,
      writable: true,
      value: msg
    });

    this.hash = hash;
    var stacktrace;

    if (hash && hash.exception instanceof Error) {
      var ex2 = hash.exception;
      this.message = ex2.message || msg;
      stacktrace = ex2.stack;
    }

    if (!stacktrace) {
      if (Error.hasOwnProperty('captureStackTrace')) {
        // V8
        Error.captureStackTrace(this, this.constructor);
      } else {
        stacktrace = new Error(msg).stack;
      }
    }

    if (stacktrace) {
      Object.defineProperty(this, 'stack', {
        enumerable: false,
        writable: false,
        value: stacktrace
      });
    }
  }

  if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
  } else {
    JisonLexerError.prototype = Object.create(Error.prototype);
  }

  JisonLexerError.prototype.constructor = JisonLexerError;
  JisonLexerError.prototype.name = 'JisonLexerError';

  var lexer = {
    
// Code Generator Information Report
// ---------------------------------
//
// Options:
//
//   backtracking: .................... false
//   location.ranges: ................. false
//   location line+column tracking: ... true
//
//
// Forwarded Parser Analysis flags:
//
//   uses yyleng: ..................... false
//   uses yylineno: ................... false
//   uses yytext: ..................... false
//   uses yylloc: ..................... false
//   uses lexer values: ............... true / true
//   location tracking: ............... false
//   location assignment: ............. false
//
//
// Lexer Analysis flags:
//
//   uses yyleng: ..................... ???
//   uses yylineno: ................... ???
//   uses yytext: ..................... ???
//   uses yylloc: ..................... ???
//   uses ParseError API: ............. ???
//   uses yyerror: .................... ???
//   uses location tracking & editing:  ???
//   uses more() API: ................. ???
//   uses unput() API: ................ ???
//   uses reject() API: ............... ???
//   uses less() API: ................. ???
//   uses display APIs pastInput(), upcomingInput(), showPosition():
//        ............................. ???
//   uses describeYYLLOC() API: ....... ???
//
// --------- END OF REPORT -----------

EOF: 1,
    ERROR: 2,

    // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

    // options: {},                             /// <-- injected by the code generator

    // yy: ...,                                 /// <-- injected by setInput()

    __currentRuleSet__: null,                   /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  

    __error_infos: [],                          /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  
    __decompressed: false,                      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  
    done: false,                                /// INTERNAL USE ONLY  
    _backtrack: false,                          /// INTERNAL USE ONLY  
    _input: '',                                 /// INTERNAL USE ONLY  
    _more: false,                               /// INTERNAL USE ONLY  
    _signaled_error_token: false,               /// INTERNAL USE ONLY  
    conditionStack: [],                         /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  
    match: '',                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  
    matched: '',                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  
    matches: false,                             /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  
    yytext: '',                                 /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  
    offset: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  
    yyleng: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  
    yylineno: 0,                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  
    yylloc: null,                               /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  

    /**
     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {
      msg = '' + msg;

      // heuristic to determine if the error message already contains a (partial) source code dump
      // as produced by either `showPosition()` or `prettyPrintRange()`:
      if (show_input_position == undefined) {
        show_input_position = !(msg.indexOf('\n') > 0 && msg.indexOf('^') > 0);
      }

      if (this.yylloc && show_input_position) {
        if (typeof this.prettyPrintRange === 'function') {
          var pretty_src = this.prettyPrintRange(this.yylloc);

          if (!/\n\s*$/.test(msg)) {
            msg += '\n';
          }

          msg += '\n  Erroneous area:\n' + this.prettyPrintRange(this.yylloc);
        } else if (typeof this.showPosition === 'function') {
          var pos_str = this.showPosition();

          if (pos_str) {
            if (msg.length && msg[msg.length - 1] !== '\n' && pos_str[0] !== '\n') {
              msg += '\n' + pos_str;
            } else {
              msg += pos_str;
            }
          }
        }
      }

      /** @constructor */
      var pei = {
        errStr: msg,
        recoverable: !!recoverable,
        text: this.match,           // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  
        token: null,
        line: this.yylineno,
        loc: this.yylloc,
        yy: this.yy,
        lexer: this,

        /**
         * and make sure the error info doesn't stay due to potential
         * ref cycle via userland code manipulations.
         * These would otherwise all be memory leak opportunities!
         * 
         * Note that only array and object references are nuked as those
         * constitute the set of elements which can produce a cyclic ref.
         * The rest of the members is kept intact as they are harmless.
         * 
         * @public
         * @this {LexErrorInfo}
         */
        destroy: function destructLexErrorInfo() {
          // remove cyclic references added to error info:
          // info.yy = null;
          // info.lexer = null;
          // ...
          var rec = !!this.recoverable;

          for (var key in this) {
            if (this.hasOwnProperty(key) && typeof key === 'object') {
              this[key] = undefined;
            }
          }

          this.recoverable = rec;
        }
      };

      // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!
      this.__error_infos.push(pei);

      return pei;
    },

    /**
     * handler which is invoked when a lexer error occurs.
     * 
     * @public
     * @this {RegExpLexer}
     */
    parseError: function lexer_parseError(str, hash, ExceptionClass) {
      if (!ExceptionClass) {
        ExceptionClass = this.JisonLexerError;
      }

      if (this.yy) {
        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
          return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        } else if (typeof this.yy.parseError === 'function') {
          return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
        }
      }

      throw new ExceptionClass(str, hash);
    },

    /**
     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
     * 
     * @public
     * @this {RegExpLexer}
     */
    yyerror: function yyError(str /*, ...args */) {
      var lineno_msg = '';

      if (this.yylloc) {
        lineno_msg = ' on line ' + (this.yylineno + 1);
      }

      var p = this.constructLexErrorInfo(
        'Lexical error' + lineno_msg + ': ' + str,
        this.options.lexerErrorsAreRecoverable
      );

      // Add any extra args to the hash under the name `extra_error_attributes`:
      var args = Array.prototype.slice.call(arguments, 1);

      if (args.length) {
        p.extra_error_attributes = args;
      }

      return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
    },

    /**
     * final cleanup function for when we have completed lexing the input;
     * make it an API so that external code can use this one once userland
     * code has decided it's time to destroy any lingering lexer error
     * hash object instances and the like: this function helps to clean
     * up these constructs, which *may* carry cyclic references which would
     * otherwise prevent the instances from being properly and timely
     * garbage-collected, i.e. this function helps prevent memory leaks!
     * 
     * @public
     * @this {RegExpLexer}
     */
    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
      // prevent lingering circular references from causing memory leaks:
      this.setInput('', {});

      // nuke the error hash info instances created during this run.
      // Userland code must COPY any data/references
      // in the error hash instance(s) it is more permanently interested in.
      if (!do_not_nuke_errorinfos) {
        for (var i = this.__error_infos.length - 1; i >= 0; i--) {
          var el = this.__error_infos[i];

          if (el && typeof el.destroy === 'function') {
            el.destroy();
          }
        }

        this.__error_infos.length = 0;
      }

      return this;
    },

    /**
     * clear the lexer token context; intended for internal use only
     * 
     * @public
     * @this {RegExpLexer}
     */
    clear: function lexer_clear() {
      this.yytext = '';
      this.yyleng = 0;
      this.match = '';

      // - DO NOT reset `this.matched`
      this.matches = false;

      this._more = false;
      this._backtrack = false;
      var col = (this.yylloc ? this.yylloc.last_column : 0);

      this.yylloc = {
        first_line: this.yylineno + 1,
        first_column: col,
        last_line: this.yylineno + 1,
        last_column: col,
        range: [this.offset, this.offset]
      };
    },

    /**
     * resets the lexer, sets new input
     * 
     * @public
     * @this {RegExpLexer}
     */
    setInput: function lexer_setInput(input, yy) {
      this.yy = yy || this.yy || {};

      // also check if we've fully initialized the lexer instance,
      // including expansion work to be done to go from a loaded
      // lexer to a usable lexer:
      if (!this.__decompressed) {
        // step 1: decompress the regex list:
        var rules = this.rules;

        for (var i = 0, len = rules.length; i < len; i++) {
          var rule_re = rules[i];

          // compression: is the RE an xref to another RE slot in the rules[] table?
          if (typeof rule_re === 'number') {
            rules[i] = rules[rule_re];
          }
        }

        // step 2: unfold the conditions[] set to make these ready for use:
        var conditions = this.conditions;

        for (var k in conditions) {
          var spec = conditions[k];
          var rule_ids = spec.rules;
          var len = rule_ids.length;
          var rule_regexes = new Array(len + 1);             // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! 
          var rule_new_ids = new Array(len + 1);

          for (var i = 0; i < len; i++) {
            var idx = rule_ids[i];
            var rule_re = rules[idx];
            rule_regexes[i + 1] = rule_re;
            rule_new_ids[i + 1] = idx;
          }

          spec.rules = rule_new_ids;
          spec.__rule_regexes = rule_regexes;
          spec.__rule_count = len;
        }

        this.__decompressed = true;
      }

      this._input = input || '';
      this.clear();
      this._signaled_error_token = false;
      this.done = false;
      this.yylineno = 0;
      this.matched = '';
      this.conditionStack = ['INITIAL'];
      this.__currentRuleSet__ = null;

      this.yylloc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      this.offset = 0;
      return this;
    },

    /**
     * edit the remaining input via user-specified callback.
     * This can be used to forward-adjust the input-to-parse, 
     * e.g. inserting macro expansions and alike in the
     * input which has yet to be lexed.
     * The behaviour of this API contrasts the `unput()` et al
     * APIs as those act on the *consumed* input, while this
     * one allows one to manipulate the future, without impacting
     * the current `yyloc` cursor location or any history. 
     * 
     * Use this API to help implement C-preprocessor-like
     * `#include` statements, etc.
     * 
     * The provided callback must be synchronous and is
     * expected to return the edited input (string).
     *
     * The `cpsArg` argument value is passed to the callback
     * as-is.
     *
     * `callback` interface: 
     * `function callback(input, cpsArg)`
     * 
     * - `input` will carry the remaining-input-to-lex string
     *   from the lexer.
     * - `cpsArg` is `cpsArg` passed into this API.
     * 
     * The `this` reference for the callback will be set to
     * reference this lexer instance so that userland code
     * in the callback can easily and quickly access any lexer
     * API. 
     *
     * When the callback returns a non-string-type falsey value,
     * we assume the callback did not edit the input and we
     * will using the input as-is.
     *
     * When the callback returns a non-string-type value, it
     * is converted to a string for lexing via the `"" + retval`
     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html 
     * -- that way any returned object's `toValue()` and `toString()`
     * methods will be invoked in a proper/desirable order.)
     * 
     * @public
     * @this {RegExpLexer}
     */
    editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
      var rv = callback.call(this, this._input, cpsArg);

      if (typeof rv !== 'string') {
        if (rv) {
          this._input = '' + rv;
        } 
        // else: keep `this._input` as is.  
      } else {
        this._input = rv;
      }

      return this;
    },

    /**
     * consumes and returns one char from the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    input: function lexer_input() {
      if (!this._input) {
        //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)
        return null;
      }

      var ch = this._input[0];
      this.yytext += ch;
      this.yyleng++;
      this.offset++;
      this.match += ch;
      this.matched += ch;

      // Count the linenumber up when we hit the LF (or a stand-alone CR).
      // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
      // and we advance immediately past the LF as well, returning both together as if
      // it was all a single 'character' only.
      var slice_len = 1;

      var lines = false;

      if (ch === '\n') {
        lines = true;
      } else if (ch === '\r') {
        lines = true;
        var ch2 = this._input[1];

        if (ch2 === '\n') {
          slice_len++;
          ch += ch2;
          this.yytext += ch2;
          this.yyleng++;
          this.offset++;
          this.match += ch2;
          this.matched += ch2;
          this.yylloc.range[1]++;
        }
      }

      if (lines) {
        this.yylineno++;
        this.yylloc.last_line++;
        this.yylloc.last_column = 0;
      } else {
        this.yylloc.last_column++;
      }

      this.yylloc.range[1]++;
      this._input = this._input.slice(slice_len);
      return ch;
    },

    /**
     * unshifts one char (or an entire string) into the input
     * 
     * @public
     * @this {RegExpLexer}
     */
    unput: function lexer_unput(ch) {
      var len = ch.length;
      var lines = ch.split(/(?:\r\n?|\n)/g);
      this._input = ch + this._input;
      this.yytext = this.yytext.substr(0, this.yytext.length - len);
      this.yyleng = this.yytext.length;
      this.offset -= len;
      this.match = this.match.substr(0, this.match.length - len);
      this.matched = this.matched.substr(0, this.matched.length - len);

      if (lines.length > 1) {
        this.yylineno -= lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;

        // Get last entirely matched line into the `pre_lines[]` array's
        // last index slot; we don't mind when other previously 
        // matched lines end up in the array too. 
        var pre = this.match;

        var pre_lines = pre.split(/(?:\r\n?|\n)/g);

        if (pre_lines.length === 1) {
          pre = this.matched;
          pre_lines = pre.split(/(?:\r\n?|\n)/g);
        }

        this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
      } else {
        this.yylloc.last_column -= len;
      }

      this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
      this.done = false;
      return this;
    },

    /**
     * cache matched text and append it on next action
     * 
     * @public
     * @this {RegExpLexer}
     */
    more: function lexer_more() {
      this._more = true;
      return this;
    },

    /**
     * signal the lexer that this rule fails to match the input, so the
     * next matching rule (regex) should be tested instead.
     * 
     * @public
     * @this {RegExpLexer}
     */
    reject: function lexer_reject() {
      if (this.options.backtrack_lexer) {
        this._backtrack = true;
      } else {
        // when the `parseError()` call returns, we MUST ensure that the error is registered.
        // We accomplish this by signaling an 'error' token to be produced for the current
        // `.lex()` run.
        var lineno_msg = '';

        if (this.yylloc) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).',
          false
        );

        this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
      }

      return this;
    },

    /**
     * retain first n characters of the match
     * 
     * @public
     * @this {RegExpLexer}
     */
    less: function lexer_less(n) {
      return this.unput(this.match.slice(n));
    },

    /**
     * return (part of the) already matched input, i.e. for error
     * messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of
     * input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     * 
     * @public
     * @this {RegExpLexer}
     */
    pastInput: function lexer_pastInput(maxSize, maxLines) {
      var past = this.matched.substring(0, this.matched.length - this.match.length);

      if (maxSize < 0)
        maxSize = past.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = past.length;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substr` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      past = past.substr(-maxSize * 2 - 2);

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = past.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(-maxLines);
      past = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis prefix...
      if (past.length > maxSize) {
        past = '...' + past.substr(-maxSize);
      }

      return past;
    },

    /**
     * return (part of the) upcoming input, i.e. for error messages.
     * 
     * Limit the returned string length to `maxSize` (default: 20).
     * 
     * Limit the returned string to the `maxLines` number of lines of input (default: 1).
     * 
     * Negative limit values equal *unlimited*.
     *
     * > ### NOTE ###
     * >
     * > *"upcoming input"* is defined as the whole of the both
     * > the *currently lexed* input, together with any remaining input
     * > following that. *"currently lexed"* input is the input 
     * > already recognized by the lexer but not yet returned with
     * > the lexer token. This happens when you are invoking this API
     * > from inside any lexer rule action code block. 
     * >
     * 
     * @public
     * @this {RegExpLexer}
     */
    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
      var next = this.match;

      if (maxSize < 0)
        maxSize = next.length + this._input.length;
      else if (!maxSize)
        maxSize = 20;

      if (maxLines < 0)
        maxLines = maxSize;          // can't ever have more input lines than this! 
      else if (!maxLines)
        maxLines = 1;

      // `substring` anticipation: treat \r\n as a single character and take a little
      // more than necessary so that we can still properly check against maxSize
      // after we've transformed and limited the newLines in here:
      if (next.length < maxSize * 2 + 2) {
        next += this._input.substring(0, maxSize * 2 + 2);   // substring is faster on Chrome/V8 
      }

      // now that we have a significantly reduced string to process, transform the newlines
      // and chop them, then limit them:
      var a = next.replace(/\r\n|\r/g, '\n').split('\n');

      a = a.slice(0, maxLines);
      next = a.join('\n');

      // When, after limiting to maxLines, we still have too much to return,
      // do add an ellipsis postfix...
      if (next.length > maxSize) {
        next = next.substring(0, maxSize) + '...';
      }

      return next;
    },

    /**
     * return a string which displays the character position where the
     * lexing error occurred, i.e. for error messages
     * 
     * @public
     * @this {RegExpLexer}
     */
    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
      var pre = this.pastInput(maxPrefix).replace(/\s/g, ' ');
      var c = new Array(pre.length + 1).join('-');
      return pre + this.upcomingInput(maxPostfix).replace(/\s/g, ' ') + '\n' + c + '^';
    },

    /**
     * return an YYLLOC info object derived off the given context (actual, preceding, following, current).
     * Use this method when the given `actual` location is not guaranteed to exist (i.e. when
     * it MAY be NULL) and you MUST have a valid location info object anyway:
     * then we take the given context of the `preceding` and `following` locations, IFF those are available,
     * and reconstruct the `actual` location info from those.
     * If this fails, the heuristic is to take the `current` location, IFF available.
     * If this fails as well, we assume the sought location is at/around the current lexer position
     * and then produce that one as a response. DO NOTE that these heuristic/derived location info
     * values MAY be inaccurate!
     *
     * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just
     * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).
     * 
     * @public
     * @this {RegExpLexer}
     */
    deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {
      var loc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0,
        range: [0, 0]
      };

      if (actual) {
        loc.first_line = actual.first_line | 0;
        loc.last_line = actual.last_line | 0;
        loc.first_column = actual.first_column | 0;
        loc.last_column = actual.last_column | 0;

        if (actual.range) {
          loc.range[0] = actual.range[0] | 0;
          loc.range[1] = actual.range[1] | 0;
        }
      }

      if (loc.first_line <= 0 || loc.last_line < loc.first_line) {
        // plan B: heuristic using preceding and following:
        if (loc.first_line <= 0 && preceding) {
          loc.first_line = preceding.last_line | 0;
          loc.first_column = preceding.last_column | 0;

          if (preceding.range) {
            loc.range[0] = actual.range[1] | 0;
          }
        }

        if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {
          loc.last_line = following.first_line | 0;
          loc.last_column = following.first_column | 0;

          if (following.range) {
            loc.range[1] = actual.range[0] | 0;
          }
        }

        // plan C?: see if the 'current' location is useful/sane too:
        if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {
          loc.first_line = current.first_line | 0;
          loc.first_column = current.first_column | 0;

          if (current.range) {
            loc.range[0] = current.range[0] | 0;
          }
        }

        if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {
          loc.last_line = current.last_line | 0;
          loc.last_column = current.last_column | 0;

          if (current.range) {
            loc.range[1] = current.range[1] | 0;
          }
        }
      }

      // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter
      // or plan D heuristics to produce a 'sensible' last_line value:
      if (loc.last_line <= 0) {
        if (loc.first_line <= 0) {
          loc.first_line = this.yylloc.first_line;
          loc.last_line = this.yylloc.last_line;
          loc.first_column = this.yylloc.first_column;
          loc.last_column = this.yylloc.last_column;
          loc.range[0] = this.yylloc.range[0];
          loc.range[1] = this.yylloc.range[1];
        } else {
          loc.last_line = this.yylloc.last_line;
          loc.last_column = this.yylloc.last_column;
          loc.range[1] = this.yylloc.range[1];
        }
      }

      if (loc.first_line <= 0) {
        loc.first_line = loc.last_line;
        loc.first_column = 0;  // loc.last_column; 
        loc.range[1] = loc.range[0];
      }

      if (loc.first_column < 0) {
        loc.first_column = 0;
      }

      if (loc.last_column < 0) {
        loc.last_column = (loc.first_column > 0 ? loc.first_column : 80);
      }

      return loc;
    },

    /**
     * return a string which displays the lines & columns of input which are referenced 
     * by the given location info range, plus a few lines of context.
     * 
     * This function pretty-prints the indicated section of the input, with line numbers 
     * and everything!
     * 
     * This function is very useful to provide highly readable error reports, while
     * the location range may be specified in various flexible ways:
     * 
     * - `loc` is the location info object which references the area which should be
     *   displayed and 'marked up': these lines & columns of text are marked up by `^`
     *   characters below each character in the entire input range.
     * 
     * - `context_loc` is the *optional* location info object which instructs this
     *   pretty-printer how much *leading* context should be displayed alongside
     *   the area referenced by `loc`. This can help provide context for the displayed
     *   error, etc.
     * 
     *   When this location info is not provided, a default context of 3 lines is
     *   used.
     * 
     * - `context_loc2` is another *optional* location info object, which serves
     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
     *   context lines to display in the pretty-print output.
     * 
     *   When this location info is not provided, a default context of 1 line only is
     *   used.
     * 
     * Special Notes:
     * 
     * - when the `loc`-indicated range is very large (about 5 lines or more), then
     *   only the first and last few lines of this block are printed while a
     *   `...continued...` message will be printed between them.
     * 
     *   This serves the purpose of not printing a huge amount of text when the `loc`
     *   range happens to be huge: this way a manageable & readable output results
     *   for arbitrary large ranges.
     * 
     * - this function can display lines of input which whave not yet been lexed.
     *   `prettyPrintRange()` can access the entire input!
     * 
     * @public
     * @this {RegExpLexer}
     */
    prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
      loc = this.deriveLocationInfo(loc, context_loc, context_loc2);
      const CONTEXT = 3;
      const CONTEXT_TAIL = 1;
      const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
      var input = this.matched + this._input;
      var lines = input.split('\n');
      var l0 = Math.max(1, (context_loc ? context_loc.first_line : loc.first_line - CONTEXT));
      var l1 = Math.max(1, (context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL));
      var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
      var ws_prefix = new Array(lineno_display_width).join(' ');
      var nonempty_line_indexes = [];

      var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
        var lno = index + l0;
        var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
        var rv = lno_pfx + ': ' + line;
        var errpfx = new Array(lineno_display_width + 1).join('^');
        var offset = 2 + 1;
        var len = 0;

        if (lno === loc.first_line) {
          offset += loc.first_column;

          len = Math.max(
            2,
            ((lno === loc.last_line ? loc.last_column : line.length)) - loc.first_column + 1
          );
        } else if (lno === loc.last_line) {
          len = Math.max(2, loc.last_column + 1);
        } else if (lno > loc.first_line && lno < loc.last_line) {
          len = Math.max(2, line.length + 1);
        }

        if (len) {
          var lead = new Array(offset).join('.');
          var mark = new Array(len).join('^');
          rv += '\n' + errpfx + lead + mark;

          if (line.trim().length > 0) {
            nonempty_line_indexes.push(index);
          }
        }

        rv = rv.replace(/\t/g, ' ');
        return rv;
      });

      // now make sure we don't print an overly large amount of error area: limit it 
      // to the top and bottom line count:
      if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
        var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
        var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;
        var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';
        intermediate_line += '\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';
        rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
      }

      return rv.join('\n');
    },

    /**
     * helper function, used to produce a human readable description as a string, given
     * the input `yylloc` location object.
     * 
     * Set `display_range_too` to TRUE to include the string character index position(s)
     * in the description if the `yylloc.range` is available.
     * 
     * @public
     * @this {RegExpLexer}
     */
    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
      var l1 = yylloc.first_line;
      var l2 = yylloc.last_line;
      var c1 = yylloc.first_column;
      var c2 = yylloc.last_column;
      var dl = l2 - l1;
      var dc = c2 - c1;
      var rv;

      if (dl === 0) {
        rv = 'line ' + l1 + ', ';

        if (dc <= 1) {
          rv += 'column ' + c1;
        } else {
          rv += 'columns ' + c1 + ' .. ' + c2;
        }
      } else {
        rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';
      }

      if (yylloc.range && display_range_too) {
        var r1 = yylloc.range[0];
        var r2 = yylloc.range[1] - 1;

        if (r2 <= r1) {
          rv += ' {String Offset: ' + r1 + '}';
        } else {
          rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';
        }
      }

      return rv;
    },

    /**
     * test the lexed token: return FALSE when not a match, otherwise return token.
     * 
     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
     * contains the actually matched text string.
     * 
     * Also move the input cursor forward and update the match collectors:
     * 
     * - `yytext`
     * - `yyleng`
     * - `match`
     * - `matches`
     * - `yylloc`
     * - `offset`
     * 
     * @public
     * @this {RegExpLexer}
     */
    test_match: function lexer_test_match(match, indexed_rule) {
      var token, lines, backup, match_str, match_str_len;

      if (this.options.backtrack_lexer) {
        // save context
        backup = {
          yylineno: this.yylineno,

          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.yylloc.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column,
            range: this.yylloc.range.slice(0)
          },

          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,

          //_signaled_error_token: this._signaled_error_token,
          yy: this.yy,

          conditionStack: this.conditionStack.slice(0),
          done: this.done
        };
      }

      match_str = match[0];
      match_str_len = match_str.length;

      // if (match_str.indexOf('\n') !== -1 || match_str.indexOf('\r') !== -1) {
      lines = match_str.split(/(?:\r\n?|\n)/g);

      if (lines.length > 1) {
        this.yylineno += lines.length - 1;
        this.yylloc.last_line = this.yylineno + 1;
        this.yylloc.last_column = lines[lines.length - 1].length;
      } else {
        this.yylloc.last_column += match_str_len;
      }

      // }
      this.yytext += match_str;

      this.match += match_str;
      this.matched += match_str;
      this.matches = match;
      this.yyleng = this.yytext.length;
      this.yylloc.range[1] += match_str_len;

      // previous lex rules MAY have invoked the `more()` API rather than producing a token:
      // those rules will already have moved this `offset` forward matching their match lengths,
      // hence we must only add our own match length now:
      this.offset += match_str_len;

      this._more = false;
      this._backtrack = false;
      this._input = this._input.slice(match_str_len);

      // calling this method:
      //
      //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}
      token = this.performAction.call(
        this,
        this.yy,
        indexed_rule,
        this.conditionStack[this.conditionStack.length - 1] /* = YY_START */
      );

      // otherwise, when the action codes are all simple return token statements:
      //token = this.simpleCaseActionClusters[indexed_rule];

      if (this.done && this._input) {
        this.done = false;
      }

      if (token) {
        return token;
      } else if (this._backtrack) {
        // recover context
        for (var k in backup) {
          this[k] = backup[k];
        }

        this.__currentRuleSet__ = null;
        return false;  // rule action called reject() implying the next rule should be tested instead. 
      } else if (this._signaled_error_token) {
        // produce one 'error' token as `.parseError()` in `reject()`
        // did not guarantee a failure signal by throwing an exception!
        token = this._signaled_error_token;

        this._signaled_error_token = false;
        return token;
      }

      return false;
    },

    /**
     * return next match in input
     * 
     * @public
     * @this {RegExpLexer}
     */
    next: function lexer_next() {
      if (this.done) {
        this.clear();
        return this.EOF;
      }

      if (!this._input) {
        this.done = true;
      }

      var token, match, tempMatch, index;

      if (!this._more) {
        this.clear();
      }

      var spec = this.__currentRuleSet__;

      if (!spec) {
        // Update the ruleset cache as we apparently encountered a state change or just started lexing.
        // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will
        // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps
        // speed up those activities a tiny bit.
        spec = this.__currentRuleSet__ = this._currentRules();

        // Check whether a *sane* condition has been pushed before: this makes the lexer robust against
        // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19
        if (!spec || !spec.rules) {
          var lineno_msg = '';

          if (this.options.trackPosition) {
            lineno_msg = ' on line ' + (this.yylineno + 1);
          }

          var p = this.constructLexErrorInfo(
            'Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!',
            false
          );

          // produce one 'error' token until this situation has been resolved, most probably by parse termination!
          return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;
        }
      }

      var rule_ids = spec.rules;
      var regexes = spec.__rule_regexes;
      var len = spec.__rule_count;

      // Note: the arrays are 1-based, while `len` itself is a valid index,
      // hence the non-standard less-or-equal check in the next loop condition!
      for (var i = 1; i <= len; i++) {
        tempMatch = this._input.match(regexes[i]);

        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
          match = tempMatch;
          index = i;

          if (this.options.backtrack_lexer) {
            token = this.test_match(tempMatch, rule_ids[i]);

            if (token !== false) {
              return token;
            } else if (this._backtrack) {
              match = undefined;
              continue;  // rule action called reject() implying a rule MISmatch. 
            } else {
              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
              return false;
            }
          } else if (!this.options.flex) {
            break;
          }
        }
      }

      if (match) {
        token = this.test_match(match, rule_ids[index]);

        if (token !== false) {
          return token;
        }

        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
        return false;
      }

      if (!this._input) {
        this.done = true;
        this.clear();
        return this.EOF;
      } else {
        var lineno_msg = '';

        if (this.options.trackPosition) {
          lineno_msg = ' on line ' + (this.yylineno + 1);
        }

        var p = this.constructLexErrorInfo(
          'Lexical error' + lineno_msg + ': Unrecognized text.',
          this.options.lexerErrorsAreRecoverable
        );

        var pendingInput = this._input;
        var activeCondition = this.topState();
        var conditionStackDepth = this.conditionStack.length;
        token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;

        if (token === this.ERROR) {
          // we can try to recover from a lexer error that `parseError()` did not 'recover' for us
          // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`
          // has not consumed/modified any pending input or changed state in the error handler:
          if (!this.matches && // and make sure the input has been modified/consumed ...
          pendingInput === this._input && // ...or the lexer state has been modified significantly enough
          // to merit a non-consuming error handling action right now.
          activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {
            this.input();
          }
        }

        return token;
      }
    },

    /**
     * return next match that has a token
     * 
     * @public
     * @this {RegExpLexer}
     */
    lex: function lexer_lex() {
      var r;

      // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
      if (typeof this.pre_lex === 'function') {
        r = this.pre_lex.call(this, 0);
      }

      if (typeof this.options.pre_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.options.pre_lex.call(this, r) || r;
      }

      if (this.yy && typeof this.yy.pre_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.yy.pre_lex.call(this, r) || r;
      }

      while (!r) {
        r = this.next();
      }

      if (this.yy && typeof this.yy.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.yy.post_lex.call(this, r) || r;
      }

      if (typeof this.options.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.options.post_lex.call(this, r) || r;
      }

      if (typeof this.post_lex === 'function') {
        // (also account for a userdef function which does not return any value: keep the token as is)
        r = this.post_lex.call(this, r) || r;
      }

      return r;
    },

    /**
     * return next match that has a token. Identical to the `lex()` API but does not invoke any of the 
     * `pre_lex()` nor any of the `post_lex()` callbacks.
     * 
     * @public
     * @this {RegExpLexer}
     */
    fastLex: function lexer_fastLex() {
      var r;

      while (!r) {
        r = this.next();
      }

      return r;
    },

    /**
     * return info about the lexer state that can help a parser or other lexer API user to use the
     * most efficient means available. This API is provided to aid run-time performance for larger
     * systems which employ this lexer.
     * 
     * @public
     * @this {RegExpLexer}
     */
    canIUse: function lexer_canIUse() {
      var rv = {
        fastLex: !(typeof this.pre_lex === 'function' || typeof this.options.pre_lex === 'function' || this.yy && typeof this.yy.pre_lex === 'function' || this.yy && typeof this.yy.post_lex === 'function' || typeof this.options.post_lex === 'function' || typeof this.post_lex === 'function') && typeof this.fastLex === 'function'
      };

      return rv;
    },

    /**
     * backwards compatible alias for `pushState()`;
     * the latter is symmetrical with `popState()` and we advise to use
     * those APIs in any modern lexer code, rather than `begin()`.
     * 
     * @public
     * @this {RegExpLexer}
     */
    begin: function lexer_begin(condition) {
      return this.pushState(condition);
    },

    /**
     * activates a new lexer condition state (pushes the new lexer
     * condition state onto the condition stack)
     * 
     * @public
     * @this {RegExpLexer}
     */
    pushState: function lexer_pushState(condition) {
      this.conditionStack.push(condition);
      this.__currentRuleSet__ = null;
      return this;
    },

    /**
     * pop the previously active lexer condition state off the condition
     * stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    popState: function lexer_popState() {
      var n = this.conditionStack.length - 1;

      if (n > 0) {
        this.__currentRuleSet__ = null;
        return this.conditionStack.pop();
      } else {
        return this.conditionStack[0];
      }
    },

    /**
     * return the currently active lexer condition state; when an index
     * argument is provided it produces the N-th previous condition state,
     * if available
     * 
     * @public
     * @this {RegExpLexer}
     */
    topState: function lexer_topState(n) {
      n = this.conditionStack.length - 1 - Math.abs(n || 0);

      if (n >= 0) {
        return this.conditionStack[n];
      } else {
        return 'INITIAL';
      }
    },

    /**
     * (internal) determine the lexer rule set which is active for the
     * currently active lexer condition state
     * 
     * @public
     * @this {RegExpLexer}
     */
    _currentRules: function lexer__currentRules() {
      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
      } else {
        return this.conditions['INITIAL'];
      }
    },

    /**
     * return the number of states currently on the stack
     * 
     * @public
     * @this {RegExpLexer}
     */
    stateStackSize: function lexer_stateStackSize() {
      return this.conditionStack.length;
    },

    options: {
      trackPosition: true,
      caseInsensitive: true
    },

    JisonLexerError: JisonLexerError,

    performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
      var yy_ = this;
      var YYSTATE = YY_START;

      switch (yyrulenumber) {
      case 0:
        /*! Conditions:: INITIAL */
        /*! Rule::       \s+ */
        /* skip whitespace */
        break;

      default:
        return this.simpleCaseActionClusters[yyrulenumber];
      }
    },

    simpleCaseActionClusters: {
      /*! Conditions:: INITIAL */
      /*! Rule::       (-(webkit|moz)-)?calc\b */
      1: 3,

      /*! Conditions:: INITIAL */
      /*! Rule::       [a-z][a-z0-9-]*\s*\((?:(?:"(?:\\.|[^\"\\])*"|'(?:\\.|[^\'\\])*')|\([^)]*\)|[^\(\)]*)*\) */
      2: 10,

      /*! Conditions:: INITIAL */
      /*! Rule::       \* */
      3: 8,

      /*! Conditions:: INITIAL */
      /*! Rule::       \/ */
      4: 9,

      /*! Conditions:: INITIAL */
      /*! Rule::       \+ */
      5: 6,

      /*! Conditions:: INITIAL */
      /*! Rule::       - */
      6: 7,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)em\b */
      7: 17,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)ex\b */
      8: 18,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)ch\b */
      9: 19,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)rem\b */
      10: 20,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)vw\b */
      11: 22,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)vh\b */
      12: 21,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)vmin\b */
      13: 23,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)vmax\b */
      14: 24,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)cm\b */
      15: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)mm\b */
      16: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)Q\b */
      17: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)in\b */
      18: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)pt\b */
      19: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)pc\b */
      20: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)px\b */
      21: 11,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)deg\b */
      22: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)grad\b */
      23: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)rad\b */
      24: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)turn\b */
      25: 12,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)s\b */
      26: 13,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)ms\b */
      27: 13,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)Hz\b */
      28: 14,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)kHz\b */
      29: 14,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)dpi\b */
      30: 15,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)dpcm\b */
      31: 15,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)dppx\b */
      32: 15,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)% */
      33: 25,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)\b */
      34: 26,

      /*! Conditions:: INITIAL */
      /*! Rule::       (([0-9]+(\.[0-9]+)?|\.[0-9]+)(e(\+|-)[0-9]+)?)-?([a-zA-Z_]|[\240-\377]|(\\[0-9a-fA-F]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-fA-F]))([a-zA-Z0-9_-]|[\240-\377]|(\\[0-9a-fA-F]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-fA-F]))*\b */
      35: 16,

      /*! Conditions:: INITIAL */
      /*! Rule::       \( */
      36: 4,

      /*! Conditions:: INITIAL */
      /*! Rule::       \) */
      37: 5,

      /*! Conditions:: INITIAL */
      /*! Rule::       $ */
      38: 1
    },

    rules: [
      /*  0: */  /^(?:\s+)/i,
      /*  1: */  /^(?:(-(webkit|moz)-)?calc\b)/i,
      /*  2: */  /^(?:[a-z][\d\-a-z]*\s*\((?:(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*')|\([^)]*\)|[^()]*)*\))/i,
      /*  3: */  /^(?:\*)/i,
      /*  4: */  /^(?:\/)/i,
      /*  5: */  /^(?:\+)/i,
      /*  6: */  /^(?:-)/i,
      /*  7: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)em\b)/i,
      /*  8: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)ex\b)/i,
      /*  9: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)ch\b)/i,
      /* 10: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)rem\b)/i,
      /* 11: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)vw\b)/i,
      /* 12: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)vh\b)/i,
      /* 13: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)vmin\b)/i,
      /* 14: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)vmax\b)/i,
      /* 15: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)cm\b)/i,
      /* 16: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)mm\b)/i,
      /* 17: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)Q\b)/i,
      /* 18: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)in\b)/i,
      /* 19: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)pt\b)/i,
      /* 20: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)pc\b)/i,
      /* 21: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)px\b)/i,
      /* 22: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)deg\b)/i,
      /* 23: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)grad\b)/i,
      /* 24: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)rad\b)/i,
      /* 25: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)turn\b)/i,
      /* 26: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)s\b)/i,
      /* 27: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)ms\b)/i,
      /* 28: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)Hz\b)/i,
      /* 29: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)kHz\b)/i,
      /* 30: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)dpi\b)/i,
      /* 31: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)dpcm\b)/i,
      /* 32: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)dppx\b)/i,
      /* 33: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)%)/i,
      /* 34: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)\b)/i,
      /* 35: */  /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)-?([^\W\d]|[ -ÿ]|(\\[\dA-Fa-f]{1,6}(\r\n|[\t\n\f\r ])?|\\[^\d\n\f\rA-Fa-f]))([\w\-]|[ -ÿ]|(\\[\dA-Fa-f]{1,6}(\r\n|[\t\n\f\r ])?|\\[^\d\n\f\rA-Fa-f]))*\b)/i,
      /* 36: */  /^(?:\()/i,
      /* 37: */  /^(?:\))/i,
      /* 38: */  /^(?:$)/i
    ],

    conditions: {
      'INITIAL': {
        rules: [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38
        ],

        inclusive: true
      }
    }
  };

  return lexer;
}();
parser.lexer = lexer;



function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();

        


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = parser;
  exports.Parser = parser.Parser;
  exports.parse = function () {
    return parser.parse.apply(parser, arguments);
  };
  
}

},{}],"node_modules/postcss-calc/dist/lib/convertUnit.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var conversions = {
  // Absolute length units
  'px': {
    'px': 1,
    'cm': 96 / 2.54,
    'mm': 96 / 25.4,
    'q': 96 / 101.6,
    'in': 96,
    'pt': 96 / 72,
    'pc': 16
  },
  'cm': {
    'px': 2.54 / 96,
    'cm': 1,
    'mm': 0.1,
    'q': 0.025,
    'in': 2.54,
    'pt': 2.54 / 72,
    'pc': 2.54 / 6
  },
  'mm': {
    'px': 25.4 / 96,
    'cm': 10,
    'mm': 1,
    'q': 0.25,
    'in': 25.4,
    'pt': 25.4 / 72,
    'pc': 25.4 / 6
  },
  'q': {
    'px': 101.6 / 96,
    'cm': 40,
    'mm': 4,
    'q': 1,
    'in': 101.6,
    'pt': 101.6 / 72,
    'pc': 101.6 / 6
  },
  'in': {
    'px': 1 / 96,
    'cm': 1 / 2.54,
    'mm': 1 / 25.4,
    'q': 1 / 101.6,
    'in': 1,
    'pt': 1 / 72,
    'pc': 1 / 6
  },
  'pt': {
    'px': 0.75,
    'cm': 72 / 2.54,
    'mm': 72 / 25.4,
    'q': 72 / 101.6,
    'in': 72,
    'pt': 1,
    'pc': 12
  },
  'pc': {
    'px': 0.0625,
    'cm': 6 / 2.54,
    'mm': 6 / 25.4,
    'q': 6 / 101.6,
    'in': 6,
    'pt': 6 / 72,
    'pc': 1
  },
  // Angle units
  'deg': {
    'deg': 1,
    'grad': 0.9,
    'rad': 180 / Math.PI,
    'turn': 360
  },
  'grad': {
    'deg': 400 / 360,
    'grad': 1,
    'rad': 200 / Math.PI,
    'turn': 400
  },
  'rad': {
    'deg': Math.PI / 180,
    'grad': Math.PI / 200,
    'rad': 1,
    'turn': Math.PI * 2
  },
  'turn': {
    'deg': 1 / 360,
    'grad': 0.0025,
    'rad': 0.5 / Math.PI,
    'turn': 1
  },
  // Duration units
  's': {
    's': 1,
    'ms': 0.001
  },
  'ms': {
    's': 1000,
    'ms': 1
  },
  // Frequency units
  'hz': {
    'hz': 1,
    'khz': 1000
  },
  'khz': {
    'hz': 0.001,
    'khz': 1
  },
  // Resolution units
  'dpi': {
    'dpi': 1,
    'dpcm': 1 / 2.54,
    'dppx': 1 / 96
  },
  'dpcm': {
    'dpi': 2.54,
    'dpcm': 1,
    'dppx': 2.54 / 96
  },
  'dppx': {
    'dpi': 96,
    'dpcm': 96 / 2.54,
    'dppx': 1
  }
};

function convertUnit(value, sourceUnit, targetUnit, precision) {
  var sourceUnitNormalized = sourceUnit.toLowerCase();
  var targetUnitNormalized = targetUnit.toLowerCase();

  if (!conversions[targetUnitNormalized]) {
    throw new Error("Cannot convert to " + targetUnit);
  }

  if (!conversions[targetUnitNormalized][sourceUnitNormalized]) {
    throw new Error("Cannot convert from " + sourceUnit + " to " + targetUnit);
  }

  var converted = conversions[targetUnitNormalized][sourceUnitNormalized] * value;

  if (precision !== false) {
    precision = Math.pow(10, parseInt(precision) || 5);
    return Math.round(converted * precision) / precision;
  }

  return converted;
}

var _default = convertUnit;
exports.default = _default;
module.exports = exports.default;
},{}],"node_modules/postcss-calc/dist/lib/reducer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _convertUnit = _interopRequireDefault(require("./convertUnit"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isEqual(left, right) {
  return left.type === right.type && left.value === right.value;
}

function isValueType(type) {
  switch (type) {
    case 'LengthValue':
    case 'AngleValue':
    case 'TimeValue':
    case 'FrequencyValue':
    case 'ResolutionValue':
    case 'EmValue':
    case 'ExValue':
    case 'ChValue':
    case 'RemValue':
    case 'VhValue':
    case 'VwValue':
    case 'VminValue':
    case 'VmaxValue':
    case 'PercentageValue':
    case 'Number':
      return true;
  }

  return false;
}

function flip(operator) {
  return operator === '+' ? '-' : '+';
}

function flipValue(node) {
  if (isValueType(node.type)) {
    node.value = -node.value;
  } else if (node.type === 'MathExpression') {
    if (node.operator === '*' || node.operator === '/') {
      node.left = flipValue(node.left);
    } else {
      node.left = flipValue(node.left);
      node.right = flipValue(node.right);
    }
  }

  return node;
}

function reduceAddSubExpression(node, precision) {
  // something + 0 => something
  // something - 0 => something
  if (isValueType(node.right.type) && node.right.value === 0) {
    return node.left;
  } // 0 + something => something


  if (isValueType(node.left.type) && node.left.value === 0 && node.operator === "+") {
    return node.right;
  } // 0 - something => -something


  if (isValueType(node.left.type) && node.left.value === 0 && node.operator === "-" && node.right.type !== "Function") {
    return flipValue(node.right);
  } // value + value
  // value - value


  if (isValueType(node.left.type) && node.left.type === node.right.type) {
    var operator = node.operator;

    var _covertNodesUnits = covertNodesUnits(node.left, node.right, precision),
        left = _covertNodesUnits.left,
        right = _covertNodesUnits.right;

    if (operator === "+") {
      left.value += right.value;
    } else {
      left.value -= right.value;
    }

    return left;
  } // value <op> (expr)


  if (node.right.type === 'MathExpression' && (node.right.operator === '+' || node.right.operator === '-')) {
    // something - (something + something) => something - something - something
    // something - (something - something) => something - something + something
    if ((node.right.operator === '+' || node.right.operator === '-') && node.operator === '-') {
      node.right.operator = flip(node.right.operator);
    }

    if (isValueType(node.left.type)) {
      // value + (value + something) => value + something
      // value + (value - something) => value - something
      // value - (value + something) => value - something
      // value - (value - something) => value + something
      if (node.left.type === node.right.left.type) {
        var _left = node.left,
            _operator = node.operator,
            _right = node.right;
        node.left = reduce({
          type: 'MathExpression',
          operator: _operator,
          left: _left,
          right: _right.left
        });
        node.operator = _right.operator;
        node.right = _right.right;
        return reduce(node, precision);
      } // something + (something + value) => dimension + something
      // something + (something - value) => dimension + something
      // something - (something + value) => dimension - something
      // something - (something - value) => dimension - something


      if (node.left.type === node.right.right.type) {
        var _left2 = node.left,
            _right2 = node.right;
        node.left = reduce({
          type: 'MathExpression',
          operator: _right2.operator,
          left: _left2,
          right: _right2.right
        });
        node.right = _right2.left;
        return reduce(node, precision);
      }
    }
  } // (expr) <op> value


  if (node.left.type === 'MathExpression' && (node.left.operator === '+' || node.left.operator === '-') && isValueType(node.right.type)) {
    // (value + something) + value => value + something
    // (value - something) + value => value - something
    // (value + something) - value => value + something
    // (value - something) - value => value - something
    if (node.right.type === node.left.left.type) {
      var _left3 = node.left,
          _operator2 = node.operator,
          _right3 = node.right;
      _left3.left = reduce({
        type: 'MathExpression',
        operator: _operator2,
        left: _left3.left,
        right: _right3
      }, precision);
      return reduce(_left3, precision);
    } // (something + dimension) + dimension => something + dimension
    // (something - dimension) + dimension => something - dimension
    // (something + dimension) - dimension => something + dimension
    // (something - dimension) - dimension => something - dimension


    if (node.right.type === node.left.right.type) {
      var _left4 = node.left,
          _operator3 = node.operator,
          _right4 = node.right;

      if (_left4.operator === '-') {
        _left4.operator = _operator3 === '-' ? '-' : '+';
        _left4.right = reduce({
          type: 'MathExpression',
          operator: _operator3 === '-' ? '+' : '-',
          left: _right4,
          right: _left4.right
        }, precision);
      } else {
        _left4.right = reduce({
          type: 'MathExpression',
          operator: _operator3,
          left: _left4.right,
          right: _right4
        }, precision);
      }

      if (_left4.right.value < 0) {
        _left4.right.value *= -1;
        _left4.operator = _left4.operator === '-' ? '+' : '-';
      }

      _left4.parenthesized = node.parenthesized;
      return reduce(_left4, precision);
    }
  } // (expr) + (expr) => number
  // (expr) - (expr) => number


  if (node.right.type === 'MathExpression' && node.left.type === 'MathExpression') {
    if (isEqual(node.left.right, node.right.right)) {
      var newNodes = covertNodesUnits(node.left.left, node.right.left, precision);
      node.left = newNodes.left;
      node.right = newNodes.right;
      return reduce(node);
    }

    if (isEqual(node.left.right, node.right.left)) {
      var _newNodes = covertNodesUnits(node.left.left, node.right.right, precision);

      node.left = _newNodes.left;
      node.right = _newNodes.right;
      return reduce(node);
    }
  }

  return node;
}

function reduceDivisionExpression(node) {
  if (!isValueType(node.right.type)) {
    return node;
  }

  if (node.right.type !== 'Number') {
    throw new Error(`Cannot divide by "${node.right.unit}", number expected`);
  }

  if (node.right.value === 0) {
    throw new Error('Cannot divide by zero');
  } // something / value


  if (isValueType(node.left.type)) {
    node.left.value /= node.right.value;
    return node.left;
  }

  return node;
}

function reduceMultiplicationExpression(node) {
  // (expr) * number
  if (node.left.type === 'MathExpression' && node.right.type === 'Number') {
    if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {
      node.left.left.value *= node.right.value;
      node.left.right.value *= node.right.value;
      return node.left;
    }
  } // something * number


  if (isValueType(node.left.type) && node.right.type === 'Number') {
    node.left.value *= node.right.value;
    return node.left;
  } // number * (expr)


  if (node.left.type === 'Number' && node.right.type === 'MathExpression') {
    if (isValueType(node.right.left.type) && isValueType(node.right.right.type)) {
      node.right.left.value *= node.left.value;
      node.right.right.value *= node.left.value;
      return node.right;
    }
  } // number * something


  if (node.left.type === 'Number' && isValueType(node.right.type)) {
    node.right.value *= node.left.value;
    return node.right;
  }

  return node;
}

function covertNodesUnits(left, right, precision) {
  switch (left.type) {
    case 'LengthValue':
    case 'AngleValue':
    case 'TimeValue':
    case 'FrequencyValue':
    case 'ResolutionValue':
      if (right.type === left.type && right.unit && left.unit) {
        var converted = (0, _convertUnit.default)(right.value, right.unit, left.unit, precision);
        right = {
          type: left.type,
          value: converted,
          unit: left.unit
        };
      }

      return {
        left,
        right
      };

    default:
      return {
        left,
        right
      };
  }
}

function reduce(node, precision) {
  if (node.type === "MathExpression") {
    node.left = reduce(node.left, precision);
    node.right = reduce(node.right, precision);

    switch (node.operator) {
      case "+":
      case "-":
        return reduceAddSubExpression(node, precision);

      case "/":
        return reduceDivisionExpression(node, precision);

      case "*":
        return reduceMultiplicationExpression(node, precision);
    }

    return node;
  }

  return node;
}

var _default = reduce;
exports.default = _default;
module.exports = exports.default;
},{"./convertUnit":"node_modules/postcss-calc/dist/lib/convertUnit.js"}],"node_modules/postcss-calc/dist/lib/stringifier.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var order = {
  "*": 0,
  "/": 0,
  "+": 1,
  "-": 1
};

function round(value, prec) {
  if (prec !== false) {
    var precision = Math.pow(10, prec);
    return Math.round(value * precision) / precision;
  }

  return value;
}

function stringify(node, prec) {
  switch (node.type) {
    case "MathExpression":
      {
        var left = node.left,
            right = node.right,
            op = node.operator;
        var str = "";

        if (left.type === 'MathExpression' && order[op] < order[left.operator]) {
          str += `(${stringify(left, prec)})`;
        } else {
          str += stringify(left, prec);
        }

        str += order[op] ? ` ${node.operator} ` : node.operator;

        if (right.type === 'MathExpression' && order[op] < order[right.operator]) {
          str += `(${stringify(right, prec)})`;
        } else {
          str += stringify(right, prec);
        }

        return str;
      }

    case 'Number':
      return round(node.value, prec);

    case 'Function':
      return node.value;

    default:
      return round(node.value, prec) + node.unit;
  }
}

function _default(calc, node, originalValue, options, result, item) {
  var str = stringify(node, options.precision);
  var shouldPrintCalc = node.type === "MathExpression" || node.type === "Function";

  if (shouldPrintCalc) {
    // if calc expression couldn't be resolved to a single value, re-wrap it as
    // a calc()
    str = `${calc}(${str})`; // if the warnWhenCannotResolve option is on, inform the user that the calc
    // expression could not be resolved to a single value

    if (options.warnWhenCannotResolve) {
      result.warn("Could not reduce expression: " + originalValue, {
        plugin: 'postcss-calc',
        node: item
      });
    }
  }

  return str;
}

module.exports = exports.default;
},{}],"node_modules/postcss-calc/dist/lib/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _postcssSelectorParser = _interopRequireDefault(require("postcss-selector-parser"));

var _postcssValueParser = _interopRequireDefault(require("postcss-value-parser"));

var _parser = require("../parser");

var _reducer = _interopRequireDefault(require("./reducer"));

var _stringifier = _interopRequireDefault(require("./stringifier"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line import/no-unresolved
var MATCH_CALC = /((?:-(moz|webkit)-)?calc)/i;

function transformValue(value, options, result, item) {
  return (0, _postcssValueParser.default)(value).walk(function (node) {
    // skip anything which isn't a calc() function
    if (node.type !== 'function' || !MATCH_CALC.test(node.value)) {
      return node;
    } // stringify calc expression and produce an AST


    var contents = _postcssValueParser.default.stringify(node.nodes);

    var ast = _parser.parser.parse(contents); // reduce AST to its simplest form, that is, either to a single value
    // or a simplified calc expression


    var reducedAst = (0, _reducer.default)(ast, options.precision); // stringify AST and write it back

    node.type = 'word';
    node.value = (0, _stringifier.default)(node.value, reducedAst, value, options, result, item);
    return false;
  }).toString();
}

function transformSelector(value, options, result, item) {
  return (0, _postcssSelectorParser.default)(function (selectors) {
    selectors.walk(function (node) {
      // attribute value
      // e.g. the "calc(3*3)" part of "div[data-size="calc(3*3)"]"
      if (node.type === 'attribute' && node.value) {
        node.setValue(transformValue(node.value, options, result, item));
      } // tag value
      // e.g. the "calc(3*3)" part of "div:nth-child(2n + calc(3*3))"


      if (node.type === 'tag') {
        node.value = transformValue(node.value, options, result, item);
      }

      return;
    });
  }).processSync(value);
}

var _default = function _default(node, property, options, result) {
  var value = property === "selector" ? transformSelector(node[property], options, result, node) : transformValue(node[property], options, result, node); // if the preserve option is enabled and the value has changed, write the
  // transformed value into a cloned node which is inserted before the current
  // node, preserving the original value. Otherwise, overwrite the original
  // value.

  if (options.preserve && node[property] !== value) {
    var clone = node.clone();
    clone[property] = value;
    node.parent.insertBefore(node, clone);
  } else {
    node[property] = value;
  }
};

exports.default = _default;
module.exports = exports.default;
},{"postcss-selector-parser":"node_modules/postcss-calc/node_modules/postcss-selector-parser/dist/index.js","postcss-value-parser":"node_modules/postcss-calc/node_modules/postcss-value-parser/lib/index.js","../parser":"node_modules/postcss-calc/dist/parser.js","./reducer":"node_modules/postcss-calc/dist/lib/reducer.js","./stringifier":"node_modules/postcss-calc/dist/lib/stringifier.js"}],"node_modules/postcss-calc/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _postcss = require("postcss");

var _transform = _interopRequireDefault(require("./lib/transform"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _postcss.plugin)('postcss-calc', function (opts) {
  var options = Object.assign({
    precision: 5,
    preserve: false,
    warnWhenCannotResolve: false,
    mediaQueries: false,
    selectors: false
  }, opts);
  return function (css, result) {
    css.walk(function (node) {
      var type = node.type;

      if (type === 'decl') {
        (0, _transform.default)(node, "value", options, result);
      }

      if (type === 'atrule' && options.mediaQueries) {
        (0, _transform.default)(node, "params", options, result);
      }

      if (type === 'rule' && options.selectors) {
        (0, _transform.default)(node, "selector", options, result);
      }
    });
  };
});

exports.default = _default;
module.exports = exports.default;
},{"postcss":"node_modules/postcss/lib/postcss.js","./lib/transform":"node_modules/postcss-calc/dist/lib/transform.js"}],"node_modules/color-name/index.js":[function(require,module,exports) {
'use strict'

module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

},{}],"node_modules/simple-swizzle/node_modules/is-arrayish/index.js":[function(require,module,exports) {
module.exports = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

},{}],"node_modules/simple-swizzle/index.js":[function(require,module,exports) {
'use strict';

var isArrayish = require('is-arrayish');

var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};

},{"is-arrayish":"node_modules/simple-swizzle/node_modules/is-arrayish/index.js"}],"node_modules/color-string/index.js":[function(require,module,exports) {
/* MIT license */
var colorNames = require('color-name');
var swizzle = require('simple-swizzle');

var reverseNames = {};

// create a list of reverse color names
for (var name in colorNames) {
	if (colorNames.hasOwnProperty(name)) {
		reverseNames[colorNames[name]] = name;
	}
}

var cs = module.exports = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var keyword = /(\D+)/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorNames[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d*\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = (parseFloat(match[1]) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = swizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}

},{"color-name":"node_modules/color-name/index.js","simple-swizzle":"node_modules/simple-swizzle/index.js"}],"node_modules/color-convert/node_modules/color-name/index.js":[function(require,module,exports) {
'use strict'

module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

},{}],"node_modules/color-convert/conversions.js":[function(require,module,exports) {
/* MIT license */
var cssKeywords = require('color-name');

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var rdif;
	var gdif;
	var bdif;
	var h;
	var s;

	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var v = Math.max(r, g, b);
	var diff = v - Math.min(r, g, b);
	var diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}
		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

},{"color-name":"node_modules/color-convert/node_modules/color-name/index.js"}],"node_modules/color-convert/route.js":[function(require,module,exports) {
var conversions = require('./conversions');

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};


},{"./conversions":"node_modules/color-convert/conversions.js"}],"node_modules/color-convert/index.js":[function(require,module,exports) {
var conversions = require('./conversions');
var route = require('./route');

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;

},{"./conversions":"node_modules/color-convert/conversions.js","./route":"node_modules/color-convert/route.js"}],"node_modules/color/index.js":[function(require,module,exports) {
'use strict';

var colorString = require('color-string');
var convert = require('color-convert');

var _slice = [].slice;

var skippedModels = [
	// to be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// gray conflicts with some method names, and has its own method defined.
	'gray',

	// shouldn't really be in color-convert either...
	'hex'
];

var hashedModelKeys = {};
Object.keys(convert).forEach(function (model) {
	hashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;
});

var limiters = {};

function Color(obj, model) {
	if (!(this instanceof Color)) {
		return new Color(obj, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in convert)) {
		throw new Error('Unknown model: ' + model);
	}

	var i;
	var channels;

	if (obj == null) { // eslint-disable-line no-eq-null,eqeqeq
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (obj instanceof Color) {
		this.model = obj.model;
		this.color = obj.color.slice();
		this.valpha = obj.valpha;
	} else if (typeof obj === 'string') {
		var result = colorString.get(obj);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + obj);
		}

		this.model = result.model;
		channels = convert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (obj.length) {
		this.model = model || 'rgb';
		channels = convert[this.model].channels;
		var newArr = _slice.call(obj, 0, channels);
		this.color = zeroArray(newArr, channels);
		this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
	} else if (typeof obj === 'number') {
		// this is always RGB - can be converted later on.
		obj &= 0xFFFFFF;
		this.model = 'rgb';
		this.color = [
			(obj >> 16) & 0xFF,
			(obj >> 8) & 0xFF,
			obj & 0xFF
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		var keys = Object.keys(obj);
		if ('alpha' in obj) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
		}

		var hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
		}

		this.model = hashedModelKeys[hashedKeys];

		var labels = convert[this.model].labels;
		var color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(obj[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = convert[this.model].channels;
		for (i = 0; i < channels; i++) {
			var limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString: function () {
		return this.string();
	},

	toJSON: function () {
		return this[this.model]();
	},

	string: function (places) {
		var self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to[self.model](args);
	},

	percentString: function (places) {
		var self = this.rgb().round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to.rgb.percent(args);
	},

	array: function () {
		return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
	},

	object: function () {
		var result = {};
		var channels = convert[this.model].channels;
		var labels = convert[this.model].labels;

		for (var i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray: function () {
		var rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject: function () {
		var rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round: function (places) {
		places = Math.max(places || 0, 0);
		return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
	},

	alpha: function (val) {
		if (arguments.length) {
			return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
		}

		return this.valpha;
	},

	// rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(100)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(100)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return convert[this.model].keyword(this.color);
	},

	hex: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	rgbNumber: function () {
		var rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.rgb().color;

		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	isDark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.rgb().color;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	isLight: function () {
		return !this.isDark();
	},

	negate: function () {
		var rgb = this.rgb();
		for (var i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}
		return rgb;
	},

	lighten: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten: function (ratio) {
		var hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken: function (ratio) {
		var hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale: function () {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var rgb = this.rgb().color;
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(val, val, val);
	},

	fade: function (ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer: function (ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate: function (degrees) {
		var hsl = this.hsl();
		var hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix: function (mixinColor, weight) {
		// ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		if (!mixinColor || !mixinColor.rgb) {
			throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
		}
		var color1 = mixinColor.rgb();
		var color2 = this.rgb();
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return Color.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue(),
				color1.alpha() * p + color2.alpha() * (1 - p));
	}
};

// model conversion methods and static constructors
Object.keys(convert).forEach(function (model) {
	if (skippedModels.indexOf(model) !== -1) {
		return;
	}

	var channels = convert[model].channels;

	// conversion methods
	Color.prototype[model] = function () {
		if (this.model === model) {
			return new Color(this);
		}

		if (arguments.length) {
			return new Color(arguments, model);
		}

		var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
		return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
	};

	// 'static' construction methods
	Color[model] = function (color) {
		if (typeof color === 'number') {
			color = zeroArray(_slice.call(arguments), channels);
		}
		return new Color(color, model);
	};
});

function roundTo(num, places) {
	return Number(num.toFixed(places));
}

function roundToPlace(places) {
	return function (num) {
		return roundTo(num, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	model.forEach(function (m) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	});

	model = model[0];

	return function (val) {
		var result;

		if (arguments.length) {
			if (modifier) {
				val = modifier(val);
			}

			result = this[model]();
			result.color[channel] = val;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(val) {
	return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
	for (var i = 0; i < length; i++) {
		if (typeof arr[i] !== 'number') {
			arr[i] = 0;
		}
	}

	return arr;
}

module.exports = Color;

},{"color-string":"node_modules/color-string/index.js","color-convert":"node_modules/color-convert/index.js"}],"node_modules/postcss-colormin/dist/keywords.json":[function(require,module,exports) {
module.exports = {
  "#f0ffff": "azure",
  "#f5f5dc": "beige",
  "#ffe4c4": "bisque",
  "#a52a2a": "brown",
  "#ff7f50": "coral",
  "#ffd700": "gold",
  "#808080": "grey",
  "#008000": "green",
  "#4b0082": "indigo",
  "#fffff0": "ivory",
  "#f0e68c": "khaki",
  "#faf0e6": "linen",
  "#800000": "maroon",
  "#000080": "navy",
  "#808000": "olive",
  "#ffa500": "orange",
  "#da70d6": "orchid",
  "#cd853f": "peru",
  "#ffc0cb": "pink",
  "#dda0dd": "plum",
  "#800080": "purple",
  "#f00": "red",
  "#fa8072": "salmon",
  "#a0522d": "sienna",
  "#c0c0c0": "silver",
  "#fffafa": "snow",
  "#d2b48c": "tan",
  "#008080": "teal",
  "#ff6347": "tomato",
  "#ee82ee": "violet",
  "#f5deb3": "wheat"
};
},{}],"node_modules/postcss-colormin/dist/lib/toShorthand.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (hex) {
  if (hex[1] === hex[2] && hex[3] === hex[4] && hex[5] === hex[6]) {
    return '#' + hex[2] + hex[4] + hex[6];
  }

  return hex;
};
},{}],"node_modules/postcss-colormin/dist/colours.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _color = require('color');

var _color2 = _interopRequireDefault(_color);

var _keywords = require('./keywords.json');

var _keywords2 = _interopRequireDefault(_keywords);

var _toShorthand = require('./lib/toShorthand');

var _toShorthand2 = _interopRequireDefault(_toShorthand);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var shorter = function shorter(a, b) {
  return (a && a.length < b.length ? a : b).toLowerCase();
};

exports.default = function (colour) {
  var isLegacy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var key = colour + "|" + isLegacy;

  if (cache && cache[key]) {
    return cache[key];
  }

  try {
    var parsed = (0, _color2.default)(colour.toLowerCase());
    var alpha = parsed.alpha();

    if (alpha === 1) {
      var toHex = (0, _toShorthand2.default)(parsed.hex().toLowerCase());
      var result = shorter(_keywords2.default[toHex], toHex);

      if (cache) {
        cache[key] = result;
      }

      return result;
    } else {
      var rgb = parsed.rgb();

      if (!isLegacy && !rgb.color[0] && !rgb.color[1] && !rgb.color[2] && !alpha) {
        var _result2 = 'transparent';

        if (cache) {
          cache[key] = _result2;
        }

        return _result2;
      }

      var hsla = parsed.hsl().string();
      var rgba = rgb.string();

      var _result = hsla.length < rgba.length ? hsla : rgba;

      if (cache) {
        cache[key] = _result;
      }

      return _result;
    }
  } catch (e) {
    // Possibly malformed, so pass through
    var _result3 = colour;

    if (cache) {
      cache[key] = _result3;
    }

    return _result3;
  }
};
},{"color":"node_modules/color/index.js","./keywords.json":"node_modules/postcss-colormin/dist/keywords.json","./lib/toShorthand":"node_modules/postcss-colormin/dist/lib/toShorthand.js"}],"node_modules/postcss-colormin/dist/index.js":[function(require,module,exports) {
var __dirname = "/home/royyan/csspurge/node_modules/postcss-colormin/dist";
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _browserslist = require("browserslist");

var _browserslist2 = _interopRequireDefault(_browserslist);

var _postcss = require("postcss");

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require("postcss-value-parser");

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _colours = require("./colours");

var _colours2 = _interopRequireDefault(_colours);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function walk(parent, callback) {
  parent.nodes.forEach(function (node, index) {
    var bubble = callback(node, index, parent);

    if (node.nodes && bubble !== false) {
      walk(node, callback);
    }
  });
}
/*
 * IE 8 & 9 do not properly handle clicks on elements
 * with a `transparent` `background-color`.
 *
 * https://developer.mozilla.org/en-US/docs/Web/Events/click#Internet_Explorer
 */


function hasTransparentBug(browser) {
  return ~["ie 8", "ie 9"].indexOf(browser);
}

exports.default = _postcss2.default.plugin("postcss-colormin", function () {
  return function (css, result) {
    var resultOpts = result.opts || {};
    var browsers = (0, _browserslist2.default)(null, {
      stats: resultOpts.stats,
      path: __dirname,
      env: resultOpts.env
    });
    var isLegacy = browsers.some(hasTransparentBug);
    var colorminCache = {};
    var cache = {};
    css.walkDecls(function (decl) {
      if (/^(composes|font|filter|-webkit-tap-highlight-color)/i.test(decl.prop)) {
        return;
      }

      if (cache[decl.value]) {
        decl.value = cache[decl.value];
        return;
      }

      var parsed = (0, _postcssValueParser2.default)(decl.value);
      walk(parsed, function (node, index, parent) {
        if (node.type === "function") {
          if (/^(rgb|hsl)a?$/i.test(node.value)) {
            var value = node.value;
            node.value = (0, _colours2.default)((0, _postcssValueParser.stringify)(node), isLegacy, colorminCache);
            node.type = "word";
            var next = parent.nodes[index + 1];

            if (node.value !== value && next && (next.type === "word" || next.type === "function")) {
              parent.nodes.splice(index + 1, 0, {
                type: "space",
                value: " "
              });
            }
          } else if (node.value.toLowerCase() === "calc") {
            return false;
          }
        } else if (node.type === "word") {
          node.value = (0, _colours2.default)(node.value, isLegacy, colorminCache);
        }
      });
      var optimizedValue = parsed.toString();
      decl.value = optimizedValue;
      cache[decl.value] = optimizedValue;
    });
  };
});
},{"browserslist":"node_modules/browserslist/index.js","postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","./colours":"node_modules/postcss-colormin/dist/colours.js"}],"node_modules/postcss-ordered-values/dist/lib/addSpace.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addSpace;

function addSpace() {
  return {
    type: 'space',
    value: ' '
  };
}

module.exports = exports['default'];
},{}],"node_modules/postcss-ordered-values/dist/lib/getValue.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getValue;

var _postcssValueParser = require('postcss-value-parser');

function getValue(values) {
  return (0, _postcssValueParser.stringify)({
    nodes: values.reduce(function (nodes, arg, index) {
      arg.forEach(function (val, idx) {
        if (idx === arg.length - 1 && index === values.length - 1 && val.type === 'space') {
          return;
        }

        nodes.push(val);
      });

      if (index !== values.length - 1) {
        nodes[nodes.length - 1].type = 'div';
        nodes[nodes.length - 1].value = ',';
      }

      return nodes;
    }, [])
  });
}

module.exports = exports['default'];
},{"postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js"}],"node_modules/postcss-ordered-values/dist/rules/animation.js":[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalizeAnimation;

var _postcssValueParser = require('postcss-value-parser');

var _cssnanoUtilGetArguments = require('cssnano-util-get-arguments');

var _cssnanoUtilGetArguments2 = _interopRequireDefault(_cssnanoUtilGetArguments);

var _addSpace = require('../lib/addSpace');

var _addSpace2 = _interopRequireDefault(_addSpace);

var _getValue = require('../lib/getValue');

var _getValue2 = _interopRequireDefault(_getValue);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
} // animation: [ none | <keyframes-name> ] || <time> || <single-timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state>


var isTimingFunction = function isTimingFunction(value, type) {
  var functions = ['steps', 'cubic-bezier', 'frames'];
  var keywords = ['ease', 'ease-in', 'ease-in-out', 'ease-out', 'linear', 'step-end', 'step-start'];
  return type === 'function' && functions.includes(value) || keywords.includes(value);
};

var isDirection = function isDirection(value) {
  return ['normal', 'reverse', 'alternate', 'alternate-reverse'].includes(value);
};

var isFillMode = function isFillMode(value) {
  return ['none', 'forwards', 'backwards', 'both'].includes(value);
};

var isPlayState = function isPlayState(value) {
  return ['running', 'paused'].includes(value);
};

var isTime = function isTime(value) {
  var quantity = (0, _postcssValueParser.unit)(value);
  return quantity && ['ms', 's'].includes(quantity.unit);
};

var isIterationCount = function isIterationCount(value) {
  var quantity = (0, _postcssValueParser.unit)(value);
  return value === 'infinite' || quantity && !quantity.unit;
};

function normalizeAnimation(parsed) {
  var args = (0, _cssnanoUtilGetArguments2.default)(parsed);
  var values = args.reduce(function (list, arg) {
    var state = {
      name: [],
      duration: [],
      timingFunction: [],
      delay: [],
      iterationCount: [],
      direction: [],
      fillMode: [],
      playState: []
    };
    var stateConditions = [{
      property: 'duration',
      delegate: isTime
    }, {
      property: 'timingFunction',
      delegate: isTimingFunction
    }, {
      property: 'delay',
      delegate: isTime
    }, {
      property: 'iterationCount',
      delegate: isIterationCount
    }, {
      property: 'direction',
      delegate: isDirection
    }, {
      property: 'fillMode',
      delegate: isFillMode
    }, {
      property: 'playState',
      delegate: isPlayState
    }];
    arg.forEach(function (node) {
      var type = node.type,
          value = node.value;

      if (type === 'space') {
        return;
      }

      value = value.toLowerCase();
      var hasMatch = stateConditions.some(function (_ref) {
        var property = _ref.property,
            delegate = _ref.delegate;

        if (delegate(value, type) && !state[property].length) {
          state[property] = [node, (0, _addSpace2.default)()];
          return true;
        }
      });

      if (!hasMatch) {
        state.name = [].concat(_toConsumableArray(state.name), [node, (0, _addSpace2.default)()]);
      }
    });
    return [].concat(_toConsumableArray(list), [[].concat(_toConsumableArray(state.name), _toConsumableArray(state.duration), _toConsumableArray(state.timingFunction), _toConsumableArray(state.delay), _toConsumableArray(state.iterationCount), _toConsumableArray(state.direction), _toConsumableArray(state.fillMode), _toConsumableArray(state.playState))]);
  }, []);
  return (0, _getValue2.default)(values);
}

;
module.exports = exports['default'];
},{"postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","cssnano-util-get-arguments":"node_modules/cssnano-util-get-arguments/dist/index.js","../lib/addSpace":"node_modules/postcss-ordered-values/dist/lib/addSpace.js","../lib/getValue":"node_modules/postcss-ordered-values/dist/lib/getValue.js"}],"node_modules/postcss-ordered-values/dist/rules/border.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalizeBorder;

var _postcssValueParser = require('postcss-value-parser'); // border: <line-width> || <line-style> || <color>
// outline: <outline-color> || <outline-style> || <outline-width>


var borderWidths = ['thin', 'medium', 'thick'];
var borderStyles = ['none', 'auto', // only in outline-style
'hidden', 'dotted', 'dashed', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset'];

function normalizeBorder(border) {
  var order = {
    width: '',
    style: '',
    color: ''
  };
  border.walk(function (node) {
    var type = node.type,
        value = node.value;

    if (type === 'word') {
      if (~borderStyles.indexOf(value.toLowerCase())) {
        order.style = value;
        return false;
      }

      if (~borderWidths.indexOf(value.toLowerCase()) || (0, _postcssValueParser.unit)(value.toLowerCase())) {
        if (order.width !== '') {
          order.width = "".concat(order.width, " ").concat(value);
          return false;
        }

        order.width = value;
        return false;
      }

      order.color = value;
      return false;
    }

    if (type === 'function') {
      if (value.toLowerCase() === 'calc') {
        order.width = (0, _postcssValueParser.stringify)(node);
      } else {
        order.color = (0, _postcssValueParser.stringify)(node);
      }

      return false;
    }
  });
  return "".concat(order.width, " ").concat(order.style, " ").concat(order.color).trim();
}

;
module.exports = exports['default'];
},{"postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js"}],"node_modules/postcss-ordered-values/dist/rules/boxShadow.js":[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalizeBoxShadow;

var _postcssValueParser = require('postcss-value-parser');

var _cssnanoUtilGetArguments = require('cssnano-util-get-arguments');

var _cssnanoUtilGetArguments2 = _interopRequireDefault(_cssnanoUtilGetArguments);

var _addSpace = require('../lib/addSpace');

var _addSpace2 = _interopRequireDefault(_addSpace);

var _getValue = require('../lib/getValue');

var _getValue2 = _interopRequireDefault(_getValue);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
} // box-shadow: inset? && <length>{2,4} && <color>?


function normalizeBoxShadow(parsed) {
  var args = (0, _cssnanoUtilGetArguments2.default)(parsed);
  var abort = false;
  var values = args.reduce(function (list, arg) {
    var val = [];
    var state = {
      inset: [],
      color: []
    };
    arg.forEach(function (node) {
      var type = node.type,
          value = node.value;

      if (type === 'function' && ~value.toLowerCase().indexOf('calc')) {
        abort = true;
        return;
      }

      if (type === 'space') {
        return;
      }

      if ((0, _postcssValueParser.unit)(value)) {
        val = [].concat(_toConsumableArray(val), [node, (0, _addSpace2.default)()]);
      } else if (value.toLowerCase() === 'inset') {
        state.inset = [].concat(_toConsumableArray(state.inset), [node, (0, _addSpace2.default)()]);
      } else {
        state.color = [].concat(_toConsumableArray(state.color), [node, (0, _addSpace2.default)()]);
      }
    });
    return [].concat(_toConsumableArray(list), [[].concat(_toConsumableArray(state.inset), _toConsumableArray(val), _toConsumableArray(state.color))]);
  }, []);

  if (abort) {
    return parsed.toString();
  }

  return (0, _getValue2.default)(values);
}

module.exports = exports['default'];
},{"postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","cssnano-util-get-arguments":"node_modules/cssnano-util-get-arguments/dist/index.js","../lib/addSpace":"node_modules/postcss-ordered-values/dist/lib/addSpace.js","../lib/getValue":"node_modules/postcss-ordered-values/dist/lib/getValue.js"}],"node_modules/postcss-ordered-values/dist/rules/flexFlow.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalizeFlexFlow; // flex-flow: <flex-direction> || <flex-wrap>

var flexDirection = ['row', 'row-reverse', 'column', 'column-reverse'];
var flexWrap = ['nowrap', 'wrap', 'wrap-reverse'];

function normalizeFlexFlow(flexFlow) {
  var order = {
    direction: '',
    wrap: ''
  };
  flexFlow.walk(function (_ref) {
    var value = _ref.value;

    if (~flexDirection.indexOf(value.toLowerCase())) {
      order.direction = value;
      return;
    }

    if (~flexWrap.indexOf(value.toLowerCase())) {
      order.wrap = value;
      return;
    }
  });
  return "".concat(order.direction, " ").concat(order.wrap).trim();
}

;
module.exports = exports['default'];
},{}],"node_modules/postcss-ordered-values/dist/rules/transition.js":[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalizeTransition;

var _postcssValueParser = require('postcss-value-parser');

var _cssnanoUtilGetArguments = require('cssnano-util-get-arguments');

var _cssnanoUtilGetArguments2 = _interopRequireDefault(_cssnanoUtilGetArguments);

var _addSpace = require('../lib/addSpace');

var _addSpace2 = _interopRequireDefault(_addSpace);

var _getValue = require('../lib/getValue');

var _getValue2 = _interopRequireDefault(_getValue);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
} // transition: [ none | <single-transition-property> ] || <time> || <single-transition-timing-function> || <time>


var timingFunctions = ['ease', 'linear', 'ease-in', 'ease-out', 'ease-in-out', 'step-start', 'step-end'];

function normalizeTransition(parsed) {
  var args = (0, _cssnanoUtilGetArguments2.default)(parsed);
  var values = args.reduce(function (list, arg) {
    var state = {
      timingFunction: [],
      property: [],
      time1: [],
      time2: []
    };
    arg.forEach(function (node) {
      var type = node.type,
          value = node.value;

      if (type === 'space') {
        return;
      }

      if (type === 'function' && ~['steps', 'cubic-bezier'].indexOf(value.toLowerCase())) {
        state.timingFunction = [].concat(_toConsumableArray(state.timingFunction), [node, (0, _addSpace2.default)()]);
      } else if ((0, _postcssValueParser.unit)(value)) {
        if (!state.time1.length) {
          state.time1 = [].concat(_toConsumableArray(state.time1), [node, (0, _addSpace2.default)()]);
        } else {
          state.time2 = [].concat(_toConsumableArray(state.time2), [node, (0, _addSpace2.default)()]);
        }
      } else if (~timingFunctions.indexOf(value.toLowerCase())) {
        state.timingFunction = [].concat(_toConsumableArray(state.timingFunction), [node, (0, _addSpace2.default)()]);
      } else {
        state.property = [].concat(_toConsumableArray(state.property), [node, (0, _addSpace2.default)()]);
      }
    });
    return [].concat(_toConsumableArray(list), [[].concat(_toConsumableArray(state.property), _toConsumableArray(state.time1), _toConsumableArray(state.timingFunction), _toConsumableArray(state.time2))]);
  }, []);
  return (0, _getValue2.default)(values);
}

module.exports = exports['default'];
},{"postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","cssnano-util-get-arguments":"node_modules/cssnano-util-get-arguments/dist/index.js","../lib/addSpace":"node_modules/postcss-ordered-values/dist/lib/addSpace.js","../lib/getValue":"node_modules/postcss-ordered-values/dist/lib/getValue.js"}],"node_modules/postcss-ordered-values/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _animation = require('./rules/animation');

var _animation2 = _interopRequireDefault(_animation);

var _border = require('./rules/border');

var _border2 = _interopRequireDefault(_border);

var _boxShadow = require('./rules/boxShadow');

var _boxShadow2 = _interopRequireDefault(_boxShadow);

var _flexFlow = require('./rules/flexFlow');

var _flexFlow2 = _interopRequireDefault(_flexFlow);

var _transition = require('./rules/transition');

var _transition2 = _interopRequireDefault(_transition);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/* eslint-disable quote-props */


var rules = {
  'animation': _animation2.default,
  '-webkit-animation': _animation2.default,
  'border': _border2.default,
  'border-top': _border2.default,
  'border-right': _border2.default,
  'border-bottom': _border2.default,
  'border-left': _border2.default,
  'outline': _border2.default,
  'box-shadow': _boxShadow2.default,
  'flex-flow': _flexFlow2.default,
  'transition': _transition2.default,
  '-webkit-transition': _transition2.default
};
/* eslint-enable */
// rules

function shouldAbort(parsed) {
  var abort = false;
  parsed.walk(function (_ref) {
    var type = _ref.type,
        value = _ref.value;

    if (type === 'comment' || type === 'function' && value.toLowerCase() === 'var' || type === 'word' && ~value.indexOf("___CSS_LOADER_IMPORT___")) {
      abort = true;
      return false;
    }
  });
  return abort;
}

function getValue(decl) {
  var value = decl.value,
      raws = decl.raws;

  if (raws && raws.value && raws.value.raw) {
    value = raws.value.raw;
  }

  return value;
}

exports.default = _postcss2.default.plugin('postcss-ordered-values', function () {
  return function (css) {
    var cache = {};
    css.walkDecls(function (decl) {
      var lowerCasedProp = decl.prop.toLowerCase();
      var processor = rules[lowerCasedProp];

      if (!processor) {
        return;
      }

      var value = getValue(decl);

      if (cache[value]) {
        decl.value = cache[value];
        return;
      }

      var parsed = (0, _postcssValueParser2.default)(value);

      if (parsed.nodes.length < 2 || shouldAbort(parsed)) {
        cache[value] = value;
        return;
      }

      var result = processor(parsed);
      decl.value = result;
      cache[value] = result;
    });
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","./rules/animation":"node_modules/postcss-ordered-values/dist/rules/animation.js","./rules/border":"node_modules/postcss-ordered-values/dist/rules/border.js","./rules/boxShadow":"node_modules/postcss-ordered-values/dist/rules/boxShadow.js","./rules/flexFlow":"node_modules/postcss-ordered-values/dist/rules/flexFlow.js","./rules/transition":"node_modules/postcss-ordered-values/dist/rules/transition.js"}],"node_modules/alphanum-sort/lib/compare.js":[function(require,module,exports) {
var zero = '0'.charCodeAt(0);
var plus = '+'.charCodeAt(0);
var minus = '-'.charCodeAt(0);

function isWhitespace(code) {
	return code <= 32;
}

function isDigit(code) {
	return 48 <= code && code <= 57;
}

function isSign(code) {
	return code === minus || code === plus;
}

module.exports = function (opts, a, b) {
	var checkSign = opts.sign;
	var ia = 0;
	var ib = 0;
	var ma = a.length;
	var mb = b.length;
	var ca, cb; // character code
	var za, zb; // leading zero count
	var na, nb; // number length
	var sa, sb; // number sign
	var ta, tb; // temporary
	var bias;

	while (ia < ma && ib < mb) {
		ca = a.charCodeAt(ia);
		cb = b.charCodeAt(ib);
		za = zb = 0;
		na = nb = 0;
		sa = sb = true;
		bias = 0;

		// skip over leading spaces
		while (isWhitespace(ca)) {
			ia += 1;
			ca = a.charCodeAt(ia);
		}
		while (isWhitespace(cb)) {
			ib += 1;
			cb = b.charCodeAt(ib);
		}

		// skip and save sign
		if (checkSign) {
			ta = a.charCodeAt(ia + 1);
			if (isSign(ca) && isDigit(ta)) {
				if (ca === minus) {
					sa = false;
				}
				ia += 1;
				ca = ta;
			}
			tb = b.charCodeAt(ib + 1);
			if (isSign(cb) && isDigit(tb)) {
				if (cb === minus) {
					sb = false;
				}
				ib += 1;
				cb = tb;
			}
		}

		// compare digits with other symbols
		if (isDigit(ca) && !isDigit(cb)) {
			return -1;
		}
		if (!isDigit(ca) && isDigit(cb)) {
			return 1;
		}

		// compare negative and positive
		if (!sa && sb) {
			return -1;
		}
		if (sa && !sb) {
			return 1;
		}

		// count leading zeros
		while (ca === zero) {
			za += 1;
			ia += 1;
			ca = a.charCodeAt(ia);
		}
		while (cb === zero) {
			zb += 1;
			ib += 1;
			cb = b.charCodeAt(ib);
		}

		// count numbers
		while (isDigit(ca) || isDigit(cb)) {
			if (isDigit(ca) && isDigit(cb) && bias === 0) {
				if (sa) {
					if (ca < cb) {
						bias = -1;
					} else if (ca > cb) {
						bias = 1;
					}
				} else {
					if (ca > cb) {
						bias = -1;
					} else if (ca < cb) {
						bias = 1;
					}
				}
			}
			if (isDigit(ca)) {
				ia += 1;
				na += 1;
				ca = a.charCodeAt(ia);
			}
			if (isDigit(cb)) {
				ib += 1;
				nb += 1;
				cb = b.charCodeAt(ib);
			}
		}

		// compare number length
		if (sa) {
			if (na < nb) {
				return -1;
			}
			if (na > nb) {
				return 1;
			}
		} else {
			if (na > nb) {
				return -1;
			}
			if (na < nb) {
				return 1;
			}
		}

		// compare numbers
		if (bias) {
			return bias;
		}

		// compare leading zeros
		if (sa) {
			if (za > zb) {
				return -1;
			}
			if (za < zb) {
				return 1;
			}
		} else {
			if (za < zb) {
				return -1;
			}
			if (za > zb) {
				return 1;
			}
		}

		// compare ascii codes
		if (ca < cb) {
			return -1;
		}
		if (ca > cb) {
			return 1;
		}

		ia += 1;
		ib += 1;
	}

	// compare length
	if (ma < mb) {
		return -1;
	}
	if (ma > mb) {
		return 1;
	}
};

},{}],"node_modules/alphanum-sort/lib/index.js":[function(require,module,exports) {
var compare = require('./compare');

function mediator(a, b) {
	return compare(this, a.converted, b.converted);
}

module.exports = function (array, opts) {
	if (!Array.isArray(array) || array.length < 2) {
		return array;
	}
	if (typeof opts !== 'object') {
		opts = {};
	}
	opts.sign = !!opts.sign;
	var insensitive = !!opts.insensitive;
	var result = Array(array.length);
	var i, max, value;

	for (i = 0, max = array.length; i < max; i += 1) {
		value = String(array[i]);
		result[i] = {
			value: array[i],
			converted: insensitive ? value.toLowerCase() : value
		};
	}

	result.sort(mediator.bind(opts));

	for (i = result.length - 1; ~i; i -= 1) {
		result[i] = result[i].value;
	}

	return result;
};

},{"./compare":"node_modules/alphanum-sort/lib/compare.js"}],"node_modules/is-obj/index.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function (value) {
  var type = _typeof(value);

  return value !== null && (type === 'object' || type === 'function');
};
},{}],"node_modules/dot-prop/index.js":[function(require,module,exports) {
'use strict';

var isObj = require('is-obj');

var disallowedKeys = ['__proto__', 'prototype', 'constructor'];

var isValidPath = function isValidPath(pathSegments) {
  return !pathSegments.some(function (segment) {
    return disallowedKeys.includes(segment);
  });
};

function getPathSegments(path) {
  var pathArray = path.split('.');
  var parts = [];

  for (var i = 0; i < pathArray.length; i++) {
    var p = pathArray[i];

    while (p[p.length - 1] === '\\' && pathArray[i + 1] !== undefined) {
      p = p.slice(0, -1) + '.';
      p += pathArray[++i];
    }

    parts.push(p);
  }

  if (!isValidPath(parts)) {
    return [];
  }

  return parts;
}

module.exports = {
  get: function get(object, path, value) {
    if (!isObj(object) || typeof path !== 'string') {
      return value === undefined ? object : value;
    }

    var pathArray = getPathSegments(path);

    if (pathArray.length === 0) {
      return;
    }

    for (var i = 0; i < pathArray.length; i++) {
      if (!Object.prototype.propertyIsEnumerable.call(object, pathArray[i])) {
        return value;
      }

      object = object[pathArray[i]];

      if (object === undefined || object === null) {
        // `object` is either `undefined` or `null` so we want to stop the loop, and
        // if this is not the last bit of the path, and
        // if it did't return `undefined`
        // it would return `null` if `object` is `null`
        // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`
        if (i !== pathArray.length - 1) {
          return value;
        }

        break;
      }
    }

    return object;
  },
  set: function set(object, path, value) {
    if (!isObj(object) || typeof path !== 'string') {
      return object;
    }

    var root = object;
    var pathArray = getPathSegments(path);

    for (var i = 0; i < pathArray.length; i++) {
      var p = pathArray[i];

      if (!isObj(object[p])) {
        object[p] = {};
      }

      if (i === pathArray.length - 1) {
        object[p] = value;
      }

      object = object[p];
    }

    return root;
  },
  delete: function _delete(object, path) {
    if (!isObj(object) || typeof path !== 'string') {
      return;
    }

    var pathArray = getPathSegments(path);

    for (var i = 0; i < pathArray.length; i++) {
      var p = pathArray[i];

      if (i === pathArray.length - 1) {
        delete object[p];
        return;
      }

      object = object[p];

      if (!isObj(object)) {
        return;
      }
    }
  },
  has: function has(object, path) {
    if (!isObj(object) || typeof path !== 'string') {
      return false;
    }

    var pathArray = getPathSegments(path);

    if (pathArray.length === 0) {
      return false;
    } // eslint-disable-next-line unicorn/no-for-loop


    for (var i = 0; i < pathArray.length; i++) {
      if (isObj(object)) {
        if (!(pathArray[i] in object)) {
          return false;
        }

        object = object[pathArray[i]];
      } else {
        return false;
      }
    }

    return true;
  }
};
},{"is-obj":"node_modules/is-obj/index.js"}],"node_modules/postcss-selector-parser/dist/selectors/node.js":[function(require,module,exports) {
'use strict';

function _typeof2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var cloneNode = function cloneNode(obj, parent) {
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
    return obj;
  }

  var cloned = new obj.constructor();

  for (var i in obj) {
    if (!obj.hasOwnProperty(i)) {
      continue;
    }

    var value = obj[i];
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

    if (i === 'parent' && type === 'object') {
      if (parent) {
        cloned[i] = parent;
      }
    } else if (value instanceof Array) {
      cloned[i] = value.map(function (j) {
        return cloneNode(j, cloned);
      });
    } else {
      cloned[i] = cloneNode(value, cloned);
    }
  }

  return cloned;
};

var _class = function () {
  function _class() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, _class);

    Object.assign(this, opts);
    this.spaces = this.spaces || {};
    this.spaces.before = this.spaces.before || '';
    this.spaces.after = this.spaces.after || '';
  }

  _class.prototype.remove = function remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }

    this.parent = undefined;
    return this;
  };

  _class.prototype.replaceWith = function replaceWith() {
    if (this.parent) {
      for (var index in arguments) {
        this.parent.insertBefore(this, arguments[index]);
      }

      this.remove();
    }

    return this;
  };

  _class.prototype.next = function next() {
    return this.parent.at(this.parent.index(this) + 1);
  };

  _class.prototype.prev = function prev() {
    return this.parent.at(this.parent.index(this) - 1);
  };

  _class.prototype.clone = function clone() {
    var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var cloned = cloneNode(this);

    for (var name in overrides) {
      cloned[name] = overrides[name];
    }

    return cloned;
  };

  _class.prototype.toString = function toString() {
    return [this.spaces.before, String(this.value), this.spaces.after].join('');
  };

  return _class;
}();

exports.default = _class;
module.exports = exports['default'];
},{}],"node_modules/postcss-selector-parser/dist/selectors/types.js":[function(require,module,exports) {
'use strict';

exports.__esModule = true;
var TAG = exports.TAG = 'tag';
var STRING = exports.STRING = 'string';
var SELECTOR = exports.SELECTOR = 'selector';
var ROOT = exports.ROOT = 'root';
var PSEUDO = exports.PSEUDO = 'pseudo';
var NESTING = exports.NESTING = 'nesting';
var ID = exports.ID = 'id';
var COMMENT = exports.COMMENT = 'comment';
var COMBINATOR = exports.COMBINATOR = 'combinator';
var CLASS = exports.CLASS = 'class';
var ATTRIBUTE = exports.ATTRIBUTE = 'attribute';
var UNIVERSAL = exports.UNIVERSAL = 'universal';
},{}],"node_modules/postcss-selector-parser/dist/selectors/container.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _types = require('./types');

var types = _interopRequireWildcard(_types);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Container = function (_Node) {
  _inherits(Container, _Node);

  function Container(opts) {
    _classCallCheck(this, Container);

    var _this = _possibleConstructorReturn(this, _Node.call(this, opts));

    if (!_this.nodes) {
      _this.nodes = [];
    }

    return _this;
  }

  Container.prototype.append = function append(selector) {
    selector.parent = this;
    this.nodes.push(selector);
    return this;
  };

  Container.prototype.prepend = function prepend(selector) {
    selector.parent = this;
    this.nodes.unshift(selector);
    return this;
  };

  Container.prototype.at = function at(index) {
    return this.nodes[index];
  };

  Container.prototype.index = function index(child) {
    if (typeof child === 'number') {
      return child;
    }

    return this.nodes.indexOf(child);
  };

  Container.prototype.removeChild = function removeChild(child) {
    child = this.index(child);
    this.at(child).parent = undefined;
    this.nodes.splice(child, 1);
    var index = void 0;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index >= child) {
        this.indexes[id] = index - 1;
      }
    }

    return this;
  };

  Container.prototype.removeAll = function removeAll() {
    for (var _iterator = this.nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var node = _ref;
      node.parent = undefined;
    }

    this.nodes = [];
    return this;
  };

  Container.prototype.empty = function empty() {
    return this.removeAll();
  };

  Container.prototype.insertAfter = function insertAfter(oldNode, newNode) {
    newNode.parent = this;
    var oldIndex = this.index(oldNode);
    this.nodes.splice(oldIndex + 1, 0, newNode);
    newNode.parent = this;
    var index = void 0;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (oldIndex <= index) {
        this.indexes[id] = index + 1;
      }
    }

    return this;
  };

  Container.prototype.insertBefore = function insertBefore(oldNode, newNode) {
    newNode.parent = this;
    var oldIndex = this.index(oldNode);
    this.nodes.splice(oldIndex, 0, newNode);
    newNode.parent = this;
    var index = void 0;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index <= oldIndex) {
        this.indexes[id] = index + 1;
      }
    }

    return this;
  };

  Container.prototype.each = function each(callback) {
    if (!this.lastEach) {
      this.lastEach = 0;
    }

    if (!this.indexes) {
      this.indexes = {};
    }

    this.lastEach++;
    var id = this.lastEach;
    this.indexes[id] = 0;

    if (!this.length) {
      return undefined;
    }

    var index = void 0,
        result = void 0;

    while (this.indexes[id] < this.length) {
      index = this.indexes[id];
      result = callback(this.at(index), index);

      if (result === false) {
        break;
      }

      this.indexes[id] += 1;
    }

    delete this.indexes[id];

    if (result === false) {
      return false;
    }
  };

  Container.prototype.walk = function walk(callback) {
    return this.each(function (node, i) {
      var result = callback(node, i);

      if (result !== false && node.length) {
        result = node.walk(callback);
      }

      if (result === false) {
        return false;
      }
    });
  };

  Container.prototype.walkAttributes = function walkAttributes(callback) {
    var _this2 = this;

    return this.walk(function (selector) {
      if (selector.type === types.ATTRIBUTE) {
        return callback.call(_this2, selector);
      }
    });
  };

  Container.prototype.walkClasses = function walkClasses(callback) {
    var _this3 = this;

    return this.walk(function (selector) {
      if (selector.type === types.CLASS) {
        return callback.call(_this3, selector);
      }
    });
  };

  Container.prototype.walkCombinators = function walkCombinators(callback) {
    var _this4 = this;

    return this.walk(function (selector) {
      if (selector.type === types.COMBINATOR) {
        return callback.call(_this4, selector);
      }
    });
  };

  Container.prototype.walkComments = function walkComments(callback) {
    var _this5 = this;

    return this.walk(function (selector) {
      if (selector.type === types.COMMENT) {
        return callback.call(_this5, selector);
      }
    });
  };

  Container.prototype.walkIds = function walkIds(callback) {
    var _this6 = this;

    return this.walk(function (selector) {
      if (selector.type === types.ID) {
        return callback.call(_this6, selector);
      }
    });
  };

  Container.prototype.walkNesting = function walkNesting(callback) {
    var _this7 = this;

    return this.walk(function (selector) {
      if (selector.type === types.NESTING) {
        return callback.call(_this7, selector);
      }
    });
  };

  Container.prototype.walkPseudos = function walkPseudos(callback) {
    var _this8 = this;

    return this.walk(function (selector) {
      if (selector.type === types.PSEUDO) {
        return callback.call(_this8, selector);
      }
    });
  };

  Container.prototype.walkTags = function walkTags(callback) {
    var _this9 = this;

    return this.walk(function (selector) {
      if (selector.type === types.TAG) {
        return callback.call(_this9, selector);
      }
    });
  };

  Container.prototype.walkUniversals = function walkUniversals(callback) {
    var _this10 = this;

    return this.walk(function (selector) {
      if (selector.type === types.UNIVERSAL) {
        return callback.call(_this10, selector);
      }
    });
  };

  Container.prototype.split = function split(callback) {
    var _this11 = this;

    var current = [];
    return this.reduce(function (memo, node, index) {
      var split = callback.call(_this11, node);
      current.push(node);

      if (split) {
        memo.push(current);
        current = [];
      } else if (index === _this11.length - 1) {
        memo.push(current);
      }

      return memo;
    }, []);
  };

  Container.prototype.map = function map(callback) {
    return this.nodes.map(callback);
  };

  Container.prototype.reduce = function reduce(callback, memo) {
    return this.nodes.reduce(callback, memo);
  };

  Container.prototype.every = function every(callback) {
    return this.nodes.every(callback);
  };

  Container.prototype.some = function some(callback) {
    return this.nodes.some(callback);
  };

  Container.prototype.filter = function filter(callback) {
    return this.nodes.filter(callback);
  };

  Container.prototype.sort = function sort(callback) {
    return this.nodes.sort(callback);
  };

  Container.prototype.toString = function toString() {
    return this.map(String).join('');
  };

  _createClass(Container, [{
    key: 'first',
    get: function get() {
      return this.at(0);
    }
  }, {
    key: 'last',
    get: function get() {
      return this.at(this.length - 1);
    }
  }, {
    key: 'length',
    get: function get() {
      return this.nodes.length;
    }
  }]);

  return Container;
}(_node2.default);

exports.default = Container;
module.exports = exports['default'];
},{"./node":"node_modules/postcss-selector-parser/dist/selectors/node.js","./types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/selectors/root.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Root = function (_Container) {
  _inherits(Root, _Container);

  function Root(opts) {
    _classCallCheck(this, Root);

    var _this = _possibleConstructorReturn(this, _Container.call(this, opts));

    _this.type = _types.ROOT;
    return _this;
  }

  Root.prototype.toString = function toString() {
    var str = this.reduce(function (memo, selector) {
      var sel = String(selector);
      return sel ? memo + sel + ',' : '';
    }, '').slice(0, -1);
    return this.trailingComma ? str + ',' : str;
  };

  Root.prototype.error = function error(message, options) {
    if (this._error) {
      return this._error(message, options);
    } else {
      return new Error(message);
    }
  };

  _createClass(Root, [{
    key: 'errorGenerator',
    set: function set(handler) {
      this._error = handler;
    }
  }]);

  return Root;
}(_container2.default);

exports.default = Root;
module.exports = exports['default'];
},{"./container":"node_modules/postcss-selector-parser/dist/selectors/container.js","./types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/selectors/selector.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Selector = function (_Container) {
  _inherits(Selector, _Container);

  function Selector(opts) {
    _classCallCheck(this, Selector);

    var _this = _possibleConstructorReturn(this, _Container.call(this, opts));

    _this.type = _types.SELECTOR;
    return _this;
  }

  return Selector;
}(_container2.default);

exports.default = Selector;
module.exports = exports['default'];
},{"./container":"node_modules/postcss-selector-parser/dist/selectors/container.js","./types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/selectors/namespace.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Namespace = function (_Node) {
  _inherits(Namespace, _Node);

  function Namespace() {
    _classCallCheck(this, Namespace);

    return _possibleConstructorReturn(this, _Node.apply(this, arguments));
  }

  Namespace.prototype.qualifiedName = function qualifiedName(value) {
    if (this.namespace) {
      return this.namespaceString + '|' + value;
    } else {
      return value;
    }
  };

  Namespace.prototype.toString = function toString() {
    return [this.spaces.before, this.qualifiedName(this.value), this.spaces.after].join('');
  };

  _createClass(Namespace, [{
    key: 'namespace',
    get: function get() {
      return this._namespace;
    },
    set: function set(namespace) {
      this._namespace = namespace;

      if (this.raws) {
        delete this.raws.namespace;
      }
    }
  }, {
    key: 'ns',
    get: function get() {
      return this._namespace;
    },
    set: function set(namespace) {
      this._namespace = namespace;

      if (this.raws) {
        delete this.raws.namespace;
      }
    }
  }, {
    key: 'namespaceString',
    get: function get() {
      if (this.namespace) {
        var ns = this.raws && this.raws.namespace || this.namespace;

        if (ns === true) {
          return '';
        } else {
          return ns;
        }
      } else {
        return '';
      }
    }
  }]);

  return Namespace;
}(_node2.default);

exports.default = Namespace;
;
module.exports = exports['default'];
},{"./node":"node_modules/postcss-selector-parser/dist/selectors/node.js"}],"node_modules/postcss-selector-parser/dist/selectors/className.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;

var _namespace = require('./namespace');

var _namespace2 = _interopRequireDefault(_namespace);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var ClassName = function (_Namespace) {
  _inherits(ClassName, _Namespace);

  function ClassName(opts) {
    _classCallCheck(this, ClassName);

    var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));

    _this.type = _types.CLASS;
    return _this;
  }

  ClassName.prototype.toString = function toString() {
    return [this.spaces.before, this.ns, String('.' + this.value), this.spaces.after].join('');
  };

  return ClassName;
}(_namespace2.default);

exports.default = ClassName;
module.exports = exports['default'];
},{"./namespace":"node_modules/postcss-selector-parser/dist/selectors/namespace.js","./types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/selectors/comment.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Comment = function (_Node) {
  _inherits(Comment, _Node);

  function Comment(opts) {
    _classCallCheck(this, Comment);

    var _this = _possibleConstructorReturn(this, _Node.call(this, opts));

    _this.type = _types.COMMENT;
    return _this;
  }

  return Comment;
}(_node2.default);

exports.default = Comment;
module.exports = exports['default'];
},{"./node":"node_modules/postcss-selector-parser/dist/selectors/node.js","./types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/selectors/id.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;

var _namespace = require('./namespace');

var _namespace2 = _interopRequireDefault(_namespace);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var ID = function (_Namespace) {
  _inherits(ID, _Namespace);

  function ID(opts) {
    _classCallCheck(this, ID);

    var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));

    _this.type = _types.ID;
    return _this;
  }

  ID.prototype.toString = function toString() {
    return [this.spaces.before, this.ns, String('#' + this.value), this.spaces.after].join('');
  };

  return ID;
}(_namespace2.default);

exports.default = ID;
module.exports = exports['default'];
},{"./namespace":"node_modules/postcss-selector-parser/dist/selectors/namespace.js","./types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/selectors/tag.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;

var _namespace = require('./namespace');

var _namespace2 = _interopRequireDefault(_namespace);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Tag = function (_Namespace) {
  _inherits(Tag, _Namespace);

  function Tag(opts) {
    _classCallCheck(this, Tag);

    var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));

    _this.type = _types.TAG;
    return _this;
  }

  return Tag;
}(_namespace2.default);

exports.default = Tag;
module.exports = exports['default'];
},{"./namespace":"node_modules/postcss-selector-parser/dist/selectors/namespace.js","./types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/selectors/string.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var String = function (_Node) {
  _inherits(String, _Node);

  function String(opts) {
    _classCallCheck(this, String);

    var _this = _possibleConstructorReturn(this, _Node.call(this, opts));

    _this.type = _types.STRING;
    return _this;
  }

  return String;
}(_node2.default);

exports.default = String;
module.exports = exports['default'];
},{"./node":"node_modules/postcss-selector-parser/dist/selectors/node.js","./types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/selectors/pseudo.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;

var _container = require('./container');

var _container2 = _interopRequireDefault(_container);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Pseudo = function (_Container) {
  _inherits(Pseudo, _Container);

  function Pseudo(opts) {
    _classCallCheck(this, Pseudo);

    var _this = _possibleConstructorReturn(this, _Container.call(this, opts));

    _this.type = _types.PSEUDO;
    return _this;
  }

  Pseudo.prototype.toString = function toString() {
    var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
    return [this.spaces.before, String(this.value), params, this.spaces.after].join('');
  };

  return Pseudo;
}(_container2.default);

exports.default = Pseudo;
module.exports = exports['default'];
},{"./container":"node_modules/postcss-selector-parser/dist/selectors/container.js","./types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/selectors/attribute.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _namespace = require('./namespace');

var _namespace2 = _interopRequireDefault(_namespace);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Attribute = function (_Namespace) {
  _inherits(Attribute, _Namespace);

  function Attribute() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Attribute);

    var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));

    _this.type = _types.ATTRIBUTE;
    _this.raws = _this.raws || {};
    _this._constructed = true;
    return _this;
  }

  Attribute.prototype._spacesFor = function _spacesFor(name) {
    var attrSpaces = {
      before: '',
      after: ''
    };
    var spaces = this.spaces[name] || {};
    var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
    return Object.assign(attrSpaces, spaces, rawSpaces);
  };

  Attribute.prototype._valueFor = function _valueFor(name) {
    return this.raws[name] || this[name];
  };

  Attribute.prototype._stringFor = function _stringFor(name) {
    var spaceName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : name;
    var concat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultAttrConcat;

    var attrSpaces = this._spacesFor(spaceName);

    return concat(this._valueFor(name), attrSpaces);
  };
  /**
   * returns the offset of the attribute part specified relative to the
   * start of the node of the output string.
   *
   * * "ns" - alias for "namespace"
   * * "namespace" - the namespace if it exists.
   * * "attribute" - the attribute name
   * * "attributeNS" - the start of the attribute or its namespace
   * * "operator" - the match operator of the attribute
   * * "value" - The value (string or identifier)
   * * "insensitive" - the case insensitivity flag;
   * @param part One of the possible values inside an attribute.
   * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
   */


  Attribute.prototype.offsetOf = function offsetOf(name) {
    var count = 1;

    var attributeSpaces = this._spacesFor("attribute");

    count += attributeSpaces.before.length;

    if (name === "namespace" || name === "ns") {
      return this.namespace ? count : -1;
    }

    if (name === "attributeNS") {
      return count;
    }

    count += this.namespaceString.length;

    if (this.namespace) {
      count += 1;
    }

    if (name === "attribute") {
      return count;
    }

    count += this._valueFor("attribute").length;
    count += attributeSpaces.after.length;

    var operatorSpaces = this._spacesFor("operator");

    count += operatorSpaces.before.length;

    var operator = this._valueFor("operator");

    if (name === "operator") {
      return operator ? count : -1;
    }

    count += operator.length;
    count += operatorSpaces.after.length;

    var valueSpaces = this._spacesFor("value");

    count += valueSpaces.before.length;

    var value = this._valueFor("value");

    if (name === "value") {
      return value ? count : -1;
    }

    count += value.length;
    count += valueSpaces.after.length;

    var insensitiveSpaces = this._spacesFor("insensitive");

    count += insensitiveSpaces.before.length;

    if (name === "insensitive") {
      return this.insensitive ? count : -1;
    }

    return -1;
  };

  Attribute.prototype.toString = function toString() {
    var _this2 = this;

    var selector = [this.spaces.before, '['];
    selector.push(this._stringFor('qualifiedAttribute', 'attribute'));

    if (this.operator && this.value) {
      selector.push(this._stringFor('operator'));
      selector.push(this._stringFor('value'));
      selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
        if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
          attrSpaces.before = " ";
        }

        return defaultAttrConcat(attrValue, attrSpaces);
      }));
    }

    selector.push(']');
    selector.push(this.spaces.after);
    return selector.join('');
  };

  _createClass(Attribute, [{
    key: 'qualifiedAttribute',
    get: function get() {
      return this.qualifiedName(this.raws.attribute || this.attribute);
    }
  }, {
    key: 'insensitiveFlag',
    get: function get() {
      return this.insensitive ? 'i' : '';
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    },
    set: function set(v) {
      this._value = v;

      if (this._constructed) {
        delete this.raws.value;
      }
    }
  }, {
    key: 'namespace',
    get: function get() {
      return this._namespace;
    },
    set: function set(v) {
      this._namespace = v;

      if (this._constructed) {
        delete this.raws.namespace;
      }
    }
  }, {
    key: 'attribute',
    get: function get() {
      return this._attribute;
    },
    set: function set(v) {
      this._attribute = v;

      if (this._constructed) {
        delete this.raws.attibute;
      }
    }
  }]);

  return Attribute;
}(_namespace2.default);

exports.default = Attribute;

function defaultAttrConcat(attrValue, attrSpaces) {
  return '' + attrSpaces.before + attrValue + attrSpaces.after;
}

module.exports = exports['default'];
},{"./namespace":"node_modules/postcss-selector-parser/dist/selectors/namespace.js","./types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/selectors/universal.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;

var _namespace = require('./namespace');

var _namespace2 = _interopRequireDefault(_namespace);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Universal = function (_Namespace) {
  _inherits(Universal, _Namespace);

  function Universal(opts) {
    _classCallCheck(this, Universal);

    var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));

    _this.type = _types.UNIVERSAL;
    _this.value = '*';
    return _this;
  }

  return Universal;
}(_namespace2.default);

exports.default = Universal;
module.exports = exports['default'];
},{"./namespace":"node_modules/postcss-selector-parser/dist/selectors/namespace.js","./types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/selectors/combinator.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Combinator = function (_Node) {
  _inherits(Combinator, _Node);

  function Combinator(opts) {
    _classCallCheck(this, Combinator);

    var _this = _possibleConstructorReturn(this, _Node.call(this, opts));

    _this.type = _types.COMBINATOR;
    return _this;
  }

  return Combinator;
}(_node2.default);

exports.default = Combinator;
module.exports = exports['default'];
},{"./node":"node_modules/postcss-selector-parser/dist/selectors/node.js","./types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/selectors/nesting.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.__esModule = true;

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _types = require('./types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Nesting = function (_Node) {
  _inherits(Nesting, _Node);

  function Nesting(opts) {
    _classCallCheck(this, Nesting);

    var _this = _possibleConstructorReturn(this, _Node.call(this, opts));

    _this.type = _types.NESTING;
    _this.value = '&';
    return _this;
  }

  return Nesting;
}(_node2.default);

exports.default = Nesting;
module.exports = exports['default'];
},{"./node":"node_modules/postcss-selector-parser/dist/selectors/node.js","./types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/sortAscending.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;
exports.default = sortAscending;

function sortAscending(list) {
  return list.sort(function (a, b) {
    return a - b;
  });
}

;
module.exports = exports["default"];
},{}],"node_modules/postcss-selector-parser/dist/tokenTypes.js":[function(require,module,exports) {
'use strict';

exports.__esModule = true;
var ampersand = exports.ampersand = 38;
var asterisk = exports.asterisk = 42;
var at = exports.at = 64;
var comma = exports.comma = 44;
var colon = exports.colon = 58;
var semicolon = exports.semicolon = 59;
var openParenthesis = exports.openParenthesis = 40;
var closeParenthesis = exports.closeParenthesis = 41;
var openSquare = exports.openSquare = 91;
var closeSquare = exports.closeSquare = 93;
var dollar = exports.dollar = 36;
var tilde = exports.tilde = 126;
var caret = exports.caret = 94;
var plus = exports.plus = 43;
var equals = exports.equals = 61;
var pipe = exports.pipe = 124;
var greaterThan = exports.greaterThan = 62;
var space = exports.space = 32;
var singleQuote = exports.singleQuote = 39;
var doubleQuote = exports.doubleQuote = 34;
var slash = exports.slash = 47;
var backslash = exports.backslash = 92;
var cr = exports.cr = 13;
var feed = exports.feed = 12;
var newline = exports.newline = 10;
var tab = exports.tab = 9; // Expose aliases primarily for readability.

var str = exports.str = singleQuote; // No good single character representation!

var comment = exports.comment = -1;
var word = exports.word = -2;
var combinator = exports.combinator = -3;
},{}],"node_modules/postcss-selector-parser/dist/tokenize.js":[function(require,module,exports) {
'use strict';

exports.__esModule = true;
exports.default = tokenize;

var _tokenTypes = require('./tokenTypes');

var t = _interopRequireWildcard(_tokenTypes);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

var wordEnd = /[ \n\t\r\(\)\*:;!&'"\+\|~>,=$^\[\]\\]|\/(?=\*)/g;

function tokenize(input) {
  var tokens = [];
  var css = input.css.valueOf();
  var _css = css,
      length = _css.length;
  var offset = -1;
  var line = 1;
  var start = 0;
  var end = 0;
  var code = void 0,
      content = void 0,
      endColumn = void 0,
      endLine = void 0,
      escaped = void 0,
      escapePos = void 0,
      last = void 0,
      lines = void 0,
      next = void 0,
      nextLine = void 0,
      nextOffset = void 0,
      quote = void 0,
      tokenType = void 0;

  function unclosed(what, fix) {
    if (input.safe) {
      // fyi: this is never set to true.
      css += fix;
      next = css.length - 1;
    } else {
      throw input.error('Unclosed ' + what, line, start - offset, start);
    }
  }

  while (start < length) {
    code = css.charCodeAt(start);

    if (code === t.newline) {
      offset = start;
      line += 1;
    }

    switch (code) {
      case t.newline:
      case t.space:
      case t.tab:
      case t.cr:
      case t.feed:
        next = start;

        do {
          next += 1;
          code = css.charCodeAt(next);

          if (code === t.newline) {
            offset = next;
            line += 1;
          }
        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);

        tokenType = t.space;
        endLine = line;
        endColumn = start - offset;
        end = next;
        break;

      case t.plus:
      case t.greaterThan:
      case t.tilde:
      case t.pipe:
        next = start;

        do {
          next += 1;
          code = css.charCodeAt(next);
        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);

        tokenType = t.combinator;
        endLine = line;
        endColumn = start - offset;
        end = next;
        break;
      // Consume these characters as single tokens.

      case t.asterisk:
      case t.ampersand:
      case t.comma:
      case t.equals:
      case t.dollar:
      case t.caret:
      case t.openSquare:
      case t.closeSquare:
      case t.colon:
      case t.semicolon:
      case t.openParenthesis:
      case t.closeParenthesis:
        next = start;
        tokenType = code;
        endLine = line;
        endColumn = start - offset;
        end = next + 1;
        break;

      case t.singleQuote:
      case t.doubleQuote:
        quote = code === t.singleQuote ? "'" : '"';
        next = start;

        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);

          if (next === -1) {
            unclosed('quote', quote);
          }

          escapePos = next;

          while (css.charCodeAt(escapePos - 1) === t.backslash) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);

        tokenType = t.str;
        endLine = line;
        endColumn = start - offset;
        end = next + 1;
        break;

      case t.backslash:
        next = start;
        escaped = true;

        while (css.charCodeAt(next + 1) === t.backslash) {
          next += 1;
          escaped = !escaped;
        }

        code = css.charCodeAt(next + 1);

        if (escaped && code !== t.slash && code !== t.space && code !== t.newline && code !== t.tab && code !== t.cr && code !== t.feed) {
          next += 1;
        }

        tokenType = t.word;
        endLine = line;
        endColumn = next - offset;
        end = next + 1;
        break;

      default:
        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
          next = css.indexOf('*/', start + 2) + 1;

          if (next === 0) {
            unclosed('comment', '*/');
          }

          content = css.slice(start, next + 1);
          lines = content.split('\n');
          last = lines.length - 1;

          if (last > 0) {
            nextLine = line + last;
            nextOffset = next - lines[last].length;
          } else {
            nextLine = line;
            nextOffset = offset;
          }

          tokenType = t.comment;
          line = nextLine;
          endLine = nextLine;
          endColumn = next - nextOffset;
        } else {
          wordEnd.lastIndex = start + 1;
          wordEnd.test(css);

          if (wordEnd.lastIndex === 0) {
            next = css.length - 1;
          } else {
            next = wordEnd.lastIndex - 2;
          }

          tokenType = t.word;
          endLine = line;
          endColumn = next - offset;
        }

        end = next + 1;
        break;
    } // Ensure that the token structure remains consistent


    tokens.push([tokenType, // [0] Token type
    line, // [1] Starting line
    start - offset, // [2] Starting column
    endLine, // [3] Ending line
    endColumn, // [4] Ending column
    start, // [5] Start position / Source index
    end] // [6] End position
    ); // Reset offset for the next token

    if (nextOffset) {
      offset = nextOffset;
      nextOffset = null;
    }

    start = end;
  }

  return tokens;
}

module.exports = exports['default'];
},{"./tokenTypes":"node_modules/postcss-selector-parser/dist/tokenTypes.js"}],"node_modules/postcss-selector-parser/dist/parser.js":[function(require,module,exports) {
'use strict';

exports.__esModule = true;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _dotProp = require('dot-prop');

var _dotProp2 = _interopRequireDefault(_dotProp);

var _indexesOf = require('indexes-of');

var _indexesOf2 = _interopRequireDefault(_indexesOf);

var _uniq = require('uniq');

var _uniq2 = _interopRequireDefault(_uniq);

var _root = require('./selectors/root');

var _root2 = _interopRequireDefault(_root);

var _selector = require('./selectors/selector');

var _selector2 = _interopRequireDefault(_selector);

var _className = require('./selectors/className');

var _className2 = _interopRequireDefault(_className);

var _comment = require('./selectors/comment');

var _comment2 = _interopRequireDefault(_comment);

var _id = require('./selectors/id');

var _id2 = _interopRequireDefault(_id);

var _tag = require('./selectors/tag');

var _tag2 = _interopRequireDefault(_tag);

var _string = require('./selectors/string');

var _string2 = _interopRequireDefault(_string);

var _pseudo = require('./selectors/pseudo');

var _pseudo2 = _interopRequireDefault(_pseudo);

var _attribute = require('./selectors/attribute');

var _attribute2 = _interopRequireDefault(_attribute);

var _universal = require('./selectors/universal');

var _universal2 = _interopRequireDefault(_universal);

var _combinator = require('./selectors/combinator');

var _combinator2 = _interopRequireDefault(_combinator);

var _nesting = require('./selectors/nesting');

var _nesting2 = _interopRequireDefault(_nesting);

var _sortAscending = require('./sortAscending');

var _sortAscending2 = _interopRequireDefault(_sortAscending);

var _tokenize = require('./tokenize');

var _tokenize2 = _interopRequireDefault(_tokenize);

var _tokenTypes = require('./tokenTypes');

var tokens = _interopRequireWildcard(_tokenTypes);

var _types = require('./selectors/types');

var types = _interopRequireWildcard(_types);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function getSource(startLine, startColumn, endLine, endColumn) {
  return {
    start: {
      line: startLine,
      column: startColumn
    },
    end: {
      line: endLine,
      column: endColumn
    }
  };
}

var Parser = function () {
  function Parser(rule) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Parser);

    this.rule = rule;
    this.options = Object.assign({
      lossy: false,
      safe: false
    }, options);
    this.position = 0;
    this.root = new _root2.default();
    this.root.errorGenerator = this._errorGenerator();
    var selector = new _selector2.default();
    this.root.append(selector);
    this.current = selector;
    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;

    if (this.options.lossy) {
      this.css = this.css.trim();
    }

    this.tokens = (0, _tokenize2.default)({
      css: this.css,
      error: this._errorGenerator(),
      safe: this.options.safe
    });
    this.loop();
  }

  Parser.prototype._errorGenerator = function _errorGenerator() {
    var _this = this;

    return function (message, errorOptions) {
      if (typeof _this.rule === 'string') {
        return new Error(message);
      }

      return _this.rule.error(message, errorOptions);
    };
  };

  Parser.prototype.attribute = function attribute() {
    var attr = [];
    var startingToken = this.currToken;
    this.position++;

    while (this.position < this.tokens.length && this.currToken[0] !== tokens.closeSquare) {
      attr.push(this.currToken);
      this.position++;
    }

    if (this.currToken[0] !== tokens.closeSquare) {
      return this.expected('closing square bracket', this.currToken[5]);
    }

    var len = attr.length;
    var node = {
      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
      sourceIndex: startingToken[5]
    };

    if (len === 1 && !~[tokens.word].indexOf(attr[0][0])) {
      return this.expected('attribute', attr[0][5]);
    }

    var pos = 0;
    var spaceBefore = '';
    var commentBefore = '';
    var lastAdded = null;
    var spaceAfterMeaningfulToken = false;

    while (pos < len) {
      var token = attr[pos];
      var content = this.content(token);
      var next = attr[pos + 1];

      switch (token[0]) {
        case tokens.space:
          if (len === 1 || pos === 0 && this.content(next) === '|') {
            return this.expected('attribute', token[5], content);
          }

          spaceAfterMeaningfulToken = true;

          if (this.options.lossy) {
            break;
          }

          if (lastAdded) {
            var spaceProp = 'spaces.' + lastAdded + '.after';

            _dotProp2.default.set(node, spaceProp, _dotProp2.default.get(node, spaceProp, '') + content);

            var commentProp = 'raws.spaces.' + lastAdded + '.after';

            var existingComment = _dotProp2.default.get(node, commentProp);

            if (existingComment) {
              _dotProp2.default.set(node, commentProp, existingComment + content);
            }
          } else {
            spaceBefore = spaceBefore + content;
            commentBefore = commentBefore + content;
          }

          break;

        case tokens.asterisk:
          if (next[0] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
            if (spaceBefore) {
              _dotProp2.default.set(node, 'spaces.attribute.before', spaceBefore);

              spaceBefore = '';
            }

            if (commentBefore) {
              _dotProp2.default.set(node, 'raws.spaces.attribute.before', spaceBefore);

              commentBefore = '';
            }

            node.namespace = (node.namespace || "") + content;

            var rawValue = _dotProp2.default.get(node, "raws.namespace");

            if (rawValue) {
              node.raws.namespace += content;
            }

            lastAdded = 'namespace';
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.dollar:
        case tokens.caret:
          if (next[0] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.combinator:
          if (content === '~' && next[0] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }

          if (content !== '|') {
            spaceAfterMeaningfulToken = false;
            break;
          }

          if (next[0] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if (!node.namespace && !node.attribute) {
            node.namespace = true;
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.word:
          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][0] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
          !node.operator && !node.namespace) {
            node.namespace = content;
            lastAdded = 'namespace';
          } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
            if (spaceBefore) {
              _dotProp2.default.set(node, 'spaces.attribute.before', spaceBefore);

              spaceBefore = '';
            }

            if (commentBefore) {
              _dotProp2.default.set(node, 'raws.spaces.attribute.before', commentBefore);

              commentBefore = '';
            }

            node.attribute = (node.attribute || "") + content;

            var _rawValue = _dotProp2.default.get(node, "raws.attribute");

            if (_rawValue) {
              node.raws.attribute += content;
            }

            lastAdded = 'attribute';
          } else if (!node.value || lastAdded === "value" && !spaceAfterMeaningfulToken) {
            node.value = (node.value || "") + content;

            var _rawValue2 = _dotProp2.default.get(node, "raws.value");

            if (_rawValue2) {
              node.raws.value += content;
            }

            lastAdded = 'value';

            _dotProp2.default.set(node, 'raws.unquoted', _dotProp2.default.get(node, 'raws.unquoted', '') + content);
          } else if (content === 'i') {
            if (node.value && (node.quoted || spaceAfterMeaningfulToken)) {
              node.insensitive = true;
              lastAdded = 'insensitive';

              if (spaceBefore) {
                _dotProp2.default.set(node, 'spaces.insensitive.before', spaceBefore);

                spaceBefore = '';
              }

              if (commentBefore) {
                _dotProp2.default.set(node, 'raws.spaces.insensitive.before', commentBefore);

                commentBefore = '';
              }
            } else if (node.value) {
              lastAdded = 'value';
              node.value += 'i';

              if (node.raws.value) {
                node.raws.value += 'i';
              }
            }
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.str:
          if (!node.attribute || !node.operator) {
            return this.error('Expected an attribute followed by an operator preceding the string.', {
              index: token[5]
            });
          }

          node.value = content;
          node.quoted = true;
          lastAdded = 'value';

          _dotProp2.default.set(node, 'raws.unquoted', content.slice(1, -1));

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.equals:
          if (!node.attribute) {
            return this.expected('attribute', token[5], content);
          }

          if (node.value) {
            return this.error('Unexpected "=" found; an operator was already defined.', {
              index: token[5]
            });
          }

          node.operator = node.operator ? node.operator + content : content;
          lastAdded = 'operator';
          spaceAfterMeaningfulToken = false;
          break;

        case tokens.comment:
          if (lastAdded) {
            if (spaceAfterMeaningfulToken || next && next[0] === tokens.space) {
              var lastComment = _dotProp2.default.get(node, 'raws.spaces.' + lastAdded + '.after', _dotProp2.default.get(node, 'spaces.' + lastAdded + '.after', ''));

              _dotProp2.default.set(node, 'raws.spaces.' + lastAdded + '.after', lastComment + content);
            } else {
              var lastValue = _dotProp2.default.get(node, 'raws.' + lastAdded, _dotProp2.default.get(node, lastAdded, ''));

              _dotProp2.default.set(node, 'raws.' + lastAdded, lastValue + content);
            }
          } else {
            commentBefore = commentBefore + content;
          }

          break;

        default:
          return this.error('Unexpected "' + content + '" found.', {
            index: token[5]
          });
      }

      pos++;
    }

    this.newNode(new _attribute2.default(node));
    this.position++;
  };

  Parser.prototype.combinator = function combinator() {
    var current = this.currToken;

    if (this.content() === '|') {
      return this.namespace();
    }

    var node = new _combinator2.default({
      value: '',
      source: getSource(current[1], current[2], current[3], current[4]),
      sourceIndex: current[5]
    });

    while (this.position < this.tokens.length && this.currToken && (this.currToken[0] === tokens.space || this.currToken[0] === tokens.combinator)) {
      var content = this.content();

      if (this.nextToken && this.nextToken[0] === tokens.combinator) {
        node.spaces.before = this.parseSpace(content);
        node.source = getSource(this.nextToken[1], this.nextToken[2], this.nextToken[3], this.nextToken[4]);
        node.sourceIndex = this.nextToken[5];
      } else if (this.prevToken && this.prevToken[0] === tokens.combinator) {
        node.spaces.after = this.parseSpace(content);
      } else if (this.currToken[0] === tokens.combinator) {
        node.value = content;
      } else if (this.currToken[0] === tokens.space) {
        node.value = this.parseSpace(content, ' ');
      }

      this.position++;
    }

    return this.newNode(node);
  };

  Parser.prototype.comma = function comma() {
    if (this.position === this.tokens.length - 1) {
      this.root.trailingComma = true;
      this.position++;
      return;
    }

    var selector = new _selector2.default();
    this.current.parent.append(selector);
    this.current = selector;
    this.position++;
  };

  Parser.prototype.comment = function comment() {
    var current = this.currToken;
    this.newNode(new _comment2.default({
      value: this.content(),
      source: getSource(current[1], current[2], current[3], current[4]),
      sourceIndex: current[5]
    }));
    this.position++;
  };

  Parser.prototype.error = function error(message, opts) {
    throw this.root.error(message, opts);
  };

  Parser.prototype.missingBackslash = function missingBackslash() {
    return this.error('Expected a backslash preceding the semicolon.', {
      index: this.currToken[5]
    });
  };

  Parser.prototype.missingParenthesis = function missingParenthesis() {
    return this.expected('opening parenthesis', this.currToken[5]);
  };

  Parser.prototype.missingSquareBracket = function missingSquareBracket() {
    return this.expected('opening square bracket', this.currToken[5]);
  };

  Parser.prototype.namespace = function namespace() {
    var before = this.prevToken && this.content(this.prevToken) || true;

    if (this.nextToken[0] === tokens.word) {
      this.position++;
      return this.word(before);
    } else if (this.nextToken[0] === tokens.asterisk) {
      this.position++;
      return this.universal(before);
    }
  };

  Parser.prototype.nesting = function nesting() {
    var current = this.currToken;
    this.newNode(new _nesting2.default({
      value: this.content(),
      source: getSource(current[1], current[2], current[3], current[4]),
      sourceIndex: current[5]
    }));
    this.position++;
  };

  Parser.prototype.parentheses = function parentheses() {
    var last = this.current.last;
    var balanced = 1;
    this.position++;

    if (last && last.type === types.PSEUDO) {
      var selector = new _selector2.default();
      var cache = this.current;
      last.append(selector);
      this.current = selector;

      while (this.position < this.tokens.length && balanced) {
        if (this.currToken[0] === tokens.openParenthesis) {
          balanced++;
        }

        if (this.currToken[0] === tokens.closeParenthesis) {
          balanced--;
        }

        if (balanced) {
          this.parse();
        } else {
          selector.parent.source.end.line = this.currToken[3];
          selector.parent.source.end.column = this.currToken[4];
          this.position++;
        }
      }

      this.current = cache;
    } else {
      last.value += '(';

      while (this.position < this.tokens.length && balanced) {
        if (this.currToken[0] === tokens.openParenthesis) {
          balanced++;
        }

        if (this.currToken[0] === tokens.closeParenthesis) {
          balanced--;
        }

        last.value += this.parseParenthesisToken(this.currToken);
        this.position++;
      }
    }

    if (balanced) {
      return this.expected('closing parenthesis', this.currToken[5]);
    }
  };

  Parser.prototype.pseudo = function pseudo() {
    var _this2 = this;

    var pseudoStr = '';
    var startingToken = this.currToken;

    while (this.currToken && this.currToken[0] === tokens.colon) {
      pseudoStr += this.content();
      this.position++;
    }

    if (!this.currToken) {
      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
    }

    if (this.currToken[0] === tokens.word) {
      this.splitWord(false, function (first, length) {
        pseudoStr += first;

        _this2.newNode(new _pseudo2.default({
          value: pseudoStr,
          source: getSource(startingToken[1], startingToken[2], _this2.currToken[3], _this2.currToken[4]),
          sourceIndex: startingToken[5]
        }));

        if (length > 1 && _this2.nextToken && _this2.nextToken[0] === tokens.openParenthesis) {
          _this2.error('Misplaced parenthesis.', {
            index: _this2.nextToken[5]
          });
        }
      });
    } else {
      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[5]);
    }
  };

  Parser.prototype.space = function space() {
    var content = this.content(); // Handle space before and after the selector

    if (this.position === 0 || this.prevToken[0] === tokens.comma || this.prevToken[0] === tokens.openParenthesis) {
      this.spaces = this.parseSpace(content);
      this.position++;
    } else if (this.position === this.tokens.length - 1 || this.nextToken[0] === tokens.comma || this.nextToken[0] === tokens.closeParenthesis) {
      this.current.last.spaces.after = this.parseSpace(content);
      this.position++;
    } else {
      this.combinator();
    }
  };

  Parser.prototype.string = function string() {
    var current = this.currToken;
    this.newNode(new _string2.default({
      value: this.content(),
      source: getSource(current[1], current[2], current[3], current[4]),
      sourceIndex: current[5]
    }));
    this.position++;
  };

  Parser.prototype.universal = function universal(namespace) {
    var nextToken = this.nextToken;

    if (nextToken && this.content(nextToken) === '|') {
      this.position++;
      return this.namespace();
    }

    var current = this.currToken;
    this.newNode(new _universal2.default({
      value: this.content(),
      source: getSource(current[1], current[2], current[3], current[4]),
      sourceIndex: current[5]
    }), namespace);
    this.position++;
  };

  Parser.prototype.splitWord = function splitWord(namespace, firstCallback) {
    var _this3 = this;

    var nextToken = this.nextToken;
    var word = this.content();

    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[0])) {
      this.position++;
      var current = this.content();
      word += current;

      if (current.lastIndexOf('\\') === current.length - 1) {
        var next = this.nextToken;

        if (next && next[0] === tokens.space) {
          word += this.parseSpace(this.content(next), ' ');
          this.position++;
        }
      }

      nextToken = this.nextToken;
    }

    var hasClass = (0, _indexesOf2.default)(word, '.');
    var hasId = (0, _indexesOf2.default)(word, '#'); // Eliminate Sass interpolations from the list of id indexes

    var interpolations = (0, _indexesOf2.default)(word, '#{');

    if (interpolations.length) {
      hasId = hasId.filter(function (hashIndex) {
        return !~interpolations.indexOf(hashIndex);
      });
    }

    var indices = (0, _sortAscending2.default)((0, _uniq2.default)([0].concat(hasClass, hasId)));
    indices.forEach(function (ind, i) {
      var index = indices[i + 1] || word.length;
      var value = word.slice(ind, index);

      if (i === 0 && firstCallback) {
        return firstCallback.call(_this3, value, indices.length);
      }

      var node = void 0;
      var current = _this3.currToken;
      var sourceIndex = current[5] + indices[i];
      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));

      if (~hasClass.indexOf(ind)) {
        node = new _className2.default({
          value: value.slice(1),
          source: source,
          sourceIndex: sourceIndex
        });
      } else if (~hasId.indexOf(ind)) {
        node = new _id2.default({
          value: value.slice(1),
          source: source,
          sourceIndex: sourceIndex
        });
      } else {
        node = new _tag2.default({
          value: value,
          source: source,
          sourceIndex: sourceIndex
        });
      }

      _this3.newNode(node, namespace); // Ensure that the namespace is used only once


      namespace = null;
    });
    this.position++;
  };

  Parser.prototype.word = function word(namespace) {
    var nextToken = this.nextToken;

    if (nextToken && this.content(nextToken) === '|') {
      this.position++;
      return this.namespace();
    }

    return this.splitWord(namespace);
  };

  Parser.prototype.loop = function loop() {
    while (this.position < this.tokens.length) {
      this.parse(true);
    }

    return this.root;
  };

  Parser.prototype.parse = function parse(throwOnParenthesis) {
    switch (this.currToken[0]) {
      case tokens.space:
        this.space();
        break;

      case tokens.comment:
        this.comment();
        break;

      case tokens.openParenthesis:
        this.parentheses();
        break;

      case tokens.closeParenthesis:
        if (throwOnParenthesis) {
          this.missingParenthesis();
        }

        break;

      case tokens.openSquare:
        this.attribute();
        break;

      case tokens.dollar:
      case tokens.caret:
      case tokens.equals:
      case tokens.word:
        this.word();
        break;

      case tokens.colon:
        this.pseudo();
        break;

      case tokens.comma:
        this.comma();
        break;

      case tokens.asterisk:
        this.universal();
        break;

      case tokens.ampersand:
        this.nesting();
        break;

      case tokens.combinator:
        this.combinator();
        break;

      case tokens.str:
        this.string();
        break;
      // These cases throw; no break needed.

      case tokens.closeSquare:
        this.missingSquareBracket();

      case tokens.semicolon:
        this.missingBackslash();
    }
  };
  /**
   * Helpers
   */


  Parser.prototype.expected = function expected(description, index, found) {
    if (Array.isArray(description)) {
      var last = description.pop();
      description = description.join(', ') + ' or ' + last;
    }

    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';

    if (!found) {
      return this.error('Expected ' + an + ' ' + description + '.', {
        index: index
      });
    }

    return this.error('Expected ' + an + ' ' + description + ', found "' + found + '" instead.', {
      index: index
    });
  };

  Parser.prototype.parseNamespace = function parseNamespace(namespace) {
    if (this.options.lossy && typeof namespace === 'string') {
      var trimmed = namespace.trim();

      if (!trimmed.length) {
        return true;
      }

      return trimmed;
    }

    return namespace;
  };

  Parser.prototype.parseSpace = function parseSpace(space) {
    var replacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    return this.options.lossy ? replacement : space;
  };

  Parser.prototype.parseValue = function parseValue(value) {
    if (!this.options.lossy || !value || typeof value !== 'string') {
      return value;
    }

    return value.trim();
  };

  Parser.prototype.parseParenthesisToken = function parseParenthesisToken(token) {
    var content = this.content(token);

    if (!this.options.lossy) {
      return content;
    }

    if (token[0] === tokens.space) {
      return this.parseSpace(content, ' ');
    }

    return this.parseValue(content);
  };

  Parser.prototype.newNode = function newNode(node, namespace) {
    if (namespace) {
      node.namespace = this.parseNamespace(namespace);
    }

    if (this.spaces) {
      node.spaces.before = this.spaces;
      this.spaces = '';
    }

    return this.current.append(node);
  };

  Parser.prototype.content = function content() {
    var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currToken;
    return this.css.slice(token[5], token[6]);
  };

  _createClass(Parser, [{
    key: 'currToken',
    get: function get() {
      return this.tokens[this.position];
    }
  }, {
    key: 'nextToken',
    get: function get() {
      return this.tokens[this.position + 1];
    }
  }, {
    key: 'prevToken',
    get: function get() {
      return this.tokens[this.position - 1];
    }
  }]);

  return Parser;
}();

exports.default = Parser;
module.exports = exports['default'];
},{"dot-prop":"node_modules/dot-prop/index.js","indexes-of":"node_modules/indexes-of/index.js","uniq":"node_modules/uniq/uniq.js","./selectors/root":"node_modules/postcss-selector-parser/dist/selectors/root.js","./selectors/selector":"node_modules/postcss-selector-parser/dist/selectors/selector.js","./selectors/className":"node_modules/postcss-selector-parser/dist/selectors/className.js","./selectors/comment":"node_modules/postcss-selector-parser/dist/selectors/comment.js","./selectors/id":"node_modules/postcss-selector-parser/dist/selectors/id.js","./selectors/tag":"node_modules/postcss-selector-parser/dist/selectors/tag.js","./selectors/string":"node_modules/postcss-selector-parser/dist/selectors/string.js","./selectors/pseudo":"node_modules/postcss-selector-parser/dist/selectors/pseudo.js","./selectors/attribute":"node_modules/postcss-selector-parser/dist/selectors/attribute.js","./selectors/universal":"node_modules/postcss-selector-parser/dist/selectors/universal.js","./selectors/combinator":"node_modules/postcss-selector-parser/dist/selectors/combinator.js","./selectors/nesting":"node_modules/postcss-selector-parser/dist/selectors/nesting.js","./sortAscending":"node_modules/postcss-selector-parser/dist/sortAscending.js","./tokenize":"node_modules/postcss-selector-parser/dist/tokenize.js","./tokenTypes":"node_modules/postcss-selector-parser/dist/tokenTypes.js","./selectors/types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/processor.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;

var _parser = require("./parser");

var _parser2 = _interopRequireDefault(_parser);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Processor = function () {
  function Processor(func, options) {
    _classCallCheck(this, Processor);

    this.func = func || function noop() {};

    this.funcRes = null;
    this.options = options;
  }

  Processor.prototype._shouldUpdateSelector = function _shouldUpdateSelector(rule) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var merged = Object.assign({}, this.options, options);

    if (merged.updateSelector === false) {
      return false;
    } else {
      return typeof rule !== "string";
    }
  };

  Processor.prototype._isLossy = function _isLossy() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var merged = Object.assign({}, this.options, options);

    if (merged.lossless === false) {
      return true;
    } else {
      return false;
    }
  };

  Processor.prototype._root = function _root(rule) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var parser = new _parser2.default(rule, this._parseOptions(options));
    return parser.root;
  };

  Processor.prototype._parseOptions = function _parseOptions(options) {
    return {
      lossy: this._isLossy(options)
    };
  };

  Processor.prototype._run = function _run(rule) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new Promise(function (resolve, reject) {
      try {
        var root = _this._root(rule, options);

        Promise.resolve(_this.func(root)).then(function (transform) {
          var string = undefined;

          if (_this._shouldUpdateSelector(rule, options)) {
            string = root.toString();
            rule.selector = string;
          }

          return {
            transform: transform,
            root: root,
            string: string
          };
        }).then(resolve, reject);
      } catch (e) {
        reject(e);
        return;
      }
    });
  };

  Processor.prototype._runSync = function _runSync(rule) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var root = this._root(rule, options);

    var transform = this.func(root);

    if (transform && typeof transform.then === "function") {
      throw new Error("Selector processor returned a promise to a synchronous call.");
    }

    var string = undefined;

    if (options.updateSelector && typeof rule !== "string") {
      string = root.toString();
      rule.selector = string;
    }

    return {
      transform: transform,
      root: root,
      string: string
    };
  };
  /**
   * Process rule into a selector AST.
   * 
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {Promise<parser.Root>} The AST of the selector after processing it.
   */


  Processor.prototype.ast = function ast(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.root;
    });
  };
  /**
   * Process rule into a selector AST synchronously.
   * 
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {parser.Root} The AST of the selector after processing it.
   */


  Processor.prototype.astSync = function astSync(rule, options) {
    return this._runSync(rule, options).root;
  };
  /**
   * Process a selector into a transformed value asynchronously
   * 
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {Promise<any>} The value returned by the processor.
   */


  Processor.prototype.transform = function transform(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.transform;
    });
  };
  /**
   * Process a selector into a transformed value synchronously.
   * 
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {any} The value returned by the processor.
   */


  Processor.prototype.transformSync = function transformSync(rule, options) {
    return this._runSync(rule, options).transform;
  };
  /**
   * Process a selector into a new selector string asynchronously.
   * 
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {string} the selector after processing.
   */


  Processor.prototype.process = function process(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.string || result.root.toString();
    });
  };
  /**
   * Process a selector into a new selector string synchronously.
   * 
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {string} the selector after processing.
   */


  Processor.prototype.processSync = function processSync(rule, options) {
    var result = this._runSync(rule, options);

    return result.string || result.root.toString();
  };

  return Processor;
}();

exports.default = Processor;
module.exports = exports["default"];
},{"./parser":"node_modules/postcss-selector-parser/dist/parser.js"}],"node_modules/postcss-selector-parser/dist/selectors/constructors.js":[function(require,module,exports) {
'use strict';

exports.__esModule = true;
exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = undefined;

var _attribute = require('./attribute');

var _attribute2 = _interopRequireDefault(_attribute);

var _className = require('./className');

var _className2 = _interopRequireDefault(_className);

var _combinator = require('./combinator');

var _combinator2 = _interopRequireDefault(_combinator);

var _comment = require('./comment');

var _comment2 = _interopRequireDefault(_comment);

var _id = require('./id');

var _id2 = _interopRequireDefault(_id);

var _nesting = require('./nesting');

var _nesting2 = _interopRequireDefault(_nesting);

var _pseudo = require('./pseudo');

var _pseudo2 = _interopRequireDefault(_pseudo);

var _root = require('./root');

var _root2 = _interopRequireDefault(_root);

var _selector = require('./selector');

var _selector2 = _interopRequireDefault(_selector);

var _string = require('./string');

var _string2 = _interopRequireDefault(_string);

var _tag = require('./tag');

var _tag2 = _interopRequireDefault(_tag);

var _universal = require('./universal');

var _universal2 = _interopRequireDefault(_universal);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var attribute = exports.attribute = function attribute(opts) {
  return new _attribute2.default(opts);
};

var className = exports.className = function className(opts) {
  return new _className2.default(opts);
};

var combinator = exports.combinator = function combinator(opts) {
  return new _combinator2.default(opts);
};

var comment = exports.comment = function comment(opts) {
  return new _comment2.default(opts);
};

var id = exports.id = function id(opts) {
  return new _id2.default(opts);
};

var nesting = exports.nesting = function nesting(opts) {
  return new _nesting2.default(opts);
};

var pseudo = exports.pseudo = function pseudo(opts) {
  return new _pseudo2.default(opts);
};

var root = exports.root = function root(opts) {
  return new _root2.default(opts);
};

var selector = exports.selector = function selector(opts) {
  return new _selector2.default(opts);
};

var string = exports.string = function string(opts) {
  return new _string2.default(opts);
};

var tag = exports.tag = function tag(opts) {
  return new _tag2.default(opts);
};

var universal = exports.universal = function universal(opts) {
  return new _universal2.default(opts);
};
},{"./attribute":"node_modules/postcss-selector-parser/dist/selectors/attribute.js","./className":"node_modules/postcss-selector-parser/dist/selectors/className.js","./combinator":"node_modules/postcss-selector-parser/dist/selectors/combinator.js","./comment":"node_modules/postcss-selector-parser/dist/selectors/comment.js","./id":"node_modules/postcss-selector-parser/dist/selectors/id.js","./nesting":"node_modules/postcss-selector-parser/dist/selectors/nesting.js","./pseudo":"node_modules/postcss-selector-parser/dist/selectors/pseudo.js","./root":"node_modules/postcss-selector-parser/dist/selectors/root.js","./selector":"node_modules/postcss-selector-parser/dist/selectors/selector.js","./string":"node_modules/postcss-selector-parser/dist/selectors/string.js","./tag":"node_modules/postcss-selector-parser/dist/selectors/tag.js","./universal":"node_modules/postcss-selector-parser/dist/selectors/universal.js"}],"node_modules/postcss-selector-parser/dist/selectors/guards.js":[function(require,module,exports) {
"use strict";

function _typeof2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

exports.__esModule = true;
exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = undefined;

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
};

var _IS_TYPE;

exports.isNode = isNode;
exports.isPseudoElement = isPseudoElement;
exports.isPseudoClass = isPseudoClass;
exports.isContainer = isContainer;
exports.isNamespace = isNamespace;

var _types = require("./types");

var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);

function isNode(node) {
  return (typeof node === "undefined" ? "undefined" : _typeof(node)) === "object" && IS_TYPE[node.type];
}

function isNodeType(type, node) {
  return isNode(node) && node.type === type;
}

var isAttribute = exports.isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
var isClassName = exports.isClassName = isNodeType.bind(null, _types.CLASS);
var isCombinator = exports.isCombinator = isNodeType.bind(null, _types.COMBINATOR);
var isComment = exports.isComment = isNodeType.bind(null, _types.COMMENT);
var isIdentifier = exports.isIdentifier = isNodeType.bind(null, _types.ID);
var isNesting = exports.isNesting = isNodeType.bind(null, _types.NESTING);
var isPseudo = exports.isPseudo = isNodeType.bind(null, _types.PSEUDO);
var isRoot = exports.isRoot = isNodeType.bind(null, _types.ROOT);
var isSelector = exports.isSelector = isNodeType.bind(null, _types.SELECTOR);
var isString = exports.isString = isNodeType.bind(null, _types.STRING);
var isTag = exports.isTag = isNodeType.bind(null, _types.TAG);
var isUniversal = exports.isUniversal = isNodeType.bind(null, _types.UNIVERSAL);

function isPseudoElement(node) {
  return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value === ":before" || node.value === ":after");
}

function isPseudoClass(node) {
  return isPseudo(node) && !isPseudoElement(node);
}

function isContainer(node) {
  return !!(isNode(node) && node.walk);
}

function isNamespace(node) {
  return isClassName(node) || isAttribute(node) || isTag(node);
}
},{"./types":"node_modules/postcss-selector-parser/dist/selectors/types.js"}],"node_modules/postcss-selector-parser/dist/selectors/index.js":[function(require,module,exports) {
"use strict";

exports.__esModule = true;

var _types = require("./types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _types[key];
    }
  });
});

var _constructors = require("./constructors");

Object.keys(_constructors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _constructors[key];
    }
  });
});

var _guards = require("./guards");

Object.keys(_guards).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _guards[key];
    }
  });
});
},{"./types":"node_modules/postcss-selector-parser/dist/selectors/types.js","./constructors":"node_modules/postcss-selector-parser/dist/selectors/constructors.js","./guards":"node_modules/postcss-selector-parser/dist/selectors/guards.js"}],"node_modules/postcss-selector-parser/dist/index.js":[function(require,module,exports) {
'use strict';

exports.__esModule = true;

var _processor = require('./processor');

var _processor2 = _interopRequireDefault(_processor);

var _selectors = require('./selectors');

var selectors = _interopRequireWildcard(_selectors);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var parser = function parser(processor) {
  return new _processor2.default(processor);
};

Object.assign(parser, selectors);
delete parser.__esModule;
exports.default = parser;
module.exports = exports['default'];
},{"./processor":"node_modules/postcss-selector-parser/dist/processor.js","./selectors":"node_modules/postcss-selector-parser/dist/selectors/index.js"}],"node_modules/postcss-minify-selectors/dist/lib/unquote.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (string) {
  return string.replace(/["']/g, '');
};

module.exports = exports['default'];
},{}],"node_modules/postcss-minify-selectors/dist/lib/canUnquote.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = canUnquote;

var _unquote = require('./unquote');

var _unquote2 = _interopRequireDefault(_unquote);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Can unquote attribute detection from mothereff.in
 * Copyright Mathias Bynens <https://mathiasbynens.be/>
 * https://github.com/mathiasbynens/mothereff.in
 */


var escapes = /\\([0-9A-Fa-f]{1,6})[ \t\n\f\r]?/g;
var range = /[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;

function canUnquote(value) {
  value = (0, _unquote2.default)(value);

  if (value === '-' || value === '') {
    return false;
  }

  value = value.replace(escapes, 'a').replace(/\\./g, 'a');
  return !(range.test(value) || /^(?:-?\d|--)/.test(value));
}

module.exports = exports['default'];
},{"./unquote":"node_modules/postcss-minify-selectors/dist/lib/unquote.js"}],"node_modules/postcss-minify-selectors/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require("postcss");

var _alphanumSort = require("alphanum-sort");

var _alphanumSort2 = _interopRequireDefault(_alphanumSort);

var _has = require("has");

var _has2 = _interopRequireDefault(_has);

var _postcssSelectorParser = require("postcss-selector-parser");

var _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);

var _unquote = require("./lib/unquote");

var _unquote2 = _interopRequireDefault(_unquote);

var _canUnquote = require("./lib/canUnquote");

var _canUnquote2 = _interopRequireDefault(_canUnquote);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var pseudoElements = ["::before", "::after", "::first-letter", "::first-line"];

function getParsed(selectors, callback) {
  return (0, _postcssSelectorParser2.default)(callback).processSync(selectors);
}

function attribute(selector) {
  if (selector.value) {
    // Join selectors that are split over new lines
    selector.value = selector.value.replace(/\\\n/g, "").trim();

    if ((0, _canUnquote2.default)(selector.value)) {
      selector.value = (0, _unquote2.default)(selector.value);
    }

    selector.operator = selector.operator.trim();
  }

  if (!selector.raws) {
    selector.raws = {};
  }

  if (!selector.raws.spaces) {
    selector.raws.spaces = {};
  }

  selector.raws.spaces.attribute = {
    before: "",
    after: ""
  };
  selector.raws.spaces.operator = {
    before: "",
    after: ""
  };
  selector.raws.spaces.value = {
    before: "",
    after: selector.insensitive ? " " : ""
  };

  if (selector.insensitive) {
    selector.raws.spaces.insensitive = {
      before: "",
      after: ""
    };
  }

  selector.attribute = selector.attribute.trim();
}

function combinator(selector) {
  var value = selector.value.trim();
  selector.value = value.length ? value : " ";
}

var pseudoReplacements = {
  ":nth-child": ":first-child",
  ":nth-of-type": ":first-of-type",
  ":nth-last-child": ":last-child",
  ":nth-last-of-type": ":last-of-type"
};

function pseudo(selector) {
  var value = selector.value.toLowerCase();

  if (selector.nodes.length === 1 && pseudoReplacements[value]) {
    var first = selector.at(0);
    var one = first.at(0);

    if (first.length === 1) {
      if (one.value === "1") {
        selector.replaceWith(_postcssSelectorParser2.default.pseudo({
          value: pseudoReplacements[value]
        }));
      }

      if (one.value.toLowerCase() === "even") {
        one.value = "2n";
      }
    }

    if (first.length === 3) {
      var two = first.at(1);
      var three = first.at(2);

      if (one.value.toLowerCase() === "2n" && two.value === "+" && three.value === "1") {
        one.value = "odd";
        two.remove();
        three.remove();
      }
    }

    return;
  }

  var uniques = [];
  selector.walk(function (child) {
    if (child.type === "selector") {
      var childStr = String(child);

      if (!~uniques.indexOf(childStr)) {
        uniques.push(childStr);
      } else {
        child.remove();
      }
    }
  });

  if (~pseudoElements.indexOf(value)) {
    selector.value = selector.value.slice(1);
  }
}

var tagReplacements = {
  from: "0%",
  "100%": "to"
};

function tag(selector) {
  var value = selector.value.toLowerCase();

  if ((0, _has2.default)(tagReplacements, value)) {
    selector.value = tagReplacements[value];
  }
}

function universal(selector) {
  var next = selector.next();

  if (next && next.type !== "combinator") {
    selector.remove();
  }
}

var reducers = {
  attribute: attribute,
  combinator: combinator,
  pseudo: pseudo,
  tag: tag,
  universal: universal
};
exports.default = (0, _postcss.plugin)("postcss-minify-selectors", function () {
  return function (css) {
    var cache = {};
    css.walkRules(function (rule) {
      var selector = rule.raws.selector && rule.raws.selector.value === rule.selector ? rule.raws.selector.raw : rule.selector; // If the selector ends with a ':' it is likely a part of a custom mixin,
      // so just pass through.

      if (selector[selector.length - 1] === ":") {
        return;
      }

      if (cache[selector]) {
        rule.selector = cache[selector];
        return;
      }

      var optimizedSelector = getParsed(selector, function (selectors) {
        selectors.nodes = (0, _alphanumSort2.default)(selectors.nodes, {
          insensitive: true
        });
        var uniqueSelectors = [];
        selectors.walk(function (sel) {
          var type = sel.type; // Trim whitespace around the value

          sel.spaces.before = sel.spaces.after = "";

          if ((0, _has2.default)(reducers, type)) {
            reducers[type](sel);
            return;
          }

          var toString = String(sel);

          if (type === "selector" && sel.parent.type !== "pseudo") {
            if (!~uniqueSelectors.indexOf(toString)) {
              uniqueSelectors.push(toString);
            } else {
              sel.remove();
            }
          }
        });
      });
      rule.selector = optimizedSelector;
      cache[selector] = optimizedSelector;
    });
  };
});
module.exports = exports["default"];
},{"postcss":"node_modules/postcss/lib/postcss.js","alphanum-sort":"node_modules/alphanum-sort/lib/index.js","has":"node_modules/has/src/index.js","postcss-selector-parser":"node_modules/postcss-selector-parser/dist/index.js","./lib/unquote":"node_modules/postcss-minify-selectors/dist/lib/unquote.js","./lib/canUnquote":"node_modules/postcss-minify-selectors/dist/lib/canUnquote.js"}],"node_modules/uniqs/index.js":[function(require,module,exports) {
module.exports = function uniqs() {
  var list = Array.prototype.concat.apply([], arguments);
  return list.filter(function(item, i) {
    return i == list.indexOf(item);
  });
};

},{}],"node_modules/postcss-minify-params/dist/index.js":[function(require,module,exports) {
var __dirname = "/home/royyan/csspurge/node_modules/postcss-minify-params/dist";
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _browserslist = require('browserslist');

var _browserslist2 = _interopRequireDefault(_browserslist);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _alphanumSort = require('alphanum-sort');

var _alphanumSort2 = _interopRequireDefault(_alphanumSort);

var _uniqs = require('uniqs');

var _uniqs2 = _interopRequireDefault(_uniqs);

var _cssnanoUtilGetArguments = require('cssnano-util-get-arguments');

var _cssnanoUtilGetArguments2 = _interopRequireDefault(_cssnanoUtilGetArguments);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Return the greatest common divisor
 * of two numbers.
 */


function gcd(a, b) {
  return b ? gcd(b, a % b) : a;
}

function aspectRatio(a, b) {
  var divisor = gcd(a, b);
  return [a / divisor, b / divisor];
}

function split(args) {
  return args.map(function (arg) {
    return (0, _postcssValueParser.stringify)(arg);
  }).join('');
}

function removeNode(node) {
  node.value = '';
  node.type = 'word';
}

function transform(legacy, rule) {
  var ruleName = rule.name.toLowerCase(); // We should re-arrange parameters only for `@media` and `@supports` at-rules

  if (!rule.params || !["media", "supports"].includes(ruleName)) {
    return;
  }

  var params = (0, _postcssValueParser2.default)(rule.params);
  params.walk(function (node, index) {
    if (node.type === 'div' || node.type === 'function') {
      node.before = node.after = '';

      if (node.type === 'function' && node.nodes[4] && node.nodes[0].value.toLowerCase().indexOf('-aspect-ratio') === 3) {
        var _aspectRatio = aspectRatio(node.nodes[2].value, node.nodes[4].value),
            _aspectRatio2 = _slicedToArray(_aspectRatio, 2),
            a = _aspectRatio2[0],
            b = _aspectRatio2[1];

        node.nodes[2].value = a;
        node.nodes[4].value = b;
      }
    } else if (node.type === 'space') {
      node.value = ' ';
    } else {
      var prevWord = params.nodes[index - 2];

      if (node.value.toLowerCase() === 'all' && rule.name.toLowerCase() === 'media' && !prevWord) {
        var nextWord = params.nodes[index + 2];

        if (!legacy || nextWord) {
          removeNode(node);
        }

        if (nextWord && nextWord.value.toLowerCase() === 'and') {
          var nextSpace = params.nodes[index + 1];
          var secondSpace = params.nodes[index + 3];
          removeNode(nextWord);
          removeNode(nextSpace);
          removeNode(secondSpace);
        }
      }
    }
  }, true);
  rule.params = (0, _alphanumSort2.default)((0, _uniqs2.default)((0, _cssnanoUtilGetArguments2.default)(params).map(split)), {
    insensitive: true
  }).join();

  if (!rule.params.length) {
    rule.raws.afterName = '';
  }
}

function hasAllBug(browser) {
  return ~['ie 10', 'ie 11'].indexOf(browser);
}

exports.default = _postcss2.default.plugin('postcss-minify-params', function () {
  return function (css, result) {
    var resultOpts = result.opts || {};
    var browsers = (0, _browserslist2.default)(null, {
      stats: resultOpts.stats,
      path: __dirname,
      env: resultOpts.env
    });
    return css.walkAtRules(transform.bind(null, browsers.some(hasAllBug)));
  };
});
module.exports = exports['default'];
},{"browserslist":"node_modules/browserslist/index.js","postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","alphanum-sort":"node_modules/alphanum-sort/lib/index.js","uniqs":"node_modules/uniqs/index.js","cssnano-util-get-arguments":"node_modules/cssnano-util-get-arguments/dist/index.js"}],"node_modules/postcss-normalize-charset/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var charset = 'charset';
exports.default = _postcss2.default.plugin('postcss-normalize-' + charset, function () {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (css) {
    var charsetRule;
    var nonAsciiNode;
    var nonAscii = /[^\x00-\x7F]/;
    css.walk(function (node) {
      if (node.type === 'atrule' && node.name === charset) {
        if (!charsetRule) {
          charsetRule = node;
        }

        node.remove();
      } else if (!nonAsciiNode && node.parent === css && nonAscii.test(node)) {
        nonAsciiNode = node;
      }
    });

    if (nonAsciiNode) {
      if (!charsetRule && opts.add !== false) {
        charsetRule = _postcss2.default.atRule({
          name: charset,
          params: '"utf-8"'
        });
      }

      if (charsetRule) {
        charsetRule.source = nonAsciiNode.source;
        css.prepend(charsetRule);
      }
    }
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js"}],"node_modules/postcss-minify-font-values/dist/lib/minify-weight.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (value) {
  var valueInLowerCase = value.toLowerCase();
  return valueInLowerCase === 'normal' ? '400' : valueInLowerCase === 'bold' ? '700' : value;
};

;
module.exports = exports['default'];
},{}],"node_modules/postcss-minify-font-values/dist/lib/uniqs.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = uniqueExcept;

function uniqueExcept(exclude) {
  return function unique() {
    var list = Array.prototype.concat.apply([], arguments);
    return list.filter(function (item, i) {
      if (item.toLowerCase() === exclude) {
        return true;
      }

      return i === list.indexOf(item);
    });
  };
}

;
module.exports = exports["default"];
},{}],"node_modules/postcss-minify-font-values/dist/lib/minify-family.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (nodes, opts) {
  var family = [];
  var last = null;
  var i, max;
  nodes.forEach(function (node, index, arr) {
    if (node.type === 'string' || node.type === 'function') {
      family.push(node);
    } else if (node.type === 'word') {
      if (!last) {
        last = {
          type: 'word',
          value: ''
        };
        family.push(last);
      }

      last.value += node.value;
    } else if (node.type === 'space') {
      if (last && index !== arr.length - 1) {
        last.value += ' ';
      }
    } else {
      last = null;
    }
  });
  family = family.map(function (node) {
    if (node.type === 'string') {
      var isKeyword = regexKeyword.test(node.value);

      if (!opts.removeQuotes || isKeyword || /[0-9]/.test(node.value.slice(0, 1))) {
        return (0, _postcssValueParser.stringify)(node);
      }

      var escaped = escapeIdentifierSequence(node.value);

      if (escaped.length < node.value.length + 2) {
        return escaped;
      }
    }

    return (0, _postcssValueParser.stringify)(node);
  });

  if (opts.removeAfterKeyword) {
    for (i = 0, max = family.length; i < max; i += 1) {
      if (~genericFontFamilykeywords.indexOf(family[i].toLowerCase())) {
        family = family.slice(0, i + 1);
        break;
      }
    }
  }

  if (opts.removeDuplicates) {
    family = uniqs(family);
  }

  return [{
    type: 'word',
    value: family.join()
  }];
};

var _postcssValueParser = require('postcss-value-parser');

var _uniqs = require('./uniqs');

var _uniqs2 = _interopRequireDefault(_uniqs);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var uniqs = (0, _uniqs2.default)('monospace');
var globalKeywords = ['inherit', 'initial', 'unset'];
var genericFontFamilykeywords = ['sans-serif', 'serif', 'fantasy', 'cursive', 'monospace', 'system-ui'];

function makeArray(value, length) {
  var array = [];

  while (length--) {
    array[length] = value;
  }

  return array;
}

var regexSimpleEscapeCharacters = /[ !"#$%&'()*+,.\/;<=>?@\[\\\]^`{|}~]/;

function escape(string, escapeForString) {
  var counter = 0;
  var character = null;
  var charCode = null;
  var value = null;
  var output = '';

  while (counter < string.length) {
    character = string.charAt(counter++);
    charCode = character.charCodeAt(); // \r is already tokenized away at this point
    // `:` can be escaped as `\:`, but that fails in IE < 8

    if (!escapeForString && /[\t\n\v\f:]/.test(character)) {
      value = '\\' + charCode.toString(16) + ' ';
    } else if (!escapeForString && regexSimpleEscapeCharacters.test(character)) {
      value = '\\' + character;
    } else {
      value = character;
    }

    output += value;
  }

  if (!escapeForString) {
    if (/^-[-\d]/.test(output)) {
      output = '\\-' + output.slice(1);
    }

    var firstChar = string.charAt(0);

    if (/\d/.test(firstChar)) {
      output = '\\3' + firstChar + ' ' + output.slice(1);
    }
  }

  return output;
}

var regexKeyword = new RegExp(genericFontFamilykeywords.concat(globalKeywords).join('|'), 'i');
var regexInvalidIdentifier = /^(-?\d|--)/;
var regexSpaceAtStart = /^\x20/;
var regexWhitespace = /[\t\n\f\r\x20]/g;
var regexIdentifierCharacter = /^[a-zA-Z\d\xa0-\uffff_-]+$/;
var regexConsecutiveSpaces = /(\\(?:[a-fA-F0-9]{1,6}\x20|\x20))?(\x20{2,})/g;
var regexTrailingEscape = /\\[a-fA-F0-9]{0,6}\x20$/;
var regexTrailingSpace = /\x20$/;

function escapeIdentifierSequence(string) {
  var identifiers = string.split(regexWhitespace);
  var index = 0;
  var result = [];
  var escapeResult;

  while (index < identifiers.length) {
    var subString = identifiers[index++];

    if (subString === '') {
      result.push(subString);
      continue;
    }

    escapeResult = escape(subString, false);

    if (regexIdentifierCharacter.test(subString)) {
      // the font family name part consists of allowed characters exclusively
      if (regexInvalidIdentifier.test(subString)) {
        // the font family name part starts with two hyphens, a digit, or a
        // hyphen followed by a digit
        if (index === 1) {
          // if this is the first item
          result.push(escapeResult);
        } else {
          // if it’s not the first item, we can simply escape the space
          // between the two identifiers to merge them into a single
          // identifier rather than escaping the start characters of the
          // second identifier
          result[index - 2] += '\\';
          result.push(escape(subString, true));
        }
      } else {
        // the font family name part doesn’t start with two hyphens, a digit,
        // or a hyphen followed by a digit
        result.push(escapeResult);
      }
    } else {
      // the font family name part contains invalid identifier characters
      result.push(escapeResult);
    }
  }

  result = result.join(' ').replace(regexConsecutiveSpaces, function ($0, $1, $2) {
    var spaceCount = $2.length;
    var escapesNeeded = Math.floor(spaceCount / 2);
    var array = makeArray('\\ ', escapesNeeded);

    if (spaceCount % 2) {
      array[escapesNeeded - 1] += '\\ ';
    }

    return ($1 || '') + ' ' + array.join(' ');
  }); // Escape trailing spaces unless they’re already part of an escape

  if (regexTrailingSpace.test(result) && !regexTrailingEscape.test(result)) {
    result = result.replace(regexTrailingSpace, '\\ ');
  }

  if (regexSpaceAtStart.test(result)) {
    result = '\\ ' + result.slice(1);
  }

  return result;
}

;
module.exports = exports['default'];
},{"postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","./uniqs":"node_modules/postcss-minify-font-values/dist/lib/uniqs.js"}],"node_modules/postcss-minify-font-values/dist/lib/keywords.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  style: ['italic', 'oblique'],
  variant: ['small-caps'],
  weight: ['100', '200', '300', '400', '500', '600', '700', '800', '900', 'bold', 'lighter', 'bolder'],
  stretch: ['ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded'],
  size: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large', 'larger', 'smaller']
};
module.exports = exports['default'];
},{}],"node_modules/postcss-minify-font-values/dist/lib/minify-font.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (nodes, opts) {
  var i, max, node, familyStart, family;
  var hasSize = false;

  for (i = 0, max = nodes.length; i < max; i += 1) {
    node = nodes[i];

    if (node.type === 'word') {
      if (hasSize) {
        continue;
      }

      var value = node.value.toLowerCase();

      if (value === 'normal' || ~_keywords2.default.style.indexOf(value) || ~_keywords2.default.variant.indexOf(value) || ~_keywords2.default.stretch.indexOf(value)) {
        familyStart = i;
      } else if (~_keywords2.default.weight.indexOf(value)) {
        node.value = (0, _minifyWeight2.default)(value);
        familyStart = i;
      } else if (~_keywords2.default.size.indexOf(value) || (0, _postcssValueParser.unit)(value)) {
        familyStart = i;
        hasSize = true;
      }
    } else if (node.type === 'div' && node.value === '/') {
      familyStart = i + 1;
      break;
    }
  }

  familyStart += 2;
  family = (0, _minifyFamily2.default)(nodes.slice(familyStart), opts);
  return nodes.slice(0, familyStart).concat(family);
};

var _postcssValueParser = require('postcss-value-parser');

var _keywords = require('./keywords');

var _keywords2 = _interopRequireDefault(_keywords);

var _minifyFamily = require('./minify-family');

var _minifyFamily2 = _interopRequireDefault(_minifyFamily);

var _minifyWeight = require('./minify-weight');

var _minifyWeight2 = _interopRequireDefault(_minifyWeight);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

;
module.exports = exports['default'];
},{"postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","./keywords":"node_modules/postcss-minify-font-values/dist/lib/keywords.js","./minify-family":"node_modules/postcss-minify-font-values/dist/lib/minify-family.js","./minify-weight":"node_modules/postcss-minify-font-values/dist/lib/minify-weight.js"}],"node_modules/postcss-minify-font-values/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _minifyWeight = require('./lib/minify-weight');

var _minifyWeight2 = _interopRequireDefault(_minifyWeight);

var _minifyFamily = require('./lib/minify-family');

var _minifyFamily2 = _interopRequireDefault(_minifyFamily);

var _minifyFont = require('./lib/minify-font');

var _minifyFont2 = _interopRequireDefault(_minifyFont);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function transform(opts, decl) {
  var tree;
  var prop = decl.prop.toLowerCase();

  if (prop === 'font-weight') {
    decl.value = (0, _minifyWeight2.default)(decl.value);
  } else if (prop === 'font-family') {
    tree = (0, _postcssValueParser2.default)(decl.value);
    tree.nodes = (0, _minifyFamily2.default)(tree.nodes, opts);
    decl.value = tree.toString();
  } else if (prop === 'font') {
    tree = (0, _postcssValueParser2.default)(decl.value);
    tree.nodes = (0, _minifyFont2.default)(tree.nodes, opts);
    decl.value = tree.toString();
  }
}

exports.default = _postcss2.default.plugin('postcss-minify-font-values', function (opts) {
  opts = Object.assign({}, {
    removeAfterKeyword: false,
    removeDuplicates: true,
    removeQuotes: true
  }, opts);
  return function (css) {
    return css.walkDecls(/font/i, transform.bind(null, opts));
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","./lib/minify-weight":"node_modules/postcss-minify-font-values/dist/lib/minify-weight.js","./lib/minify-family":"node_modules/postcss-minify-font-values/dist/lib/minify-family.js","./lib/minify-font":"node_modules/postcss-minify-font-values/dist/lib/minify-font.js"}],"node_modules/node-libs-browser/node_modules/punycode/punycode.js":[function(require,module,exports) {
var global = arguments[3];
var define;
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

},{}],"node_modules/url/util.js":[function(require,module,exports) {
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],"node_modules/querystring-es3/decode.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict'; // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};
},{}],"node_modules/querystring-es3/encode.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var stringifyPrimitive = function (v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }

  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }

  return res;
};
},{}],"node_modules/querystring-es3/index.js":[function(require,module,exports) {
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');
},{"./decode":"node_modules/querystring-es3/decode.js","./encode":"node_modules/querystring-es3/encode.js"}],"node_modules/url/url.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"punycode":"node_modules/node-libs-browser/node_modules/punycode/punycode.js","./util":"node_modules/url/util.js","querystring":"node_modules/querystring-es3/index.js"}],"node_modules/normalize-url/index.js":[function(require,module,exports) {
'use strict'; // TODO: Use the `URL` global when targeting Node.js 10

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var URLParser = typeof URL === 'undefined' ? require('url').URL : URL;

var testParameter = function (name, filters) {
  return filters.some(function (filter) {
    return filter instanceof RegExp ? filter.test(name) : filter === name;
  });
};

module.exports = function (urlString, opts) {
  opts = Object.assign({
    defaultProtocol: 'http:',
    normalizeProtocol: true,
    forceHttp: false,
    forceHttps: false,
    stripHash: true,
    stripWWW: true,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: true,
    removeDirectoryIndex: false,
    sortQueryParameters: true
  }, opts); // Backwards compatibility

  if (Reflect.has(opts, 'normalizeHttps')) {
    opts.forceHttp = opts.normalizeHttps;
  }

  if (Reflect.has(opts, 'normalizeHttp')) {
    opts.forceHttps = opts.normalizeHttp;
  }

  if (Reflect.has(opts, 'stripFragment')) {
    opts.stripHash = opts.stripFragment;
  }

  urlString = urlString.trim();
  var hasRelativeProtocol = urlString.startsWith('//');
  var isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString); // Prepend protocol

  if (!isRelativeUrl) {
    urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, opts.defaultProtocol);
  }

  var urlObj = new URLParser(urlString);

  if (opts.forceHttp && opts.forceHttps) {
    throw new Error('The `forceHttp` and `forceHttps` options cannot be used together');
  }

  if (opts.forceHttp && urlObj.protocol === 'https:') {
    urlObj.protocol = 'http:';
  }

  if (opts.forceHttps && urlObj.protocol === 'http:') {
    urlObj.protocol = 'https:';
  } // Remove hash


  if (opts.stripHash) {
    urlObj.hash = '';
  } // Remove duplicate slashes if not preceded by a protocol


  if (urlObj.pathname) {
    // TODO: Use the following instead when targeting Node.js 10
    // `urlObj.pathname = urlObj.pathname.replace(/(?<!https?:)\/{2,}/g, '/');`
    urlObj.pathname = urlObj.pathname.replace(/((?![https?:]).)\/{2,}/g, function (_, p1) {
      if (/^(?!\/)/g.test(p1)) {
        return "".concat(p1, "/");
      }

      return '/';
    });
  } // Decode URI octets


  if (urlObj.pathname) {
    urlObj.pathname = decodeURI(urlObj.pathname);
  } // Remove directory index


  if (opts.removeDirectoryIndex === true) {
    opts.removeDirectoryIndex = [/^index\.[a-z]+$/];
  }

  if (Array.isArray(opts.removeDirectoryIndex) && opts.removeDirectoryIndex.length > 0) {
    var pathComponents = urlObj.pathname.split('/');
    var lastComponent = pathComponents[pathComponents.length - 1];

    if (testParameter(lastComponent, opts.removeDirectoryIndex)) {
      pathComponents = pathComponents.slice(0, pathComponents.length - 1);
      urlObj.pathname = pathComponents.slice(1).join('/') + '/';
    }
  }

  if (urlObj.hostname) {
    // Remove trailing dot
    urlObj.hostname = urlObj.hostname.replace(/\.$/, ''); // Remove `www.`
    // eslint-disable-next-line no-useless-escape

    if (opts.stripWWW && /^www\.([a-z\-\d]{2,63})\.([a-z\.]{2,5})$/.test(urlObj.hostname)) {
      // Each label should be max 63 at length (min: 2).
      // The extension should be max 5 at length (min: 2).
      // Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
      urlObj.hostname = urlObj.hostname.replace(/^www\./, '');
    }
  } // Remove query unwanted parameters


  if (Array.isArray(opts.removeQueryParameters)) {
    for (var key of _toConsumableArray(urlObj.searchParams.keys())) {
      if (testParameter(key, opts.removeQueryParameters)) {
        urlObj.searchParams.delete(key);
      }
    }
  } // Sort query parameters


  if (opts.sortQueryParameters) {
    urlObj.searchParams.sort();
  } // Take advantage of many of the Node `url` normalizations


  urlString = urlObj.toString(); // Remove ending `/`

  if (opts.removeTrailingSlash || urlObj.pathname === '/') {
    urlString = urlString.replace(/\/$/, '');
  } // Restore relative protocol, if applicable


  if (hasRelativeProtocol && !opts.normalizeProtocol) {
    urlString = urlString.replace(/^http:\/\//, '//');
  }

  return urlString;
};
},{"url":"node_modules/url/url.js"}],"node_modules/is-absolute-url/index.js":[function(require,module,exports) {
'use strict';

module.exports = function (url) {
  if (typeof url !== 'string') {
    throw new TypeError('Expected a string');
  }

  return /^[a-z][a-z0-9+.-]*:/.test(url);
};
},{}],"node_modules/postcss-normalize-url/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _normalizeUrl = require('normalize-url');

var _normalizeUrl2 = _interopRequireDefault(_normalizeUrl);

var _isAbsoluteUrl = require('is-absolute-url');

var _isAbsoluteUrl2 = _interopRequireDefault(_isAbsoluteUrl);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var multiline = /\\[\r\n]/;
var escapeChars = /([\s\(\)"'])/g;

function convert(url, options) {
  if ((0, _isAbsoluteUrl2.default)(url) || url.startsWith('//')) {
    var normalizedURL = null;

    try {
      normalizedURL = (0, _normalizeUrl2.default)(url, options);
    } catch (e) {
      normalizedURL = url;
    }

    return normalizedURL;
  } // `path.normalize` always returns backslashes on Windows, need replace in `/`


  return _path2.default.normalize(url).replace(new RegExp('\\' + _path2.default.sep, 'g'), '/');
}

function transformNamespace(rule) {
  rule.params = (0, _postcssValueParser2.default)(rule.params).walk(function (node) {
    if (node.type === 'function' && node.value.toLowerCase() === 'url' && node.nodes.length) {
      node.type = 'string';
      node.quote = node.nodes[0].quote || '"';
      node.value = node.nodes[0].value;
    }

    if (node.type === 'string') {
      node.value = node.value.trim();
    }

    return false;
  }).toString();
}

function transformDecl(decl, opts) {
  decl.value = (0, _postcssValueParser2.default)(decl.value).walk(function (node) {
    if (node.type !== 'function' || node.value.toLowerCase() !== 'url' || !node.nodes.length) {
      return false;
    }

    var url = node.nodes[0];
    var escaped;
    node.before = node.after = '';
    url.value = url.value.trim().replace(multiline, ''); // Skip empty URLs
    // Empty URL function equals request to current stylesheet where it is declared

    if (url.value.length === 0) {
      url.quote = '';
      return false;
    }

    if (/^data:(.*)?,/i.test(url.value)) {
      return false;
    }

    if (!/^.+-extension:\//i.test(url.value)) {
      url.value = convert(url.value, opts);
    }

    if (escapeChars.test(url.value) && url.type === 'string') {
      escaped = url.value.replace(escapeChars, '\\$1');

      if (escaped.length < url.value.length + 2) {
        url.value = escaped;
        url.type = 'word';
      }
    } else {
      url.type = 'word';
    }

    return false;
  }).toString();
}

exports.default = _postcss2.default.plugin('postcss-normalize-url', function (opts) {
  opts = Object.assign({}, {
    normalizeProtocol: false,
    stripFragment: false,
    stripWWW: false
  }, opts);
  return function (css) {
    css.walk(function (node) {
      if (node.type === 'decl') {
        return transformDecl(node, opts);
      } else if (node.type === 'atrule' && node.name.toLowerCase() === 'namespace') {
        return transformNamespace(node);
      }
    });
  };
});
module.exports = exports['default'];
},{"path":"node_modules/path-browserify/index.js","postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","normalize-url":"node_modules/normalize-url/index.js","is-absolute-url":"node_modules/is-absolute-url/index.js"}],"node_modules/stylehacks/dist/exists.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exists;

function exists(selector, index, value) {
  var node = selector.at(index);
  return node && node.value && node.value.toLowerCase() === value;
}

module.exports = exports["default"];
},{}],"node_modules/stylehacks/dist/isMixin.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isMixin;

function isMixin(node) {
  var selector = node.selector; // If the selector ends with a ':' it is likely a part of a custom mixin.

  if (!selector || selector[selector.length - 1] === ':') {
    return true;
  }

  return false;
}

module.exports = exports['default'];
},{}],"node_modules/stylehacks/dist/plugin.js":[function(require,module,exports) {
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = plugin;

function plugin(targets, nodeTypes, detect) {
  var Plugin = /*#__PURE__*/function () {
    function Plugin(result) {
      _classCallCheck(this, Plugin);

      this.nodes = [];
      this.result = result;
      this.targets = targets;
      this.nodeTypes = nodeTypes;
    }

    _createClass(Plugin, [{
      key: "push",
      value: function push(node, metadata) {
        node._stylehacks = Object.assign({}, metadata, {
          message: "Bad ".concat(metadata.identifier, ": ").concat(metadata.hack),
          browsers: this.targets
        });
        this.nodes.push(node);
      }
    }, {
      key: "any",
      value: function any(node) {
        if (~this.nodeTypes.indexOf(node.type)) {
          detect.apply(this, arguments);
          return !!node._stylehacks;
        }

        return false;
      }
    }, {
      key: "detectAndResolve",
      value: function detectAndResolve() {
        this.nodes = [];

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        detect.apply(this, args);
        return this.resolve();
      }
    }, {
      key: "detectAndWarn",
      value: function detectAndWarn() {
        this.nodes = [];

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        detect.apply(this, args);
        return this.warn();
      }
    }, {
      key: "resolve",
      value: function resolve() {
        return this.nodes.forEach(function (node) {
          return node.remove();
        });
      }
    }, {
      key: "warn",
      value: function warn() {
        var _this = this;

        return this.nodes.forEach(function (node) {
          var _node$_stylehacks = node._stylehacks,
              message = _node$_stylehacks.message,
              browsers = _node$_stylehacks.browsers,
              identifier = _node$_stylehacks.identifier,
              hack = _node$_stylehacks.hack;
          return node.warn(_this.result, message, {
            browsers: browsers,
            identifier: identifier,
            hack: hack
          });
        });
      }
    }]);

    return Plugin;
  }();

  return Plugin;
}

module.exports = exports["default"];
},{}],"node_modules/stylehacks/dist/dictionary/browsers.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var FF_2 = exports.FF_2 = 'firefox 2';
var IE_5_5 = exports.IE_5_5 = 'ie 5.5';
var IE_6 = exports.IE_6 = 'ie 6';
var IE_7 = exports.IE_7 = 'ie 7';
var IE_8 = exports.IE_8 = 'ie 8';
var OP_9 = exports.OP_9 = 'opera 9';
},{}],"node_modules/stylehacks/dist/dictionary/identifiers.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var MEDIA_QUERY = exports.MEDIA_QUERY = 'media query';
var PROPERTY = exports.PROPERTY = 'property';
var SELECTOR = exports.SELECTOR = 'selector';
var VALUE = exports.VALUE = 'value';
},{}],"node_modules/stylehacks/dist/dictionary/postcss.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ATRULE = exports.ATRULE = 'atrule';
var DECL = exports.DECL = 'decl';
var RULE = exports.RULE = 'rule';
},{}],"node_modules/stylehacks/dist/dictionary/tags.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var BODY = exports.BODY = 'body';
var HTML = exports.HTML = 'html';
},{}],"node_modules/stylehacks/dist/plugins/bodyEmpty.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcssSelectorParser = require('postcss-selector-parser');

var _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);

var _exists = require('../exists');

var _exists2 = _interopRequireDefault(_exists);

var _isMixin = require('../isMixin');

var _isMixin2 = _interopRequireDefault(_isMixin);

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

var _tags = require('../dictionary/tags');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function analyse(ctx, rule) {
  return function (selectors) {
    selectors.each(function (selector) {
      if ((0, _exists2.default)(selector, 0, _tags.BODY) && (0, _exists2.default)(selector, 1, ':empty') && (0, _exists2.default)(selector, 2, ' ') && selector.at(3)) {
        ctx.push(rule, {
          identifier: _identifiers.SELECTOR,
          hack: selector.toString()
        });
      }
    });
  };
}

exports.default = (0, _plugin2.default)([_browsers.FF_2], [_postcss.RULE], function (rule) {
  if ((0, _isMixin2.default)(rule)) {
    return;
  }

  (0, _postcssSelectorParser2.default)(analyse(this, rule)).processSync(rule.selector);
});
module.exports = exports['default'];
},{"postcss-selector-parser":"node_modules/postcss-selector-parser/dist/index.js","../exists":"node_modules/stylehacks/dist/exists.js","../isMixin":"node_modules/stylehacks/dist/isMixin.js","../plugin":"node_modules/stylehacks/dist/plugin.js","../dictionary/browsers":"node_modules/stylehacks/dist/dictionary/browsers.js","../dictionary/identifiers":"node_modules/stylehacks/dist/dictionary/identifiers.js","../dictionary/postcss":"node_modules/stylehacks/dist/dictionary/postcss.js","../dictionary/tags":"node_modules/stylehacks/dist/dictionary/tags.js"}],"node_modules/stylehacks/dist/plugins/htmlCombinatorCommentBody.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcssSelectorParser = require('postcss-selector-parser');

var _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);

var _exists = require('../exists');

var _exists2 = _interopRequireDefault(_exists);

var _isMixin = require('../isMixin');

var _isMixin2 = _interopRequireDefault(_isMixin);

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

var _tags = require('../dictionary/tags');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function analyse(ctx, rule) {
  return function (selectors) {
    selectors.each(function (selector) {
      if ((0, _exists2.default)(selector, 0, _tags.HTML) && ((0, _exists2.default)(selector, 1, '>') || (0, _exists2.default)(selector, 1, '~')) && selector.at(2) && selector.at(2).type === 'comment' && (0, _exists2.default)(selector, 3, ' ') && (0, _exists2.default)(selector, 4, _tags.BODY) && (0, _exists2.default)(selector, 5, ' ') && selector.at(6)) {
        ctx.push(rule, {
          identifier: _identifiers.SELECTOR,
          hack: selector.toString()
        });
      }
    });
  };
}

exports.default = (0, _plugin2.default)([_browsers.IE_5_5, _browsers.IE_6, _browsers.IE_7], [_postcss.RULE], function (rule) {
  if ((0, _isMixin2.default)(rule)) {
    return;
  }

  if (rule.raws.selector && rule.raws.selector.raw) {
    (0, _postcssSelectorParser2.default)(analyse(this, rule)).processSync(rule.raws.selector.raw);
  }
});
module.exports = exports['default'];
},{"postcss-selector-parser":"node_modules/postcss-selector-parser/dist/index.js","../exists":"node_modules/stylehacks/dist/exists.js","../isMixin":"node_modules/stylehacks/dist/isMixin.js","../plugin":"node_modules/stylehacks/dist/plugin.js","../dictionary/browsers":"node_modules/stylehacks/dist/dictionary/browsers.js","../dictionary/identifiers":"node_modules/stylehacks/dist/dictionary/identifiers.js","../dictionary/postcss":"node_modules/stylehacks/dist/dictionary/postcss.js","../dictionary/tags":"node_modules/stylehacks/dist/dictionary/tags.js"}],"node_modules/stylehacks/dist/plugins/htmlFirstChild.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcssSelectorParser = require('postcss-selector-parser');

var _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);

var _exists = require('../exists');

var _exists2 = _interopRequireDefault(_exists);

var _isMixin = require('../isMixin');

var _isMixin2 = _interopRequireDefault(_isMixin);

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

var _tags = require('../dictionary/tags');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function analyse(ctx, rule) {
  return function (selectors) {
    selectors.each(function (selector) {
      if ((0, _exists2.default)(selector, 0, _tags.HTML) && (0, _exists2.default)(selector, 1, ':first-child') && (0, _exists2.default)(selector, 2, ' ') && selector.at(3)) {
        ctx.push(rule, {
          identifier: _identifiers.SELECTOR,
          hack: selector.toString()
        });
      }
    });
  };
}

exports.default = (0, _plugin2.default)([_browsers.OP_9], [_postcss.RULE], function (rule) {
  if ((0, _isMixin2.default)(rule)) {
    return;
  }

  (0, _postcssSelectorParser2.default)(analyse(this, rule)).processSync(rule.selector);
});
module.exports = exports['default'];
},{"postcss-selector-parser":"node_modules/postcss-selector-parser/dist/index.js","../exists":"node_modules/stylehacks/dist/exists.js","../isMixin":"node_modules/stylehacks/dist/isMixin.js","../plugin":"node_modules/stylehacks/dist/plugin.js","../dictionary/browsers":"node_modules/stylehacks/dist/dictionary/browsers.js","../dictionary/identifiers":"node_modules/stylehacks/dist/dictionary/identifiers.js","../dictionary/postcss":"node_modules/stylehacks/dist/dictionary/postcss.js","../dictionary/tags":"node_modules/stylehacks/dist/dictionary/tags.js"}],"node_modules/stylehacks/dist/plugins/important.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _postcss = require('../dictionary/postcss');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = (0, _plugin2.default)([_browsers.IE_5_5, _browsers.IE_6, _browsers.IE_7], [_postcss.DECL], function (decl) {
  var match = decl.value.match(/!\w/);

  if (match) {
    var hack = decl.value.substr(match.index, decl.value.length - 1);
    this.push(decl, {
      identifier: '!important',
      hack: hack
    });
  }
});
module.exports = exports['default'];
},{"../plugin":"node_modules/stylehacks/dist/plugin.js","../dictionary/browsers":"node_modules/stylehacks/dist/dictionary/browsers.js","../dictionary/postcss":"node_modules/stylehacks/dist/dictionary/postcss.js"}],"node_modules/stylehacks/dist/plugins/leadingStar.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var hacks = '!_$_&_*_)_=_%_+_,_._/_`_]_#_~_?_:_|'.split('_');
exports.default = (0, _plugin2.default)([_browsers.IE_5_5, _browsers.IE_6, _browsers.IE_7], [_postcss.ATRULE, _postcss.DECL], function (node) {
  var _this = this;

  if (node.type === _postcss.DECL) {
    // some values are not picked up by before, so ensure they are
    // at the beginning of the value
    hacks.some(function (hack) {
      if (!node.prop.indexOf(hack)) {
        _this.push(node, {
          identifier: _identifiers.PROPERTY,
          hack: node.prop
        });

        return true;
      }
    });
    var before = node.raws.before;

    if (!before) {
      return;
    }

    hacks.some(function (hack) {
      if (~before.indexOf(hack)) {
        _this.push(node, {
          identifier: _identifiers.PROPERTY,
          hack: "".concat(before.trim()).concat(node.prop)
        });

        return true;
      }
    });
  } else {
    // test for the @property: value; hack
    var name = node.name;
    var len = name.length - 1;

    if (name.lastIndexOf(':') === len) {
      this.push(node, {
        identifier: _identifiers.PROPERTY,
        hack: "@".concat(name.substr(0, len))
      });
    }
  }
});
module.exports = exports['default'];
},{"../plugin":"node_modules/stylehacks/dist/plugin.js","../dictionary/browsers":"node_modules/stylehacks/dist/dictionary/browsers.js","../dictionary/identifiers":"node_modules/stylehacks/dist/dictionary/identifiers.js","../dictionary/postcss":"node_modules/stylehacks/dist/dictionary/postcss.js"}],"node_modules/stylehacks/dist/plugins/leadingUnderscore.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss3 = require('../dictionary/postcss');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = (0, _plugin2.default)([_browsers.IE_6], [_postcss3.DECL], function (decl) {
  var before = decl.raws.before;

  if (before && ~before.indexOf('_')) {
    this.push(decl, {
      identifier: _identifiers.PROPERTY,
      hack: "".concat(before.trim()).concat(decl.prop)
    });
  }

  if (decl.prop[0] === '-' && decl.prop[1] !== '-' && _postcss2.default.vendor.prefix(decl.prop) === '') {
    this.push(decl, {
      identifier: _identifiers.PROPERTY,
      hack: decl.prop
    });
  }
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","../plugin":"node_modules/stylehacks/dist/plugin.js","../dictionary/browsers":"node_modules/stylehacks/dist/dictionary/browsers.js","../dictionary/identifiers":"node_modules/stylehacks/dist/dictionary/identifiers.js","../dictionary/postcss":"node_modules/stylehacks/dist/dictionary/postcss.js"}],"node_modules/stylehacks/dist/plugins/mediaSlash0.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = (0, _plugin2.default)([_browsers.IE_8], [_postcss.ATRULE], function (rule) {
  var params = rule.params.trim();

  if (params.toLowerCase() === '\\0screen') {
    this.push(rule, {
      identifier: _identifiers.MEDIA_QUERY,
      hack: params
    });
  }
});
module.exports = exports['default'];
},{"../plugin":"node_modules/stylehacks/dist/plugin.js","../dictionary/browsers":"node_modules/stylehacks/dist/dictionary/browsers.js","../dictionary/identifiers":"node_modules/stylehacks/dist/dictionary/identifiers.js","../dictionary/postcss":"node_modules/stylehacks/dist/dictionary/postcss.js"}],"node_modules/stylehacks/dist/plugins/mediaSlash0Slash9.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = (0, _plugin2.default)([_browsers.IE_5_5, _browsers.IE_6, _browsers.IE_7, _browsers.IE_8], [_postcss.ATRULE], function (rule) {
  var params = rule.params.trim();

  if (params.toLowerCase() === '\\0screen\\,screen\\9') {
    this.push(rule, {
      identifier: _identifiers.MEDIA_QUERY,
      hack: params
    });
  }
});
module.exports = exports['default'];
},{"../plugin":"node_modules/stylehacks/dist/plugin.js","../dictionary/browsers":"node_modules/stylehacks/dist/dictionary/browsers.js","../dictionary/identifiers":"node_modules/stylehacks/dist/dictionary/identifiers.js","../dictionary/postcss":"node_modules/stylehacks/dist/dictionary/postcss.js"}],"node_modules/stylehacks/dist/plugins/mediaSlash9.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = (0, _plugin2.default)([_browsers.IE_5_5, _browsers.IE_6, _browsers.IE_7], [_postcss.ATRULE], function (rule) {
  var params = rule.params.trim();

  if (params.toLowerCase() === 'screen\\9') {
    this.push(rule, {
      identifier: _identifiers.MEDIA_QUERY,
      hack: params
    });
  }
});
module.exports = exports['default'];
},{"../plugin":"node_modules/stylehacks/dist/plugin.js","../dictionary/browsers":"node_modules/stylehacks/dist/dictionary/browsers.js","../dictionary/identifiers":"node_modules/stylehacks/dist/dictionary/identifiers.js","../dictionary/postcss":"node_modules/stylehacks/dist/dictionary/postcss.js"}],"node_modules/stylehacks/dist/plugins/slash9.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = (0, _plugin2.default)([_browsers.IE_6, _browsers.IE_7, _browsers.IE_8], [_postcss.DECL], function (decl) {
  var v = decl.value;

  if (v && v.length > 2 && v.indexOf('\\9') === v.length - 2) {
    this.push(decl, {
      identifier: _identifiers.VALUE,
      hack: v
    });
  }
});
module.exports = exports['default'];
},{"../plugin":"node_modules/stylehacks/dist/plugin.js","../dictionary/browsers":"node_modules/stylehacks/dist/dictionary/browsers.js","../dictionary/identifiers":"node_modules/stylehacks/dist/dictionary/identifiers.js","../dictionary/postcss":"node_modules/stylehacks/dist/dictionary/postcss.js"}],"node_modules/stylehacks/dist/plugins/starHtml.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcssSelectorParser = require('postcss-selector-parser');

var _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);

var _exists = require('../exists');

var _exists2 = _interopRequireDefault(_exists);

var _isMixin = require('../isMixin');

var _isMixin2 = _interopRequireDefault(_isMixin);

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

var _tags = require('../dictionary/tags');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function analyse(ctx, rule) {
  return function (selectors) {
    selectors.each(function (selector) {
      if ((0, _exists2.default)(selector, 0, '*') && (0, _exists2.default)(selector, 1, ' ') && (0, _exists2.default)(selector, 2, _tags.HTML) && (0, _exists2.default)(selector, 3, ' ') && selector.at(4)) {
        ctx.push(rule, {
          identifier: _identifiers.SELECTOR,
          hack: selector.toString()
        });
      }
    });
  };
}

exports.default = (0, _plugin2.default)([_browsers.IE_5_5, _browsers.IE_6], [_postcss.RULE], function (rule) {
  if ((0, _isMixin2.default)(rule)) {
    return;
  }

  (0, _postcssSelectorParser2.default)(analyse(this, rule)).processSync(rule.selector);
});
module.exports = exports['default'];
},{"postcss-selector-parser":"node_modules/postcss-selector-parser/dist/index.js","../exists":"node_modules/stylehacks/dist/exists.js","../isMixin":"node_modules/stylehacks/dist/isMixin.js","../plugin":"node_modules/stylehacks/dist/plugin.js","../dictionary/browsers":"node_modules/stylehacks/dist/dictionary/browsers.js","../dictionary/identifiers":"node_modules/stylehacks/dist/dictionary/identifiers.js","../dictionary/postcss":"node_modules/stylehacks/dist/dictionary/postcss.js","../dictionary/tags":"node_modules/stylehacks/dist/dictionary/tags.js"}],"node_modules/stylehacks/dist/plugins/trailingSlashComma.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _plugin = require('../plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _isMixin = require('../isMixin');

var _isMixin2 = _interopRequireDefault(_isMixin);

var _browsers = require('../dictionary/browsers');

var _identifiers = require('../dictionary/identifiers');

var _postcss = require('../dictionary/postcss');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = (0, _plugin2.default)([_browsers.IE_5_5, _browsers.IE_6, _browsers.IE_7], [_postcss.RULE], function (rule) {
  if ((0, _isMixin2.default)(rule)) {
    return;
  }

  var selector = rule.selector;
  var trim = selector.trim();

  if (trim.lastIndexOf(',') === selector.length - 1 || trim.lastIndexOf('\\') === selector.length - 1) {
    this.push(rule, {
      identifier: _identifiers.SELECTOR,
      hack: selector
    });
  }
});
module.exports = exports['default'];
},{"../plugin":"node_modules/stylehacks/dist/plugin.js","../isMixin":"node_modules/stylehacks/dist/isMixin.js","../dictionary/browsers":"node_modules/stylehacks/dist/dictionary/browsers.js","../dictionary/identifiers":"node_modules/stylehacks/dist/dictionary/identifiers.js","../dictionary/postcss":"node_modules/stylehacks/dist/dictionary/postcss.js"}],"node_modules/stylehacks/dist/plugins/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bodyEmpty = require('./bodyEmpty');

var _bodyEmpty2 = _interopRequireDefault(_bodyEmpty);

var _htmlCombinatorCommentBody = require('./htmlCombinatorCommentBody');

var _htmlCombinatorCommentBody2 = _interopRequireDefault(_htmlCombinatorCommentBody);

var _htmlFirstChild = require('./htmlFirstChild');

var _htmlFirstChild2 = _interopRequireDefault(_htmlFirstChild);

var _important = require('./important');

var _important2 = _interopRequireDefault(_important);

var _leadingStar = require('./leadingStar');

var _leadingStar2 = _interopRequireDefault(_leadingStar);

var _leadingUnderscore = require('./leadingUnderscore');

var _leadingUnderscore2 = _interopRequireDefault(_leadingUnderscore);

var _mediaSlash = require('./mediaSlash0');

var _mediaSlash2 = _interopRequireDefault(_mediaSlash);

var _mediaSlash0Slash = require('./mediaSlash0Slash9');

var _mediaSlash0Slash2 = _interopRequireDefault(_mediaSlash0Slash);

var _mediaSlash3 = require('./mediaSlash9');

var _mediaSlash4 = _interopRequireDefault(_mediaSlash3);

var _slash = require('./slash9');

var _slash2 = _interopRequireDefault(_slash);

var _starHtml = require('./starHtml');

var _starHtml2 = _interopRequireDefault(_starHtml);

var _trailingSlashComma = require('./trailingSlashComma');

var _trailingSlashComma2 = _interopRequireDefault(_trailingSlashComma);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = [_bodyEmpty2.default, _htmlCombinatorCommentBody2.default, _htmlFirstChild2.default, _important2.default, _leadingStar2.default, _leadingUnderscore2.default, _mediaSlash2.default, _mediaSlash0Slash2.default, _mediaSlash4.default, _slash2.default, _starHtml2.default, _trailingSlashComma2.default];
module.exports = exports['default'];
},{"./bodyEmpty":"node_modules/stylehacks/dist/plugins/bodyEmpty.js","./htmlCombinatorCommentBody":"node_modules/stylehacks/dist/plugins/htmlCombinatorCommentBody.js","./htmlFirstChild":"node_modules/stylehacks/dist/plugins/htmlFirstChild.js","./important":"node_modules/stylehacks/dist/plugins/important.js","./leadingStar":"node_modules/stylehacks/dist/plugins/leadingStar.js","./leadingUnderscore":"node_modules/stylehacks/dist/plugins/leadingUnderscore.js","./mediaSlash0":"node_modules/stylehacks/dist/plugins/mediaSlash0.js","./mediaSlash0Slash9":"node_modules/stylehacks/dist/plugins/mediaSlash0Slash9.js","./mediaSlash9":"node_modules/stylehacks/dist/plugins/mediaSlash9.js","./slash9":"node_modules/stylehacks/dist/plugins/slash9.js","./starHtml":"node_modules/stylehacks/dist/plugins/starHtml.js","./trailingSlashComma":"node_modules/stylehacks/dist/plugins/trailingSlashComma.js"}],"node_modules/stylehacks/dist/index.js":[function(require,module,exports) {
var __dirname = "/home/royyan/csspurge/node_modules/stylehacks/dist";
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _browserslist = require('browserslist');

var _browserslist2 = _interopRequireDefault(_browserslist);

var _plugins = require('./plugins');

var _plugins2 = _interopRequireDefault(_plugins);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var stylehacks = _postcss2.default.plugin('stylehacks', function () {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (css, result) {
    var resultOpts = result.opts || {};
    var browsers = (0, _browserslist2.default)(null, {
      stats: resultOpts.stats,
      path: __dirname,
      env: resultOpts.env
    });

    var processors = _plugins2.default.reduce(function (list, Plugin) {
      var hack = new Plugin(result);
      var applied = browsers.some(function (browser) {
        return hack.targets.some(function (target) {
          return browser === target;
        });
      });

      if (applied) {
        return list;
      }

      return [].concat(_toConsumableArray(list), [hack]);
    }, []);

    css.walk(function (node) {
      processors.forEach(function (proc) {
        if (!~proc.nodeTypes.indexOf(node.type)) {
          return;
        }

        if (opts.lint) {
          return proc.detectAndWarn(node);
        }

        return proc.detectAndResolve(node);
      });
    });
  };
});

stylehacks.detect = function (node) {
  return _plugins2.default.some(function (Plugin) {
    var hack = new Plugin();
    return hack.any(node);
  });
};

exports.default = stylehacks;
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","browserslist":"node_modules/browserslist/index.js","./plugins":"node_modules/stylehacks/dist/plugins/index.js"}],"node_modules/postcss-merge-longhand/dist/lib/insertCloned.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = insertCloned;

function insertCloned(rule, decl, props) {
  var newNode = Object.assign(decl.clone(), props);
  rule.insertAfter(decl, newNode);
  return newNode;
}

;
module.exports = exports["default"];
},{}],"node_modules/postcss-merge-longhand/dist/lib/parseTrbl.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

exports.default = function (v) {
  var s = typeof v === 'string' ? _postcss.list.space(v) : v;
  return [s[0], // top
  s[1] || s[0], // right
  s[2] || s[0], // bottom
  s[3] || s[1] || s[0]];
};

module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js"}],"node_modules/postcss-merge-longhand/dist/lib/hasAllProps.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (rule) {
  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    props[_key - 1] = arguments[_key];
  }

  return props.every(function (p) {
    return rule.some(function (_ref) {
      var prop = _ref.prop;
      return prop && ~prop.toLowerCase().indexOf(p);
    });
  });
};

module.exports = exports["default"];
},{}],"node_modules/postcss-merge-longhand/dist/lib/getDecls.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getDecls;

function getDecls(rule, properties) {
  return rule.nodes.filter(function (_ref) {
    var prop = _ref.prop;
    return prop && ~properties.indexOf(prop.toLowerCase());
  });
}

module.exports = exports["default"];
},{}],"node_modules/postcss-merge-longhand/dist/lib/getLastNode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (rule, prop) {
  return rule.filter(function (n) {
    return n.prop && n.prop.toLowerCase() === prop;
  }).pop();
};

module.exports = exports["default"];
},{}],"node_modules/postcss-merge-longhand/dist/lib/getRules.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getRules;

var _getLastNode = require("./getLastNode");

var _getLastNode2 = _interopRequireDefault(_getLastNode);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function getRules(props, properties) {
  return properties.map(function (property) {
    return (0, _getLastNode2.default)(props, property);
  }).filter(Boolean);
}

module.exports = exports["default"];
},{"./getLastNode":"node_modules/postcss-merge-longhand/dist/lib/getLastNode.js"}],"node_modules/postcss-merge-longhand/dist/lib/getValue.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getValue;

function getValue(_ref) {
  var value = _ref.value;
  return value;
}

module.exports = exports["default"];
},{}],"node_modules/postcss-merge-longhand/dist/lib/mergeRules.js":[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mergeRules;

var _hasAllProps = require('./hasAllProps');

var _hasAllProps2 = _interopRequireDefault(_hasAllProps);

var _getDecls = require('./getDecls');

var _getDecls2 = _interopRequireDefault(_getDecls);

var _getRules = require('./getRules');

var _getRules2 = _interopRequireDefault(_getRules);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function isConflictingProp(propA, propB) {
  if (!propB.prop || propB.important !== propA.important) {
    return;
  }

  var parts = propA.prop.split('-');
  return parts.some(function () {
    parts.pop();
    return parts.join('-') === propB.prop;
  });
}

function hasConflicts(match, nodes) {
  var firstNode = Math.min.apply(null, match.map(function (n) {
    return nodes.indexOf(n);
  }));
  var lastNode = Math.max.apply(null, match.map(function (n) {
    return nodes.indexOf(n);
  }));
  var between = nodes.slice(firstNode + 1, lastNode);
  return match.some(function (a) {
    return between.some(function (b) {
      return isConflictingProp(a, b);
    });
  });
}

function mergeRules(rule, properties, callback) {
  var decls = (0, _getDecls2.default)(rule, properties);

  var _loop = function _loop() {
    var last = decls[decls.length - 1];
    var props = decls.filter(function (node) {
      return node.important === last.important;
    });
    var rules = (0, _getRules2.default)(props, properties);

    if ((0, _hasAllProps2.default).apply(void 0, [rules].concat(_toConsumableArray(properties))) && !hasConflicts(rules, rule.nodes)) {
      if (callback(rules, last, props)) {
        decls = decls.filter(function (node) {
          return !~rules.indexOf(node);
        });
      }
    }

    decls = decls.filter(function (node) {
      return node !== last;
    });
  };

  while (decls.length) {
    _loop();
  }
}

module.exports = exports['default'];
},{"./hasAllProps":"node_modules/postcss-merge-longhand/dist/lib/hasAllProps.js","./getDecls":"node_modules/postcss-merge-longhand/dist/lib/getDecls.js","./getRules":"node_modules/postcss-merge-longhand/dist/lib/getRules.js"}],"node_modules/postcss-merge-longhand/dist/lib/minifyTrbl.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parseTrbl = require('./parseTrbl');

var _parseTrbl2 = _interopRequireDefault(_parseTrbl);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = function (v) {
  var value = (0, _parseTrbl2.default)(v);

  if (value[3] === value[1]) {
    value.pop();

    if (value[2] === value[0]) {
      value.pop();

      if (value[0] === value[1]) {
        value.pop();
      }
    }
  }

  return value.join(' ');
};

module.exports = exports['default'];
},{"./parseTrbl":"node_modules/postcss-merge-longhand/dist/lib/parseTrbl.js"}],"node_modules/postcss-merge-longhand/dist/lib/validateWsc.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isStyle = isStyle;
exports.isWidth = isWidth;
exports.isColor = isColor;
exports.isValidWsc = isValidWsc;

var _cssColorNames = require("css-color-names");

var _cssColorNames2 = _interopRequireDefault(_cssColorNames);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var widths = ["thin", "medium", "thick"];
var styles = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"];
var colors = Object.keys(_cssColorNames2.default);

function isStyle(value) {
  return value && !!~styles.indexOf(value.toLowerCase());
}

function isWidth(value) {
  return value && !!~widths.indexOf(value.toLowerCase()) || /^(\d+(\.\d+)?|\.\d+)(\w+)?$/.test(value);
}

function isColor(value) {
  if (!value) {
    return false;
  }

  value = value.toLowerCase();

  if (/rgba?\(/.test(value)) {
    return true;
  }

  if (/hsla?\(/.test(value)) {
    return true;
  }

  if (/#([0-9a-z]{6}|[0-9a-z]{3})/.test(value)) {
    return true;
  }

  if (value === "transparent") {
    return true;
  }

  if (value === "currentcolor") {
    return true;
  }

  return !!~colors.indexOf(value);
}

function isValidWsc(wscs) {
  var validWidth = isWidth(wscs[0]);
  var validStyle = isStyle(wscs[1]);
  var validColor = isColor(wscs[2]);
  return validWidth && validStyle || validWidth && validColor || validStyle && validColor;
}
},{"css-color-names":"node_modules/css-color-names/css-color-names.json"}],"node_modules/postcss-merge-longhand/dist/lib/parseWsc.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseWsc;

var _postcss = require('postcss');

var _validateWsc = require('./validateWsc');

var none = /^\s*(none|medium)(\s+none(\s+(none|currentcolor))?)?\s*$/i;
var varRE = /(^.*var)(.*\(.*--.*\))(.*)/i;

var varPreserveCase = function varPreserveCase(p) {
  return "".concat(p[1].toLowerCase()).concat(p[2]).concat(p[3].toLowerCase());
};

var toLower = function toLower(v) {
  var match = varRE.exec(v);
  return match ? varPreserveCase(match) : v.toLowerCase();
};

function parseWsc(value) {
  if (none.test(value)) {
    return ['medium', 'none', 'currentcolor'];
  }

  var width, style, color;

  var values = _postcss.list.space(value);

  if (values.length > 1 && (0, _validateWsc.isStyle)(values[1]) && values[0].toLowerCase() === 'none') {
    values.unshift();
    width = '0';
  }

  var unknown = [];
  values.forEach(function (v) {
    if ((0, _validateWsc.isStyle)(v)) {
      style = toLower(v);
    } else if ((0, _validateWsc.isWidth)(v)) {
      width = toLower(v);
    } else if ((0, _validateWsc.isColor)(v)) {
      color = toLower(v);
    } else {
      unknown.push(v);
    }
  });

  if (unknown.length) {
    if (!width && style && color) {
      width = unknown.pop();
    }

    if (width && !style && color) {
      style = unknown.pop();
    }

    if (width && style && !color) {
      color = unknown.pop();
    }
  }

  return [width, style, color];
}

module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","./validateWsc":"node_modules/postcss-merge-longhand/dist/lib/validateWsc.js"}],"node_modules/postcss-merge-longhand/dist/lib/minifyWsc.js":[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parseWsc = require('./parseWsc');

var _parseWsc2 = _interopRequireDefault(_parseWsc);

var _minifyTrbl = require('./minifyTrbl');

var _minifyTrbl2 = _interopRequireDefault(_minifyTrbl);

var _validateWsc = require('./validateWsc');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var defaults = ['medium', 'none', 'currentcolor'];

exports.default = function (v) {
  var values = (0, _parseWsc2.default)(v);

  if (!(0, _validateWsc.isValidWsc)(values)) {
    return (0, _minifyTrbl2.default)(v);
  }

  var value = [].concat(_toConsumableArray(values), ['']).reduceRight(function (prev, cur, i, arr) {
    if (cur === undefined || cur.toLowerCase() === defaults[i] && (!i || (arr[i - 1] || '').toLowerCase() !== cur.toLowerCase())) {
      return prev;
    }

    return cur + ' ' + prev;
  }).trim();
  return (0, _minifyTrbl2.default)(value || 'none');
};

module.exports = exports['default'];
},{"./parseWsc":"node_modules/postcss-merge-longhand/dist/lib/parseWsc.js","./minifyTrbl":"node_modules/postcss-merge-longhand/dist/lib/minifyTrbl.js","./validateWsc":"node_modules/postcss-merge-longhand/dist/lib/validateWsc.js"}],"node_modules/postcss-merge-longhand/dist/lib/isCustomProp.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node) {
  return ~node.value.search(/var\s*\(\s*--/i);
};

module.exports = exports["default"];
},{}],"node_modules/postcss-merge-longhand/dist/lib/canMerge.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isCustomProp = require('./isCustomProp');

var _isCustomProp2 = _interopRequireDefault(_isCustomProp);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var important = function important(node) {
  return node.important;
};

var unimportant = function unimportant(node) {
  return !node.important;
};

var hasInherit = function hasInherit(node) {
  return node.value.toLowerCase() === 'inherit';
};

var hasInitial = function hasInitial(node) {
  return node.value.toLowerCase() === 'initial';
};

var hasUnset = function hasUnset(node) {
  return node.value.toLowerCase() === 'unset';
};

exports.default = function (props) {
  var includeCustomProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (props.some(hasInherit) && !props.every(hasInherit)) {
    return false;
  }

  if (props.some(hasInitial) && !props.every(hasInitial)) {
    return false;
  }

  if (props.some(hasUnset) && !props.every(hasUnset)) {
    return false;
  }

  if (includeCustomProps && props.some(_isCustomProp2.default) && !props.every(_isCustomProp2.default)) {
    return false;
  }

  return props.every(unimportant) || props.every(important);
};

module.exports = exports['default'];
},{"./isCustomProp":"node_modules/postcss-merge-longhand/dist/lib/isCustomProp.js"}],"node_modules/postcss-merge-longhand/dist/lib/remove.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = remove;

function remove(node) {
  return node.remove();
}

module.exports = exports["default"];
},{}],"node_modules/postcss-merge-longhand/dist/lib/trbl.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ['top', 'right', 'bottom', 'left'];
module.exports = exports['default'];
},{}],"node_modules/postcss-merge-longhand/dist/lib/canExplode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isCustomProp = require("./isCustomProp");

var _isCustomProp2 = _interopRequireDefault(_isCustomProp);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var hasInherit = function hasInherit(node) {
  return node.value.toLowerCase().includes("inherit");
};

var hasInitial = function hasInitial(node) {
  return node.value.toLowerCase().includes("initial");
};

var hasUnset = function hasUnset(node) {
  return node.value.toLowerCase().includes("unset");
};

exports.default = function (prop) {
  var includeCustomProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (includeCustomProps && (0, _isCustomProp2.default)(prop)) {
    return false;
  }

  return !hasInherit(prop) && !hasInitial(prop) && !hasUnset(prop);
};

module.exports = exports["default"];
},{"./isCustomProp":"node_modules/postcss-merge-longhand/dist/lib/isCustomProp.js"}],"node_modules/postcss-merge-longhand/dist/lib/decl/borders.js":[function(require,module,exports) {
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _stylehacks = require('stylehacks');

var _insertCloned = require('../insertCloned');

var _insertCloned2 = _interopRequireDefault(_insertCloned);

var _parseTrbl = require('../parseTrbl');

var _parseTrbl2 = _interopRequireDefault(_parseTrbl);

var _hasAllProps = require('../hasAllProps');

var _hasAllProps2 = _interopRequireDefault(_hasAllProps);

var _getDecls = require('../getDecls');

var _getDecls2 = _interopRequireDefault(_getDecls);

var _getRules = require('../getRules');

var _getRules2 = _interopRequireDefault(_getRules);

var _getValue = require('../getValue');

var _getValue2 = _interopRequireDefault(_getValue);

var _mergeRules = require('../mergeRules');

var _mergeRules2 = _interopRequireDefault(_mergeRules);

var _minifyTrbl = require('../minifyTrbl');

var _minifyTrbl2 = _interopRequireDefault(_minifyTrbl);

var _minifyWsc = require('../minifyWsc');

var _minifyWsc2 = _interopRequireDefault(_minifyWsc);

var _canMerge = require('../canMerge');

var _canMerge2 = _interopRequireDefault(_canMerge);

var _remove = require('../remove');

var _remove2 = _interopRequireDefault(_remove);

var _trbl = require('../trbl');

var _trbl2 = _interopRequireDefault(_trbl);

var _isCustomProp = require('../isCustomProp');

var _isCustomProp2 = _interopRequireDefault(_isCustomProp);

var _canExplode = require('../canExplode');

var _canExplode2 = _interopRequireDefault(_canExplode);

var _getLastNode = require('../getLastNode');

var _getLastNode2 = _interopRequireDefault(_getLastNode);

var _parseWsc = require('../parseWsc');

var _parseWsc2 = _interopRequireDefault(_parseWsc);

var _validateWsc = require('../validateWsc');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var wsc = ['width', 'style', 'color'];
var defaults = ['medium', 'none', 'currentcolor'];

function borderProperty() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }

  return "border-".concat(parts.join('-'));
}

function mapBorderProperty(value) {
  return borderProperty(value);
}

var directions = _trbl2.default.map(mapBorderProperty);

var properties = wsc.map(mapBorderProperty);
var directionalProperties = directions.reduce(function (prev, curr) {
  return prev.concat(wsc.map(function (prop) {
    return "".concat(curr, "-").concat(prop);
  }));
}, []);
var precedence = [['border'], directions.concat(properties), directionalProperties];
var allProperties = precedence.reduce(function (a, b) {
  return a.concat(b);
});

function getLevel(prop) {
  for (var i = 0; i < precedence.length; i++) {
    if (!!~precedence[i].indexOf(prop.toLowerCase())) {
      return i;
    }
  }
}

var isValueCustomProp = function isValueCustomProp(value) {
  return value && !!~value.search(/var\s*\(\s*--/i);
};

function canMergeValues(values) {
  return !values.some(isValueCustomProp) || values.every(isValueCustomProp);
}

function getColorValue(decl) {
  if (decl.prop.substr(-5) === 'color') {
    return decl.value;
  }

  return (0, _parseWsc2.default)(decl.value)[2] || defaults[2];
}

function diffingProps(values, nextValues) {
  return wsc.reduce(function (prev, curr, i) {
    if (values[i] === nextValues[i]) {
      return prev;
    }

    return [].concat(_toConsumableArray(prev), [curr]);
  }, []);
}

function mergeRedundant(_ref) {
  var values = _ref.values,
      nextValues = _ref.nextValues,
      decl = _ref.decl,
      nextDecl = _ref.nextDecl,
      index = _ref.index;

  if (!(0, _canMerge2.default)([decl, nextDecl])) {
    return;
  }

  if ((0, _stylehacks.detect)(decl) || (0, _stylehacks.detect)(nextDecl)) {
    return;
  }

  var diff = diffingProps(values, nextValues);

  if (diff.length > 1) {
    return;
  }

  var prop = diff.pop();
  var position = wsc.indexOf(prop);
  var prop1 = "".concat(nextDecl.prop, "-").concat(prop);
  var prop2 = "border-".concat(prop);
  var props = (0, _parseTrbl2.default)(values[position]);
  props[index] = nextValues[position];
  var borderValue2 = values.filter(function (e, i) {
    return i !== position;
  }).join(' ');
  var propValue2 = (0, _minifyTrbl2.default)(props);
  var origLength = ((0, _minifyWsc2.default)(decl.value) + nextDecl.prop + nextDecl.value).length;
  var newLength1 = decl.value.length + prop1.length + (0, _minifyWsc2.default)(nextValues[position]).length;
  var newLength2 = borderValue2.length + prop2.length + propValue2.length;

  if (newLength1 < newLength2 && newLength1 < origLength) {
    nextDecl.prop = prop1;
    nextDecl.value = nextValues[position];
  }

  if (newLength2 < newLength1 && newLength2 < origLength) {
    decl.value = borderValue2;
    nextDecl.prop = prop2;
    nextDecl.value = propValue2;
  }
}

function isCloseEnough(mapped) {
  return mapped[0] === mapped[1] && mapped[1] === mapped[2] || mapped[1] === mapped[2] && mapped[2] === mapped[3] || mapped[2] === mapped[3] && mapped[3] === mapped[0] || mapped[3] === mapped[0] && mapped[0] === mapped[1];
}

function getDistinctShorthands(mapped) {
  return mapped.reduce(function (a, b) {
    a = Array.isArray(a) ? a : [a];

    if (!~a.indexOf(b)) {
      a.push(b);
    }

    return a;
  });
}

function explode(rule) {
  rule.walkDecls(/^border/i, function (decl) {
    if (!(0, _canExplode2.default)(decl, false)) {
      return;
    }

    if ((0, _stylehacks.detect)(decl)) {
      return;
    }

    var prop = decl.prop.toLowerCase(); // border -> border-trbl

    if (prop === 'border') {
      if ((0, _validateWsc.isValidWsc)((0, _parseWsc2.default)(decl.value))) {
        directions.forEach(function (direction) {
          (0, _insertCloned2.default)(decl.parent, decl, {
            prop: direction
          });
        });
        return decl.remove();
      }
    } // border-trbl -> border-trbl-wsc


    if (directions.some(function (direction) {
      return prop === direction;
    })) {
      var values = (0, _parseWsc2.default)(decl.value);

      if ((0, _validateWsc.isValidWsc)(values)) {
        wsc.forEach(function (d, i) {
          (0, _insertCloned2.default)(decl.parent, decl, {
            prop: "".concat(prop, "-").concat(d),
            value: values[i] || defaults[i]
          });
        });
        return decl.remove();
      }
    } // border-wsc -> border-trbl-wsc


    wsc.some(function (style) {
      if (prop !== borderProperty(style)) {
        return false;
      }

      (0, _parseTrbl2.default)(decl.value).forEach(function (value, i) {
        (0, _insertCloned2.default)(decl.parent, decl, {
          prop: borderProperty(_trbl2.default[i], style),
          value: value
        });
      });
      return decl.remove();
    });
  });
}

function merge(rule) {
  // border-trbl-wsc -> border-trbl
  _trbl2.default.forEach(function (direction) {
    var prop = borderProperty(direction);
    (0, _mergeRules2.default)(rule, wsc.map(function (style) {
      return borderProperty(direction, style);
    }), function (rules, lastNode) {
      if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {
        (0, _insertCloned2.default)(lastNode.parent, lastNode, {
          prop: prop,
          value: rules.map(_getValue2.default).join(' ')
        });
        rules.forEach(_remove2.default);
        return true;
      }
    });
  }); // border-trbl-wsc -> border-wsc


  wsc.forEach(function (style) {
    var prop = borderProperty(style);
    (0, _mergeRules2.default)(rule, _trbl2.default.map(function (direction) {
      return borderProperty(direction, style);
    }), function (rules, lastNode) {
      if ((0, _canMerge2.default)(rules) && !rules.some(_stylehacks.detect)) {
        (0, _insertCloned2.default)(lastNode.parent, lastNode, {
          prop: prop,
          value: (0, _minifyTrbl2.default)(rules.map(_getValue2.default).join(' '))
        });
        rules.forEach(_remove2.default);
        return true;
      }
    });
  }); // border-trbl -> border-wsc

  (0, _mergeRules2.default)(rule, directions, function (rules, lastNode) {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    var values = rules.map(function (_ref2) {
      var value = _ref2.value;
      return value;
    });

    if (!canMergeValues(values)) {
      return;
    }

    var parsed = values.map(function (value) {
      return (0, _parseWsc2.default)(value);
    });

    if (!parsed.every(_validateWsc.isValidWsc)) {
      return;
    }

    wsc.forEach(function (d, i) {
      var value = parsed.map(function (v) {
        return v[i] || defaults[i];
      });

      if (canMergeValues(value)) {
        (0, _insertCloned2.default)(lastNode.parent, lastNode, {
          prop: borderProperty(d),
          value: (0, _minifyTrbl2.default)(value)
        });
      } else {
        (0, _insertCloned2.default)(lastNode.parent, lastNode);
      }
    });
    rules.forEach(_remove2.default);
    return true;
  }); // border-wsc -> border
  // border-wsc -> border + border-color
  // border-wsc -> border + border-dir

  (0, _mergeRules2.default)(rule, properties, function (rules, lastNode) {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    var values = rules.map(function (node) {
      return (0, _parseTrbl2.default)(node.value);
    });
    var mapped = [0, 1, 2, 3].map(function (i) {
      return [values[0][i], values[1][i], values[2][i]].join(' ');
    });

    if (!canMergeValues(mapped)) {
      return;
    }

    var _rules = _slicedToArray(rules, 3),
        width = _rules[0],
        style = _rules[1],
        color = _rules[2];

    var reduced = getDistinctShorthands(mapped);

    if (isCloseEnough(mapped) && (0, _canMerge2.default)(rules, false)) {
      var first = mapped.indexOf(reduced[0]) !== mapped.lastIndexOf(reduced[0]);
      var border = (0, _insertCloned2.default)(lastNode.parent, lastNode, {
        prop: 'border',
        value: first ? reduced[0] : reduced[1]
      });

      if (reduced[1]) {
        var value = first ? reduced[1] : reduced[0];
        var prop = borderProperty(_trbl2.default[mapped.indexOf(value)]);
        rule.insertAfter(border, Object.assign(lastNode.clone(), {
          prop: prop,
          value: value
        }));
      }

      rules.forEach(_remove2.default);
      return true;
    } else if (reduced.length === 1) {
      rule.insertBefore(color, Object.assign(lastNode.clone(), {
        prop: 'border',
        value: [width, style].map(_getValue2.default).join(' ')
      }));
      rules.filter(function (node) {
        return node.prop.toLowerCase() !== properties[2];
      }).forEach(_remove2.default);
      return true;
    }
  }); // border-wsc -> border + border-trbl

  (0, _mergeRules2.default)(rule, properties, function (rules, lastNode) {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    var values = rules.map(function (node) {
      return (0, _parseTrbl2.default)(node.value);
    });
    var mapped = [0, 1, 2, 3].map(function (i) {
      return [values[0][i], values[1][i], values[2][i]].join(' ');
    });
    var reduced = getDistinctShorthands(mapped);
    var none = 'medium none currentcolor';

    if (reduced.length > 1 && reduced.length < 4 && reduced.includes(none)) {
      var filtered = mapped.filter(function (p) {
        return p !== none;
      });
      var mostCommon = reduced.sort(function (a, b) {
        return mapped.filter(function (v) {
          return v === b;
        }).length - mapped.filter(function (v) {
          return v === a;
        }).length;
      })[0];
      var borderValue = reduced.length === 2 ? filtered[0] : mostCommon;
      rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
        prop: 'border',
        value: borderValue
      }));
      directions.forEach(function (dir, i) {
        if (mapped[i] !== borderValue) {
          rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
            prop: dir,
            value: mapped[i]
          }));
        }
      });
      rules.forEach(_remove2.default);
      return true;
    }
  }); // border-trbl -> border
  // border-trbl -> border + border-trbl

  (0, _mergeRules2.default)(rule, directions, function (rules, lastNode) {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    var values = rules.map(function (node) {
      var wscValue = (0, _parseWsc2.default)(node.value);

      if (!(0, _validateWsc.isValidWsc)(wscValue)) {
        return node.value;
      }

      return wscValue.map(function (value, i) {
        return value || defaults[i];
      }).join(' ');
    });
    var reduced = getDistinctShorthands(values);

    if (isCloseEnough(values)) {
      var first = values.indexOf(reduced[0]) !== values.lastIndexOf(reduced[0]);
      rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
        prop: 'border',
        value: (0, _minifyWsc2.default)(first ? values[0] : values[1])
      }));

      if (reduced[1]) {
        var value = first ? reduced[1] : reduced[0];
        var prop = directions[values.indexOf(value)];
        rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
          prop: prop,
          value: (0, _minifyWsc2.default)(value)
        }));
      }

      rules.forEach(_remove2.default);
      return true;
    }
  }); // border-trbl-wsc + border-trbl (custom prop) -> border-trbl + border-trbl-wsc (custom prop)

  directions.forEach(function (direction) {
    wsc.forEach(function (style, i) {
      var prop = "".concat(direction, "-").concat(style);
      (0, _mergeRules2.default)(rule, [direction, prop], function (rules, lastNode) {
        if (lastNode.prop !== direction) {
          return;
        }

        var values = (0, _parseWsc2.default)(lastNode.value);

        if (!(0, _validateWsc.isValidWsc)(values)) {
          return;
        }

        var wscProp = rules.filter(function (r) {
          return r !== lastNode;
        })[0];

        if (!isValueCustomProp(values[i]) || (0, _isCustomProp2.default)(wscProp)) {
          return;
        }

        var wscValue = values[i];
        values[i] = wscProp.value;

        if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {
          (0, _insertCloned2.default)(lastNode.parent, lastNode, {
            prop: prop,
            value: wscValue
          });
          lastNode.value = (0, _minifyWsc2.default)(values);
          wscProp.remove();
          return true;
        }
      });
    });
  }); // border-wsc + border (custom prop) -> border + border-wsc (custom prop)

  wsc.forEach(function (style, i) {
    var prop = borderProperty(style);
    (0, _mergeRules2.default)(rule, ['border', prop], function (rules, lastNode) {
      if (lastNode.prop !== 'border') {
        return;
      }

      var values = (0, _parseWsc2.default)(lastNode.value);

      if (!(0, _validateWsc.isValidWsc)(values)) {
        return;
      }

      var wscProp = rules.filter(function (r) {
        return r !== lastNode;
      })[0];

      if (!isValueCustomProp(values[i]) || (0, _isCustomProp2.default)(wscProp)) {
        return;
      }

      var wscValue = values[i];
      values[i] = wscProp.value;

      if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {
        (0, _insertCloned2.default)(lastNode.parent, lastNode, {
          prop: prop,
          value: wscValue
        });
        lastNode.value = (0, _minifyWsc2.default)(values);
        wscProp.remove();
        return true;
      }
    });
  }); // optimize border-trbl

  var decls = (0, _getDecls2.default)(rule, directions);

  var _loop = function _loop() {
    var lastNode = decls[decls.length - 1];
    wsc.forEach(function (d, i) {
      var names = directions.filter(function (name) {
        return name !== lastNode.prop;
      }).map(function (name) {
        return "".concat(name, "-").concat(d);
      });
      var nodes = rule.nodes.slice(0, rule.nodes.indexOf(lastNode));
      var border = (0, _getLastNode2.default)(nodes, 'border');

      if (border) {
        nodes = nodes.slice(nodes.indexOf(border));
      }

      var props = nodes.filter(function (node) {
        return node.prop && ~names.indexOf(node.prop) && node.important === lastNode.important;
      });
      var rules = (0, _getRules2.default)(props, names);

      if ((0, _hasAllProps2.default).apply(void 0, [rules].concat(_toConsumableArray(names))) && !rules.some(_stylehacks.detect)) {
        var values = rules.map(function (node) {
          return node ? node.value : null;
        });
        var filteredValues = values.filter(Boolean);

        var lastNodeValue = _postcss.list.space(lastNode.value)[i];

        values[directions.indexOf(lastNode.prop)] = lastNodeValue;
        var value = (0, _minifyTrbl2.default)(values.join(' '));

        if (filteredValues[0] === filteredValues[1] && filteredValues[1] === filteredValues[2]) {
          value = filteredValues[0];
        }

        var refNode = props[props.length - 1];

        if (value === lastNodeValue) {
          refNode = lastNode;

          var valueArray = _postcss.list.space(lastNode.value);

          valueArray.splice(i, 1);
          lastNode.value = valueArray.join(' ');
        }

        (0, _insertCloned2.default)(refNode.parent, refNode, {
          prop: borderProperty(d),
          value: value
        });
        decls = decls.filter(function (node) {
          return !~rules.indexOf(node);
        });
        rules.forEach(_remove2.default);
      }
    });
    decls = decls.filter(function (node) {
      return node !== lastNode;
    });
  };

  while (decls.length) {
    _loop();
  }

  rule.walkDecls('border', function (decl) {
    var nextDecl = decl.next();

    if (!nextDecl || nextDecl.type !== 'decl') {
      return;
    }

    var index = directions.indexOf(nextDecl.prop);

    if (!~index) {
      return;
    }

    var values = (0, _parseWsc2.default)(decl.value);
    var nextValues = (0, _parseWsc2.default)(nextDecl.value);

    if (!(0, _validateWsc.isValidWsc)(values) || !(0, _validateWsc.isValidWsc)(nextValues)) {
      return;
    }

    var config = {
      values: values,
      nextValues: nextValues,
      decl: decl,
      nextDecl: nextDecl,
      index: index
    };
    return mergeRedundant(config);
  });
  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, function (decl) {
    var values = (0, _parseWsc2.default)(decl.value);

    if (!(0, _validateWsc.isValidWsc)(values)) {
      return;
    }

    var position = directions.indexOf(decl.prop);

    var dirs = _toConsumableArray(directions);

    dirs.splice(position, 1);
    wsc.forEach(function (d, i) {
      var props = dirs.map(function (dir) {
        return "".concat(dir, "-").concat(d);
      });
      (0, _mergeRules2.default)(rule, [decl.prop].concat(_toConsumableArray(props)), function (rules) {
        if (!rules.includes(decl)) {
          return;
        }

        var longhands = rules.filter(function (p) {
          return p !== decl;
        });

        if (longhands[0].value.toLowerCase() === longhands[1].value.toLowerCase() && longhands[1].value.toLowerCase() === longhands[2].value.toLowerCase() && longhands[0].value.toLowerCase() === values[i].toLowerCase()) {
          longhands.forEach(_remove2.default);
          (0, _insertCloned2.default)(decl.parent, decl, {
            prop: borderProperty(d),
            value: values[i]
          });
          values[i] = null;
        }
      });
      var newValue = values.join(' ');

      if (newValue) {
        decl.value = newValue;
      } else {
        decl.remove();
      }
    });
  }); // clean-up values

  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, function (decl) {
    decl.value = (0, _minifyWsc2.default)(decl.value);
  }); // border-spacing-hv -> border-spacing

  rule.walkDecls(/^border-spacing$/i, function (decl) {
    var value = _postcss.list.space(decl.value); // merge vertical and horizontal dups


    if (value.length > 1 && value[0] === value[1]) {
      decl.value = value.slice(1).join(' ');
    }
  }); // clean-up rules

  decls = (0, _getDecls2.default)(rule, allProperties);

  var _loop2 = function _loop2() {
    var lastNode = decls[decls.length - 1];
    var lastPart = lastNode.prop.split('-').pop(); // remove properties of lower precedence

    var lesser = decls.filter(function (node) {
      return !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && !(0, _isCustomProp2.default)(lastNode) && node !== lastNode && node.important === lastNode.important && getLevel(node.prop) > getLevel(lastNode.prop) && (!!~node.prop.toLowerCase().indexOf(lastNode.prop) || node.prop.toLowerCase().endsWith(lastPart));
    });
    lesser.forEach(_remove2.default);
    decls = decls.filter(function (node) {
      return !~lesser.indexOf(node);
    }); // get duplicate properties

    var duplicates = decls.filter(function (node) {
      return !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp2.default)(node) && (0, _isCustomProp2.default)(lastNode));
    });

    if (duplicates.length) {
      if (/hsla\(|rgba\(/i.test(getColorValue(lastNode))) {
        var preserve = duplicates.filter(function (node) {
          return !/hsla\(|rgba\(/i.test(getColorValue(node));
        }).pop();
        duplicates = duplicates.filter(function (node) {
          return node !== preserve;
        });
      }

      duplicates.forEach(_remove2.default);
    }

    decls = decls.filter(function (node) {
      return node !== lastNode && !~duplicates.indexOf(node);
    });
  };

  while (decls.length) {
    _loop2();
  }
}

exports.default = {
  explode: explode,
  merge: merge
};
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","stylehacks":"node_modules/stylehacks/dist/index.js","../insertCloned":"node_modules/postcss-merge-longhand/dist/lib/insertCloned.js","../parseTrbl":"node_modules/postcss-merge-longhand/dist/lib/parseTrbl.js","../hasAllProps":"node_modules/postcss-merge-longhand/dist/lib/hasAllProps.js","../getDecls":"node_modules/postcss-merge-longhand/dist/lib/getDecls.js","../getRules":"node_modules/postcss-merge-longhand/dist/lib/getRules.js","../getValue":"node_modules/postcss-merge-longhand/dist/lib/getValue.js","../mergeRules":"node_modules/postcss-merge-longhand/dist/lib/mergeRules.js","../minifyTrbl":"node_modules/postcss-merge-longhand/dist/lib/minifyTrbl.js","../minifyWsc":"node_modules/postcss-merge-longhand/dist/lib/minifyWsc.js","../canMerge":"node_modules/postcss-merge-longhand/dist/lib/canMerge.js","../remove":"node_modules/postcss-merge-longhand/dist/lib/remove.js","../trbl":"node_modules/postcss-merge-longhand/dist/lib/trbl.js","../isCustomProp":"node_modules/postcss-merge-longhand/dist/lib/isCustomProp.js","../canExplode":"node_modules/postcss-merge-longhand/dist/lib/canExplode.js","../getLastNode":"node_modules/postcss-merge-longhand/dist/lib/getLastNode.js","../parseWsc":"node_modules/postcss-merge-longhand/dist/lib/parseWsc.js","../validateWsc":"node_modules/postcss-merge-longhand/dist/lib/validateWsc.js"}],"node_modules/postcss-merge-longhand/dist/lib/decl/columns.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcssValueParser = require('postcss-value-parser');

var _stylehacks = require('stylehacks');

var _canMerge = require('../canMerge');

var _canMerge2 = _interopRequireDefault(_canMerge);

var _getDecls = require('../getDecls');

var _getDecls2 = _interopRequireDefault(_getDecls);

var _getValue = require('../getValue');

var _getValue2 = _interopRequireDefault(_getValue);

var _mergeRules = require('../mergeRules');

var _mergeRules2 = _interopRequireDefault(_mergeRules);

var _insertCloned = require('../insertCloned');

var _insertCloned2 = _interopRequireDefault(_insertCloned);

var _remove = require('../remove');

var _remove2 = _interopRequireDefault(_remove);

var _isCustomProp = require('../isCustomProp');

var _isCustomProp2 = _interopRequireDefault(_isCustomProp);

var _canExplode = require('../canExplode');

var _canExplode2 = _interopRequireDefault(_canExplode);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var properties = ['column-width', 'column-count'];
var auto = 'auto';
var inherit = 'inherit';
/**
 * Normalize a columns shorthand definition. Both of the longhand
 * properties' initial values are 'auto', and as per the spec,
 * omitted values are set to their initial values. Thus, we can
 * remove any 'auto' definition when there are two values.
 *
 * Specification link: https://www.w3.org/TR/css3-multicol/
 */

function normalize(values) {
  if (values[0].toLowerCase() === auto) {
    return values[1];
  }

  if (values[1].toLowerCase() === auto) {
    return values[0];
  }

  if (values[0].toLowerCase() === inherit && values[1].toLowerCase() === inherit) {
    return inherit;
  }

  return values.join(' ');
}

function explode(rule) {
  rule.walkDecls(/^columns$/i, function (decl) {
    if (!(0, _canExplode2.default)(decl)) {
      return;
    }

    if ((0, _stylehacks.detect)(decl)) {
      return;
    }

    var values = _postcss.list.space(decl.value);

    if (values.length === 1) {
      values.push(auto);
    }

    values.forEach(function (value, i) {
      var prop = properties[1];

      if (value.toLowerCase() === auto) {
        prop = properties[i];
      } else if ((0, _postcssValueParser.unit)(value).unit) {
        prop = properties[0];
      }

      (0, _insertCloned2.default)(decl.parent, decl, {
        prop: prop,
        value: value
      });
    });
    decl.remove();
  });
}

function cleanup(rule) {
  var decls = (0, _getDecls2.default)(rule, ['columns'].concat(properties));

  var _loop = function _loop() {
    var lastNode = decls[decls.length - 1]; // remove properties of lower precedence

    var lesser = decls.filter(function (node) {
      return !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && lastNode.prop === 'columns' && node.prop !== lastNode.prop;
    });
    lesser.forEach(_remove2.default);
    decls = decls.filter(function (node) {
      return !~lesser.indexOf(node);
    }); // get duplicate properties

    var duplicates = decls.filter(function (node) {
      return !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp2.default)(node) && (0, _isCustomProp2.default)(lastNode));
    });
    duplicates.forEach(_remove2.default);
    decls = decls.filter(function (node) {
      return node !== lastNode && !~duplicates.indexOf(node);
    });
  };

  while (decls.length) {
    _loop();
  }
}

function merge(rule) {
  (0, _mergeRules2.default)(rule, properties, function (rules, lastNode) {
    if ((0, _canMerge2.default)(rules) && !rules.some(_stylehacks.detect)) {
      (0, _insertCloned2.default)(lastNode.parent, lastNode, {
        prop: 'columns',
        value: normalize(rules.map(_getValue2.default))
      });
      rules.forEach(_remove2.default);
      return true;
    }
  });
  cleanup(rule);
}

exports.default = {
  explode: explode,
  merge: merge
};
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","stylehacks":"node_modules/stylehacks/dist/index.js","../canMerge":"node_modules/postcss-merge-longhand/dist/lib/canMerge.js","../getDecls":"node_modules/postcss-merge-longhand/dist/lib/getDecls.js","../getValue":"node_modules/postcss-merge-longhand/dist/lib/getValue.js","../mergeRules":"node_modules/postcss-merge-longhand/dist/lib/mergeRules.js","../insertCloned":"node_modules/postcss-merge-longhand/dist/lib/insertCloned.js","../remove":"node_modules/postcss-merge-longhand/dist/lib/remove.js","../isCustomProp":"node_modules/postcss-merge-longhand/dist/lib/isCustomProp.js","../canExplode":"node_modules/postcss-merge-longhand/dist/lib/canExplode.js"}],"node_modules/postcss-merge-longhand/dist/lib/mergeValues.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getValue = require('./getValue');

var _getValue2 = _interopRequireDefault(_getValue);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = function () {
  for (var _len = arguments.length, rules = new Array(_len), _key = 0; _key < _len; _key++) {
    rules[_key] = arguments[_key];
  }

  return rules.map(_getValue2.default).join(' ');
};

module.exports = exports['default'];
},{"./getValue":"node_modules/postcss-merge-longhand/dist/lib/getValue.js"}],"node_modules/postcss-merge-longhand/dist/lib/decl/boxBase.js":[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stylehacks = require('stylehacks');

var _canMerge = require('../canMerge');

var _canMerge2 = _interopRequireDefault(_canMerge);

var _getDecls = require('../getDecls');

var _getDecls2 = _interopRequireDefault(_getDecls);

var _minifyTrbl = require('../minifyTrbl');

var _minifyTrbl2 = _interopRequireDefault(_minifyTrbl);

var _parseTrbl = require('../parseTrbl');

var _parseTrbl2 = _interopRequireDefault(_parseTrbl);

var _insertCloned = require('../insertCloned');

var _insertCloned2 = _interopRequireDefault(_insertCloned);

var _mergeRules = require('../mergeRules');

var _mergeRules2 = _interopRequireDefault(_mergeRules);

var _mergeValues = require('../mergeValues');

var _mergeValues2 = _interopRequireDefault(_mergeValues);

var _remove = require('../remove');

var _remove2 = _interopRequireDefault(_remove);

var _trbl = require('../trbl');

var _trbl2 = _interopRequireDefault(_trbl);

var _isCustomProp = require('../isCustomProp');

var _isCustomProp2 = _interopRequireDefault(_isCustomProp);

var _canExplode = require('../canExplode');

var _canExplode2 = _interopRequireDefault(_canExplode);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = function (prop) {
  var properties = _trbl2.default.map(function (direction) {
    return "".concat(prop, "-").concat(direction);
  });

  var cleanup = function cleanup(rule) {
    var decls = (0, _getDecls2.default)(rule, [prop].concat(properties));

    var _loop = function _loop() {
      var lastNode = decls[decls.length - 1]; // remove properties of lower precedence

      var lesser = decls.filter(function (node) {
        return !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && lastNode.prop === prop && node.prop !== lastNode.prop;
      });
      lesser.forEach(_remove2.default);
      decls = decls.filter(function (node) {
        return !~lesser.indexOf(node);
      }); // get duplicate properties

      var duplicates = decls.filter(function (node) {
        return !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp2.default)(node) && (0, _isCustomProp2.default)(lastNode));
      });
      duplicates.forEach(_remove2.default);
      decls = decls.filter(function (node) {
        return node !== lastNode && !~duplicates.indexOf(node);
      });
    };

    while (decls.length) {
      _loop();
    }
  };

  var processor = {
    explode: function explode(rule) {
      rule.walkDecls(new RegExp("^" + prop + "$", "i"), function (decl) {
        if (!(0, _canExplode2.default)(decl)) {
          return;
        }

        if ((0, _stylehacks.detect)(decl)) {
          return;
        }

        var values = (0, _parseTrbl2.default)(decl.value);

        _trbl2.default.forEach(function (direction, index) {
          (0, _insertCloned2.default)(decl.parent, decl, {
            prop: properties[index],
            value: values[index]
          });
        });

        decl.remove();
      });
    },
    merge: function merge(rule) {
      (0, _mergeRules2.default)(rule, properties, function (rules, lastNode) {
        if ((0, _canMerge2.default)(rules) && !rules.some(_stylehacks.detect)) {
          (0, _insertCloned2.default)(lastNode.parent, lastNode, {
            prop: prop,
            value: (0, _minifyTrbl2.default)((0, _mergeValues2.default).apply(void 0, _toConsumableArray(rules)))
          });
          rules.forEach(_remove2.default);
          return true;
        }
      });
      cleanup(rule);
    }
  };
  return processor;
};

module.exports = exports['default'];
},{"stylehacks":"node_modules/stylehacks/dist/index.js","../canMerge":"node_modules/postcss-merge-longhand/dist/lib/canMerge.js","../getDecls":"node_modules/postcss-merge-longhand/dist/lib/getDecls.js","../minifyTrbl":"node_modules/postcss-merge-longhand/dist/lib/minifyTrbl.js","../parseTrbl":"node_modules/postcss-merge-longhand/dist/lib/parseTrbl.js","../insertCloned":"node_modules/postcss-merge-longhand/dist/lib/insertCloned.js","../mergeRules":"node_modules/postcss-merge-longhand/dist/lib/mergeRules.js","../mergeValues":"node_modules/postcss-merge-longhand/dist/lib/mergeValues.js","../remove":"node_modules/postcss-merge-longhand/dist/lib/remove.js","../trbl":"node_modules/postcss-merge-longhand/dist/lib/trbl.js","../isCustomProp":"node_modules/postcss-merge-longhand/dist/lib/isCustomProp.js","../canExplode":"node_modules/postcss-merge-longhand/dist/lib/canExplode.js"}],"node_modules/postcss-merge-longhand/dist/lib/decl/margin.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _boxBase = require('./boxBase');

var _boxBase2 = _interopRequireDefault(_boxBase);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = (0, _boxBase2.default)('margin');
module.exports = exports['default'];
},{"./boxBase":"node_modules/postcss-merge-longhand/dist/lib/decl/boxBase.js"}],"node_modules/postcss-merge-longhand/dist/lib/decl/padding.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _boxBase = require('./boxBase');

var _boxBase2 = _interopRequireDefault(_boxBase);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = (0, _boxBase2.default)('padding');
module.exports = exports['default'];
},{"./boxBase":"node_modules/postcss-merge-longhand/dist/lib/decl/boxBase.js"}],"node_modules/postcss-merge-longhand/dist/lib/decl/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _borders = require('./borders');

var _borders2 = _interopRequireDefault(_borders);

var _columns = require('./columns');

var _columns2 = _interopRequireDefault(_columns);

var _margin = require('./margin');

var _margin2 = _interopRequireDefault(_margin);

var _padding = require('./padding');

var _padding2 = _interopRequireDefault(_padding);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = [_borders2.default, _columns2.default, _margin2.default, _padding2.default];
module.exports = exports['default'];
},{"./borders":"node_modules/postcss-merge-longhand/dist/lib/decl/borders.js","./columns":"node_modules/postcss-merge-longhand/dist/lib/decl/columns.js","./margin":"node_modules/postcss-merge-longhand/dist/lib/decl/margin.js","./padding":"node_modules/postcss-merge-longhand/dist/lib/decl/padding.js"}],"node_modules/postcss-merge-longhand/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _decl = require('./lib/decl');

var _decl2 = _interopRequireDefault(_decl);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = _postcss2.default.plugin('postcss-merge-longhand', function () {
  return function (css) {
    css.walkRules(function (rule) {
      _decl2.default.forEach(function (p) {
        p.explode(rule);
        p.merge(rule);
      });
    });
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","./lib/decl":"node_modules/postcss-merge-longhand/dist/lib/decl/index.js"}],"node_modules/postcss-discard-duplicates/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

function noop() {}

function trimValue(value) {
  return value ? value.trim() : value;
}

function empty(node) {
  return !node.nodes.filter(function (child) {
    return child.type !== 'comment';
  }).length;
}

function equals(a, b) {
  if (a.type !== b.type) {
    return false;
  }

  if (a.important !== b.important) {
    return false;
  }

  if (a.raws && !b.raws || !a.raws && b.raws) {
    return false;
  }

  switch (a.type) {
    case 'rule':
      if (a.selector !== b.selector) {
        return false;
      }

      break;

    case 'atrule':
      if (a.name !== b.name || a.params !== b.params) {
        return false;
      }

      if (a.raws && trimValue(a.raws.before) !== trimValue(b.raws.before)) {
        return false;
      }

      if (a.raws && trimValue(a.raws.afterName) !== trimValue(b.raws.afterName)) {
        return false;
      }

      break;

    case 'decl':
      if (a.prop !== b.prop || a.value !== b.value) {
        return false;
      }

      if (a.raws && trimValue(a.raws.before) !== trimValue(b.raws.before)) {
        return false;
      }

      break;
  }

  if (a.nodes) {
    if (a.nodes.length !== b.nodes.length) {
      return false;
    }

    for (var i = 0; i < a.nodes.length; i++) {
      if (!equals(a.nodes[i], b.nodes[i])) {
        return false;
      }
    }
  }

  return true;
}

function dedupeRule(last, nodes) {
  var index = nodes.indexOf(last) - 1;

  var _loop = function _loop() {
    var node = nodes[index--];

    if (node && node.type === 'rule' && node.selector === last.selector) {
      last.each(function (child) {
        if (child.type === 'decl') {
          dedupeNode(child, node.nodes);
        }
      });

      if (empty(node)) {
        node.remove();
      }
    }
  };

  while (index >= 0) {
    _loop();
  }
}

function dedupeNode(last, nodes) {
  var index = !!~nodes.indexOf(last) ? nodes.indexOf(last) - 1 : nodes.length - 1;

  while (index >= 0) {
    var node = nodes[index--];

    if (node && equals(node, last)) {
      node.remove();
    }
  }
}

var handlers = {
  rule: dedupeRule,
  atrule: dedupeNode,
  decl: dedupeNode,
  comment: noop
};

function dedupe(root) {
  var nodes = root.nodes;

  if (!nodes) {
    return;
  }

  var index = nodes.length - 1;

  while (index >= 0) {
    var last = nodes[index--];

    if (!last || !last.parent) {
      continue;
    }

    dedupe(last);
    handlers[last.type](last, nodes);
  }
}

exports.default = (0, _postcss.plugin)('postcss-discard-duplicates', function () {
  return dedupe;
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js"}],"node_modules/postcss-discard-overridden/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var OVERRIDABLE_RULES = ['keyframes', 'counter-style'];
var SCOPE_RULES = ['media', 'supports'];

function isOverridable(name) {
  return ~OVERRIDABLE_RULES.indexOf(_postcss2.default.vendor.unprefixed(name.toLowerCase()));
}

function isScope(name) {
  return ~SCOPE_RULES.indexOf(_postcss2.default.vendor.unprefixed(name.toLowerCase()));
}

function getScope(node) {
  var current = node.parent;
  var chain = [node.name.toLowerCase(), node.params];

  do {
    if (current.type === 'atrule' && isScope(current.name)) {
      chain.unshift(current.name + ' ' + current.params);
    }

    current = current.parent;
  } while (current);

  return chain.join('|');
}

exports.default = _postcss2.default.plugin('postcss-discard-overridden', function () {
  return function (css) {
    var cache = {};
    var rules = [];
    css.walkAtRules(function (node) {
      if (isOverridable(node.name)) {
        var scope = getScope(node);
        cache[scope] = node;
        rules.push({
          node: node,
          scope: scope
        });
      }
    });
    rules.forEach(function (rule) {
      if (cache[rule.scope] !== rule.node) {
        rule.node.remove();
      }
    });
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js"}],"node_modules/postcss-normalize-repeat-style/dist/lib/map.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = [['repeat-x', ['repeat', 'no-repeat']], ['repeat-y', ['no-repeat', 'repeat']], ['repeat', ['repeat', 'repeat']], ['space', ['space', 'space']], ['round', ['round', 'round']], ['no-repeat', ['no-repeat', 'no-repeat']]];
module.exports = exports['default'];
},{}],"node_modules/postcss-normalize-repeat-style/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _cssnanoUtilGetArguments = require('cssnano-util-get-arguments');

var _cssnanoUtilGetArguments2 = _interopRequireDefault(_cssnanoUtilGetArguments);

var _cssnanoUtilGetMatch = require('cssnano-util-get-match');

var _cssnanoUtilGetMatch2 = _interopRequireDefault(_cssnanoUtilGetMatch);

var _map = require('./lib/map');

var _map2 = _interopRequireDefault(_map);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function evenValues(list, index) {
  return index % 2 === 0;
}

var repeatKeywords = _map2.default.map(function (mapping) {
  return mapping[0];
});

var getMatch = (0, _cssnanoUtilGetMatch2.default)(_map2.default);
exports.default = _postcss2.default.plugin('postcss-normalize-repeat-style', function () {
  return function (css) {
    var cache = {};
    css.walkDecls(/background(-repeat)?|(-webkit-)?mask-repeat/i, function (decl) {
      var value = decl.value;

      if (cache[value]) {
        decl.value = cache[value];
        return;
      }

      var parsed = (0, _postcssValueParser2.default)(value);

      if (parsed.nodes.length === 1) {
        cache[value] = value;
        return;
      }

      var args = (0, _cssnanoUtilGetArguments2.default)(parsed);
      var relevant = [];
      args.forEach(function (arg) {
        relevant.push({
          start: null,
          end: null
        });
        arg.forEach(function (part, index) {
          var isRepeat = ~repeatKeywords.indexOf(part.value.toLowerCase());
          var len = relevant.length - 1;

          if (relevant[len].start === null && isRepeat) {
            relevant[len].start = index;
            relevant[len].end = index;
            return;
          }

          if (relevant[len].start !== null) {
            if (part.type === 'space') {
              return;
            } else if (isRepeat) {
              relevant[len].end = index;
              return;
            }

            return;
          }
        });
      });
      relevant.forEach(function (range, index) {
        if (range.start === null) {
          return;
        }

        var val = args[index].slice(range.start, range.end + 1);

        if (val.length !== 3) {
          return;
        }

        var match = getMatch(val.filter(evenValues).map(function (n) {
          return n.value.toLowerCase();
        }));

        if (match) {
          args[index][range.start].value = match;
          args[index][range.start + 1].value = '';
          args[index][range.end].value = '';
        }
      });
      var result = parsed.toString();
      decl.value = result;
      cache[value] = result;
    });
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","cssnano-util-get-arguments":"node_modules/cssnano-util-get-arguments/dist/index.js","cssnano-util-get-match":"node_modules/cssnano-util-get-match/dist/index.js","./lib/map":"node_modules/postcss-normalize-repeat-style/dist/lib/map.js"}],"node_modules/vendors/index.json":[function(require,module,exports) {
module.exports = [
  "ah",
  "apple",
  "atsc",
  "epub",
  "hp",
  "khtml",
  "moz",
  "ms",
  "o",
  "rim",
  "ro",
  "tc",
  "wap",
  "webkit",
  "xv"
]
;
},{}],"node_modules/cssnano-util-same-parent/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sameParent;

function sameParent(ruleA, ruleB) {
  var hasParent = ruleA.parent && ruleB.parent; // Check for detached rules

  if (!hasParent) {
    return true;
  } // If an at rule, ensure that the parameters are the same


  if (ruleA.parent.type === 'atrule' && ruleB.parent.type === 'atrule') {
    return ruleA.parent.params === ruleB.parent.params && ruleA.parent.name.toLowerCase() === ruleB.parent.name.toLowerCase();
  }

  return ruleA.parent.type === ruleB.parent.type;
}

module.exports = exports['default'];
},{}],"node_modules/postcss-merge-rules/dist/lib/ensureCompatibility.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pseudoElements = undefined;
exports.default = ensureCompatibility;

var _caniuseApi = require('caniuse-api');

var _postcssSelectorParser = require('postcss-selector-parser');

var _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var simpleSelectorRe = /^#?[-._a-z0-9 ]+$/i;
var cssSel2 = 'css-sel2';
var cssSel3 = 'css-sel3';
var cssGencontent = 'css-gencontent';
var cssFirstLetter = 'css-first-letter';
var cssFirstLine = 'css-first-line';
var cssInOutOfRange = 'css-in-out-of-range';
var pseudoElements = exports.pseudoElements = {
  ':active': cssSel2,
  ':after': cssGencontent,
  ':before': cssGencontent,
  ':checked': cssSel3,
  ':default': 'css-default-pseudo',
  ':dir': 'css-dir-pseudo',
  ':disabled': cssSel3,
  ':empty': cssSel3,
  ':enabled': cssSel3,
  ':first-child': cssSel2,
  ':first-letter': cssFirstLetter,
  ':first-line': cssFirstLine,
  ':first-of-type': cssSel3,
  ':focus': cssSel2,
  ':focus-within': 'css-focus-within',
  ':has': 'css-has',
  ':hover': cssSel2,
  ':in-range': cssInOutOfRange,
  ':indeterminate': 'css-indeterminate-pseudo',
  ':lang': cssSel2,
  ':last-child': cssSel3,
  ':last-of-type': cssSel3,
  ':matches': 'css-matches-pseudo',
  ':not': cssSel3,
  ':nth-child': cssSel3,
  ':nth-last-child': cssSel3,
  ':nth-last-of-type': cssSel3,
  ':nth-of-type': cssSel3,
  ':only-child': cssSel3,
  ':only-of-type': cssSel3,
  ':optional': 'css-optional-pseudo',
  ':out-of-range': cssInOutOfRange,
  ':placeholder-shown': 'css-placeholder-shown',
  ':root': cssSel3,
  ':target': cssSel3,
  '::after': cssGencontent,
  '::backdrop': 'dialog',
  '::before': cssGencontent,
  '::first-letter': cssFirstLetter,
  '::first-line': cssFirstLine,
  '::marker': 'css-marker-pseudo',
  '::placeholder': 'css-placeholder',
  '::selection': 'css-selection'
};

function isCssMixin(selector) {
  return selector[selector.length - 1] === ':';
}

var isSupportedCache = {}; // Move to util in future

function isSupportedCached(feature, browsers) {
  var key = JSON.stringify({
    feature: feature,
    browsers: browsers
  });
  var result = isSupportedCache[key];

  if (!result) {
    result = (0, _caniuseApi.isSupported)(feature, browsers);
    isSupportedCache[key] = result;
  }

  return result;
}

function ensureCompatibility(selectors, browsers, compatibilityCache) {
  // Should not merge mixins
  if (selectors.some(isCssMixin)) {
    return false;
  }

  return selectors.every(function (selector) {
    if (simpleSelectorRe.test(selector)) {
      return true;
    }

    if (compatibilityCache && selector in compatibilityCache) {
      return compatibilityCache[selector];
    }

    var compatible = true;
    (0, _postcssSelectorParser2.default)(function (ast) {
      ast.walk(function (node) {
        var type = node.type,
            value = node.value;

        if (type === 'pseudo') {
          var entry = pseudoElements[value];

          if (entry && compatible) {
            compatible = isSupportedCached(entry, browsers);
          }
        }

        if (type === 'combinator') {
          if (~value.indexOf('~')) {
            compatible = isSupportedCached(cssSel3, browsers);
          }

          if (~value.indexOf('>') || ~value.indexOf('+')) {
            compatible = isSupportedCached(cssSel2, browsers);
          }
        }

        if (type === 'attribute' && node.attribute) {
          // [foo]
          if (!node.operator) {
            compatible = isSupportedCached(cssSel2, browsers);
          }

          if (value) {
            // [foo="bar"], [foo~="bar"], [foo|="bar"]
            if (~['=', '~=', '|='].indexOf(node.operator)) {
              compatible = isSupportedCached(cssSel2, browsers);
            } // [foo^="bar"], [foo$="bar"], [foo*="bar"]


            if (~['^=', '$=', '*='].indexOf(node.operator)) {
              compatible = isSupportedCached(cssSel3, browsers);
            }
          } // [foo="bar" i]


          if (node.insensitive) {
            compatible = isSupportedCached('css-case-insensitive', browsers);
          }
        }

        if (!compatible) {
          // If this node was not compatible,
          // break out early from walking the rest
          return false;
        }
      });
    }).processSync(selector);

    if (compatibilityCache) {
      compatibilityCache[selector] = compatible;
    }

    return compatible;
  });
}
},{"caniuse-api":"node_modules/caniuse-api/dist/index.js","postcss-selector-parser":"node_modules/postcss-selector-parser/dist/index.js"}],"node_modules/postcss-merge-rules/dist/index.js":[function(require,module,exports) {
var __dirname = "/home/royyan/csspurge/node_modules/postcss-merge-rules/dist";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _browserslist = require('browserslist');

var _browserslist2 = _interopRequireDefault(_browserslist);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _vendors = require('vendors');

var _vendors2 = _interopRequireDefault(_vendors);

var _cssnanoUtilSameParent = require('cssnano-util-same-parent');

var _cssnanoUtilSameParent2 = _interopRequireDefault(_cssnanoUtilSameParent);

var _ensureCompatibility = require('./lib/ensureCompatibility');

var _ensureCompatibility2 = _interopRequireDefault(_ensureCompatibility);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var prefixes = _vendors2.default.map(function (v) {
  return "-".concat(v, "-");
});

function intersect(a, b, not) {
  return a.filter(function (c) {
    var index = ~b.indexOf(c);
    return not ? !index : index;
  });
} // Internet Explorer use :-ms-input-placeholder.
// Microsoft Edge use ::-ms-input-placeholder.


var findMsInputPlaceholder = function findMsInputPlaceholder(selector) {
  return ~selector.search(/-ms-input-placeholder/i);
};

var different = function different(a, b) {
  return intersect(a, b, true).concat(intersect(b, a, true));
};

var filterPrefixes = function filterPrefixes(selector) {
  return intersect(prefixes, selector);
};

function sameVendor(selectorsA, selectorsB) {
  var same = function same(selectors) {
    return selectors.map(filterPrefixes).join();
  };

  var findMsVendor = function findMsVendor(selectors) {
    return selectors.find(findMsInputPlaceholder);
  };

  return same(selectorsA) === same(selectorsB) && !(findMsVendor(selectorsA) && findMsVendor(selectorsB));
}

var noVendor = function noVendor(selector) {
  return !filterPrefixes(selector).length;
};

function canMerge(ruleA, ruleB, browsers, compatibilityCache) {
  var a = ruleA.selectors;
  var b = ruleB.selectors;
  var selectors = a.concat(b);

  if (!(0, _ensureCompatibility2.default)(selectors, browsers, compatibilityCache)) {
    return false;
  }

  var parent = (0, _cssnanoUtilSameParent2.default)(ruleA, ruleB);
  var name = ruleA.parent.name;

  if (parent && name && ~name.indexOf('keyframes')) {
    return false;
  }

  return parent && (selectors.every(noVendor) || sameVendor(a, b));
}

var getDecls = function getDecls(rule) {
  return rule.nodes && rule.nodes.map(String);
};

var joinSelectors = function joinSelectors() {
  for (var _len = arguments.length, rules = new Array(_len), _key = 0; _key < _len; _key++) {
    rules[_key] = arguments[_key];
  }

  return rules.map(function (s) {
    return s.selector;
  }).join();
};

function ruleLength() {
  for (var _len2 = arguments.length, rules = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    rules[_key2] = arguments[_key2];
  }

  return rules.map(function (r) {
    return r.nodes.length ? String(r) : '';
  }).join('').length;
}

function splitProp(prop) {
  var parts = prop.split('-');
  var base, rest; // Treat vendor prefixed properties as if they were unprefixed;
  // moving them when combined with non-prefixed properties can
  // cause issues. e.g. moving -webkit-background-clip when there
  // is a background shorthand definition.

  if (prop[0] === '-') {
    base = parts[2];
    rest = parts.slice(3);
  } else {
    base = parts[0];
    rest = parts.slice(1);
  }

  return [base, rest];
}

function isConflictingProp(propA, propB) {
  if (propA === propB) {
    return true;
  }

  var a = splitProp(propA);
  var b = splitProp(propB);
  return a[0] === b[0] && a[1].length !== b[1].length;
}

function hasConflicts(declProp, notMoved) {
  return notMoved.some(function (prop) {
    return isConflictingProp(prop, declProp);
  });
}

function partialMerge(first, second) {
  var _this = this;

  var intersection = intersect(getDecls(first), getDecls(second));

  if (!intersection.length) {
    return second;
  }

  var nextRule = second.next();

  if (nextRule && nextRule.type === 'rule' && canMerge(second, nextRule)) {
    var nextIntersection = intersect(getDecls(second), getDecls(nextRule));

    if (nextIntersection.length > intersection.length) {
      first = second;
      second = nextRule;
      intersection = nextIntersection;
    }
  }

  var recievingBlock = second.clone();
  recievingBlock.selector = joinSelectors(first, second);
  recievingBlock.nodes = [];
  var difference = different(getDecls(first), getDecls(second));

  var filterConflicts = function filterConflicts(decls, intersectn) {
    var willNotMove = [];
    return decls.reduce(function (willMove, decl) {
      var intersects = ~intersectn.indexOf(decl);
      var prop = decl.split(':')[0];
      var base = prop.split('-')[0];
      var canMove = difference.every(function (d) {
        return d.split(':')[0] !== base;
      });

      if (intersects && canMove && !hasConflicts(prop, willNotMove)) {
        willMove.push(decl);
      } else {
        willNotMove.push(prop);
      }

      return willMove;
    }, []);
  };

  var containsAllDeclaration = function containsAllDeclaration(intersectionList) {
    return intersectionList.some(function (declaration) {
      return declaration.split(':')[0].toLowerCase() === 'all';
    });
  };

  intersection = filterConflicts(getDecls(first).reverse(), intersection);
  intersection = filterConflicts(getDecls(second), intersection); // Rules with "all" declarations must be on top

  if (containsAllDeclaration(intersection)) {
    second.parent.insertBefore(first, recievingBlock);
  } else {
    second.parent.insertBefore(second, recievingBlock);
  }

  var firstClone = first.clone();
  var secondClone = second.clone();

  var moveDecl = function moveDecl(callback) {
    return function (decl) {
      if (~intersection.indexOf(String(decl))) {
        callback.call(_this, decl);
      }
    };
  };

  firstClone.walkDecls(moveDecl(function (decl) {
    decl.remove();
    recievingBlock.append(decl);
  }));
  secondClone.walkDecls(moveDecl(function (decl) {
    return decl.remove();
  }));
  var merged = ruleLength(firstClone, recievingBlock, secondClone);
  var original = ruleLength(first, second);

  if (merged < original) {
    first.replaceWith(firstClone);
    second.replaceWith(secondClone);
    [firstClone, recievingBlock, secondClone].forEach(function (r) {
      if (!r.nodes.length) {
        r.remove();
      }
    });

    if (!secondClone.parent) {
      return recievingBlock;
    }

    return secondClone;
  } else {
    recievingBlock.remove();
    return second;
  }
}

function selectorMerger(browsers, compatibilityCache) {
  var cache = null;
  return function (rule) {
    // Prime the cache with the first rule, or alternately ensure that it is
    // safe to merge both declarations before continuing
    if (!cache || !canMerge(rule, cache, browsers, compatibilityCache)) {
      cache = rule;
      return;
    } // Ensure that we don't deduplicate the same rule; this is sometimes
    // caused by a partial merge


    if (cache === rule) {
      cache = rule;
      return;
    } // Merge when declarations are exactly equal
    // e.g. h1 { color: red } h2 { color: red }


    if (getDecls(rule).join(';') === getDecls(cache).join(';')) {
      rule.selector = joinSelectors(cache, rule);
      cache.remove();
      cache = rule;
      return;
    } // Merge when both selectors are exactly equal
    // e.g. a { color: blue } a { font-weight: bold }


    if (cache.selector === rule.selector) {
      var cached = getDecls(cache);
      rule.walk(function (decl) {
        if (~cached.indexOf(String(decl))) {
          return decl.remove();
        }

        cache.append(decl);
      });
      rule.remove();
      return;
    } // Partial merge: check if the rule contains a subset of the last; if
    // so create a joined selector with the subset, if smaller.


    cache = partialMerge(cache, rule);
  };
}

exports.default = _postcss2.default.plugin('postcss-merge-rules', function () {
  return function (css, result) {
    var resultOpts = result.opts || {};
    var browsers = (0, _browserslist2.default)(null, {
      stats: resultOpts.stats,
      path: __dirname,
      env: resultOpts.env
    });
    var compatibilityCache = {};
    css.walkRules(selectorMerger(browsers, compatibilityCache));
  };
});
module.exports = exports['default'];
},{"browserslist":"node_modules/browserslist/index.js","postcss":"node_modules/postcss/lib/postcss.js","vendors":"node_modules/vendors/index.json","cssnano-util-same-parent":"node_modules/cssnano-util-same-parent/dist/index.js","./lib/ensureCompatibility":"node_modules/postcss-merge-rules/dist/lib/ensureCompatibility.js"}],"node_modules/postcss-discard-empty/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var plugin = 'postcss-discard-empty';

function discardAndReport(css, result) {
  function discardEmpty(node) {
    var type = node.type,
        sub = node.nodes,
        params = node.params;

    if (sub) {
      node.each(discardEmpty);
    }

    if (type === 'decl' && !node.value || type === 'rule' && !node.selector || sub && !sub.length || type === 'atrule' && (!sub && !params || !params && !sub.length)) {
      node.remove();
      result.messages.push({
        type: 'removal',
        plugin: plugin,
        node: node
      });
    }
  }

  css.each(discardEmpty);
}

exports.default = _postcss2.default.plugin(plugin, function () {
  return discardAndReport;
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js"}],"node_modules/postcss-unique-selectors/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _alphanumSort = require('alphanum-sort');

var _alphanumSort2 = _interopRequireDefault(_alphanumSort);

var _uniqs = require('uniqs');

var _uniqs2 = _interopRequireDefault(_uniqs);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function unique(rule) {
  rule.selector = (0, _alphanumSort2.default)((0, _uniqs2.default)(rule.selectors), {
    insensitive: true
  }).join();
}

exports.default = (0, _postcss.plugin)('postcss-unique-selectors', function () {
  return function (css) {
    return css.walkRules(unique);
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","alphanum-sort":"node_modules/alphanum-sort/lib/index.js","uniqs":"node_modules/uniqs/index.js"}],"node_modules/postcss-normalize-string/dist/index.js":[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _has = require('has');

var _has2 = _interopRequireDefault(_has);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/*
 * Constants (parser usage)
 */


var SINGLE_QUOTE = '\''.charCodeAt(0);
var DOUBLE_QUOTE = '"'.charCodeAt(0);
var BACKSLASH = '\\'.charCodeAt(0);
var NEWLINE = '\n'.charCodeAt(0);
var SPACE = ' '.charCodeAt(0);
var FEED = '\f'.charCodeAt(0);
var TAB = '\t'.charCodeAt(0);
var CR = '\r'.charCodeAt(0);
var WORD_END = /[ \n\t\r\f'"\\]/g;
/*
 * Constants (node type strings)
 */

var C_STRING = 'string';
var C_ESCAPED_SINGLE_QUOTE = 'escapedSingleQuote';
var C_ESCAPED_DOUBLE_QUOTE = 'escapedDoubleQuote';
var C_SINGLE_QUOTE = 'singleQuote';
var C_DOUBLE_QUOTE = 'doubleQuote';
var C_NEWLINE = 'newline';
var C_SINGLE = 'single';
/*
 * Literals
 */

var L_SINGLE_QUOTE = "'";
var L_DOUBLE_QUOTE = "\"";
var L_NEWLINE = "\\\n";
/*
 * Parser nodes
 */

var T_ESCAPED_SINGLE_QUOTE = {
  type: C_ESCAPED_SINGLE_QUOTE,
  value: "\\'"
};
var T_ESCAPED_DOUBLE_QUOTE = {
  type: C_ESCAPED_DOUBLE_QUOTE,
  value: "\\\""
};
var T_SINGLE_QUOTE = {
  type: C_SINGLE_QUOTE,
  value: L_SINGLE_QUOTE
};
var T_DOUBLE_QUOTE = {
  type: C_DOUBLE_QUOTE,
  value: L_DOUBLE_QUOTE
};
var T_NEWLINE = {
  type: C_NEWLINE,
  value: L_NEWLINE
};

function stringify(ast) {
  return ast.nodes.reduce(function (str, _ref) {
    var value = _ref.value;

    // Collapse multiple line strings automatically
    if (value === L_NEWLINE) {
      return str;
    }

    return str + value;
  }, '');
}

function parse(str) {
  var code, next, value;
  var pos = 0;
  var len = str.length;
  var ast = {
    nodes: [],
    types: {
      escapedSingleQuote: 0,
      escapedDoubleQuote: 0,
      singleQuote: 0,
      doubleQuote: 0
    },
    quotes: false
  };

  while (pos < len) {
    code = str.charCodeAt(pos);

    switch (code) {
      case SPACE:
      case TAB:
      case CR:
      case FEED:
        next = pos;

        do {
          next += 1;
          code = str.charCodeAt(next);
        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);

        ast.nodes.push({
          type: 'space',
          value: str.slice(pos, next)
        });
        pos = next - 1;
        break;

      case SINGLE_QUOTE:
        ast.nodes.push(T_SINGLE_QUOTE);
        ast.types[C_SINGLE_QUOTE]++;
        ast.quotes = true;
        break;

      case DOUBLE_QUOTE:
        ast.nodes.push(T_DOUBLE_QUOTE);
        ast.types[C_DOUBLE_QUOTE]++;
        ast.quotes = true;
        break;

      case BACKSLASH:
        next = pos + 1;

        if (str.charCodeAt(next) === SINGLE_QUOTE) {
          ast.nodes.push(T_ESCAPED_SINGLE_QUOTE);
          ast.types[C_ESCAPED_SINGLE_QUOTE]++;
          ast.quotes = true;
          pos = next;
          break;
        } else if (str.charCodeAt(next) === DOUBLE_QUOTE) {
          ast.nodes.push(T_ESCAPED_DOUBLE_QUOTE);
          ast.types[C_ESCAPED_DOUBLE_QUOTE]++;
          ast.quotes = true;
          pos = next;
          break;
        } else if (str.charCodeAt(next) === NEWLINE) {
          ast.nodes.push(T_NEWLINE);
          pos = next;
          break;
        }

      /*
       * We need to fall through here to handle the token as
       * a whole word. The missing 'break' is intentional.
       */

      default:
        WORD_END.lastIndex = pos + 1;
        WORD_END.test(str);

        if (WORD_END.lastIndex === 0) {
          next = len - 1;
        } else {
          next = WORD_END.lastIndex - 2;
        }

        value = str.slice(pos, next + 1);
        ast.nodes.push({
          type: C_STRING,
          value: value
        });
        pos = next;
    }

    pos++;
  }

  return ast;
}

function changeWrappingQuotes(node, ast) {
  var types = ast.types;

  if (types[C_SINGLE_QUOTE] || types[C_DOUBLE_QUOTE]) {
    return;
  }

  if (node.quote === L_SINGLE_QUOTE && types[C_ESCAPED_SINGLE_QUOTE] > 0 && !types[C_ESCAPED_DOUBLE_QUOTE]) {
    node.quote = L_DOUBLE_QUOTE;
  }

  if (node.quote === L_DOUBLE_QUOTE && types[C_ESCAPED_DOUBLE_QUOTE] > 0 && !types[C_ESCAPED_SINGLE_QUOTE]) {
    node.quote = L_SINGLE_QUOTE;
  }

  ast.nodes = ast.nodes.reduce(function (newAst, child) {
    if (child.type === C_ESCAPED_DOUBLE_QUOTE && node.quote === L_SINGLE_QUOTE) {
      return [].concat(_toConsumableArray(newAst), [T_DOUBLE_QUOTE]);
    }

    if (child.type === C_ESCAPED_SINGLE_QUOTE && node.quote === L_DOUBLE_QUOTE) {
      return [].concat(_toConsumableArray(newAst), [T_SINGLE_QUOTE]);
    }

    return [].concat(_toConsumableArray(newAst), [child]);
  }, []);
}

function normalize(value, preferredQuote) {
  if (!value || !value.length) {
    return value;
  }

  return (0, _postcssValueParser2.default)(value).walk(function (child) {
    if (child.type !== C_STRING) {
      return;
    }

    var ast = parse(child.value);

    if (ast.quotes) {
      changeWrappingQuotes(child, ast);
    } else if (preferredQuote === C_SINGLE) {
      child.quote = L_SINGLE_QUOTE;
    } else {
      child.quote = L_DOUBLE_QUOTE;
    }

    child.value = stringify(ast);
  }).toString();
}

var params = {
  rule: 'selector',
  decl: 'value',
  atrule: 'params'
};
exports.default = _postcss2.default.plugin('postcss-normalize-string', function (opts) {
  var _Object$assign = Object.assign({}, {
    preferredQuote: 'double'
  }, opts),
      preferredQuote = _Object$assign.preferredQuote;

  return function (css) {
    var cache = {};
    css.walk(function (node) {
      var type = node.type;

      if ((0, _has2.default)(params, type)) {
        var param = params[type];
        var key = node[param] + '|' + preferredQuote;

        if (cache[key]) {
          node[param] = cache[key];
          return;
        }

        var result = normalize(node[param], preferredQuote);
        node[param] = result;
        cache[key] = result;
      }
    });
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","has":"node_modules/has/src/index.js"}],"node_modules/postcss-normalize-positions/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _cssnanoUtilGetArguments = require('cssnano-util-get-arguments');

var _cssnanoUtilGetArguments2 = _interopRequireDefault(_cssnanoUtilGetArguments);

var _has = require('has');

var _has2 = _interopRequireDefault(_has);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var directions = ['top', 'right', 'bottom', 'left', 'center'];
var center = '50%';
var horizontal = {
  right: '100%',
  left: '0'
};
var vertical = {
  bottom: '100%',
  top: '0'
};

function transform(value) {
  var parsed = (0, _postcssValueParser2.default)(value);
  var args = (0, _cssnanoUtilGetArguments2.default)(parsed);
  var relevant = [];
  args.forEach(function (arg) {
    relevant.push({
      start: null,
      end: null
    });
    arg.forEach(function (part, index) {
      var isPosition = ~directions.indexOf(part.value.toLowerCase()) || (0, _postcssValueParser.unit)(part.value);
      var len = relevant.length - 1;

      if (relevant[len].start === null && isPosition) {
        relevant[len].start = index;
        relevant[len].end = index;
        return;
      }

      if (relevant[len].start !== null) {
        if (part.type === 'space') {
          return;
        } else if (isPosition) {
          relevant[len].end = index;
          return;
        }

        return;
      }
    });
  });
  relevant.forEach(function (range, index) {
    if (range.start === null) {
      return;
    }

    var position = args[index].slice(range.start, range.end + 1);

    if (position.length > 3) {
      return;
    }

    var firstValue = position[0].value.toLowerCase();
    var secondValue = position[2] && position[2].value ? position[2].value.toLowerCase() : null;

    if (position.length === 1 || secondValue === 'center') {
      if (secondValue) {
        position[2].value = position[1].value = '';
      }

      var map = Object.assign({}, horizontal, {
        center: center
      });

      if ((0, _has2.default)(map, firstValue)) {
        position[0].value = map[firstValue];
      }

      return;
    }

    if (firstValue === 'center' && ~directions.indexOf(secondValue)) {
      position[0].value = position[1].value = '';

      if ((0, _has2.default)(horizontal, secondValue)) {
        position[2].value = horizontal[secondValue];
      }

      return;
    }

    if ((0, _has2.default)(horizontal, firstValue) && (0, _has2.default)(vertical, secondValue)) {
      position[0].value = horizontal[firstValue];
      position[2].value = vertical[secondValue];
      return;
    } else if ((0, _has2.default)(vertical, firstValue) && (0, _has2.default)(horizontal, secondValue)) {
      position[0].value = horizontal[secondValue];
      position[2].value = vertical[firstValue];
      return;
    }
  });
  return parsed.toString();
}

exports.default = (0, _postcss.plugin)('postcss-normalize-positions', function () {
  return function (css) {
    var cache = {};
    css.walkDecls(/^(background(-position)?|(-webkit-)?perspective-origin)$/i, function (decl) {
      var value = decl.value;

      if (cache[value]) {
        decl.value = cache[value];
        return;
      }

      var result = transform(value);
      decl.value = result;
      cache[value] = result;
    });
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","cssnano-util-get-arguments":"node_modules/cssnano-util-get-arguments/dist/index.js","has":"node_modules/has/src/index.js"}],"node_modules/postcss-normalize-whitespace/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require("postcss");

var _postcssValueParser = require("postcss-value-parser");

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var atrule = "atrule";
var decl = "decl";
var rule = "rule";

function reduceCalcWhitespaces(node) {
  if (node.type === "space") {
    node.value = " ";
  } else if (node.type === "function") {
    node.before = node.after = "";
  }
}

function reduceWhitespaces(node) {
  if (node.type === "space") {
    node.value = " ";
  } else if (node.type === "div") {
    node.before = node.after = "";
  } else if (node.type === "function") {
    node.before = node.after = "";

    if (node.value.toLowerCase() === "calc") {
      _postcssValueParser2.default.walk(node.nodes, reduceCalcWhitespaces);

      return false;
    }
  }
}

exports.default = (0, _postcss.plugin)("postcss-normalize-whitespace", function () {
  return function (css) {
    var cache = {};
    css.walk(function (node) {
      var type = node.type;

      if (~[decl, rule, atrule].indexOf(type) && node.raws.before) {
        node.raws.before = node.raws.before.replace(/\s/g, "");
      }

      if (type === decl) {
        // Ensure that !important values do not have any excess whitespace
        if (node.important) {
          node.raws.important = "!important";
        } // Remove whitespaces around ie 9 hack


        node.value = node.value.replace(/\s*(\\9)\s*/, "$1");
        var value = node.value;

        if (cache[value]) {
          node.value = cache[value];
        } else {
          var parsed = (0, _postcssValueParser2.default)(node.value);
          var result = parsed.walk(reduceWhitespaces).toString(); // Trim whitespace inside functions & dividers

          node.value = result;
          cache[value] = result;
        } // Remove extra semicolons and whitespace before the declaration


        if (node.raws.before) {
          var prev = node.prev();

          if (prev && prev.type !== rule) {
            node.raws.before = node.raws.before.replace(/;/g, "");
          }
        }

        node.raws.between = ":";
        node.raws.semicolon = false;
      } else if (type === rule || type === atrule) {
        node.raws.between = node.raws.after = "";
        node.raws.semicolon = false;
      }
    }); // Remove final newline

    css.raws.after = "";
  };
});
module.exports = exports["default"];
},{"postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js"}],"node_modules/postcss-normalize-unicode/dist/index.js":[function(require,module,exports) {
var __dirname = "/home/royyan/csspurge/node_modules/postcss-normalize-unicode/dist";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _browserslist = require('browserslist');

var _browserslist2 = _interopRequireDefault(_browserslist);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var regexLowerCaseUPrefix = /^u(?=\+)/;

function unicode(range) {
  var values = range.slice(2).split('-');

  if (values.length < 2) {
    return range;
  }

  var left = values[0].split('');
  var right = values[1].split('');

  if (left.length !== right.length) {
    return range;
  }

  var questionCounter = 0;
  var merged = left.reduce(function (group, value, index) {
    if (group === false) {
      return false;
    }

    if (value === right[index] && !questionCounter) {
      return group + value;
    }

    if (value === '0' && right[index] === 'f') {
      questionCounter++;
      return group + '?';
    }

    return false;
  }, 'u+');
  /*
   * The maximum number of wildcard characters (?) for ranges is 5.
   */

  if (merged && questionCounter < 6) {
    return merged;
  }

  return range;
}
/*
 * IE and Edge before 16 version ignore the unicode-range if the 'U' is lowercase
 *
 * https://caniuse.com/#search=unicode-range
 */


function hasLowerCaseUPrefixBug(browser) {
  return ~(0, _browserslist2.default)('ie <=11, edge <= 15').indexOf(browser);
}

function transform() {
  var legacy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var node = arguments.length > 1 ? arguments[1] : undefined;
  node.value = (0, _postcssValueParser2.default)(node.value).walk(function (child) {
    if (child.type === 'word') {
      var transformed = unicode(child.value.toLowerCase());
      child.value = legacy ? transformed.replace(regexLowerCaseUPrefix, 'U') : transformed;
    }

    return false;
  }).toString();
}

exports.default = _postcss2.default.plugin('postcss-normalize-unicode', function () {
  return function (css, result) {
    var resultOpts = result.opts || {};
    var browsers = (0, _browserslist2.default)(null, {
      stats: resultOpts.stats,
      path: __dirname,
      env: resultOpts.env
    });
    css.walkDecls(/^unicode-range$/i, transform.bind(null, browsers.some(hasLowerCaseUPrefixBug)));
  };
});
module.exports = exports['default'];
},{"browserslist":"node_modules/browserslist/index.js","postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js"}],"node_modules/postcss-normalize-display-values/dist/lib/map.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var block = 'block';
var flex = 'flex';
var flow = 'flow';
var flowRoot = 'flow-root';
var grid = 'grid';
var inline = 'inline';
var inlineBlock = 'inline-block';
var inlineFlex = 'inline-flex';
var inlineGrid = 'inline-grid';
var inlineTable = 'inline-table';
var listItem = 'list-item';
var ruby = 'ruby';
var rubyBase = 'ruby-base';
var rubyText = 'ruby-text';
var runIn = 'run-in';
var table = 'table';
var tableCell = 'table-cell';
var tableCaption = 'table-caption';
/**
 * Specification: https://drafts.csswg.org/css-display/#the-display-properties
 */

exports.default = [[block, [block, flow]], [flowRoot, [block, flowRoot]], [inline, [inline, flow]], [inlineBlock, [inline, flowRoot]], [runIn, [runIn, flow]], [listItem, [listItem, block, flow]], [inline + ' ' + listItem, [inline, flow, listItem]], [flex, [block, flex]], [inlineFlex, [inline, flex]], [grid, [block, grid]], [inlineGrid, [inline, grid]], [ruby, [inline, ruby]], // `block ruby` is same
[table, [block, table]], [inlineTable, [inline, table]], [tableCell, [tableCell, flow]], [tableCaption, [tableCaption, flow]], [rubyBase, [rubyBase, flow]], [rubyText, [rubyText, flow]]];
module.exports = exports['default'];
},{}],"node_modules/postcss-normalize-display-values/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require("postcss");

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssValueParser = require("postcss-value-parser");

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _cssnanoUtilGetMatch = require("cssnano-util-get-match");

var _cssnanoUtilGetMatch2 = _interopRequireDefault(_cssnanoUtilGetMatch);

var _map = require("./lib/map");

var _map2 = _interopRequireDefault(_map);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var getMatch = (0, _cssnanoUtilGetMatch2.default)(_map2.default);

function evenValues(list, index) {
  return index % 2 === 0;
}

exports.default = _postcss2.default.plugin("postcss-normalize-display-values", function () {
  return function (css) {
    var cache = {};
    css.walkDecls(/display/i, function (decl) {
      var value = decl.value;

      if (cache[value]) {
        decl.value = cache[value];
        return;
      }

      var _ref = (0, _postcssValueParser2.default)(value),
          nodes = _ref.nodes;

      if (nodes.length === 1) {
        cache[value] = value;
        return;
      }

      var match = getMatch(nodes.filter(evenValues).map(function (n) {
        return n.value.toLowerCase();
      }));

      if (!match) {
        cache[value] = value;
        return;
      }

      var result = match;
      decl.value = result;
      cache[value] = result;
    });
  };
});
module.exports = exports["default"];
},{"postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","cssnano-util-get-match":"node_modules/cssnano-util-get-match/dist/index.js","./lib/map":"node_modules/postcss-normalize-display-values/dist/lib/map.js"}],"node_modules/postcss-normalize-timing-functions/dist/lib/map.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = [['ease', [0.25, 0.1, 0.25, 1]], ['linear', [0, 0, 1, 1]], ['ease-in', [0.42, 0, 1, 1]], ['ease-out', [0, 0, 0.58, 1]], ['ease-in-out', [0.42, 0, 0.58, 1]]];
module.exports = exports['default'];
},{}],"node_modules/postcss-normalize-timing-functions/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _postcssValueParser = require('postcss-value-parser');

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

var _cssnanoUtilGetMatch = require('cssnano-util-get-match');

var _cssnanoUtilGetMatch2 = _interopRequireDefault(_cssnanoUtilGetMatch);

var _map = require('./lib/map');

var _map2 = _interopRequireDefault(_map);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var getMatch = (0, _cssnanoUtilGetMatch2.default)(_map2.default);

var getValue = function getValue(node) {
  return parseFloat(node.value);
};

function evenValues(list, index) {
  return index % 2 === 0;
}

function reduce(node) {
  if (node.type !== 'function') {
    return false;
  }

  var lowerCasedValue = node.value.toLowerCase();

  if (lowerCasedValue === 'steps') {
    // Don't bother checking the step-end case as it has the same length
    // as steps(1)
    if (getValue(node.nodes[0]) === 1 && node.nodes[2] && node.nodes[2].value.toLowerCase() === 'start') {
      node.type = 'word';
      node.value = 'step-start';
      delete node.nodes;
      return;
    } // The end case is actually the browser default, so it isn't required.


    if (node.nodes[2] && node.nodes[2].value.toLowerCase() === 'end') {
      node.nodes = [node.nodes[0]];
      return;
    }

    return false;
  }

  if (lowerCasedValue === 'cubic-bezier') {
    var match = getMatch(node.nodes.filter(evenValues).map(getValue));

    if (match) {
      node.type = 'word';
      node.value = match;
      delete node.nodes;
      return;
    }
  }
}

exports.default = (0, _postcss.plugin)('postcss-normalize-timing-functions', function () {
  return function (css) {
    var cache = {};
    css.walkDecls(/(animation|transition)(-timing-function|$)/i, function (decl) {
      var value = decl.value;

      if (cache[value]) {
        decl.value = cache[value];
        return;
      }

      var result = (0, _postcssValueParser2.default)(value).walk(reduce).toString();
      decl.value = result;
      cache[value] = result;
    });
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js","postcss-value-parser":"node_modules/postcss-value-parser/lib/index.js","cssnano-util-get-match":"node_modules/cssnano-util-get-match/dist/index.js","./lib/map":"node_modules/postcss-normalize-timing-functions/dist/lib/map.js"}],"node_modules/cssnano-util-raw-cache/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

exports.default = (0, _postcss.plugin)('cssnano-util-raw-cache', function () {
  return function (css, result) {
    result.root.rawCache = {
      colon: ':',
      indent: '',
      beforeDecl: '',
      beforeRule: '',
      beforeOpen: '',
      beforeClose: '',
      beforeComment: '',
      after: '',
      emptyBody: '',
      commentLeft: '',
      commentRight: ''
    };
  };
});
module.exports = exports['default'];
},{"postcss":"node_modules/postcss/lib/postcss.js"}],"node_modules/cssnano-preset-default/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defaultPreset;

var _cssDeclarationSorter = require('css-declaration-sorter');

var _cssDeclarationSorter2 = _interopRequireDefault(_cssDeclarationSorter);

var _postcssDiscardComments = require('postcss-discard-comments');

var _postcssDiscardComments2 = _interopRequireDefault(_postcssDiscardComments);

var _postcssReduceInitial = require('postcss-reduce-initial');

var _postcssReduceInitial2 = _interopRequireDefault(_postcssReduceInitial);

var _postcssMinifyGradients = require('postcss-minify-gradients');

var _postcssMinifyGradients2 = _interopRequireDefault(_postcssMinifyGradients);

var _postcssSvgo = require('postcss-svgo');

var _postcssSvgo2 = _interopRequireDefault(_postcssSvgo);

var _postcssReduceTransforms = require('postcss-reduce-transforms');

var _postcssReduceTransforms2 = _interopRequireDefault(_postcssReduceTransforms);

var _postcssConvertValues = require('postcss-convert-values');

var _postcssConvertValues2 = _interopRequireDefault(_postcssConvertValues);

var _postcssCalc = require('postcss-calc');

var _postcssCalc2 = _interopRequireDefault(_postcssCalc);

var _postcssColormin = require('postcss-colormin');

var _postcssColormin2 = _interopRequireDefault(_postcssColormin);

var _postcssOrderedValues = require('postcss-ordered-values');

var _postcssOrderedValues2 = _interopRequireDefault(_postcssOrderedValues);

var _postcssMinifySelectors = require('postcss-minify-selectors');

var _postcssMinifySelectors2 = _interopRequireDefault(_postcssMinifySelectors);

var _postcssMinifyParams = require('postcss-minify-params');

var _postcssMinifyParams2 = _interopRequireDefault(_postcssMinifyParams);

var _postcssNormalizeCharset = require('postcss-normalize-charset');

var _postcssNormalizeCharset2 = _interopRequireDefault(_postcssNormalizeCharset);

var _postcssMinifyFontValues = require('postcss-minify-font-values');

var _postcssMinifyFontValues2 = _interopRequireDefault(_postcssMinifyFontValues);

var _postcssNormalizeUrl = require('postcss-normalize-url');

var _postcssNormalizeUrl2 = _interopRequireDefault(_postcssNormalizeUrl);

var _postcssMergeLonghand = require('postcss-merge-longhand');

var _postcssMergeLonghand2 = _interopRequireDefault(_postcssMergeLonghand);

var _postcssDiscardDuplicates = require('postcss-discard-duplicates');

var _postcssDiscardDuplicates2 = _interopRequireDefault(_postcssDiscardDuplicates);

var _postcssDiscardOverridden = require('postcss-discard-overridden');

var _postcssDiscardOverridden2 = _interopRequireDefault(_postcssDiscardOverridden);

var _postcssNormalizeRepeatStyle = require('postcss-normalize-repeat-style');

var _postcssNormalizeRepeatStyle2 = _interopRequireDefault(_postcssNormalizeRepeatStyle);

var _postcssMergeRules = require('postcss-merge-rules');

var _postcssMergeRules2 = _interopRequireDefault(_postcssMergeRules);

var _postcssDiscardEmpty = require('postcss-discard-empty');

var _postcssDiscardEmpty2 = _interopRequireDefault(_postcssDiscardEmpty);

var _postcssUniqueSelectors = require('postcss-unique-selectors');

var _postcssUniqueSelectors2 = _interopRequireDefault(_postcssUniqueSelectors);

var _postcssNormalizeString = require('postcss-normalize-string');

var _postcssNormalizeString2 = _interopRequireDefault(_postcssNormalizeString);

var _postcssNormalizePositions = require('postcss-normalize-positions');

var _postcssNormalizePositions2 = _interopRequireDefault(_postcssNormalizePositions);

var _postcssNormalizeWhitespace = require('postcss-normalize-whitespace');

var _postcssNormalizeWhitespace2 = _interopRequireDefault(_postcssNormalizeWhitespace);

var _postcssNormalizeUnicode = require('postcss-normalize-unicode');

var _postcssNormalizeUnicode2 = _interopRequireDefault(_postcssNormalizeUnicode);

var _postcssNormalizeDisplayValues = require('postcss-normalize-display-values');

var _postcssNormalizeDisplayValues2 = _interopRequireDefault(_postcssNormalizeDisplayValues);

var _postcssNormalizeTimingFunctions = require('postcss-normalize-timing-functions');

var _postcssNormalizeTimingFunctions2 = _interopRequireDefault(_postcssNormalizeTimingFunctions);

var _cssnanoUtilRawCache = require('cssnano-util-raw-cache');

var _cssnanoUtilRawCache2 = _interopRequireDefault(_cssnanoUtilRawCache);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var defaultOpts = {
  convertValues: {
    length: false
  },
  normalizeCharset: {
    add: false
  },
  cssDeclarationSorter: {
    exclude: true
  }
};
/**
 * @author Ben Briggs
 * @license MIT
 * @module cssnano:preset:default
 * @overview
 *
 * This default preset for cssnano only includes transforms that make no
 * assumptions about your CSS other than what is passed in. In previous
 * iterations of cssnano, assumptions were made about your CSS which caused
 * output to look different in certain use cases, but not others. These
 * transforms have been moved from the defaults to other presets, to make
 * this preset require only minimal configuration.
 */

function defaultPreset() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = Object.assign({}, defaultOpts, opts);
  var plugins = [[_postcssDiscardComments2.default, options.discardComments], [_postcssMinifyGradients2.default, options.minifyGradients], [_postcssReduceInitial2.default, options.reduceInitial], [_postcssSvgo2.default, options.svgo], [_postcssNormalizeDisplayValues2.default, options.normalizeDisplayValues], [_postcssReduceTransforms2.default, options.reduceTransforms], [_postcssColormin2.default, options.colormin], [_postcssNormalizeTimingFunctions2.default, options.normalizeTimingFunctions], [_postcssCalc2.default, options.calc], [_postcssConvertValues2.default, options.convertValues], [_postcssOrderedValues2.default, options.orderedValues], [_postcssMinifySelectors2.default, options.minifySelectors], [_postcssMinifyParams2.default, options.minifyParams], [_postcssNormalizeCharset2.default, options.normalizeCharset], [_postcssDiscardOverridden2.default, options.discardOverridden], [_postcssNormalizeString2.default, options.normalizeString], [_postcssNormalizeUnicode2.default, options.normalizeUnicode], [_postcssMinifyFontValues2.default, options.minifyFontValues], [_postcssNormalizeUrl2.default, options.normalizeUrl], [_postcssNormalizeRepeatStyle2.default, options.normalizeRepeatStyle], [_postcssNormalizePositions2.default, options.normalizePositions], [_postcssNormalizeWhitespace2.default, options.normalizeWhitespace], [_postcssMergeLonghand2.default, options.mergeLonghand], [_postcssDiscardDuplicates2.default, options.discardDuplicates], [_postcssMergeRules2.default, options.mergeRules], [_postcssDiscardEmpty2.default, options.discardEmpty], [_postcssUniqueSelectors2.default, options.uniqueSelectors], [_cssDeclarationSorter2.default, options.cssDeclarationSorter], [_cssnanoUtilRawCache2.default, options.rawCache]];
  return {
    plugins: plugins
  };
}

module.exports = exports['default'];
},{"css-declaration-sorter":"node_modules/css-declaration-sorter/src/index.js","postcss-discard-comments":"node_modules/postcss-discard-comments/dist/index.js","postcss-reduce-initial":"node_modules/postcss-reduce-initial/dist/index.js","postcss-minify-gradients":"node_modules/postcss-minify-gradients/dist/index.js","postcss-svgo":"node_modules/postcss-svgo/dist/index.js","postcss-reduce-transforms":"node_modules/postcss-reduce-transforms/dist/index.js","postcss-convert-values":"node_modules/postcss-convert-values/dist/index.js","postcss-calc":"node_modules/postcss-calc/dist/index.js","postcss-colormin":"node_modules/postcss-colormin/dist/index.js","postcss-ordered-values":"node_modules/postcss-ordered-values/dist/index.js","postcss-minify-selectors":"node_modules/postcss-minify-selectors/dist/index.js","postcss-minify-params":"node_modules/postcss-minify-params/dist/index.js","postcss-normalize-charset":"node_modules/postcss-normalize-charset/dist/index.js","postcss-minify-font-values":"node_modules/postcss-minify-font-values/dist/index.js","postcss-normalize-url":"node_modules/postcss-normalize-url/dist/index.js","postcss-merge-longhand":"node_modules/postcss-merge-longhand/dist/index.js","postcss-discard-duplicates":"node_modules/postcss-discard-duplicates/dist/index.js","postcss-discard-overridden":"node_modules/postcss-discard-overridden/dist/index.js","postcss-normalize-repeat-style":"node_modules/postcss-normalize-repeat-style/dist/index.js","postcss-merge-rules":"node_modules/postcss-merge-rules/dist/index.js","postcss-discard-empty":"node_modules/postcss-discard-empty/dist/index.js","postcss-unique-selectors":"node_modules/postcss-unique-selectors/dist/index.js","postcss-normalize-string":"node_modules/postcss-normalize-string/dist/index.js","postcss-normalize-positions":"node_modules/postcss-normalize-positions/dist/index.js","postcss-normalize-whitespace":"node_modules/postcss-normalize-whitespace/dist/index.js","postcss-normalize-unicode":"node_modules/postcss-normalize-unicode/dist/index.js","postcss-normalize-display-values":"node_modules/postcss-normalize-display-values/dist/index.js","postcss-normalize-timing-functions":"node_modules/postcss-normalize-timing-functions/dist/index.js","cssnano-util-raw-cache":"node_modules/cssnano-util-raw-cache/dist/index.js"}],"cssnano.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _postcss = _interopRequireWildcard(require("postcss"));

var _cssnanoPresetDefault = _interopRequireDefault(require("cssnano-preset-default"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// svgo uses fs, so we can't use it
var _preset = (0, _cssnanoPresetDefault.default)({
  svgo: true
}),
    plugins = _preset.plugins;

function initializePlugin(plugin, css, result) {
  if (Array.isArray(plugin)) {
    var _plugin = _slicedToArray(plugin, 2),
        processor = _plugin[0],
        opts = _plugin[1];

    if (typeof opts === 'undefined' || _typeof(opts) === 'object' && !opts.exclude) {
      return Promise.resolve(processor(opts)(css, result));
    }
  } else {
    return Promise.resolve(plugin()(css, result));
  } // Handle excluded plugins


  return Promise.resolve();
}

var cssNano = (0, _postcss.plugin)('cssnano', function () {
  return function (css, result) {
    return plugins.reduce(function (promise, plugin) {
      return promise.then(initializePlugin.bind(null, plugin, css, result));
    }, Promise.resolve());
  };
});

var _default = function _default(cssString) {
  return (0, _postcss.default)([cssNano]).process(cssString);
};

exports.default = _default;
},{"postcss":"node_modules/postcss/lib/postcss.js","cssnano-preset-default":"node_modules/cssnano-preset-default/dist/index.js"}],"node_modules/file-saver/dist/FileSaver.min.js":[function(require,module,exports) {
var define;
var global = arguments[3];
(function(a,b){if("function"==typeof define&&define.amd)define([],b);else if("undefined"!=typeof exports)b();else{b(),a.FileSaver={exports:{}}.exports}})(this,function(){"use strict";function b(a,b){return"undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(b,c,d){var e=new XMLHttpRequest;e.open("GET",b),e.responseType="blob",e.onload=function(){a(e.response,c,d)},e.onerror=function(){console.error("could not download file")},e.send()}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"))}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof global&&global.global===global?global:void 0,a=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i)})}}:function(a,b,d,e){if(e=e||open("","_blank"),e&&(e.document.title=e.document.body.innerText="downloading..."),"string"==typeof a)return c(a,b,d);var g="application/octet-stream"===a.type,h=/constructor/i.test(f.HTMLElement)||f.safari,i=/CriOS\/[\d]+/.test(navigator.userAgent);if((i||g&&h)&&"object"==typeof FileReader){var j=new FileReader;j.onloadend=function(){var a=j.result;a=i?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),e?e.location.href=a:location=a,e=null},j.readAsDataURL(a)}else{var k=f.URL||f.webkitURL,l=k.createObjectURL(a);e?e.location=l:location.href=l,e=null,setTimeout(function(){k.revokeObjectURL(l)},4E4)}});f.saveAs=a.saveAs=a,"undefined"!=typeof module&&(module.exports=a)});

//# sourceMappingURL=FileSaver.min.js.map
},{}],"app.js":[function(require,module,exports) {
"use strict";

var _cssnano = _interopRequireDefault(require("./cssnano"));

var _fileSaver = require("file-saver");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

new Vue({
  el: '#app',
  data: {
    fileSelected: false,
    isDragging: false,
    inputHasFocus: false,
    result: '',
    selectedFiles: [],
    worker: null
  },
  mounted: function mounted() {
    var _this = this;

    if (window.Worker) {
      this.worker = new Worker("/cssmerge/worker.ab30da2c.js");

      this.worker.onmessage = function (e) {
        _this.result = e.data;
      };
    }
  },
  methods: {
    openFileInput: function openFileInput() {
      this.$refs.fileInput.click();
    },
    readFiles: function readFiles() {
      return Promise.all(this.selectedFiles.map(function (file) {
        return readFilePromise(file);
      })).then(function (data) {
        return data.join('');
      });
    },
    drop: function drop(e) {
      var _this2 = this;

      this.isDragging = false;
      this.fileSelected = true;
      this.selectedFiles = [].concat(_toConsumableArray(this.selectedFiles), _toConsumableArray(Array.from(e.dataTransfer.files)));

      if (this.worker) {
        this.worker.postMessage(this.selectedFiles);
      } else {
        this.readFiles().then(function (cssString) {
          return (0, _cssnano.default)(cssString);
        }).then(function (result) {
          _this2.result = result.css;
        });
      }
    },
    fileInputChange: function fileInputChange(e) {
      var _this3 = this;

      this.isDragging = false;
      this.fileSelected = true;
      this.selectedFiles = [].concat(_toConsumableArray(this.selectedFiles), _toConsumableArray(Array.from(e.target.files)));

      if (this.worker) {
        this.worker.postMessage(this.selectedFiles);
      } else {
        this.readFiles().then(function (cssString) {
          return (0, _cssnano.default)(cssString);
        }).then(function (result) {
          _this3.result = result.css;
        });
      }
    },
    mergeCSS: function mergeCSS() {
      var blobObj = new Blob([this.result], {
        type: "text/plain;charset=utf-8"
      });
      (0, _fileSaver.saveAs)(blobObj, 'merged.css'); // this.readFiles().then(cssNano).then(str => console.log(str.css));
    }
  },
  filters: {
    fileSizeFormat: function fileSizeFormat(val) {
      var size = parseFloat(val) || 0;

      if (!size) {
        return '0B';
      }

      if (size < 1000) {
        return "".concat(size, "B");
      }

      if (size < 1000000) {
        return "".concat(Math.round(size / 1000), "KB");
      }

      if (size < 8000000) {
        return "".concat(Math.round(size / 1000000), "MB");
      }

      return 'Too large';
    }
  }
});
},{"./cssnano":"cssnano.js","file-saver":"node_modules/file-saver/dist/FileSaver.min.js","./worker.js":[["worker.ab30da2c.js","worker.js"],"worker.js"]}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "50591" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","app.js"], null)